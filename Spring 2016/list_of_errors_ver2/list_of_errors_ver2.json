{"fix": ["let rec sumList xs = match xs with\n| [] -> 0\n| x::xs' -> x + sumList xs'"], "hw": "hw1", "problem": "sumList", "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type ('a -> 'b -> 'c) list -> 'd list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b -> 'c) list -> 'd list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type ('a -> 'b -> 'c) list -> 'd list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b -> 'c) list -> 'd list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type ('a -> 'b -> 'c) list -> 'd list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b -> 'c) list -> 'd list\n", "Error: This expression has type ('a -> 'b -> 'c) list -> 'd list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b -> 'c) list -> 'd list\n"], "bad": ["\nlet rec sumList xs =\n  match xs with | [] -> [] | h1::h2::t -> h1 + (h2 sumList t);;\n", "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x + (1 sumList xs');;\n", "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x sumList xs';;\n", "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x + (sumList xs');;\n", "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> 1 sumList xs';;\n", "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x sumList xs';;\n", "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x + (sumList xs');;\n", "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x sumList xs';;\n", "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x sumList xs';;\n"]}
{"fix": ["let rec digitsOfInt n = match n with\n| _ -> (n mod 10) + digitsOfInt  (n/10)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value %\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec digitsOfInt n = match n with | _ -> (n % (10 digitsOfInt n)) / 10;;\n", "\nlet rec digitsOfInt n = match n with | _ -> (n mod (10 digitsOfInt n)) / 10;;\n"]}
{"fix": ["let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n"]}
{"fix": ["let rec sum n = \nif n < 0 \nthen failwith\"TBD\"\nelse (n mod 10) + digitalRoot n/10"], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: Unbound value sum\n", "Error: Unbound value %\n"], "bad": ["\nlet rec digitalRoot n =\n  let temp = sum n in if temp > 10 then digitalRoot temp;;\n", "\nlet rec digitalRoot n = failwith \"TBD\";;\n\nlet rec sum n =\n  if n < 0 then failwith \"TBD\" else (n % 10) + ((digitalRoot n) / 10);;\n"]}
{"fix": ["let rec additivePersistence n = \nlet temp = (sum n) in \nlet counter = (count counter) in \nif temp >= 10\nthen digitalRoot temp \nelse counter"], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: This expression has type int but an expression was expected of type\n         bool\nError: Unbound value sum\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         bool\n"], "bad": ["\nlet count x = x + 1;;\n\nlet rec digitalRoot n =\n  let temp = sum n in if temp >= 10 then digitalRoot temp else temp;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence n =\n  let temp = sum n in\n  let counter = count 0 in\n  if temp >= 10 then (digitalRoot temp) && (count counter) else counter;;\n"]}
{"fix": ["let rec additivePersistence n = \nlet temp = (sum n) in \nlet counter = (count counter) in \nif temp >= 10\nthen additivePersistence temp \nelse counter"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: Unbound value additivePersitence\nHint: Did you mean additivePersistence?\n"], "bad": ["\nlet count x = x + 1;;\n\nlet counter = 0;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence n =\n  let temp = sum n in\n  let counter = count counter in\n  if temp >= 10 then additivePersitence temp else counter;;\n"]}
{"fix": ["let rec additivePersistence n = additivePersistence_helper (n, 0)"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * 'b\n"], "bad": ["\nlet rec additivePersistence n = additivePersistence (n, 0);;\n"]}
{"fix": ["let rec sum (n, i) = \nif n < 10\nthen (sumList (digitsOfInt n), i)\nelse (sumList (digitsOfInt n), 1+1)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then sumList (digitsOfInt n) i\n  else (sumList (digitsOfInt n) 1) + 1;;\n"]}
{"fix": [], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type int but an expression was expected of type\n         int * int\n", "Error: This expression has type int * int\n       but an expression was expected of type int\n", "Error: This expression has type int * int\n       but an expression was expected of type 'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (1 + 1));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum (n, i) in\n  if temp >= 10 then additivePersistence_helper (temp, (i + 1)) else i;;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (1 + 1));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum (n, i) in\n  if temp >= (10, 0) then additivePersistence_helper (temp, (i + 1)) else i;;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (1 + 1));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum (n, i) in\n  if (List.hd temp) >= 10\n  then additivePersistence_helper (temp, (i + 1))\n  else i;;\n"]}
{"fix": ["let rec sum (n, i) = \nif n < 10\nthen (sumList (digitsOfInt n), i)\nelse (sumList (digitsOfInt n), 1+1)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This variant expression is expected to have type bool\n       The constructor [] does not belong to type bool\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n::i::[]) =\n  if (n < 10) || []\n  then [sumList (digitsOfInt n); i]\n  else [sumList (digitsOfInt n); 1 + 1];;\n"]}
{"fix": ["let rec digitalRoot n = \nlet temp = sumList (digitsOfInt n) in\nif temp >= 10\nthen digitalRoot temp\nelse temp"], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: Unbound value temp\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ =\n  let rec digitalRoot n = temp = (sumList (digitsOfInt n)) in\n  if temp >= 10 then digitalRoot temp else temp;;\n"]}
{"fix": ["let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  hd :: listReverse tl"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> tl :: (listReverse hd);;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) :: hd;;\n"]}
{"fix": ["let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  (listReverse tl) @ hd"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) :: hd;;\n"]}
{"fix": ["let rec listReverse l = match l with\n| [] -> []\n| _::tl -> listReverse tl"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd != [] then (listReverse tl) :: hd else hd;;\n"]}
{"fix": [], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"NO ELEMENT\";;\n\nlet rec listReverse l = match l with | [] -> [] | hd::tl -> (last tl) :: hd;;\n"]}
{"fix": ["let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse (hd::l)"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"NO ELEMENT\";;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | hd::tl -> let x = last l in if x > 0 then x else x;;\n", "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"NO ELEMENT\";;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | hd::tl -> let x = last l in if x > 0 then x :: x else x :: x;;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> listReverse (hd :: l) tl;;\n"]}
{"fix": [], "hw": "hw1", "problem": "listReverse", "message": ["Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> listReverse (hd :: l) tl;;\n"]}
{"fix": ["let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl @ hd"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet _ =\n  let rec listReverse l =\n    match l with | [] -> [] | hd::tl -> listReverse (hd :: l) t in\n  listReverse [];;\n"]}
{"fix": ["let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl :: [hd]"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) @ hd;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n"]}
{"fix": ["let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl @ [hd]"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> [listReverse tl; hd];;\n"]}
{"fix": [], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) :: hd;;\n"]}
{"fix": [], "hw": "hw1", "problem": "palindrome", "message": ["Error: Unbound value l\n"], "bad": ["\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) @ [hd];;\n\nlet palindrome w = if l = (listReverse (explode w)) then true else false;;\n"]}
{"fix": ["let rec listReverse l = match l with\n| [] -> []\n| x::[] -> x\n| hd::tl -> (listReverse tl)::hd"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet a = [];;\n\nlet b = 3;;\n\nlet f x l = [l; x];;\n\nlet _ = f b a;;\n"]}
{"fix": [], "hw": "hw1", "problem": "sumList", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec listReverse l =\n  match l with | x::[] -> x | hd::tl -> (listReverse tl) :: hd;;\n"]}
{"fix": [], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec last l = match l with | x::[] -> x | hd::tl -> last tl | [] -> [];;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (removeLast tl) | [] -> [];;\n\nlet rec listReverse l = (last l) :: (listReverse (removeLast l));;\n\nlet _ = listReverse [1; 2; 3; 4];;\n"]}
{"fix": [], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec listReverse l =\n  match l with | [] -> 0 | hd::tl -> (listReverse tl) :: hd;;\n"]}
{"fix": [], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value reverseList\n"], "bad": ["\nlet rec digitsOfInt n =\n  let x = if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  reverseList x;;\n"]}
{"fix": [], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value rlistReverse\nHint: Did you mean listReverse?\nError: Unbound value rlistReverse\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value rlistReverse\nHint: Did you mean listReverse?\n"], "bad": ["\nlet rec reversed n = if n <= 0 then [] else (n mod 10) :: (reversed (n / 10));;\n\nlet rec digitsOfInt n = rlistReverse reversed n;;\n"]}
{"fix": [], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then f b' else b';;\n", "\nlet rec wwhile (f,b) = let (bs,cs) = f b in if cs then f bs else bs;;\n"]}
{"fix": ["let fixpoint (f,b) = \nwwhile (f,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a * 'b -> 'a * 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * 'b -> 'a * 'b\n"], "bad": ["\nlet fixpoint (f,b) = let b' = f b in if b' = b then b else (f, b');;\n"]}
{"fix": ["let fixpoint (f,b) = \nlet f b = (f b, b=f b) in\nwwhile (f,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: Unbound value f'\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "bad": ["\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let b' = (b, ((f b) = b)) in wwhile (f, b');;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let b' = (b, ((f b) = b)) in wwhile (f, b');;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let b' = (b, ((f b) < b)) in wwhile (f, b');;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f' = ((f b), (f' = b)) in wwhile (f', b);;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f' = ((f b), ((f b) = b)) in wwhile (f', b);;\n"]}
{"fix": ["let fixpoint (f,b) =\nlet f b = (f b, f b = b) in\nwwhile (f, b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "Error: This expression has type ('a -> 'a) -> 'a -> 'a * bool\n       but an expression was expected of type ('a -> 'a) -> ('a -> 'a) * bool\n       Type 'a -> 'a * bool is not compatible with type ('a -> 'a) * bool \n"], "bad": ["\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let f' f b = ((f b), (b = (f b))) in wwhile (f', b);;\n"]}
{"fix": ["let fixpoint (f,b) =\nlet f b = let b' = f b in b=b' in b'"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value b'\n"], "bad": ["\nlet fixpoint (f,b) = let f b = let b' = f b in (b', (b = b')) in b = b';;\n"]}
{"fix": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: Unbound constructor Zero\n"], "bad": ["\nlet a = Zero;;\n"]}
{"fix": ["let b = exprToString Sine(VarX)"], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type expr -> string\n       but an expression was expected of type string\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> \"x\" | VarY  -> \"y\" | Sine m -> \"sin\" ^ exprToString;;\n"]}
{"fix": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin\" ^ (exprToString m);;\n\nlet b = exprToString Sine VarX;;\n"]}
{"fix": ["let b = exprToString (Cosine(VarX))"], "hw": "hw2", "problem": "exprToString", "message": ["Error: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type expr\n", "Error: Unbound value exprToStirng\nHint: Did you mean exprToString?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | (Average m,n) ->\n      \"((\" ^ ((exprToStirng m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToStirng m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")));;\n"]}
{"fix": ["let b = exprToString (Average(Cosine(VarX),VarY))"], "hw": "hw2", "problem": "exprToString", "message": ["Error: This variant pattern is expected to have type expr\n       The constructor Tresh does not belong to type expr\nHint: Did you mean Thresh?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Tresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ (exprToString p)))))));;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval(m,x,y)+.eval(n,x,y))/2."], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'b\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'b\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | Sine m -> sin (pi *. (eval m));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | Sine m -> sin (pi *. (eval m)) | _ -> x;;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m, n) -> eval(m,x,y) *. eval(n,x,y)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) / 2.;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) / 2.;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) / 2.;;\n"]}
{"fix": ["let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"], "hw": "hw2", "problem": "eval", "message": ["Error: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\nError: Unbound value sampleExpr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n"]}
{"fix": ["let rec build (rand, depth) = rand"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value i\n"], "bad": ["\nlet rec build (rand,depth) = rand i j;;\n"]}
{"fix": ["let rec build (rand, depth) = let num = rand 4 53 in\nmatch num with\n| _ -> VarX"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value rand\nHint: Did you mean land?\n"], "bad": ["\nlet _ = rand (1, 3);;\n"]}
{"fix": ["let rec build (rand, depth) =\nif depth = 0\nthen\nlet num = rand in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value x1\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (x1, x2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (x1, x2) in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n"]}
{"fix": ["let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"], "bad": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n"]}
{"fix": ["let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"], "bad": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n"], "bad": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n"], "bad": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"]}
{"fix": ["let rec build (rand, depth) =\nif depth = 0\nthen\nlet num = rand 0 2 in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand 0 5 in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n"], "bad": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"]}
{"fix": ["let rec build (rand, depth) =\nif depth = 0\nthen\nlet nums (a,b) = rand in\nlet num = rand in \nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet nums (a,b) = rand in\nlet num = rand in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"], "hw": "hw2", "problem": "build", "message": ["Error: This pattern matches values of type int\n       but a pattern was expected which matches values of type 'a * 'b -> 'c\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num (a,b) = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num (a,b) = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n"]}
{"fix": ["let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value rand\nHint: Did you mean land?\n"], "bad": ["\nlet num = rand (0, 1);;\n"]}
{"fix": ["let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> buildSine(build(rand,depth-1))\n| _ -> buildCosine(build(rand,depth-1))"], "hw": "hw2", "problem": "build", "message": ["Error: This variant expression is expected to have type expr\n       The constructor BuildSine does not belong to type expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> BuildSine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n"]}
{"fix": ["let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 2 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildCosine(build(rand,depth-1))"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 ->\n         buildAverage\n           ((build (rand, (depth - 1))),\n             (buildAverage (build (rand, (depth - 1)))))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n"]}
{"fix": ["let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"], "hw": "hw2", "problem": "eval", "message": ["Error: This variant expression is expected to have type expr\n       The constructor Square does not belong to type expr\nError: This variant pattern is expected to have type expr\n       The constructor Divide does not belong to type expr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This variant expression is expected to have type expr\n       The constructor Square does not belong to type expr\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Divide of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Divide (m,n) -> (eval (m, x, y)) /. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet _ = eval ((Square VarX), 1.0, 0.5);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n"]}
{"fix": [], "hw": "hw2", "problem": "expr", "message": ["Error: This variant expression is expected to have type expr\n       The constructor MyExpr does not belong to type expr\nError: This variant expression is expected to have type expr\n       The constructor MyExpr does not belong to type expr\nHint: Did you mean MyExp?\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This variant expression is expected to have type expr\n       The constructor MyExpr does not belong to type expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExp of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet _ = exprToString (MyExpr (VarX, VarY, VarX));;\n"]}
{"fix": [], "hw": "hw2", "problem": "exprToString", "message": ["NO ERROR FROM MINIMAL PROGRAM!!!\nError: This variant expression is expected to have type expr\n       The constructor MyExpr does not belong to type expr\n", "Error: Unbound value expToString\nHint: Did you mean exprToString?\nError: Unbound value expToString\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value expToString\nHint: Did you mean exprToString?\n", "NO ERROR FROM MINIMAL PROGRAM!!!\nError: This variant expression is expected to have type expr\n       The constructor MyExpr does not belong to type expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet _ = exprToString (MyExpr (VarX, VarY, VarX));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet _ = expToString (MyExpr (VarX, VarY, VarX));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet _ = exprToString (MyExpr (VarX, VarY, VarX));;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Square m -> eval(m,x,y)**2.0\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| MyExpr(m,n,o) -> \nif eval(m,x,y) < eval (n,x,y)\nthen sqrt(abs_float(eval(o,x,y))) \nelse eval(o,x,y) /. 2.\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | MyExpr (m,n,o) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then sqrt (abs_float (eval (o, x, y)))\n      else (eval (o, x, y)) /. 2\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type expr/2623\n       but an expression was expected of type expr/2890\nError: This expression has type expr/3015\n       but an expression was expected of type expr/3037\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type expr/2623\n       but an expression was expected of type expr/2890\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | MyExpr (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then sqrt (abs_float (eval (o, x, y)))\n      else (eval (p, x, y)) /. 2.\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n"]}
{"fix": ["let rec digits n = digitsOfInt (abs n)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec digits n = digitsOfInt (abs n) digits (-124074);;\n"]}
{"fix": ["let rec inc i n = \nif n>9 \nthen inc (i+1) ( sumList (digitsOfInt n) )\nelse i"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int list -> int\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | h::t -> h + (sumList t) | [] -> 0;;\n\nlet rec inc i n = if n > 9 then inc (i + 1) sumList (digitsOfInt n) else i;;\n"]}
{"fix": ["let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)"], "hw": "hw2", "problem": "assoc", "message": ["Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'b * 'a * 'c\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type ('d * 'e) list\n"], "bad": ["\nlet rec assoc (d,k,l) =\n  let temp = l in\n  let rec helper acc (d,k,l) =\n    match temp with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper (d, k, l) t) in\n  helper (d, k, l) acc;;\n", "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper (d, k, l) acc;;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen)\nthen \nseen\nelse \nh :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: Unbound value l\n"], "bad": ["\nlet _ = l;;\n"]}
{"fix": [], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Cube a ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString a) ^ ((\"*\" (exprToString a)) ^ \")\"))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Cube a ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString a) ^ (\"*\" ^ ((exprToString a) ^ \")\")))))\n  | Addition (a,b) ->\n      \"(\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) \")\")));;\n"]}
{"fix": ["let rec eval (e,x,y) = \nmatch e with\nVarX -> x\n| VarY -> y\n| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )\n| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )\n| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)\n| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )\n| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))\nthen (eval (c,x,y))\nelse (eval (d,x,y))\n| Cube a -> (eval (a,x,y) ) *. (eval  (a,x,y) ) *. (eval (a,x,y) )\n| Addition (a,b) -> eval(a,x,y) +. eval"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type string but an expression was expected of type\n         int\n", "Error: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Cube a ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString a) ^ (\"*\" ^ ((exprToString a) ^ \")\")))))\n  | Addition (a,b) ->\n      \"(\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")\")));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((exprToString a) * (exprToString a)) * (exprToString a);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval a) * (eval a)) * (eval a);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval (a, x, y)) * (eval (a, x, y))) * (eval (a, x, y));;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type expr * float * float -> float\n       but an expression was expected of type float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval (a, x, y)) *. (eval (a, x, y))) *. (eval (a, x, y))\n  | Addition (a,b) -> (eval (a, x, y)) +. eval;;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value buildX\nHint: Did you mean build?\n"], "bad": ["\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (1, 10) with\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildCosine (build (rand, (depth - 1)))\n     | 5 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 -> buildCube (build (rand, (depth - 1)))\n     | 9 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildAddition (build (rand, depth)));;\n"]}
{"fix": ["let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)"], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value buildX\nHint: Did you mean build?\n"], "bad": ["\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (1, 10) with\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildCosine (build (rand, (depth - 1)))\n     | 5 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 -> buildCube (build (rand, (depth - 1)))\n     | 9 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> build (rand, depth));;\n"]}
{"fix": ["let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)"], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value buildAdd\nHint: Did you mean build, buildY or buildX?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCube e = Cube e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (1, 10) with\n     | 1 -> buildX ()\n     | 2 -> buildY ()\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildCosine (build (rand, (depth - 1)))\n     | 5 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 -> buildCube (build (rand, (depth - 1)))\n     | 9 ->\n         buildAdd ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "exprToString", "message": ["Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Arc of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Tan a -> \"tan(pi*\" ^ ((exprToString a) ^ \")\")\n  | Arc (a,b,c) -> \"sin(pi*\" ^ ((exprToString a (b, c)) ^ \")\");;\n"]}
{"fix": [], "hw": "hw2", "problem": "expr", "message": ["Error: This expression has type expr\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Arc of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Tan a -> \"tan(pi*\" ^ ((exprToString a) ^ \")\")\n  | Arc (a,b,c) -> \"sin(pi*\" ^ ((exprToString (a (b, c))) ^ \")\");;\n"]}
{"fix": ["exprToString Sin_Avg(1,2,3)"], "hw": "hw2", "problem": "exprToString", "message": ["Error: This variant pattern is expected to have type expr\n       The constructor Arc does not belong to type expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Arc of expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sin_Avg of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Tan a -> \"tan(pi*\" ^ ((exprToString a) ^ \")\")\n  | Arc (a,b,c) ->\n      \"sin(pi*(\" ^\n        ((exprToString a) ^\n           (\"+\" ^ ((exprToString b) ^ ((exprToString c) ^ \")\"))));;\n"]}
{"fix": ["exprToString (Tan VarX)"], "hw": "hw2", "problem": "exprToString", "message": ["Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int but an expression was expected of type\n         expr\n", "Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sin_Avg of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Tan a -> \"tan(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sin_Avg (a,b,c) ->\n      \"sin(pi*(\" ^\n        ((exprToString a) ^\n           (\"+\" ^ ((exprToString b) ^ ((exprToString c) ^ \")/3)\"))));;\n\nlet _ = exprToString Sin_Avg (1, 2, 3);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sin_Avg of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Tan a -> \"tan(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sin_Avg (a,b,c) ->\n      \"sin(pi*(\" ^\n        ((exprToString a) ^\n           (\"+\" ^ ((exprToString b) ^ ((exprToString c) ^ \")/3)\"))));;\n\nlet _ = exprToString (Sin_Avg (1, 2, 3));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sin_Avg of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Tan a -> \"tan(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sin_Avg (a,b,c) ->\n      \"sin(pi*(\" ^\n        ((exprToString a) ^\n           (\"+\" ^ ((exprToString b) ^ ((exprToString c) ^ \")/3)\"))));;\n\nlet _ = exprToString (Sin_Avg ((VarX ()), (VarY ()), (VarX ())));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sin_Avg of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Tan a -> \"tan(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sin_Avg (a,b,c) ->\n      \"sin(pi*(\" ^\n        ((exprToString a) ^\n           (\"+\" ^ ((exprToString b) ^ ((exprToString c) ^ \")/3)\"))));;\n\nlet _ = exprToString (Sin_Avg ((VarX ()), (VarY ()), (VarX ())));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sin_Avg of expr* expr* expr;;\n\nlet x = Sin_Avg ((VarX ()), (VarY ()), (VarX ()));;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sin_Avg of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Tan a -> eval (a, (tan (pi *. x)), (tan (pi *. y)))\n  | Sin_Avg (a,b,c) ->\n      eval\n        ((eval (a, (sin (pi * x)), (sin (pi * y)))),\n          (eval (b, (sin (pi * x)), (sin (pi * y)))),\n          (eval (c, (sin (pi * x)), (sin (pi * y)))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         expr\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sine_Avg of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Tan a -> eval (a, (tan (pi *. x)), (tan (pi *. y)))\n  | Sine_Avg (a,b,c) ->\n      (eval\n         ((eval (a, (sin (pi *. x)), (sin (pi *. y)))),\n           (eval (b, (sin (pi *. x)), (sin (pi *. y)))),\n           (eval (c, (sin (pi *. x)), (sin (pi *. y))))))\n        /. 3.0;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sine_Avg of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Tan a -> eval (a, (tan (pi *. x)), (tan (pi *. y)))\n  | Sine_Avg (a,b,c) ->\n      (((eval (a, (sin (pi *. x)), (sin (pi *. y)))) +\n          (eval (b, (sin (pi *. x)), (sin (pi *. y)))))\n         + (eval (c, (sin (pi *. x)), (sin (pi *. y)))))\n        /. 3.0;;\n"]}
{"fix": ["let rec sqsum xs = \nmatch xs with\n[] -> 0\n| h::t -> (h*h) + (sqsum t)"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec sqsum xs = match xs with | [] -> [] | h::t -> (h * h) + (sqsum t);;\n", "\nlet rec sqsum xs = match xs with | [] -> [] | h::t -> (h * h) + (sqsum t);;\n", "\nlet rec sqsum xs = match xs with | [] -> [] | h::t -> (h * h) + (sqsum t);;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = (a*a) in\nlet base = 0 in\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet sqsum xs = let f a x = a * a in let base = [] in List.fold_left f base xs;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: Unbound value a\n"], "bad": ["\nlet rec sqsum xs = match xs with | [] -> [] | h::t -> (h * h) + (sqsum t);;\n", "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = a + 1 in List.fold_left f base xs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = a + x in\nlet base = 0 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'a) list -> 'a -> 'a\n       but an expression was expected of type\n         ('a -> 'a) list -> 'a -> ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n", "Error: This expression has type ('a -> 'a) list -> 'a -> 'a\n       but an expression was expected of type\n         ('a -> 'a) list -> 'a -> ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n"], "bad": ["\nlet pipe fs =\n  let f a x = match a with | [] -> x | h::t -> h x in\n  let base = fs in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = match a with | [] -> x | h::t -> h x in\n  let base = 0 in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = match a with\n[] -> []\n| h::t -> h::[] in\nlet base = [] in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b list) list -> 'a -> 'b list\n       but an expression was expected of type\n         ('a -> 'b list) list -> 'a -> ('a -> 'b list) list\n       Type 'b list is not compatible with type ('a -> 'b list) list \n", "Error: This expression has type ('a -> 'a) list -> 'a -> 'a\n       but an expression was expected of type\n         ('a -> 'a) list -> 'a -> ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n"], "bad": ["\nlet pipe fs =\n  let f a x = match a with | [] -> [] | h::t -> h x in\n  let base = 3 in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = match a with | [] -> x | h::t -> h x in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = (fun a -> x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n"], "bad": ["\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ \" \" ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a list\n       but an expression was expected of type string\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ (\" \" x)) in\n      let base = [] in let l = t in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ (\" \" ^ x)) in\n      let base = [] in let l = t in List.fold_left f base l;;\n"]}
{"fix": ["let stringOfList f l = sepConcat (f l)"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: Unbound value ssepConcat\nHint: Did you mean sepConcat?\nError: Unbound value ssepConcat\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value ssepConcat\nHint: Did you mean sepConcat?\n"], "bad": ["\nlet stringOfList f l = ssepConcat (f l);;\n"]}
{"fix": ["let stringOfList f l = \"[\" ^ ( sepConcat \";\" (List.map f l) ) ^ \"]\""], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type string list -> string\n       but an expression was expected of type 'a list\n", "Error: This expression has type string -> string list -> string\n       but an expression was expected of type string\n", "Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f (sepConcat l);;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ (sepConcat ^ (\";\" ^ ((List.map f l) ^ \"]\")));;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" List.map f l) ^ \"]\");;\n"]}
{"fix": ["let rec clone x n = let i = 0 in\nif i < n\nthen x :: ( clone x (n-1) )\nelse []"], "hw": "hw3", "problem": "clone", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n = let i = 0 in if i < n then x :: ((clone x n) - 1) else [];;\n", "\nlet rec clone x n = let i = 0 in if i < n then [(clone x n) - 1; x] else [];;\n"]}
{"fix": ["let padZero l1 l2 = if List.length l1 < List.length l2\nthen true\nelse false"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type int but an expression was expected of type\n         bool\n"], "bad": ["\nlet padZero l1 l2 =\n  let length_diff = (List.length l1) - (List.length l2) in\n  if length_diff < 0\n  then length_diff = ((List.length l1) - (List.length l2))\n  else length_diff;;\n"]}
{"fix": ["let rec removeZero l =\nmatch l with\n| [] -> false\n| h :: t -> \nif h = 0\nthen h = 0\nelse false"], "hw": "hw3", "problem": "removeZero", "message": ["Error: This expression has type bool but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then h = 0 else false;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = (fun x a -> x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n"], "bad": ["\nlet pipe fs =\n  let f a x a x = x a in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = List.rev l1 in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = 0 in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = 0 in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> 0\n| h::t -> ( (h*i)/10 + mulByDigit i t )"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> 0 | h::t -> ((h * i) / 10) + (List.rev i t);;\n"]}
{"fix": ["let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::t -> (h*i mod 10) :: []"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> [((h * i) / 10) + (mulByDigit i t); (h * i) mod 10];;\n", "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> [((h * i) / 10) + (mulByDigit i t); (h * i) mod 10];;\n"]}
{"fix": ["let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::t -> List.append (mulByDigit i t) [h*i mod 10]"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec mulByDigit i l =\n  match List.rev l with | [] -> [] | h::t -> [mulByDigit i t; (h * i) mod 10];;\n"]}
{"fix": ["let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::t -> (h*i mod 10) :: h*i/10 + h :: []"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> ((h * i) mod 10) :: (((h * i) / 10) + h);;\n"]}
{"fix": ["let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::t -> List.append (mulByDigit i t) ( (h*i) :: [] )"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> [(mulByDigit i t) ((h * i) mod 10)];;\n"]}
{"fix": ["let rec mulByDigit i l = \nmatch l with\n| []   -> 0\n| h::t -> h*i"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec mulByDigit i l = match l with | [] -> [] | h::t -> h * i;;\n"]}
{"fix": ["let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::m::t -> ( (h*i) mod 10 ) :: ( (h*i)/10 ) + m*i :: []"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::m::t -> ((h * i) mod 10) :: (((h * i) / 10) + (m * i));;\n"]}
{"fix": ["let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::m::t -> (mulByDigit i (m::t)) @ ( ( (h*i)/10 ) + (m*i) mod 10 :: ( (h*i) mod 10 ) :: [] )"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type 'a list -> 'b list list\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside 'a list -> 'b list list\n", "Error: This expression has type 'a list\n       but an expression was expected of type ('a list -> 'b list) list\n       The type variable 'a occurs inside 'a list -> 'b list\n", "Error: This expression has type 'a list\n       but an expression was expected of type ('a list -> 'b list) list\n       The type variable 'a occurs inside 'a list -> 'b list\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::m::t ->\n      [(mulByDigit m)\n      ::\n      t;\n      ((h * i) / 10) + ((m * i) mod 10);\n      (h * i) mod 10];;\n", "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::m::t ->\n      ((mulByDigit m) :: t) @\n        [((h * i) / 10) + ((m * i) mod 10); (h * i) mod 10];;\n", "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::m::t ->\n      ((mulByDigit m) :: t) @\n        [((h * i) / 10) + ((m * i) mod 10); (h * i) mod 10];;\n", "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::m::t ->\n      ((mulByDigit i m) :: t) @\n        [((h * i) / 10) + ((m * i) mod 10); (h * i) mod 10];;\n"]}
{"fix": ["let rec mulByDigit i l = \nmatch (List.rev l) with\n| _::[]   -> []\n| h::m::t -> (mulByDigit i (m::t)) @ ( ( (h*i)/10 ) + (m*i) mod 10 :: ( (h*i) mod 10 ) :: [] )"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec mulByDigit i l =\n  match List.rev l with\n  | []::[] -> []\n  | h::m::t ->\n      (mulByDigit i (m :: t)) @\n        [((h * i) / 10) + ((m * i) mod 10); (h * i) mod 10];;\n"]}
{"fix": [], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type int list * int list\n       but an expression was expected of type ('a * 'b) list\n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet _ = List.split (padZero [9; 9] [1; 0; 0; 2]);;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a -> int * int -> int * 'a\n       but an expression was expected of type 'a -> int * int -> 'a\n       The type variable 'a occurs inside int * 'a\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type 'a -> int * int -> 'a * int\n       but an expression was expected of type 'a -> int * int -> 'a\n       The type variable 'a occurs inside 'a * int\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int * int -> int * int -> int\n       but an expression was expected of type\n         int * int -> int * int -> int * int\n       Type int is not compatible with type int * int \n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int * int -> int * int -> (int * int) list\n       but an expression was expected of type\n         int * int -> int * int -> int * int\n       Type (int * int) list is not compatible with type int * int \n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> ((h1 + h2), a) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> h1 + h2 in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> h1 + h2 in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> h1 + h2 in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> (a, (h1 + h2)) in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> a in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> (match a with | (v1,v2) -> ((v1 + h1) + v2) + h2) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> (match a with | (v1,v2) -> ((v1 + h1), (v2 + h2))) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> (match a with | (v1,v2) -> [((v1 + h1), (v2 + h2))]) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n(list1, list2) -> (list1, list2)\nin\nlet base = ([0],[0]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b -> 'c -> 'a\n       but an expression was expected of type 'a * 'b -> 'c -> 'a * 'b\n       The type variable 'a occurs inside 'a * 'b\n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (list1,list2) -> list1 in\n    let base = ([0], [0]) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([],[]) -> ([],[])\n| (list1, list2) -> (list1, list2)\nin\nlet base = ([0],[0]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b * 'c\n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list1,list2) -> (match (list1, list2) with | [] -> ([], [])) in\n    let base = ([0], [0]) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([],[]) -> match x with\n(h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])\n| (list1, list2) -> ([1], [1])\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          (match x with\n           | (h1,h2) -> ([(h1 + h2) / 10], [(h1 + h2) mod 10])\n           | (list1,list2) -> (list1, list2)) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([],[]) -> match x with\n| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type 'c list\n", "Error: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type 'c list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          (match x with\n           | [] -> a\n           | (h1,h2) -> ([(h1 + h2) / 10], [(h1 + h2) mod 10])\n           | (list1,list2) -> ([1], [1])) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          (match x with\n           | [] -> ([], [])\n           | (h1,h2) -> ([(h1 + h2) / 10], [(h1 + h2) mod 10])\n           | (list1,list2) -> ([1], [1])) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          (match x with\n           | ([],[]) -> a\n           | (h1,h2) -> ([(h1 + h2) / 10], [(h1 + h2) mod 10])) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(v1,v2) -> match a with\n(h1::t1, h2::t2) -> (v1 :: h1::t1, v2::h2::t2)\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type 'c list\n", "Error: This expression has type int list * int list\n       but an expression was expected of type int list list * int list list\n       Type int is not compatible with type int list \n", "Error: This expression has type 'a list -> 'a * 'a -> 'a list * 'a list\n       but an expression was expected of type 'a list -> 'a * 'a -> 'a list\n       Type 'a list * 'a list is not compatible with type 'a list \n", "Error: This expression has type 'a list -> 'a * 'a -> 'a list * 'a list\n       but an expression was expected of type 'a list -> 'a * 'a -> 'a list\n       Type 'a list * 'a list is not compatible with type 'a list \n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (lh1::lt1,lh2::lt2) ->\n          (match x with\n           | (h1,h2) ->\n               (((((h1 + h2) + lh1) / 10) :: lt1),\n                 ((((h1 + h2) + lh1) mod 10) :: lt2))\n           | ([],[]) ->\n               (match x with\n                | (h1,h2) -> ([(h1 + h2) / 10], [(h1 + h2) mod 10]))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (lh1::lt1,lh2::lt2) ->\n          (match x with\n           | (h1,h2) ->\n               (match h1 with\n                | x::y ->\n                    (match h2 with\n                     | a::b ->\n                         (((((x + a) + lh1) / 10) :: lt1),\n                           ((((x + a) + lh1) mod 10) :: lt2))\n                     | ([],[]) ->\n                         (match x with\n                          | (h1,h2) -> ([(h1 + h2) / 10], [(h1 + h2) mod 10]))))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (lh1::lt1,lh2::lt2) ->\n          (match x with\n           | (h1,h2) ->\n               (match h1 with\n                | x::y ->\n                    (match h2 with\n                     | a::b ->\n                         (((((x + a) + lh1) / 10) :: lt1),\n                           ((((x + a) + lh1) mod 10) :: lt2))))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (v1,v2) -> ((v1 :: a), (v2 :: a)) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (v1,v2) -> ((v1 :: a), (v2 :: a)) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(v1,v2) -> match a with\n(list1, list2) -> (v1 :: list1, v2::list2)\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list * 'b list\n       but an expression was expected of type 'c list\n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) -> (match a with | ([],[]) -> ((v1 :: a), (v2 :: a))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(v1,v2) -> match a with\n(list1, list2) -> ( v1::list1, v2::list2)\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int list * int list\n       but an expression was expected of type 'a list list * 'b list list\n       Type int is not compatible with type 'a list \n", "Error: This expression has type int list * int list\n       but an expression was expected of type 'a list list * 'b list list\n       Type int is not compatible with type 'a list \n", "Error: This expression has type int list * int list\n       but an expression was expected of type 'a list list * 'b list list\n       Type int is not compatible with type 'a list \n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               ((List.append list1 v1), (List.append list2 v2))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               ((List.append list1 v1), (List.append list2 v2))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with | (list1,list2) -> ((list1 @ v1), (list2 @ v2))) in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(v1,v2) -> match a with\n(list1, list2) -> match list1 with\n| [] -> ( (v1+v2)/10::list1, (v1+v2) mod 10::list2 )\n| (h::t) -> ((v1+v2+h)/10::list1, (v1+v2+h) mod 10 :: list2)\nin\nlet base = ([],[]) in\nlet args = List.append (List.rev (List.combine l1 l2))  [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list list\n", "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = (List.rev (List.combine l1 l2)) :: (0, 0) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2) (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) (0, 0) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> mulByDigit i (List.rev l) @  h*i :: []"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> [mulByDigit i (List.rev l); h * i];;\n"]}
{"fix": ["let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> (mulByDigit i (List.rev t) @ [0])  @  h*i :: []"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list list\n", "Error: This expression has type int but an expression was expected of type\n         'a list list\n", "Error: This expression has type int but an expression was expected of type\n         'a list list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> ((mulByDigit i (List.rev t)) :: 0) @ [h * i];;\n", "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> ((mulByDigit i (List.rev t)) :: 0) @ [h * i];;\n", "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> ((mulByDigit i (List.rev t)) :: 0) @ [h * i];;\n", "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> ((mulByDigit i (List.rev t)) @ 0) @ [h * i];;\n"]}
{"fix": ["let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> mulByDigit i (List.rev t)  @  h*i :: []"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) @ [h * i];;\n"]}
{"fix": ["let rec mulByDigit i l = match (List.rev l) with\n| []   -> 0\n| h::t -> (mulByDigit i (List.rev t) * 10 ) + h*i"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> (((mulByDigit i (List.rev t)) * 10) h) * i;;\n", "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> (((mulByDigit i (List.rev t)) * 10) h) * i;;\n"]}
{"fix": ["let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: []"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int list list\n       but an expression was expected of type int list\n       Type int list is not compatible with type int \n"], "bad": ["\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (mulByDigit i (List.rev (List.map (fun x  -> [x * 10]) t))) @ [h * i];;\n"]}
{"fix": ["let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> []\n| h::t -> let rec helper lst = match lst with\n| [] -> []\n| h1::t1 -> helper t1 @ h1 mod 10 :: []\nin helper [h]"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let rec helper lst =\n             match lst with | [] -> [] | h1::t1 -> [helper t1; h1 mod 10] in\n           helper [h]);;\n"]}
{"fix": ["let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> []\n| h::t -> let rec helper v = helper (v/10) @ v mod 10 :: []\nin helper h"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: Unbound value h1\n"], "bad": ["\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let rec helper v = ((helper v) / 10) @ [h1 mod 10] in helper h);;\n", "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t -> let rec helper v = [(helper v) / 10; h1 mod 10] in helper h);;\n", "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t -> let rec helper v = [helper (v / 10); h1 mod 10] in helper h);;\n", "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let rec helper v = (helper (v / 10)) @ [h1 mod 10] in helper h);;\n"]}
{"fix": ["let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> []\n| h::t -> let rec helper acc v = if v = 0 then acc else helper (v mod 10 :: acc) (v/10)\nin helper [] h"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let rec helper acc v =\n             if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n           helper h);;\n"]}
{"fix": ["let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> []\n| h::t -> [h]"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t -> h);;\n", "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> 0\n       | h::t -> h);;\n"]}
{"fix": ["let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> []\n| h1::t1 -> let rec helper acc v = if v = 0 then [1] else [0] \n(* if v = 0 \nthen \nacc \nelse \nhelper ( (v mod 10) :: acc) (v/10) *)\nin helper [] h1"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type bool but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h1::t1 -> let rec helper acc v = v = 0 in helper [] h1);;\n"]}
{"fix": [], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type bool but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> false\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h1::t1 -> let rec helper acc v = [v] = [0] in helper [] h1);;\n"]}
{"fix": ["let rec mulByDigit i l = match (List.rev l) with\n| []   -> 0\n| h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i )"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then 0 :: acc else helper ((v mod 10) :: acc) (v / 10) in\n      (helper ((mulByDigit i (List.rev t)) * 10)) + (h * i);;\n", "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t ->\n      (match ((mulByDigit i (List.rev t)) * 10) + (h * i) with\n       | n ->\n           let rec helper acc v =\n             if v = 0 then 0 :: acc else helper ((v mod 10) :: acc) (v / 10) in\n           helper [] n);;\n", "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match ((mulByDigit i (List.rev t)) * 10) + (h * i) with\n       | n ->\n           let rec helper acc v =\n             if v = 0 then 0 :: acc else helper ((v mod 10) :: acc) (v / 10) in\n           helper [] n);;\n", "\nlet x a = a;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match [((mulByDigit i (List.rev t)) * 10) + (h * i)] with\n       | x::y ->\n           let rec helper acc v =\n             if v = 0 then 0 :: acc else helper ((v mod 10) :: acc) (v / 10) in\n           helper [] x);;\n", "\nlet x a = a;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match [((mulByDigit i (List.rev t)) * 10) + (h * i)] with\n       | x::y ->\n           let rec helper acc v =\n             if v = 0 then 0 :: acc else helper ((v mod 10) :: acc) (v / 10) in\n           helper [] x);;\n", "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> [((mulByDigit i (List.rev t)) * 10) + (h * i)];;\n", "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n"]}
{"fix": [], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> ((mulByDigit i (List.rev t)) * 10) + (h * i);;\n"]}
{"fix": ["let rec mulByDigit i l = match l with\n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10)\nin helper [] h"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else (helper (v mod 10)) :: (acc (v / 10)) in\n      helper [] h;;\n"]}
{"fix": ["let rec mulByDigit i l = match l with\n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10)\nin match ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with\n[] -> []\n| h::t -> [h]"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int list\n       but an expression was expected of type int list list\n"], "bad": ["\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | h::t -> h);;\n"]}
{"fix": ["let rec mulByDigit i l = match l with\n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\n( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) @ [])"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (adder (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)))) @\n        [helper [] (h * i)];;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (adder (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)))) @\n        ((helper [] (h * i)) @ []);;\n"]}
{"fix": ["let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n[] -> []\n| h::t -> [h]\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n", "Error: Unbound value int\n", "Error: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n", "Error: This expression has type int list\n       but an expression was expected of type int list list\n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (adder (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)))) @\n        [helper [] (h * i)];;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> int list []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x =\n        match x with | [] -> int list [] | h::t -> bigAdd h (adder t) in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> h in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n"]}
{"fix": ["let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n| [] -> []\n| h::t -> ( bigAdd h (adder t) )\nin \n[adder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )]"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x =\n        match x with | [] -> [] | h::t -> [bigAdd h (adder t)] in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x =\n        match x with | [] -> [] | h::t -> [bigAdd h (adder t)] in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n"]}
{"fix": ["let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n| [] -> []\n| h::t -> ( bigAdd h (adder t) )\nin \n[adder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )]"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (match [adder\n                ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n                   [helper [] (h * i)])]\n       with\n       | h::t -> h);;\n"]}
{"fix": ["let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n| [] -> []\n| h::t -> ( bigAdd h (adder t) )\nin \n( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: [])"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n", "Error: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> [0]\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [0] | h::t -> bigAdd h (adder t) in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> [0]\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [0] | h::t -> bigAdd h (adder t) in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           ((helper [] (h * i)) @ []));;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n"]}
{"fix": ["let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n| [] -> []\n| h::t -> ( bigAdd h (adder t) )\nin \n( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) )"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      adder\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n           [helper [] (h * i)]);;\n"]}
{"fix": [], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      let rec adder x = match x with | [] -> [] | h::t -> bigAdd h (adder t) in\n      (adder (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)))) @\n        (helper [] (h * i));;\n"]}
{"fix": [], "hw": "hw3", "problem": "removeZero", "message": ["Error: Unbound value h\n"], "bad": ["\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ = if h = 0 then removeZero t;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = (x(a)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int\n       Type int is not compatible with type int -> int \n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n"], "bad": ["\nlet f a b a = a * b;;\n\nlet pipe fs =\n  let f a x = f (x a) in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x a x = x a in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": [], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n"], "bad": ["\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) \nin ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: [])"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | x::y ->\n           let rec adder w =\n             match w with | [] -> [] | a::b -> bigAdd a (adder b) in\n           adder (h :: t));;\n"]}
{"fix": ["let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) \nin\nmatch ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with\n| [] -> []\n| x::y -> let rec adder w = match w with\n| [] -> []\n| a::b -> ( bigAdd a (adder b) )\nin \n[adder (x::y)]"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int list\n       but an expression was expected of type int list list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n"], "bad": ["\nlet x a = a;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | x::y -> x);;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | x::y ->\n           let rec adder w =\n             match w with | [] -> [] | a::b -> bigAdd a (adder b) in\n           adder (h :: t));;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x a = a;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | x::y ->\n           let rec adder w =\n             match w with | [] -> [] | a::b -> bigAdd a (adder b) in\n           adder (x :: y));;\n"]}
{"fix": ["let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ h*i :: []"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> (List.rev (List.map (fun x  -> x * 10) t)) + (h * i);;\n", "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> (List.rev (List.map (fun x  -> x * 10) t)) @ [h * i];;\n", "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> (List.rev (List.map (fun x  -> x * 10) t)) @ [h * i];;\n", "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t -> [mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)); h * i];;\n", "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t -> [mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)); h * i];;\n"]}
{"fix": ["let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> [sqsum (( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ h*i :: [])]"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      sqsum\n        ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @ [h * i]);;\n"]}
{"fix": [], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match ((mulByDigit i (List.rev t)) * 10) + (h * i) with | n -> [n]);;\n"]}
{"fix": [], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x a = a;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               (helper [] (h * i))\n       with\n       | [] -> []\n       | x::y ->\n           let rec adder w =\n             match w with | [] -> [] | a::b -> bigAdd a (adder b) in\n           adder (x :: y));;\n"]}
{"fix": ["let rec mulByDigit i l = \nmatch l with\n[] -> []\n| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []\nwith \n[] -> []\n| h::t -> h :: []"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t -> h);;\n"]}
{"fix": ["let rec mulByDigit i l = \nmatch l with\n[] -> []\n| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []\nwith \n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen \nacc\nelse \nv mod 10 :: []\nin helper [] h"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let rec helper acc v = if v = 0 then acc else v mod 10 in\n           helper [] h);;\n"]}
{"fix": ["let rec mulByDigit i l = \nmatch l with\n[] -> []\n| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []\nwith \n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen \nacc\nelse \n(v mod 10) :: acc\nin helper [] h"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet _ = (List.map (fun x  -> x * 10) [1; 2; 3] 8100) mod 10;;\n"]}
{"fix": [], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This function has type int list -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n"], "bad": ["\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        match v with | [] -> [] | h::t -> if h = 0 then acc else 0 :: acc in\n      (helper [] mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n        [h * i];;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x a = a;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [helper [] (h * i)]\n       with\n       | [] -> []\n       | x::y ->\n           let rec adder w =\n             match w with | [] -> [] | a::b -> bigAdd a (adder b) in\n           adder (x :: y));;\n"]}
{"fix": ["let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin helper [] h"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: Unbound value v\n"], "bad": ["\nlet rec helper acc v = if v = 0 then acc else helper [v mod 10] (v / 10);;\n\nlet _ =\n  let rec mulByDigit i l =\n    match List.rev l with\n    | [] -> []\n    | h::t ->\n        (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n                 [h * i]\n         with\n         | [] -> []\n         | h::t -> if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10)) in\n  helper [] h;;\n"]}
{"fix": ["let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t ->  let rec helper acc v = \nif v = 0\nthen\nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin (helper [] h)"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int list\n"], "bad": ["\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let rec helper acc v =\n             if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n           helper []);;\n"]}
{"fix": ["let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 in\n[List.fold_left f base (h::t)]"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: Unbound value lst\nHint: Did you mean fst, lsl or lsr?\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let f a x = a + x in let base = 0 in List.fold_left f base lst);;\n", "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let f a x = a + x in\n           let base = 0 in List.fold_left f base (h :: t));;\n"]}
{"fix": ["let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 in\nmatch [List.fold_left f base (h::t)] with\n| [] -> []\n| a::b -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse\n( (v/10) mod 10 ) :: (v mod 10) :: acc\nin helper [] a"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n               [h * i]\n       with\n       | [] -> []\n       | h::t ->\n           let f a x = a + x in\n           let base = 0 in\n           (match [List.fold_left f base (h :: t)] with\n            | [] -> []\n            | a::b ->\n                let rec helper acc v =\n                  if v = 0\n                  then acc\n                  else ((v / 10) mod 10) :: ((v mod 10) :: acc) :: acc in\n                helper [] a));;\n"]}
{"fix": ["let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 in\nlet rec helper acc v = \nif v = 0\nthen\nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin helper [] (List.hd [List.fold_left f base ((mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [])])"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let f a x = a + x in\n      let base = 0 in\n      let rec helper acc v =\n        if v = 0 then acc else (helper (v mod 10)) :: (acc (v / 10)) in\n      helper []\n        [List.fold_left f base\n           ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n              [h * i])];;\n", "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let f a x = a + x in\n      let base = 0 in\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      helper []\n        [List.fold_left f base\n           ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n              [h * i])];;\n"]}
{"fix": ["let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 \nin match [List.fold_left f base ((mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [])] with\n[] -> [] \n| c::d -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin helper [] c"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: Unbound value base\n"], "bad": ["\nlet f a b a = a * b;;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      (match [List.fold_left f base\n                ((mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) @\n                   [h * i])]\n       with\n       | [] -> []\n       | c::d ->\n           let rec helper acc v =\n             if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n           helper [] c);;\n"]}
{"fix": ["let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t ->\nlet rec helper acc v =  \nif v = 0\nthen \nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin bigAdd (mulByDigit i (List.rev (List.map (fun x -> x*10) t ) )) (helper [] (h*i))"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This function has type int list -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type int list\n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      bigAdd (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t))) helper\n        [] (h * i);;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      bigAdd (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)));;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = match x with\n(k,v) -> match a with\n(c,d) -> (c, bigAdd d (mulByDigit k v)) in \nlet base = ([], [0]) in\nlet args = let rec helper acc l1 l2 = \nmatch l1 with \n| [] -> acc\n| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2\nin helper [] (List.rev l1) l2\nin\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type (int * 'a) list\n       but an expression was expected of type ('b list * int list) list\n       Type int is not compatible with type 'b list \n", "Error: This expression has type 'a -> 'b -> 'a * 'b\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'a * 'b\n", "Error: This expression has type 'a -> 'b -> 'a list * 'b list\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'a list * 'b list\n"], "bad": ["\nlet bigMul l1 l2 =\n  let f a x = x in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet bigMul l1 l2 =\n  let f a x = (a, x) in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet bigMul l1 l2 =\n  let f a x = ([a], [x]) in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type (int * 'a) list\n       but an expression was expected of type ('b list * int list) list\n       Type int is not compatible with type 'b list \n"], "bad": ["\nlet bigMul l1 l2 =\n  let f a x = match x with | (k,v) -> (k, v) in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = match x with\n(k,v) -> ([k],v) in \nlet base = ([], [0]) in\nlet args = let rec helper acc l1 l2 = \nmatch l1 with \n| [] -> acc\n| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2\nin helper [] (List.rev l1) l2\nin\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type (int * 'a) list\n       but an expression was expected of type int list\n       Type int * 'a is not compatible with type int \n", "Error: This expression has type (int * 'a) list\n       but an expression was expected of type ('b list * int list) list\n       Type int is not compatible with type 'b list \n"], "bad": ["\nlet bigMul l1 l2 =\n  let f a x = ([0], [x]) in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet bigMul l1 l2 =\n  let f a x = x in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = match x with\n(k,v) -> match a with\n(c,d) -> (v :: c, k :: d) in \nlet base = ([], []) in\nlet args = let rec helper acc l1 l2 = \nmatch l1 with \n| [] -> acc\n| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2\nin helper [] (List.rev l1) l2\nin\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type (int * 'a) list\n       but an expression was expected of type (int list * 'b) list\n       Type int is not compatible with type int list \n", "Error: This expression has type (int * 'a) list\n       but an expression was expected of type (int list * 'b) list\n       Type int is not compatible with type int list \n"], "bad": ["\nlet bigMul l1 l2 =\n  let f a x =\n    match x with | (k,v) -> (match a with | (c,d) -> ((v :: c), (k :: d))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (k,v) -> (match a with | (c,d) -> ((v :: c), ((bigMul k v) :: d))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet bigMul l1 l2 =\n  let f a x =\n    match x with | (k,v) -> (match a with | (c,d) -> ((v :: c), (k :: d))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (k,v) -> (match a with | (c,d) -> ((v :: c), (bigMul k v))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = match x with\n(k,v) -> match a with\n(c,d) -> (v :: c, (mulByDigit k v) ) in \nlet base = ([], []) in\nlet args = let rec helper acc l1 l2 = \nmatch l1 with \n| [] -> acc\n| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2\nin helper [] (List.rev l1) l2\nin\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type (int * 'a) list\n       but an expression was expected of type (int list * 'b) list\n       Type int is not compatible with type int list \n"], "bad": ["\nlet bigMul l1 l2 =\n  let f a x =\n    match x with | (k,v) -> (match a with | (c,d) -> ((v :: c), (k :: d))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (k,v) -> (match a with | (c,d) -> ((v :: c), (bigMul k v))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["[1;0] @ (clone 0 1)"], "hw": "hw3", "problem": "clone", "message": ["Error: This expression has type int list\n       but an expression was expected of type (int * int) list\n       Type int is not compatible with type int * int \n", "Error: This expression has type int list\n       but an expression was expected of type (int * int) list\n       Type int is not compatible with type int * int \n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = [(1, 0)] @ (clone 0 1);;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet _ = [(1, 0)] @ (clone 0 1);;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = match a with\n(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ((mulByDigit x l1) @ (clone 0 numZeroes)) (prevRes) )  in\nlet base = (1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int list\n       This is not a function; it cannot be applied.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      bigAdd (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)))\n        (helper [] (h * i));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (numZeroes,prevRes) ->\n        ((numZeroes + 1),\n          (bigAdd ((mulByDigit x l1) @ ((clone 0 numZeroes) prevRes)))) in\n  let base = (1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      bigAdd (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)))\n        (helper [] (h * i));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (numZeroes,prevRes) ->\n        ((numZeroes + 1),\n          (bigAdd (((mulByDigit x l1) @ (clone 0 numZeroes)) prevRes))) in\n  let base = (1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let rec helper acc v =\n        if v = 0 then acc else helper ((v mod 10) :: acc) (v / 10) in\n      bigAdd (mulByDigit i (List.rev (List.map (fun x  -> x * 10) t)))\n        (helper [] (h * i));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (numZeroes,prevRes) ->\n        ((numZeroes + 1),\n          (bigAdd (((mulByDigit x l1) @ (clone 0 numZeroes)) prevRes))) in\n  let base = (1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let rec mulByDigit i l = \nlet f a x = match a with\n(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( [i*x] @ (clone 0 numZeroes) ) (prevRes) ) in\nlet base = (0, []) in\nlet (_,res) = List.fold_left f base (List.rev l) in\nres"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         'a list\n", "Error: Unbound value h\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value h\n", "Error: Unbound value List.fold\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value List.fold\n"], "bad": ["\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (numZeroes,prevRes) ->\n        ((numZeroes + 1), (bigAdd ((i * x) @ (clone 0 numZeroes)) prevRes)) in\n  let base = (0, []) in let (_,res) = List.fold f base (List.rev l) in res;;\n", "\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (numZeroes,prevRes) ->\n        ((numZeroes + 1), (bigAdd ((i * x) @ (clone 0 numZeroes)) prevRes)) in\n  let base = (0, []) in let (_,res) = List.fold f base (List.rev l) in res;;\n", "\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (numZeroes,prevRes) ->\n        ((numZeroes + 1), (bigAdd ([i * h] @ (clone 0 numZeroes)) prevRes)) in\n  let base = (0, []) in let (_,res) = List.fold f base (List.rev l) in res;;\n", "\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (v1,v2) ->\n          (match a with\n           | (list1,list2) ->\n               (match list1 with\n                | [] ->\n                    ((((v1 + v2) / 10) :: list1), (((v1 + v2) mod 10) ::\n                      list2))\n                | h::t ->\n                    (((((v1 + v2) + h) / 10) :: list1),\n                      ((((v1 + v2) + h) mod 10) :: list2)))) in\n    let base = ([], []) in\n    let args = List.append (List.rev (List.combine l1 l2)) [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (numZeroes,prevRes) ->\n        ((numZeroes + 1), (bigAdd ([i * x] @ (clone 0 numZeroes)) prevRes)) in\n  let base = (0, []) in let (_,res) = List.fold f base (List.rev l) in res;;\n"]}
{"fix": ["let listReverse l = (*failwith \"TBD\"*)\nlet rec rev x l = match x with\n| [] -> x\n| h::t -> rev (h::x) t in\nrev[] l"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'b -> 'c\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b -> 'c\n", "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet listReverse l =\n  let rec rev x = match l with | [] -> x | h::t -> rev (h :: x) t in rev [] l;;\n", "\nlet listReverse l =\n  let rec rev x = match l with | [] -> x | h::t -> rev (h :: x) t in rev [] l;;\n", "\nlet listReverse l =\n  let rec rev x = match x with | [] -> x | h::t -> rev (h :: x) t in rev [] l;;\n"]}
{"fix": ["let listReverse l = (*failwith \"TBD\"*)\nlet rec rev x = function\n| [] -> x\n| h::t -> rev (h::x) t in\nrev[] l"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type 'a list\n"], "bad": ["\nlet listReverse l =\n  let rec rev x l = function | [] -> x | h::t -> rev (h :: x) t in rev [] l;;\n"]}
{"fix": ["let listReverse l = (*failwith \"TBD\"*)\nlet x = [] in\nmatch l with\n| (h::t) -> listReverse t\n| [h] ->  h::x"], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value h\n", "Error: Unbound value h\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet listReverse l =\n  let rec rev x = function | [] -> x | h::t -> rev (h :: x) t in rev [] l;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> h :: x | _ -> listReverse x;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> listReverse t | h::[] -> h :: x;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> listReverse t | [] -> h :: x;;\n", "\nlet listReverse l =\n  let rec rev x = function | [] -> x | h::t -> rev (h :: x) t in rev [] l;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> h :: x | _ -> listReverse x;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> listReverse t | h::[] -> h :: x;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> listReverse t | _ -> h :: x;;\n", "\nlet listReverse l =\n  let rec rev x = function | [] -> x | h::t -> rev (h :: x) t in rev [] l;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> h :: x | _ -> listReverse x;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> listReverse t | h::[] -> h :: x;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> listReverse t | h -> h :: x;;\n"]}
{"fix": ["let listReverse l = (*failwith \"TBD\"*)\nlet x = [] in\nmatch l with\n| (h::t) -> listReverse t\n| [h] ->  h::x"], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value t\n"], "bad": ["\nlet listReverse l =\n  let rec rev x = function | [] -> x | h::t -> rev (h :: x) t in rev [] l;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> h :: x | _ -> listReverse x;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> listReverse t | h::[] -> h :: x;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> listReverse t | h::[] -> h :: x;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> listReverse t | h::[] -> t :: x;;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = (*failwith \"to be written\" in*)\nif List.mem h seen then\nseen\nelse \nh::seen\nin (*list of seen elts*)\nlet rest' = (*failwith \"to be written\" in *)\nt\nin (*orig list*)\nhelper (seen',rest')\n\nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: Unbound value seen'\nHint: Did you mean seen?\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let rest' = t in\n        if List.mem h seen\n        then helper (seen', rest')\n        else h :: (seen' helper (seen', rest')) in\n  List.rev (helper ([], l));;\n"]}
{"fix": [], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type int -> int * bool\n       but an expression was expected of type int -> int\n       Type int * bool is not compatible with type int \n"], "bad": ["\nlet rec wwhile (f,b) = let c' = f b in if c' = b then c' else wwhile (f, c');;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n"]}
{"fix": ["let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet c' = f b in\n(*let b' = in*)\nif c' = b \nthen c'\nelse wwhile (f, c')"], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a -> 'a\n       The type variable 'a occurs inside 'a -> 'a\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let c' = f b in let b' = b in if c' = b then c' else wwhile (c', b');;\n"]}
{"fix": ["let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet helper = f b in\nmatch helper with\n| (x, y) -> if y \nthen wwhile (f, x)\nelse x"], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value b'\n", "Error: Unbound value b'\n", "Error: Unbound value int\n", "Error: Unbound value b'\n", "Error: Unbound value bool\n", "Error: Unbound value b'\n", "Error: Unbound value int\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let helper f b = (b', (bool c')) in\n  match c' with | false  -> b' | true  -> wwhile (f, b');;\n", "\nlet rec wwhile (f,b) =\n  let helper f b = (b', (bool c')) in\n  match helper with | (int,bool) -> if c' = false then b' else wwhile (f, b');;\n", "\nlet rec wwhile (f,b) =\n  let helper f b = ((int b'), (bool c')) in\n  match helper with\n  | false  -> if c' = false then b'\n  | true  -> wwhile (f, b');;\n", "\nlet rec wwhile (f,b) =\n  let b' f b = (b', (bool c')) in\n  match helper with\n  | false  -> if c' = false then b'\n  | true  -> wwhile (f, b');;\n", "\nlet rec wwhile (f,b) =\n  let b' = f b in\n  let p = (b', (bool c')) in\n  match c' with | false  -> b' | true  -> wwhile (f, b');;\n", "\nlet rec wwhile (f,b) =\n  let f b = (b', c') in\n  match c' with | false  -> b' | true  -> wwhile (f, b');;\n", "\nlet rec wwhile (f,b) =\n  let b' = int in\n  let c' = bool in\n  let f b = (b', c') in\n  match c' with | false  -> b' | true  -> wwhile (f, b');;\n"]}
{"fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let helper = f b in\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let g =\n       let self = f b in\n       match self with | b -> (self, true) | _ -> (self, false) in\n     (g, b));;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  wwhile\n    (let g b =\n       let self = f b in\n       match b with | self -> (self, false) | _ -> (self, true) in\n     (g, b));;\n"]}
{"fix": [], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 3);;\n"]}
{"fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a -> ('a -> 'a * 'b) * bool\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a -> 'a * 'b\n", "Error: This expression has type 'a but an expression was expected of type\n         'b -> 'a\n       The type variable 'a occurs inside 'b -> 'a\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let helper = f b in\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let g b =\n       let helper = f b in\n       match helper with | (x,y) -> if x = b then (f, false) else (f, true) in\n     (g, b));;\n", "\nlet rec wwhile (f,b) =\n  let helper = f b in\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let g b =\n       let helper = f b in\n       match helper with | b -> if f = b then (f, false) else (f, true) in\n     (g, b));;\n"]}
{"fix": [], "hw": "hw2", "problem": "exprToString", "message": ["Error: Unbound constructor VarX\n", "Error: Unbound constructor VarX\n"], "bad": ["\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\")\" ^ (\"/\" ^ \")\")))))\n  | Times (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"*\" ^ ((exprToString e2) ^ \")\")))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\")\" ^ (\"/\" ^ \")\")))))\n  | Times (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"*\" ^ ((exprToString e2) ^ \")\")))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value emitGrayscale\n", "Error: This expression has type int but an expression was expected of type\n         int * int\n"], "bad": ["\nlet _ = emitGrayscale ((eval_fn sampleExpr), 150, \"sample\");;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rng = rand (0, 9) in\n  if depth >= 0\n  then match rand 0 2 with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rng with\n     | 0 -> build (rand, (depth - 1))\n     | 1 -> build (rand, (depth - 1))\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value buildExpwn\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rng = rand (0, 9) in\n  if depth >= 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rng with\n     | 0 -> build (rand, (depth - 1))\n     | 1 -> build (rand, (depth - 1))\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: Unbound value buildExpwn\n", "Error: Unbound value buildExpwn\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rng = rand (0, 9) in\n  if depth >= 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rng with\n     | 0 -> build (rand, (depth - 1))\n     | 1 -> build (rand, (depth - 1))\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rng = rand (0, 9) in\n  if depth >= 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rng with\n     | 0 -> build (rand, (depth - 1))\n     | 1 -> build (rand, (depth - 1))\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "expr", "message": ["Error: Unbound value buildExpwn\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rng = rand (0, 9) in\n  if depth >= 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rng with\n     | 0 -> build (rand, (depth - 1))\n     | 1 -> build (rand, (depth - 1))\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\n     | 8 -> buildTan (build (rand, (depth - 1))));;\n"]}
{"fix": [], "hw": "hw3", "problem": "sqsum", "message": ["Error: Unbound value sqsum\n", "Error: Unbound value sqsum\n", "Error: Unbound value f\n", "Error: Unbound value f\n", "Error: Unbound value sqsum\n", "Error: Unbound value sqsum\n", "Error: Unbound value sqsum\n"], "bad": ["\nlet sqsum xs =\n  let f a x = match x with | [] -> a | h::tl -> (h * h) + (sqsum tl) in\n  let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = match x with | [] -> a | h::tl -> (h * h) + (sqsum tl) in\n  let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = match x with | [] -> a | h::tl -> (f (a tl)) + (h * h) in\n  let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = match x with | [] -> a | h::tl -> (f (a tl)) + (h * h) in\n  let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let rec f a x = match x with | [] -> a | h::xs' -> (h * h) + (sqsum xs') in\n  let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let rec f a x =\n    match x with | [] -> a | h::xs' -> (h * h) + (sqsum (f a xs')) in\n  let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let rec f a x =\n    match x with | [] -> a | h::tl -> (h * h) + (sqsum (f a tl) tl) in\n  let base = 0 in List.fold_left f base xs;;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 0 then [] else (match n with | 0 -> [0] | _ -> digitsOfInt n []);;\n", "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | _ -> digitsOfInt (n / 10) []);;\n", "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | _ -> digitsOfInt (n / 10) []);;\n", "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | _ -> digitsOfInt (n / 10) []);;\n"]}
{"fix": ["let rec sumList xs = match xs with \n| [] -> 0\n| hd::tl -> hd + sumList tl"], "hw": "hw1", "problem": "sumList", "message": ["Error: Unbound value hd\n", "Error: Unbound record field hd\n", "Error: Unbound value hd\n", "Error: Unbound value hd\n"], "bad": ["\nlet rec sumList xs = hd + (sumList tl);;\n", "\nlet rec sumList xs = xs.hd + (sumList xs.tl);;\n", "\nlet rec sumList xs = (hd []) + (sumList (tl []));;\n", "\nlet rec sumList xs = (hd xs) + (sumList (tl xs));;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This function has type int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 0 then [] else [digitsOfInt (n / 10); n mod 10];;\n", "\nlet rec digitsOfInt n = if n < 0 then [] else [digitsOfInt (n / 10)];;\n", "\nlet rec digitsOfInt n =\n  if n < 0 then [] else [digitsOfInt (n / 10) (n mod 10)];;\n", "\nlet rec digitsOfInt n =\n  if n < 0 then [] else [digitsOfInt (n / 10) (n mod 10)];;\n", "\nlet rec digitsOfInt n = if n < 0 then [] else [digitsOfInt (n / 10)];;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> []\n| _ -> digitsOfInt (n/10)@[n mod 10]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | _ -> (digitsOfInt (n / 10)) :: (n mod 10));;\n", "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (digitsOfInt (n / 10)) :: (n mod 10));;\n", "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (digitsOfInt (n / 10)) @ (n mod 10));;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> []\n| _ -> digitsOfInt (n/10)@[n mod 10]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (digitsOfInt (n / 10)) :: (n mod 10));;\n", "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> [digitsOfInt (n / 10); n mod 10]);;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec myAppend l n = match l with | [] -> [n] | h::t -> h :: (myAppend t n);;\n\nlet rec digitsOfInt n =\n  if n = 0\n  then [0]\n  else if n > 0 then myAppend [digitsOfInt (n / 10)] (n mod 10) else [];;\n", "\nlet rec myAppend l n = match l with | [] -> [n] | h::t -> h :: (myAppend t n);;\n\nlet rec digitsOfInt n =\n  if n = 0\n  then [0]\n  else if n > 0 then myAppend [digitsOfInt (n / 10)] (n mod 10) else [];;\n"]}
{"fix": ["let rec additivePersistence n = match n with\n| 0 -> 1\n| _ -> 1 + additivePersistence (sumList (digits n))"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec myAppend l n = match l with | [] -> [n] | h::t -> h :: (myAppend t n);;\n\nlet rec getDigits n =\n  match n with | 0 -> [] | _ -> myAppend (getDigits (n / 10)) (n mod 10);;\n\nlet rec digitsOfInt n = if n = 0 then [0] else getDigits n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  match n with | 0 -> 1 | _ -> 1 + (additivePersistence sumList digits n);;\n", "\nlet rec myAppend l n = match l with | [] -> [n] | h::t -> h :: (myAppend t n);;\n\nlet rec getDigits n =\n  match n with | 0 -> [] | _ -> myAppend (getDigits (n / 10)) (n mod 10);;\n\nlet rec digitsOfInt n = if n = 0 then [0] else getDigits n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  match n with | 0 -> 1 | _ -> 1 + (additivePersistence (sumList digits n));;\n"]}
{"fix": [], "hw": "hw1", "problem": "palindrome", "message": ["Error: This expression has type char list\n       but an expression was expected of type 'a list list\n       Type char is not compatible with type 'a list \n"], "bad": ["\nlet rec myAppend l n = match l with | [] -> [n] | h::t -> h :: (myAppend t n);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listCompare l k =\n  if ((List.hd l) = []) && ((List.hd k) = [])\n  then true\n  else\n    if (List.hd l) = (List.hd k)\n    then listCompare (List.tl l) (List.tl k)\n    else false;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> myAppend (listReverse t) h;;\n\nlet palindrome w = listCompare (explode w) (listReverse (explode w));;\n"]}
{"fix": ["let rec wwhile (f,b) = \nlet helper (b', c') = \nif c' then wwhile (f, b')\nelse b'\nin f b"], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value b'\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let helper (b',c') = if c' then wwhile (f, b') else b' in f b';;\n"]}
{"fix": ["let rec wwhile (f,b) = match f b with\n| (b', c') -> if c' then wwhile (f, b')\nelse b'"], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value c'\n", "Error: Unbound value c'\n"], "bad": ["\nlet rec wwhile (f,b) = let (b',c') = if c' then wwhile (f, b') else b' in f b;;\n", "\nlet _ =\n  let rec wwhile (f,b) = if c' then wwhile (f, b') else b' in f b (b', c');;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((fun f' -> let x = f b in (f', f' != x)),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value l\n"], "bad": ["\nlet _ = l;;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n"], "bad": ["\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n"]}
{"fix": [], "hw": "hw2", "problem": "expr", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n"]}
{"fix": ["et _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "Error: This expression has type expr but an expression was expected of type\n         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)\n", "Error: This expression has type expr\n       This is not a function; it cannot be applied.\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval e'))\n  | Cosine e' -> cos (pi *. (eval e'))\n  | Average (e1,e2) -> ((eval e1) +. (eval e2)) / 2\n  | Times (e1,e2) -> (eval e1) *. (eval e2)\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval e1) < (eval e2) then eval e3 else eval e4;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval e' x y))\n  | Cosine e' -> cos (pi *. (eval e' x y))\n  | Average (e1,e2) -> ((eval e1 x y) +. (eval e2 x y)) / 2\n  | Times (e1,e2) -> (eval e1 x y) *. (eval e2 x y)\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval e1 x y) < (eval e2 x y) then eval e3 x y else eval e4 x y;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e' (e', x, y))))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e' -> sin(pi *. (eval (e', x, y)))\n| Cosine e' -> cos(pi *. (eval (e', x, y)))\n| Average (e1, e2) -> (((eval (e1, x, y)) +. (eval (e2, x, y)))/.(2.0))\n| Times (e1, e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y)))\n| Thresh (e1, e2, e3, e4) -> (if ((eval (e1, x, y))<(eval (e2, x, y))) then (eval (e3, x, y)) else (eval (e4, x, y)))"], "hw": "hw2", "problem": "eval", "message": ["Error: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\nError: Unbound value sampleExpr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e' -> sin(pi *. (eval (e', x, y)))\n| Cosine e' -> cos(pi *. (eval (e', x, y)))\n| Average (e1, e2) -> (((eval (e1, x, y)) +. (eval (e2, x, y)))/.(2.0))\n| Times (e1, e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y)))\n| Thresh (e1, e2, e3, e4) -> (if ((eval (e1, x, y))<(eval (e2, x, y))) then (eval (e3, x, y)) else (eval (e4, x, y)))\n| Custom1 (e1, e2, e3) -> ((cos(pi *. (eval (e1, x, y)))) *. (sin(pi *. (eval (e2, x, y)))))*.((cos(pi *. (eval (e3, x, y))))**(2.0))"], "hw": "hw2", "problem": "eval", "message": ["Error: Unbound value ^.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Custom1 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Custom1 (e1,e2,e3) ->\n      ((cos (pi *. (eval (e1, x, y)))) *. (sin (pi *. (eval (e2, x, y))))) *.\n        ((cos (pi *. (eval (e3, x, y)))) ^. 2);;\n"]}
{"fix": ["let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\""], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a list\n       but an expression was expected of type string\n"], "bad": ["\nlet stringOfList f l = \"[\" ^ ((List.map f \"; \" l) ^ \"]\");;\n", "\nlet stringOfList f l = \"[\" ^ ((List.map f (\"; \" l)) ^ \"]\");;\n", "\nlet stringOfList f l = \"[\" ^ ((List.map (f \"; \") l) ^ \"]\");;\n"]}
{"fix": [], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n"], "bad": ["\nlet _ =\n  let rec mulByDigit i l =\n    let (i',l') = (0, (List.rev l)) in\n    match l' with\n    | [] -> []\n    | h::t -> (((h * i) + i') mod 10) ::\n        (mulByDigit ((((h * i) + i') / 10), t)) in\n  List.rev (mulByDigit i l);;\n"]}
{"fix": ["let rec mulByDigit i l = bigAdd l (mulByDigit (i-1) l)"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  ((List.append (clone 0 (len2 - len1)) l1),\n    (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (i,l) ->\n          (match x with\n           | (x1,x2) ->\n               ((((x1 + x2) + i) / 10), ((((x1 + x2) + i) mod 10) :: l))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then mulByDigit ((i - 1), (bigAdd l l)) else l;;\n"]}
{"fix": ["let rec mulByDigit i l = match i with\n| 0 -> l\n| _ -> bigAdd l (mulByDigit (i-1) l)"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int list\n       but an expression was expected of type unit\n"], "bad": ["\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  ((List.append (clone 0 (len2 - len1)) l1),\n    (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (i,l) ->\n          (match x with\n           | (x1,x2) ->\n               ((((x1 + x2) + i) / 10), ((((x1 + x2) + i) mod 10) :: l))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i > 0 then bigAdd l (mulByDigit (i - 1) l);;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x =  match a with\n| (i, l) -> match x with\n| [] -> (i, [0])\n| h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i))) \nin\nlet base = (0, []) in\nlet args =  List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "bad": ["\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  ((List.append (clone 0 (len2 - len1)) l1),\n    (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (i,l) ->\n          (match x with\n           | (x1,x2) ->\n               ((((x1 + x2) + i) / 10), ((((x1 + x2) + i) mod 10) :: l))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [0] | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (i,l) ->\n        (match x with\n         | [] -> []\n         | h::t ->\n             ((i + 1),\n               (bigAdd l (List.append (mulByDigit h l1) (clone 0 i))))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: Unbound value digital\n"], "bad": ["\nlet rec digitalRoot xs =\n  if (xs / 10) = 0 then xs else digital (sumList (digitsOfInt xs));;\n"]}
{"fix": [], "hw": "hw1", "problem": "palindrome", "message": ["Error: Unbound value palindrome\n"], "bad": ["\nlet _ = palindrome \"racecar\";;\n"]}
{"fix": [], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet _ = wwhile (f, 3);;\n", "\nlet _ = wwhile (f, 3);;\n", "\nlet _ = wwhile (f, 2);;\n", "\nlet _ = wwhile (f, 2);;\n"]}
{"fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet fixpoint (f,b) = let b' = f b in if b' = b then b else fixpoint (f, b');;\n"]}
{"fix": ["fixpoint_helper (fun x -> x-1)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint_helper f b = let b' = f b in (b', (b = b'));;\n\nlet rec fixpoint (f,b) = wwhile ((fixpoint_helper f), b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value fixpoint_helper\n"], "bad": ["\nlet _ = fixpoint_helper (fun x  -> x - 1);;\n"]}
{"fix": ["wwhile (f, 2)"], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) = wwhile ((fixpoint_helper f), b);;\n", "\nlet _ = wwhile (f, 3);;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n"]}
{"fix": ["let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e'    -> \"sin (pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos (pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^exprToString e1^\"+\"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\"*\"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: Unbound constructor Varx\nHint: Did you mean VarX or VarY?\n", "Error: This variant pattern is expected to have type expr\n       The constructor Sin does not belong to type expr\nHint: Did you mean Sine?\n", "Error: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type expr\n", "Error: Unbound value expr\nHint: Did you mean exp?\n", "Error: Unbound value esprToString\nHint: Did you mean exprToString?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Varx  -> \"x\"\n  | VarY  -> \"y\"\n  | Sin e' -> \"sin (pi*\" ^ ((expr e') ^ \")\")\n  | Cos e' -> \"cos (pi*\" ^ ((expr e') ^ \")\")\n  | (Average e1,e2) ->\n      \"((\" ^ ((esprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | (Times e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | (Thresh e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sin e' -> \"sin (pi*\" ^ ((expr e') ^ \")\")\n  | Cos e' -> \"cos (pi*\" ^ ((expr e') ^ \")\")\n  | (Average e1,e2) ->\n      \"((\" ^ ((esprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | (Times e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | (Thresh e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi*\" ^ ((expr e') ^ \")\")\n  | Cosine e' -> \"cos (pi*\" ^ ((expr e') ^ \")\")\n  | (Average e1,e2) ->\n      \"((\" ^ ((esprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | (Times e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | (Thresh e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi*\" ^ ((expr e') ^ \")\")\n  | Cosine e' -> \"cos (pi*\" ^ ((expr e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((esprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin (pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos (pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((esprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| Average (x', y') -> (x +. y) /. 2.0"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type expr but an expression was expected of type\n         int\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "Error: This expression has type expr but an expression was expected of type\n         expr * ('a -> 'b) * ('a -> 'b)\n", "Error: This expression has type expr but an expression was expected of type\n         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)\n", "Error: This expression has type expr but an expression was expected of type\n         int\n", "Error: This expression has type expr but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Average (x',y') -> (x' + y') / 2;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Average (x',y') -> ((eval x') + (eval y')) / 2;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Average (x',y') -> ((eval x' y) + (eval x y')) / 2;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Average (x',y') -> ((eval VarX x' y) + (eval VarY x y')) / 2;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Average (x',y') -> ((eval (VarX, x', y)) + (eval (VarY, x, y'))) / 2;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Average (x',y') -> (x' + y') / 2;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Average (x',y') -> (x + y) / 2;;\n\nlet _ = eval ((Average (VarX, VarY)), 0.5, 0.5);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | Average (x',y') -> (x + y) / 2;;\n\nlet _ = eval ((Average (VarX, VarY)), 0.5, 0.5);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | Average (x',y') -> (x +. y) / 2;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | Average (x',y') -> (x +. y) / 2;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | Average (x',y') -> (x +. y) /. 2;;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (x', y')      -> (x +. y) /. 2.0\n| Times   (x', y')\t-> x *. y"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'b\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'b\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e' -> sin (pi *. (eval e'))\n  | Cosine e' -> cos (pi *. (eval e'))\n  | Average (x',y') -> (x +. y) /. 2.0\n  | Times (x',y') -> x *. y;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e' -> sin (pi *. (eval e'))\n  | Cosine e' -> cos (pi *. (eval e'))\n  | Average (x',y') -> (x +. y) /. 2.0\n  | Times (x',y') -> x *. y;;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value rand\nHint: Did you mean land?\n"], "bad": ["\nlet _ = rand;;\n"]}
{"fix": [], "hw": "hw2", "problem": "expr", "message": ["Error: This variant pattern is expected to have type expr\n       The constructor FunckyRoot does not belong to type expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyCube of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt eval (e', x, y)\n  | FunckyRoot (e1,e2,e3) ->\n      sqrt\n        ((sqrt eval (e', x, x)) (sqrt eval (e', x, y)) (sqrt eval (e', y, y)));;\n"]}
{"fix": [], "hw": "hw2", "problem": "exprToString", "message": ["Error: This variant pattern is expected to have type expr\n       The constructor FunckyCube does not belong to type expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyCube of expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | SquareRoot e' -> \"sqrt(\" ^ ((exprToString e') ^ \")\")\n  | FunckyCube (e1,e2,e3) ->\n      \"sqrt(sqrt(\" ^\n        ((exprToString e1) ^\n           (\")+sqrt(\" ^\n              ((exprToString e2) ^ (\")+sqrt(\" ^ ((exprToString e3) ^ \"))\")))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This function has type float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound value e'\n", "Error: This expression has type float\n       This is not a function; it cannot be applied.\n", "Error: This expression has type float\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt eval (e', x, y)\n  | FunckyRoot (e1,e2,e3) ->\n      sqrt\n        ((sqrt eval (e', x, x)) (sqrt eval (e', x, y)) (sqrt eval (e', y, y)));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | FunckyRoot (e1,e2,e3) ->\n      sqrt\n        ((sqrt eval (e', x, x)) (sqrt eval (e', x, y)) (sqrt eval (e', y, y)));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | FunckyRoot (e1,e2,e3) ->\n      sqrt\n        ((sqrt (eval (e', x, x))) (sqrt (eval (e', x, y)))\n           (sqrt (eval (e', y, y))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | FunckyRoot (e1,e2,e3) ->\n      sqrt\n        ((sqrt (eval (e1, x, x))) (sqrt (eval (e2, x, y)))\n           (sqrt (eval (ee3, y, y))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | FunckyRoot (e1,e2,e3) ->\n      sqrt\n        ((sqrt (eval (e1, x, x))) (sqrt (eval (e2, x, y)))\n           (sqrt (eval (e3, y, y))));;\n"]}
{"fix": ["let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,7) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareRoot(build(rand, depth-1))"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr/4327\n       but an expression was expected of type expr/3809\nError: This expression has type expr/4495\n       but an expression was expected of type expr/4485\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type expr/4327\n       but an expression was expected of type expr/3809\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | FunckyRoot of expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildFunckyRoot (e1,e2,e3) = FunckyRoot (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquareRoot e = SquareRoot e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let num = rand (0, 8) in\n     match num with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 7 -> buildSquareRoot (build (rand, (depth - 1)))\n     | 8 ->\n         buildFunckyRoot\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | DivideByOne of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | DivideByOne (e1,e2,e3) ->\n      1 /. (((eval (e1, x, y)) - (eval (e2, x, y))) - (eval (e3, x, y)));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | DivideByOne of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | DivideByOne (e1,e2,e3) ->\n      1.0 /. (((eval (e1, x, y)) - (eval (e2, x, y))) - (eval (e3, x, y)));;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t -> sqrt ( 1 /. eval(e',x,y))\n| DivideByOne (e1,e2,e3) -> sin((1.0 /. eval(e1,x,y)) +. (1.0 /. eval(e2,x,y)) +. (1.0 /. eval(e3,x,y)))"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float\n       This is not a function; it cannot be applied.\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | DivideByOne of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | DivideByOne (e1,e2,e3) ->\n      sin\n        ((1.0 /. (eval (e1, x, y))) (1.0 /. (eval (e2, x, y)))\n           (1.0 /. (eval (e3, x, y))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr\n  | DivideByOne of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareRoot e' -> sqrt (eval (e', x, y))\n  | DivideByOne (e1,e2,e3) ->\n      sin\n        (((1.0 /. (eval (e1, x, y))) + (1.0 /. (eval (e2, x, y)))) +\n           (1.0 /. (eval (e3, x, y))));;\n"]}
{"fix": ["let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr/6967\n       but an expression was expected of type expr/6204\nError: This expression has type expr/7094\n       but an expression was expected of type expr/7085\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type expr/6967\n       but an expression was expected of type expr/6204\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareRoot of expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareCosine of expr\n  | SquareSinCos of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquareRoot e = SquareRoot e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let num = rand (0, 7) in\n     match num with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 7 -> buildSquareRoot (build (rand, (depth - 1))));;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareCosine e'\t\t -> sqrt(abs_float((cos(pi *. (eval(e',x,y))))))   \n| SquareSinCos (e1,e2,e3) -> sqrt(abs_float sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y)))))"], "hw": "hw2", "problem": "eval", "message": ["Error: This function has type float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareCosine of expr\n  | SquareSinCos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareCosine e' -> sqrt (abs_float cos (pi *. (eval (e', x, y))))\n  | SquareSinCos (e1,e2,e3) ->\n      sqrt\n        (abs_float sin\n           (((cos (pi *. (eval (e1, x, y)))) *.\n               (cos (pi *. (eval (e2, x, y)))))\n              *. (cos (pi *. (eval (e3, x, y))))));;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareCosine e'\t\t -> sqrt(abs_float((cos(pi *. (eval(e',x,y))))))   \n| SquareSinCos (e1,e2,e3) -> sqrt(abs_float (sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y))))))"], "hw": "hw2", "problem": "eval", "message": ["Error: This function has type float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SquareCosine of expr\n  | SquareSinCos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | SquareCosine e' -> sqrt (abs_float (cos (pi *. (eval (e', x, y)))))\n  | SquareSinCos (e1,e2,e3) ->\n      sqrt\n        (abs_float sin\n           (((cos (pi *. (eval (e1, x, y)))) *.\n               (cos (pi *. (eval (e2, x, y)))))\n              *. (cos (pi *. (eval (e3, x, y))))));;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a ** x in\nlet base = 0.0 in\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: Unbound value f\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\nlet sqsum xs =\n  let f a x = match x with | [] -> a | h::t -> f (a + (h ** 2)) t in\n  let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs = let f a x = a ** x in let base = 0 in List.fold_left f base xs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = \nmatch x with \n| []   -> a\n| h::t -> h\nin\n\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value f\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs =\n  let f a x = match x with | [] -> a | h::t -> f t (a h) in\n  let base = [] in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base = [] in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = \nmatch x with \n| a   -> fun x -> x\n| h::t -> h\nin\n\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'b -> 'b\n"], "bad": ["\nlet pipe fs =\n  let f a x = match x with | a -> (fun x  -> x) | h::t -> h in\n  let base = [] in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = \nmatch x with \n| []   -> a\n| h::t -> h\nin\n\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value b\n"], "bad": ["\nlet pipe fs =\n  let f a x = match x with | [] -> b | h::t -> h in\n  let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'b list\n"], "bad": ["\nlet pipe fs =\n  let f a x = match x with | [] -> a | h::t -> t in\n  let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun i -> x (a i) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a but an expression was expected of type\n         'b list -> 'a\n       The type variable 'a occurs inside 'b list -> 'a\n", "Error: This expression has type 'a list -> 'b\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside 'a list -> 'b\n", "Error: This expression has type 'a but an expression was expected of type\n         'b list -> 'a\n       The type variable 'a occurs inside 'b list -> 'a\n"], "bad": ["\nlet pipe fs =\n  let f a x = match a with | [] -> x | _ -> x a in\n  let base = [] in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = match a with | _ -> x a | [] -> x in\n  let base = [] in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = match a with | [] -> x | _ -> x a in\n  let base = [] in List.fold_left f base fs;;\n"]}
{"fix": ["let rec clone x n = \nlet f a x = List.append a x in\nlet base = [] in\nList.fold_right f x base"], "hw": "hw3", "problem": "clone", "message": ["Error: Unbound value b\n"], "bad": ["\nlet rec clone x n =\n  let f a x = List.append a x in let base = [] in List.fold_right f x b;;\n"]}
{"fix": ["let rec clone x n = \nlet aux acc n = \nif n  <= 0\nthen acc\nelse clone (List.append x acc ) (n-1)\nin\naux [] n"], "hw": "hw3", "problem": "clone", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec clone x n =\n  let aux acc n = if n <= 0 then acc else clone (List.append [x] acc) (n - 1) in\n  aux [] n;;\n"]}
{"fix": ["let rec clone x n = \nlet rec aux acc n = \nif n  <= 0\nthen acc\nelse aux (List.append [x] acc ) (n-1)\nin\naux [] n"], "hw": "hw3", "problem": "clone", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: Unbound value aux\n"], "bad": ["\nlet rec clone x n =\n  let aux acc n = if n <= 0 then acc else clone (List.append [x] acc) (n - 1) in\n  aux [] n;;\n", "\nlet rec clone x n =\n  let aux acc n = if n <= 0 then acc else aux (List.append [x] acc) (n - 1) in\n  aux [] n;;\n"]}
{"fix": ["let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nif l1 < l2\nthen ((List.append (clone 0 (len2-len1)) l1), l2)\nelse (l1, (List.append (clone 0 (len1-len2)) l2))"], "hw": "hw3", "problem": "padZero", "message": ["Error: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec clone x n =\n  let rec aux acc n =\n    if n <= 0 then acc else aux (List.append [x] acc) (n - 1) in\n  aux [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if l1 < l2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2) l2)));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x in\nlet (c, l) = a in\nlet result = n1+n2+c in\n((result mod 10), List.append [(result / 10)] l) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value bigAdd\n"], "bad": ["\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value bigAdd\n", "Error: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n", "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int * 'b\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n"], "bad": ["\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,l) = a in\n      let result = (n1 + n2) + c in\n      ((result / 10),\n        (List.append (result / 10) List.append [result mod 10] l)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,l) = a in\n      let result = (n1 + n2) + c in\n      ((result / 10),\n        (List.append [result / 10] List.append [result mod 10] l)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (cin,l) = a in\n      let result = (n1 + n2) + cin in\n      let cout = result / 10 in\n      let r = result mod 10 in\n      match l with | [] -> [] | h::t -> (cout, (List.append [r] l)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (cin,l) = a in\n      let result = (n1 + n2) + cin in\n      let cout = result / 10 in\n      let r = result mod 10 in\n      match a with\n      | [] -> (cout, (List.append [r] l))\n      | h::t -> (cout, (List.append [r] t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n"]}
{"fix": [], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: Unbound value bigAdd\n", "Error: Unbound value helper\n", "Error: Unbound value aux\n"], "bad": ["\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "\nlet rec mulByDigit i l =\n  let helper aux acc n =\n    match n with | 0 -> acc | _ -> helper bigAdd acc l (n - 1) in\n  aux [0] i;;\n", "\nlet rec mulByDigit i l =\n  let aux acc n = match n with | 0 -> acc | _ -> aux (bigAdd acc l) (n - 1) in\n  aux [0] i;;\n"]}
{"fix": [], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type int but an expression was expected of type\n         'a * 'b\n"], "bad": ["\nlet _ = List.split [9; 1; 1; 1];;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type 'a * int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n =\n  let rec aux acc n =\n    if n <= 0 then acc else aux (List.append [x] acc) (n - 1) in\n  aux [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (cin,l) = a in\n      let result = (n1 + n2) + cin in\n      let cout = result / 10 in\n      let r = result mod 10 in\n      match l with\n      | [] -> (cout, (List.append [cout] (List.append [r] [])))\n      | h::t -> (cout, (List.append [cout] (List.append [r] t))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec aux acc n =\n    match n with | 0 -> acc | _ -> aux (bigAdd acc l) (n - 1) in\n  aux [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l,i) = x in\n    let (m,s) = a in\n    let result = bigAdd s (mulByDigit i l) in ((a * 10), result) in\n  let base = (1, []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l2 with\n      | [] -> acc\n      | h::t -> helper (List.append [(l1, h)] acc) l1 t in\n    helper [] l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": [], "hw": "hw3", "problem": "removeZero", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n =\n  let rec aux acc n =\n    if n <= 0 then acc else aux (List.append [x] acc) (n - 1) in\n  aux [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (cin,l) = a in\n      let result = (n1 + n2) + cin in\n      let cout = result / 10 in\n      let r = result mod 10 in\n      match l with\n      | [] -> (cout, (List.append [cout] (List.append [r] [])))\n      | h::t -> (cout, (List.append [cout] (List.append [r] t))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec aux acc n =\n    match n with | 0 -> acc | _ -> aux (bigAdd acc l) (n - 1) in\n  aux [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l,i) = x in\n    let (m,s) = a in\n    let result = bigAdd s ((mulByDigit i l) * m) in ((m * 10), result) in\n  let base = (1, []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l2 with\n      | [] -> acc\n      | h::t -> helper (List.append [(l1, h)] acc) l1 t in\n    helper [] l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| h::t -> if h = k then h else assoc(d,k,t)"], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value return\n"], "bad": ["\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> if h = k then return h else assoc (d, k, t);;\n"]}
{"fix": [], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type int -> int * bool\n       but an expression was expected of type bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match (f, b) with\n  | (x,trueOrFalse) -> if trueOrFalse then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: Unbound value rv\n", "Error: Unbound value rv\n", "Error: Unbound value rv\n", "Error: Unbound value rv\n", "Error: Unbound value rv\n", "Error: This expression has type 'a * 'b * 'c -> 'd\n       but an expression was expected of type float\n"], "bad": ["\nlet rec eval (e,x,y) = assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "\nlet rec eval (e,x,y) = assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "\nlet rec eval (e,x,y) = assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "\nlet rec eval (e,x,y) = assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "\nlet rec eval (e,x,y) = assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "\nlet rec eval (e,x,y) = assert (((-1.0) <= eval) && (eval <= 1.0)); eval;;\n"]}
{"fix": ["let rec eval (e,x,y) = (*failwith \"to be written\"*)\nfloat_of_string(exprToString e)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type 'a * 'b * 'c -> 'd\n       but an expression was expected of type expr\n", "Error: This expression has type string but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet rec eval (e,x,y) = float_of_string (exprToString eval);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet rec eval (e,x,y) = float_of_string (((exprToString e) * x) * y);;\n"]}
{"fix": ["let rec build (rand, depth) = (*failwith \"to be implemented\" *)\nlet randNum = rand(1,2) in\nif randNum = 1 then buildSine(buildX()) else buildCosine(buildY())"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type unit -> expr\n       but an expression was expected of type expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let randNum = rand (1, 2) in\n  if randNum = 1 then buildSine (buildY ()) else buildCosine buildY;;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with\n  | (x,trueOrFalse) -> if trueOrFalse then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((fun x  -> let xi = f x in (xi, (((f xi) != xi) || (f (f xi))))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n"]}
{"fix": ["let buildOp2(a,b,a_less,b_less)    = Op2(a,b,a_less)"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value e1\n", "Error: The constructor Op2 expects 3 argument(s),\n       but is applied here to 4 argument(s)\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildOp2 () = Op2 (e1, e2, e3);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less, b_less);;\n"]}
{"fix": ["let rec eval (e,x,y) = (*failwith \"to be written\"*)\nmatch e with\n| VarX                    -> x\n| VarY                    -> y\n| Sine e                  -> sin(pi *. eval(e,x,y))\n| Cosine e                -> cos(pi *. eval(e,x,y))\n| Average (e1, e2)        -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times (e1, e2)          -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y) else eval(e4,x,y)\n| Op1 e                   -> ((tan(pi *. eval(e,x,y))) -. ((tan(pi *. eval(e,x,y)))/.2.0))\n| Op2 (e1, e2, e3)    -> if eval(e1,x,y) > eval(e2,x,y) \nthen eval(e3,x,y) else eval(e1,x,y) -. eval(e2,x,y)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e ->\n      (tan (pi *. (eval (e, x, y)))) -.\n        ((tan (pi *. (eval (e, x, y)))) / 2.0)\n  | Op2 (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (eval (e1, x, y)) -. (eval (e2, x, y));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e ->\n      (tan (pi *. (eval (e, x, y)))) -.\n        ((tan (pi *. (eval (e, x, y)))) / 2.0)\n  | Op2 (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (eval (e1, x, y)) -. (eval (e2, x, y));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Op1 e ->\n      (tan (pi *. (eval (e, x, y)))) -.\n        ((tan (pi *. (eval (e, x, y)))) / 2.0)\n  | Op2 (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else (eval (e1, x, y)) -. (eval (e2, x, y));;\n"]}
{"fix": ["let rec build (rand,depth) = if depth = 0\nthen\nif rand(1,2) = 1 then buildX() else buildY()\nelse\nlet r = rand(1, 100000) in\nmatch r mod 39 with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> match r mod 9 with\n| 0 -> buildSine    (build(rand, depth - 1))\n| 1 -> buildCosine  (build(rand, depth - 1))\n| _ -> match r mod 13 with\n| 0 -> buildOp1 (build(rand, depth - 1))\n| _ -> match r mod 19 with\n| 0 -> buildAverage (build(rand, depth - 1), build(rand, depth - 1))\n| _ -> match r mod 29 with\n| 0 -> buildTimes (build(rand, depth - 1), build(rand, depth - 1))\n| _ -> match r mod 39 with\n| 0 -> buildThresh (build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| _ -> match r mod 41 with\n| 0 -> buildX()\n| _ -> build (rand, depth)"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * expr * expr * 'a\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr * expr * expr * 'd\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type int * int -> int\n       but an expression was expected of type unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: Unbound value return\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type int * int -> int\n       but an expression was expected of type unit\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr * expr * expr * 'd\n", "Error: Unbound value buildTan\nHint: Did you mean build, buildOp1, buildSine, buildOp2, buildY or buildX?\nError: Unbound value buildTan\nHint: Did you mean build, buildX, buildY or buildSine?\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value buildTan\nHint: Did you mean build, buildOp1, buildSine, buildOp2, buildY or buildX?\n", "Error: Unbound value buildDiff\nHint: Did you mean buildSine?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  let randNum = rand (1, 2) in\n  let randNum2 = rand (3, 4) in\n  if (randNum = 1) && (randNum2 = 3)\n  then buildSine (buildOp1 (buildX ()))\n  else\n    if (randNum = 1) && (randNum2 = 4)\n    then buildSine (buildOp2 (buildX ()))\n    else\n      if (randNum = 2) && (randNum2 = 3)\n      then buildCosine (buildOp1 (buildX ()))\n      else buildCosine (buildOp2 (buildX ()));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let randNum = rand (1, 2) in\n  let randNum2 = rand (3, 4) in\n  if (randNum = 1) && (randNum2 = 3)\n  then buildSine (buildOp1 (buildX ()))\n  else\n    if (randNum = 1) && (randNum2 = 4)\n    then buildSine (buildOp2 ((buildX ()), (buildY ()), (buildX ())))\n    else\n      if (randNum = 2) && (randNum2 = 3)\n      then buildCosine (buildOp1 (buildX ()))\n      else buildCosine (buildOp2 ((buildY ()), (buildX ()), (buildY ())));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth = (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    (if (randNum = 1) && (randNum2 = 3)\n     then buildSine (buildOp1 (buildX ()))\n     else\n       if (randNum = 1) && (randNum2 = 4)\n       then\n         buildSine\n           (buildOp2\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                (build (rand, (depth - 1))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  if depth = (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    (if (randNum = 1) && (randNum2 = 3)\n     then buildSine (buildOp1 (build (rand, (depth - 1))))\n     else\n       if (randNum = 1) && (randNum2 = 4)\n       then\n         buildSine\n           (buildOp2\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                (build (rand, (depth - 1))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  if depth = (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    (if (randNum = 1) && (randNum2 = 3)\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (randNum = 1) && (randNum2 = 4)\n       then\n         buildSine\n           (buildOp2\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                (build (rand, (depth - 1))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth = (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    (if (randNum = 1) && (randNum2 = 3)\n     then buildX ()\n     else\n       if (randNum = 1) && (randNum2 = 4)\n       then\n         buildSine\n           (buildOp2\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                (build (rand, (depth - 1))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth > (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    (if (randNum = 1) && (randNum2 = 3)\n     then buildX ()\n     else\n       if (randNum = 1) && (randNum2 = 4)\n       then\n         buildSine\n           (buildOp2\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                (build (rand, (depth - 1))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth > (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    (if (randNum = 1) && (randNum2 = 3)\n     then buildX rand\n     else\n       if (randNum = 1) && (randNum2 = 4)\n       then\n         buildSine\n           (buildOp2\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                (build (rand, (depth - 1))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth > (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    (if (randNum = 1) && (randNum2 = 3)\n     then buildX ()\n     else\n       if (randNum = 1) && (randNum2 = 4)\n       then\n         buildSine\n           (buildOp2\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                (build (rand, (depth - 1))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  if depth > (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    (if (randNum = 1) && (randNum2 = 3)\n     then return ()\n     else\n       if (randNum = 1) && (randNum2 = 4)\n       then\n         buildSine\n           (buildOp2\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                (build (rand, (depth - 1))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth > (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    (if (randNum = 1) && (randNum2 = 3)\n     then buildX ()\n     else\n       if (randNum = 1) && (randNum2 = 4)\n       then\n         buildSine\n           (buildOp2\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                (build (rand, (depth - 1))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth > (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    (if (randNum = 1) && (randNum2 = 3)\n     then buildCosine (buildOp1 (buildX ()))\n     else\n       if (randNum = 1) && (randNum2 = 4)\n       then\n         buildSine\n           (buildOp2\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                (build (rand, (depth - 1))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth > (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    match (randNum, randNum2) with\n    | (1,3) -> buildCosine (buildOp1 (buildX ()))\n    | (1,4) ->\n        buildSine\n          (buildOp2\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))))\n    | (2,3) -> buildCosine (buildOp1 (buildX ()))\n    | (2,4) ->\n        buildCosine\n          (buildOp2\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))))\n    | (x,y) -> failwith \"didnt work\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth > (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    match (randNum, randNum2) with\n    | (1,3) -> buildCosine (buildOp1 (buildX rand))\n    | (1,4) ->\n        buildSine\n          (buildOp2\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))))\n    | (2,3) -> buildCosine (buildOp1 (buildX ()))\n    | (2,4) ->\n        buildCosine\n          (buildOp2\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))))\n    | (x,y) -> failwith \"didnt work\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth > (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    match (randNum, randNum2) with\n    | (1,3) -> failwith \"bahh\"\n    | (1,4) ->\n        buildSine\n          (buildOp2\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))))\n    | (2,3) -> buildCosine (buildOp1 (buildX ()))\n    | (2,4) ->\n        buildCosine\n          (buildOp2\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))))\n    | (x,y) -> failwith \"didnt work\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (1, 2)) = 1 then buildX () else buildY ())\n  else\n    (let r = rand (1, 100000) in\n     match r mod 39 with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | _ ->\n         (match r mod 9 with\n          | 0 -> buildSine (build (rand, (depth - 1)))\n          | 1 -> buildCosine (build (rand, (depth - 1)))\n          | _ ->\n              (match r mod 13 with\n               | 0 -> buildTan (build (rand, (depth - 1)))\n               | _ ->\n                   (match r mod 19 with\n                    | 0 ->\n                        buildAverage\n                          ((build (rand, (depth - 1))),\n                            (build (rand, (depth - 1))))\n                    | _ ->\n                        (match r mod 29 with\n                         | 0 ->\n                             buildTimes\n                               ((build (rand, (depth - 1))),\n                                 (build (rand, (depth - 1))))\n                         | _ ->\n                             (match r mod 39 with\n                              | 0 ->\n                                  buildThresh\n                                    ((build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))))\n                              | _ ->\n                                  (match r mod 41 with\n                                   | 0 ->\n                                       buildDiff\n                                         ((build (rand, (depth - 1))),\n                                           (build (rand, (depth - 1))),\n                                           (build (rand, (depth - 1))))\n                                   | _ -> build (rand, depth))))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (1, 2)) = 1 then buildX () else buildY ())\n  else\n    (let r = rand (1, 100000) in\n     match r mod 39 with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | _ ->\n         (match r mod 9 with\n          | 0 -> buildSine (build (rand, (depth - 1)))\n          | 1 -> buildCosine (build (rand, (depth - 1)))\n          | _ ->\n              (match r mod 13 with\n               | 0 -> buildOp1 (build (rand, (depth - 1)))\n               | _ ->\n                   (match r mod 19 with\n                    | 0 ->\n                        buildAverage\n                          ((build (rand, (depth - 1))),\n                            (build (rand, (depth - 1))))\n                    | _ ->\n                        (match r mod 29 with\n                         | 0 ->\n                             buildTimes\n                               ((build (rand, (depth - 1))),\n                                 (build (rand, (depth - 1))))\n                         | _ ->\n                             (match r mod 39 with\n                              | 0 ->\n                                  buildThresh\n                                    ((build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))),\n                                      (build (rand, (depth - 1))))\n                              | _ ->\n                                  (match r mod 41 with\n                                   | 0 ->\n                                       buildDiff\n                                         ((build (rand, (depth - 1))),\n                                           (build (rand, (depth - 1))),\n                                           (build (rand, (depth - 1))))\n                                   | _ -> build (rand, depth))))))));;\n"]}
{"fix": ["let rec build (rand, depth) = \nif depth = 0\nthen \nbuildSine(buildX())\nelse\nbuildX()"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr * expr * expr * 'd\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildOp1 e = Op1 e;;\n\nlet buildOp2 (a,b,a_less,b_less) = Op2 (a, b, a_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth > (-1)\n  then\n    let randNum = rand (1, 2) in\n    let randNum2 = rand (3, 4) in\n    match (randNum, randNum2) with\n    | (1,3) -> failwith \"bahh\"\n    | (1,4) ->\n        buildSine\n          (buildOp2\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))))\n    | (2,3) -> buildCosine (buildOp1 (buildX ()))\n    | (2,4) ->\n        buildCosine\n          (buildOp2\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))))\n    | _ -> failwith \"didnt work\";;\n"]}
{"fix": ["let rec build (rand, depth) = \nif depth = 0\nthen \nbuildSine(buildX())\nelse\nlet randNum = rand(1,2) in\nmatch randNum with\n| 1 -> buildSine(buildX())\n| _ -> buildCosine(buildX())"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value buildCose\nHint: Did you mean buildCosine?\nError: Unbound value buildCose\nHint: Did you mean buildSine?\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value buildCose\nHint: Did you mean buildCosine?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Op1 of expr\n  | Op2 of expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildSine (buildX ())\n  else\n    (let randNum = rand (1, 2) in\n     match randNum with\n     | 1 -> buildSine (buildX ())\n     | _ -> buildCose (buildX ()));;\n"]}
{"fix": ["let rec build (rand, depth) = \nif depth = 0\nthen \nbuildSine(buildX())\nelse\nlet randNum = rand(1,2) in\nlet randNum2 = rand(1,2) in\nlet randNum3 = rand(1,2) in\nmatch (randNum, randNum2) with\n| (1,1) -> buildSine(build(rand, depth -1))\n| (2,2) -> buildCosine(build(rand, depth - 1))\n| _     -> match randNum3 with\n| 1 -> buildSine(buildOp1(build(rand, depth - 1)  ))\n| 2 -> buildCosine(buildOp1(build(rand, depth - 1) ))"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value buildSine\n"], "bad": ["\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildSine (buildX ())\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 2) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (buildX ())\n     | (2,2) -> buildCosine (buildX ())\n     | _ ->\n         (match randNum3 with\n          | 1 ->\n              buildSine\n                (buildOp2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1)))))\n          | 2 ->\n              buildCosine\n                (buildOp2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1)))))));;\n"]}
{"fix": ["let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value buildSine\n"], "bad": ["\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildSine (buildX ())\n  else\n    (let randNum = rand (1, 2) in\n     let randNum2 = rand (1, 2) in\n     let randNum3 = rand (1, 4) in\n     match (randNum, randNum2) with\n     | (1,1) -> buildSine (build (rand, (depth - 1)))\n     | (2,2) -> buildCosine (build (rand, (depth - 1)))\n     | _ ->\n         (match randNum3 with\n          | 1 -> buildSine (buildOp1 (build (rand, (depth - 1))))\n          | 2 -> buildCosine (buildOp1 (build (rand, (depth - 1))))\n          | _ -> buildSine (buildCosine (build (rand, (deth - 1))))));;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = (x*x) + a in\nlet base = 0 in\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: Unbound value b\n"], "bad": ["\nlet sqsum xs =\n  let f a x = (x * x) + b in let base = 0 in List.fold_left f base xs;;\n"]}
{"fix": [], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value fs\n"], "bad": ["\nlet _ =\n  let pipe fs = failwith \"boo!\" in\n  let f a x a x = x in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let rec clone x n = \nif n < 1 then []\nelse x::(clone x (n-1))"], "hw": "hw3", "problem": "clone", "message": ["Error: This expression has type int but an expression was expected of type\n         int -> int\n", "Error: This expression has type 'a but an expression was expected of type\n         int -> 'a\n       The type variable 'a occurs inside int -> 'a\n", "Error: This expression has type 'a but an expression was expected of type\n         int -> 'a\n       The type variable 'a occurs inside int -> 'a\n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone ((x n) - 1)) else x;;\n", "\nlet rec clone x n = if n > 0 then x :: (clone (x (n - 1))) else [];;\n", "\nlet rec clone x n = if n < 1 then [] else x :: (clone (x (n - 1)));;\n"]}
{"fix": ["let padZero l1 l2 = \nlet length1 = List.length(l1) in\nlet length2 = List.length(l2) in\nif length1 = length2 then (l1, l2)\nelse \nif length1 < length2 then (padZero (0::l1) l2)\nelse (padZero l1 (0::l2))"], "hw": "hw3", "problem": "padZero", "message": ["Error: Unbound value lenght1\nHint: Did you mean length1?\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type int list * 'c list\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type int list * 'c list\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type int list * 'c list\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type int list\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type int list\n"], "bad": ["\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if lenght1 = length2\n  then (l1, l2)\n  else if length1 < length2 then padZero (0 :: l1) else padZero (0 :: l2);;\n", "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else if length1 < length2 then padZero (0 :: l1) else padZero (0 :: l2);;\n", "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then padZero ((0 :: l1), l2)\n    else padZero (l1, (0 :: l2));;\n", "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then padZero ((0 :: l1), l2)\n    else padZero (l1, (0 :: l2));;\n", "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((padZero (0 :: l1)), l2)\n    else ((padZero l1), (0 :: l2));;\n", "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((padZero (0 :: l1)), l2)\n    else ((padZero l1), (0 :: l2));;\n"]}
{"fix": ["let pipe fs = \nlet f a x =  fun y -> x ( a y )  in \nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value y\n", "Error: Unbound value y\n"], "bad": ["\nlet pipe fs =\n  let f a x x = a (x y) in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x x = a (y x) in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\""], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type string -> string list -> string\n       but an expression was expected of type string\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ (sepConcat ^ (\";\" ^ ((List.map f l) ^ \"]\")));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (cin, result) = a in\nlet (d1, d2) = x in\nlet s = d1 + d2 + cin in\n(s / 10, (s mod 10)::result) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value h\n"], "bad": ["\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (cin,result) = a in\n      let (d1,d2) = h in\n      let s = (d1 + d2) + cin in ((s / 10), ((s mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse bigAdd (bigAdd l l) (mulByDigit (i-2) l)"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: Unbound value big\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd (big 1 1) (mulByDigit (i - 2) l);;\n", "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd (bigAdd 1 1) (mulByDigit (i - 2) l);;\n", "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd ((bigAdd 1 1) (mulByDigit (i - 2) l));;\n", "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd ((bigAdd 1 1) (mulByDigit (i - 2) l));;\n", "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd ((bigAdd l l) (mulByDigit (i - 2) l));;\n", "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else if i = 1 then l else bigAdd ((bigAdd l l) (mulByDigit (i - 2) l));;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet thisFun = \nlet f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in\nlet base = [] in\nlet args =  List.rev l2 in\n(* let (_, res) =*) List.fold_left f base args (*in\nres*)\nin List.fold_left bigAdd [] thisFun"], "hw": "hw3", "problem": "bigMul", "message": ["Error: Unbound value b\n", "Error: Unbound value base\n", "Error: Unbound value g\n"], "bad": ["\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  match i with\n  | (-1) -> []\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n\nlet _ =\n  let bigMul l1 l2 =\n    let f a x = ((mulByDigit x l1) @ (clone 0 (List.length b))) :: b in\n    let base = [] in let args = List.rev l2 in List.fold_left f base args in\n  List.fold_left bigAdd base g;;\n", "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  match i with\n  | (-1) -> []\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n\nlet _ =\n  let bigMul l1 l2 =\n    let f a x = ((mulByDigit x l1) @ (clone 0 (List.length a))) :: a in\n    let base = [] in let args = List.rev l2 in List.fold_left f base args in\n  List.fold_left bigAdd base g;;\n", "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  match i with\n  | (-1) -> []\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n\nlet _ =\n  let bigMul l1 l2 =\n    let f a x = ((mulByDigit x l1) @ (clone 0 (List.length a))) :: a in\n    let base = [] in let args = List.rev l2 in List.fold_left f base args in\n  List.fold_left bigAdd [] g;;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n <= 0 then [] else digits([], n)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digits (x,y) =\n  if y < 10 then y :: x else digits (((y mod 10) :: x), (y mod 10));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else digits ([], n);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec digitsOfInt n = if n <= 0 then [] else digits ([], n);;\n"]}
{"fix": ["let rec digitalRoot n = \nif n < 10 then n else digitalRoot(sumList(digitsOfInt(n)))"], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: Unbound value digitsofInt\nHint: Did you mean digitsOfInt?\nError: Unbound value digitsofInt\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value digitsofInt\nHint: Did you mean digitsOfInt?\n"], "bad": ["\nlet rec sum (x,y) = match x with | [] -> y | h::t -> sum (t, (y + h));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> sum (xs, 0);;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsofInt n));;\n"]}
{"fix": ["let palindrome w = \nif explode(w) = listReverse(explode(w)) then true else false"], "hw": "hw1", "problem": "palindrome", "message": ["Error: Unbound value rev\nHint: Did you mean ref?\n", "Error: This expression has type char list\n       but an expression was expected of type string list\n       Type char is not compatible with type string \n", "Error: This expression has type char list\n       but an expression was expected of type string list\n       Type char is not compatible with type string \n"], "bad": ["\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec revexp (x,y) = match x with | [] -> y | h::t -> revexp (t, (h ^ y));;\n\nlet palindrome w = if rev = (revexp ((explode w), \"\")) then true else false;;\n", "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec revexp (x,y) = match x with | [] -> y | h::t -> revexp (t, (h ^ y));;\n\nlet palindrome w = if w = (revexp ((explode w), \"\")) then true else false;;\n", "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec revexp (x,y) = match x with | [] -> y | h::t -> revexp (t, (h ^ y));;\n\nlet palindrome w = if w = (revexp ((explode w), \"\")) then true else false;;\n"]}
{"fix": ["let fixpoint (f,b) = \nlet f x = let xx = f(x) in (xx, xx = x) in \nwwhile (f,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (i,c) = f b in if c = true then wwhile (f, i) else i;;\n\nlet fixpoint (f,b) =\n  (wwhile ((fun x  -> ((f x), (x = (f x)))), b)) *\n    (let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0));;\n", "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n"]}
{"fix": ["let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx = x) in g\nwwhile (g,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx = x)) in wwhile (g, b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx = x)) in wwhile (g, b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx != x)) in wwhile (g, b);;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =  if ( List.mem(h, seen) = true) then let seen' = seen else let seen' = List.rev(h:: List.rev(seen)) in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: Unbound value assoc\n"], "bad": ["\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n"]}
{"fix": [], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: Unbound value assoc\n"], "bad": ["\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n"]}
{"fix": ["let rec exprToString e = failwith \"to be written\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec ets e s =\n  match e with\n  | VarX  -> ets (e, (s ^ VarX))\n  | VarY  -> ets (e, (s ^ VarY))\n  | Sine  -> ets (e, (s ^ Sine))\n  | Cosine  -> ets (e, (s ^ Cosine))\n  | Average  -> ets (e, (s ^ Average))\n  | Times  -> ets (e, (s ^ Times))\n  | Thresh  -> ets (e, (s ^ Thresh));;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr/1208\n       but an expression was expected of type expr/1436\nError: This expression has type expr/1818\n       but an expression was expected of type expr/1838\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type expr/1208\n       but an expression was expected of type expr/1436\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n"]}
{"fix": ["let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type expr/1208\n       but an expression was expected of type expr/1436\nError: This expression has type expr/1938\n       but an expression was expected of type expr/1958\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type expr/1208\n       but an expression was expected of type expr/1436\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n"]}
{"fix": ["let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type unit -> expr\n       but an expression was expected of type expr\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX else buildY)\n  else\n    (let x = rand (0, 5) in\n     if x = 0\n     then buildSine buildX\n     else\n       if x = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if x = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if x = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if x = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX () else buildY ())\n  else\n    (let x = rand (0, 5) in\n     if x = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if x = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if x = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if x = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if x = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX () else buildY ())\n  else\n    (let x = rand (0, 5) in\n     if x = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if x = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if x = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if x = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if x = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX () else buildY ())\n  else\n    (let x = rand (0, 5) in\n     if x = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if x = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if x = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if x = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"]}
{"fix": ["let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"], "hw": "hw2", "problem": "build", "message": ["Error: This function has type\n         (float * float -> float) * (float * float -> float) *\n         (float * float -> float) * int * string -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This function has type\n         (float * float -> float) * (float * float -> float) *\n         (float * float -> float) * int * string -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 2)) < 1 then buildX () else buildY ())\n  else\n    (let x = rand (0, 5) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let s = \"\" in\n  match e with\n  | VarX  -> s ^ \"x\"\n  | VarY  -> s ^ \"y\"\n  | Sine a -> s ^ (\"sin(pi*\" ^ ((exprToString a) ^ \")\"))\n  | Cosine a -> s ^ (\"cos(pi*\" ^ ((exprToString a) ^ \")\"))\n  | Average (a,b) ->\n      s ^ (\"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \"/2)\"))))\n  | Times (a,b) -> s ^ ((exprToString a) ^ (\"*\" ^ (exprToString b)))\n  | Thresh (a,b,c,d) ->\n      s ^\n        (\"(\" ^\n           ((exprToString a) ^\n              (\"<\" ^\n                 ((exprToString b) ^\n                    (\"?\" ^\n                       ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\"))))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name) doRandomColor (8, 0, 5);;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n <= 0 then []\nelse (digitsOfInt (n / 10)) @ [n mod 10]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This function has type int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt div (n, 10)) @ [n];;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else ((digitsOfInt n) / 10) @ [n mod 10];;\n"]}
{"fix": ["let rec sumList xs = \nmatch xs with\n[] -> 0\n| t::h ->\nt + sumList h"], "hw": "hw1", "problem": "sumList", "message": ["Error: Unbound constructor Pers\n", "Error: Unbound constructor Pers\n", "Error: Unbound constructor Pers\n", "Error: Unbound constructor Pers\n", "Error: This function has type int list -> 'a -> 'a * int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot xs (Pers ,Root ) =\n  if (sumList xs) < 10\n  then (Pers, (sumList xs))\n  else additivePersAndRoot digits (sumList xs) ((Pers + 1), Root);;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot xs (Pers ,Root ) =\n  if (sumList xs) < 10\n  then (Pers, (sumList xs))\n  else additivePersAndRoot digits (sumList xs) ((Pers + 1), Root);;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot xs (Pers ,Root ) =\n  if (sumList xs) < 10\n  then (Pers, (sumList xs))\n  else additivePersAndRoot digits (sumList xs) ((Pers + 1), Root);;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot xs (Pers ) =\n  if (sumList xs) < 10\n  then (Pers, (sumList xs))\n  else additivePersAndRoot digits (sumList xs) (Pers + 1) Root;;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot xs pers =\n  if (sumList xs) < 10\n  then (pers, (sumList xs))\n  else additivePersAndRoot digits (sumList xs) (pers + 1);;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot xs pers =\n  if (sumList xs) < 10\n  then (pers, (sumList xs))\n  else additivePersAndRoot (digits (sumList xs) (pers + 1));;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot xs pers =\n  if (sumList xs) < 10\n  then (pers, (sumList xs))\n  else additivePersAndRoot ((digits sumList xs) (pers + 1));;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot xs pers =\n  if (sumList xs) < 10\n  then (pers, (sumList xs))\n  else additivePersAndRoot ((digits sumList xs) (pers + 1));;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot xs pers =\n  let theSum = sumList xs in\n  if (sumList xs) < 10\n  then (pers, theSum)\n  else additivePersAndRoot ((digits theSum) (pers + 1));;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot xs pers =\n  let theSum = sumList xs in\n  if (sumList xs) < 10\n  then (pers, theSum)\n  else additivePersAndRoot ((digits theSum) (pers + 1));;\n"]}
{"fix": ["let rec additivePersAndRoot xs pers =\nlet theSum = sumList xs in\nif theSum < 10 then (pers, theSum)\nelse additivePersAndRoot (digits theSum) (pers + 1)"], "hw": "hw1", "problem": "sumList", "message": ["Error: Unbound value theSum\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersAndRoot n = if n <= 0 then (0, 0) else (1, 1);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet _ =\n  let nextArr = digits theSum in\n  if (sumList xs) < 10\n  then (pers, theSum)\n  else additivePersAndRoot (nextArr (pers + 1));;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot xs pers =\n  let theSum = sumList xs in\n  if theSum < 10\n  then (pers, theSum)\n  else additivePersAndRoot ((digits theSum) (pers + 1));;\n"]}
{"fix": ["let rec sumList xs = \nmatch xs with\n[] -> 0\n| t::h ->\nt + sumList h"], "hw": "hw1", "problem": "sumList", "message": ["Error: Unbound value num\n", "Error: Unbound value num\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet _ =\n  let rec additivePersAndRoot num persCount = (num, persCount) in\n  if num < 10\n  then (persCount, num)\n  else\n    (let xs = digits num in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet _ =\n  let rec additivePersAndRoot num persCount = (num, persCount) in\n  if num < 10\n  then (persCount, num)\n  else\n    (let xs = digits num in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n"]}
{"fix": [], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type int -> int * int\n       but an expression was expected of type 'a * 'b\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot num persCount =\n  let absNum = abs num in\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet rec additivePersistence n = let (l,r) = additivePersAndRoot n in l;;\n"]}
{"fix": [], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type int -> int * int\n       but an expression was expected of type 'a * 'b\n", "Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int -> int -> int * int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet rec additivePersistence n = let (l,r) = additivePersAndRoot (abs n) in l;;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet rec additivePersistence n =\n  let (l,r) = additivePersAndRoot (abs n 0) in l;;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet rec additivePersistence n = let (l,r) = additivePersAndRoot abs n 0 in l;;\n"]}
{"fix": ["let rec additivePersistence n = \nlet (l, r) = additivePersAndRoot (abs n) 0 in\nl"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This function has type int -> int -> int * int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int -> int -> int * int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int -> int -> int * int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet rec additivePersistence n = let (l,r) = additivePersAndRoot abs n 0 in l;;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet rec additivePersistence n = let (l,r) = additivePersAndRoot abs n 0 in l;;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet rec additivePersistence n = let (l,r) = additivePersAndRoot abs n 0 in l;;\n"]}
{"fix": ["let palindrome w = \nlet ex = explode w in 2"], "hw": "hw1", "problem": "palindrome", "message": ["Error: This expression has type char list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type char list\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w = let ex = explode w in (ex [0]) && (ex [_end]);;\n", "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w = let ex = explode w in (ex [0]) && (ex [_end]);;\n"]}
{"fix": ["let palindrome w = \nlet ex = explode w in\nlet revex = listReverse ex in\nex = revex"], "hw": "hw1", "problem": "palindrome", "message": ["Error: Unbound value listReverese\nHint: Did you mean listReverse?\nError: Unbound value listReverese\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value listReverese\nHint: Did you mean listReverse?\n", "Error: Unbound value listReverese\nHint: Did you mean listReverse?\nError: Unbound value listReverese\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value listReverese\nHint: Did you mean listReverse?\n"], "bad": ["\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w =\n  let ex = explode w in let revex = listReverese ex in ex = revex;;\n", "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w =\n  let ex = explode w in let revex = listReverese ex in ex = revex;;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n <= 0 then []\nelse (digitsOfInt (n / 10)) @ [n mod 10]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [digitsOfInt (n / 10); n mod 10];;\n"]}
{"fix": ["let rec digitsOfInt n =\nif n <= 0 then []\nelse (digitsOfInt (n / 10)) @ [n mod 10]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: Unbound value %\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let next_tail = digitsOfInt (n / 10) in\n     match next_tail with | x::xs -> xs @ [x :: (n % 10)]);;\n", "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let next_tail = digitsOfInt (n / 10) in\n     match next_tail with | x::xs -> xs @ [x :: (n % 10)]);;\n", "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let next_tail = digitsOfInt (n / 10) in\n     match next_tail with | x::xs -> xs @ [x :: (n mod 10)]);;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ (n mod 10);;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ (n % 10);;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ (n mod 10);;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n"]}
{"fix": ["let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl  -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _\t\t-> d"], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value assoc_tl\nHint: Did you mean assoc?\n"], "bad": ["\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc_tl (d, k, tl)\n  | _ -> d;;\n"]}
{"fix": ["let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value wwhile\n", "Error: This expression has type int -> int * bool\n       but an expression was expected of type bool -> bool * 'a\n       Type int is not compatible with type bool \n"], "bad": ["\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if b' then wwhile (f, b') else c';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n"]}
{"fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a -> bool\n       but an expression was expected of type 'a -> 'a * bool\n       Type bool is not compatible with type 'a * bool \n"], "bad": ["\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((=) f), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((f b),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"], "bad": ["\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ = fixpoint (collatz, 1);;\n"]}
{"fix": ["let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value f\n"], "bad": ["\nlet g b = (b, (b = (f b)));;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((g),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value x\n"], "bad": ["\nlet g f = let xx = f x in (xx, (xx = (f xx)));;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((g f),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type ('a -> 'b) * 'a -> 'b * bool\n       but an expression was expected of type\n         ('a -> 'b) * 'a -> (('a -> 'b) * 'a) * bool\n       The type variable 'b occurs inside ('a -> 'b) * 'a\n", "Error: This function has type ('a -> 'b) * 'a -> 'b * bool\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet g (f,x) = let xx = f x in (xx, (xx = (f x)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (g, b);;\n", "\nlet g (f,x) = let xx = f x in (xx, (xx = (f x)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((g f b), b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value f\n", "Error: Unbound value f\n", "Error: Unbound value fixpoint\n", "Error: Unbound value f\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet g h x = let xx = h x in (xx, (x = (h x)));;\n\nlet _ = g f;;\n", "\nlet g h x = let xx = h x in (xx, (x != (h x)));;\n\nlet _ = g f;;\n", "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 1);;\n", "\nlet g h x = let xx = h x in (xx, (x != xx));;\n\nlet _ = g f;;\n", "\nlet g h x = let xx = h x in (xx, (x != xx));;\n\nlet fixpoint (f,b) = wwhile ((g f), b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n"]}
{"fix": ["let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| _ -> randX()"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr * expr\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr * expr\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr * expr * expr * expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (1, 2) in\n    (if bin_rand = 1 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (1, 5) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 1 -> buildSine first_forced\n     | 2 -> buildCosine first_forced\n     | 3 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 5 ->\n         buildAverage\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (1, 2) in\n    (if bin_rand = 1 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (1, 5) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 1 -> buildSine first_forced\n     | 2 -> buildCosine first_forced\n     | 3 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 5 ->\n         buildAverage\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (1, 2) in\n    (if bin_rand = 1 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (1, 5) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 1 -> buildSine first_forced\n     | 2 -> buildCosine first_forced\n     | 3 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n"]}
{"fix": ["set _ = build(rand, 5)"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value randX\nHint: Did you mean rand?\n", "Error: Unbound value randX\nHint: Did you mean rand?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (1, 2) in\n    (if bin_rand = 1 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (1, 5) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 1 -> buildSine first_forced\n     | 2 -> buildCosine first_forced\n     | 3 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> randX ());;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (1, 2) in\n    (if bin_rand = 1 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (1, 5) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 1 -> buildSine first_forced\n     | 2 -> buildCosine first_forced\n     | 3 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> randX ());;\n"]}
{"fix": [], "hw": "hw2", "problem": "expr", "message": ["Error: This variant pattern is expected to have type expr\n       The constructor Asin does not belong to type expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | XOR3 of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi^2))\")))\n  | Asin (e1,e2,e3) -> \"\";;\n"]}
{"fix": [], "hw": "hw2", "problem": "exprToString", "message": ["Error: This variant pattern is expected to have type expr\n       The constructor Asin does not belong to type expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | XOR3 of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi^2))\")))\n  | Asin (e1,e2,e3) -> \"1\";;\n"]}
{"fix": [], "hw": "hw2", "problem": "expr", "message": ["Error: This variant pattern is expected to have type expr\n       The constructor Asin does not belong to type expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | XOR3 of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Asin (e1,e2,e3) -> \"1\";;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value buildAcossin\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (0, 2) in\n    (if bin_rand = 0 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (0, 6) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 0 -> buildSine first_forced\n     | 1 -> buildCosine first_forced\n     | 2 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 3 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildAcossin (first_forced, (build (rand, (depth - 1)))));;\n"]}
{"fix": ["let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * float * float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval e1)) *. (asin (eval e2))) *. 2.0) /. (pi *. pi);;\n"]}
{"fix": [], "hw": "hw2", "problem": "exprToString", "message": ["Error: Unbound value buildCrazy\n", "Error: The constructor Crazy expects 2 argument(s),\n       but is applied here to 3 argument(s)\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr;;\n\nlet buildAcossin (e1,e2) = Acossin (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then\n    let bin_rand = rand (0, 2) in\n    (if bin_rand = 0 then buildX () else buildY ())\n  else\n    (let exp_rand = rand (0, 60000) in\n     let first_forced = build (rand, (depth - 1)) in\n     match exp_rand with\n     | 0 -> buildSine first_forced\n     | 1 -> buildCosine first_forced\n     | 2 -> buildAverage (first_forced, (build (rand, (depth - 1))))\n     | 3 -> buildTimes (first_forced, (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           (first_forced, (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 -> buildAcossin (first_forced, (build (rand, (depth - 1))))\n     | _ -> buildCrazy (first_forced, first_forced, first_forced));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> eval (e1, x, y);;\n"]}
{"fix": [], "hw": "hw2", "problem": "expr", "message": ["Error: The constructor Crazy expects 2 argument(s),\n       but is applied here to 3 argument(s)\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Crazy (e1,e2,e3) -> exprToString e1;;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: Unbound constructor VarX\n", "Error: Unbound constructor VarX\n", "Error: Unbound constructor VarX\n", "Error: Unbound constructor VarX\n"], "bad": ["\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> if e1 > e2 then abs e3 else - (abs e3);;\n", "\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> if e1 > e2 then abs_float e3 else - (abs_float e3);;\n", "\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      if e1 > e2 then abs_float (eval e3) else - (abs_float (eval e3));;\n", "\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) -> if e1 > e2 then 1.0 else (-1.0);;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> if (eval(e1, x, y) > eval(e2, x, y)) then \neval(e3, x, y) else (-1.0 *. eval(e3, x, y))"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e3, x, y)\n      else - (eval (e3, x, y));;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)\n| Crazy(e1, e2, e3) -> \nlet res1 = eval(e1, x, y) in\nlet res2 = eval(e2, x, y) in\nlet res3 = eval(e3, x, y) in\nif (res1 > res2) then \n(res1 +. res2 +. res3) /. 3.0\nelse if (res2 > res3) then\n(res1 *. res2 +. res3) /. 2.0\nelse if (res1 > res3) then\n(atan(res1) +. atan(res2) -. atan(res3)) *. 2.0 /. (3.0 *. pi)\nelse\n((-1.0) *. res3)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float -> float\n       but an expression was expected of type int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         expr * float * float\n", "Error: This expression has type float but an expression was expected of type\n         expr * float * float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan2 res1) + (atan res2)) - (atan res3)) *. 2) / (3.0 *. pi)\n          else eval ((-1.0) *. res3);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan res1) + (atan res2)) - (atan res3)) *. 2) / (3.0 *. pi)\n          else eval ((-1.0) *. res3);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan res1) +. (atan res2)) -. (atan res3)) *. 2) /\n              (3.0 *. pi)\n          else eval ((-1.0) *. res3);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan res1) +. (atan res2)) -. (atan res3)) *. 2.0) /\n              (3.0 *. pi)\n          else eval ((-1.0) *. res3);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan res1) +. (atan res2)) -. (atan res3)) *. 2.0) /.\n              (3.0 *. pi)\n          else eval ((-1.0) *. res3);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Acossin of expr* expr\n  | Crazy of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Acossin (e1,e2) ->\n      (((acos (eval (e1, x, y))) *. (asin (eval (e2, x, y)))) *. 2.0) /.\n        (pi *. pi)\n  | Crazy (e1,e2,e3) ->\n      let res1 = eval (e1, x, y) in\n      let res2 = eval (e2, x, y) in\n      let res3 = eval (e3, x, y) in\n      if res1 > res2\n      then ((res1 +. res2) +. res3) /. 3.0\n      else\n        if res2 > res3\n        then ((res1 *. res2) +. res3) /. 2.0\n        else\n          if res1 > res3\n          then\n            ((((atan res1) +. (atan res2)) -. (atan res3)) *. 2.0) /.\n              (3.0 *. pi)\n          else eval ((-1.0) *. res3);;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value doRandomColor\n"], "bad": ["\nlet _ = doRandomColor (8, 1, 1500);;\n"]}
{"fix": [], "hw": "hw2", "problem": "exprToString", "message": ["Error: Unbound value doRandomColor\n"], "bad": ["\nlet _ = doRandomColor (8, 1, 1500);;\n"]}
{"fix": [], "hw": "hw2", "problem": "exprToString", "message": ["Error: Unbound value doRandomGray\n", "Error: Unbound value doRandomGray\n", "Error: Unbound value doRandomGray\n"], "bad": ["\nlet _ = doRandomGray (1, 111, 1005);;\n", "\nlet _ = doRandomGray (5, 1315, 666);;\n", "\nlet _ = doRandomGray (8, 543, 35241);;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: Unbound constructor VarX\n", "Error: Unbound value doRandomGray\n"], "bad": ["\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Acossin (e1,e2) ->\n      \"(acos(\" ^\n        ((exprToString e1) ^\n           (\")*asin(\" ^ ((exprToString e2) ^ \")*2/(pi*pi))\")))\n  | Crazy (e1,e2,e3) ->\n      let s1 = exprToString e1 in\n      let s2 = exprToString e2 in\n      let s3 = exprToString e3 in\n      s1 ^\n        (\">\" ^\n           (s2 ^\n              (\"?((\" ^\n                 (s1 ^\n                    (\"+\" ^\n                       (s2 ^\n                          (\"+\" ^\n                             (s3 ^\n                                (\")/3:(\" ^\n                                   (s2 ^\n                                      (\">\" ^\n                                         (s3 ^\n                                            (\"?(\" ^\n                                               (s1 ^\n                                                  (\"*\" ^\n                                                     (s2 ^\n                                                        (\"+\" ^\n                                                           (s1 ^\n                                                              (\")/2:(-\" ^\n                                                                 (s3 ^ \")\"))))))))))))))))))));;\n", "\nlet _ = doRandomGray (8, 543, 35241);;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value doRandomColor\n"], "bad": ["\nlet _ = doRandomColor (10, 510, 150);;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value cc\n", "Error: Unbound value doRandomGray\n"], "bad": ["\nlet _ = cc;;\n", "\nlet _ = doRandomGray (2, 111, 1005);;\n"]}
{"fix": ["let pipe fs = \nlet f a x = (+) (x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type int but an expression was expected of type\n         int -> int\n", "Error: This expression has type int but an expression was expected of type\n         int -> int\n"], "bad": ["\nlet pipe fs =\n  let f a x = (+) (x a) in let base = 0 in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = (+) (a x) in let base = 0 in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = (fun a -> a) in\nlet base =  (fun x -> x) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'a\n"], "bad": ["\nlet pipe fs = let f a x a = a in let base = 0 in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base =  0 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> 'c -> 'd -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'd -> 'a\n"], "bad": ["\nlet pipe fs =\n  let f a x r s = a in let base r s = 0 in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base =  (fun n -> n) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base n = n in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = (fun y -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x y = x a in let base = 0 in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = (fun _ -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'b -> 'c\n", "Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x _ = x a in let base = [] in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x _ = x a in let base = 0 in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = (fun _ -> x) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"], "bad": ["\nlet pipe fs = let f a x _ = a in let base y = y in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = (fun _ -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"], "bad": ["\nlet pipe fs = let f a x x = a in let base y = y in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = (x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base y = y in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = (fun y -> x) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n", "Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"], "bad": ["\nlet pipe fs = let f a x y = y a in let base y = y in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x y = a in let base y = y in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = (fun _ -> (x a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> 'c -> ('a -> 'd) -> 'd\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> ('a -> 'd) -> 'd\n"], "bad": ["\nlet pipe fs =\n  let f a x _ x = x a in let base y = y in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = (x a) in\nlet base = (fun _ -> 0) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value base\n"], "bad": ["\nlet pipe fs =\n  let f a x = x a in let base _ = base in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = (x (x a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n", "Error: This expression has type (('a -> 'b) -> 'a) -> ('a -> 'b) -> 'b\n       but an expression was expected of type\n         (('a -> 'b) -> 'a) -> ('a -> 'b) -> ('a -> 'b) -> 'a\n       The type variable 'b occurs inside ('a -> 'b) -> 'a\n"], "bad": ["\nlet pipe fs =\n  let f a x = x (a a) in let base y = y in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = x (a x) in let base y = y in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = (x a) in\nlet base = (f) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value y\n", "Error: Unbound value a\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base _ = y in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = f a in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = (fun z -> a z) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n"], "bad": ["\nlet pipe fs = let f a x z = z a in let base y = y in List.fold_left f base fs;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x a in\nlet base = \"\" in\nlet l = [fun x -> x ^ sep] in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type string -> string\n       but an expression was expected of type (string -> string) list\n", "Error: This expression has type string -> string\n       but an expression was expected of type (string -> string) list\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x a in\n      let base = \"\" in let l = (^) sep in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x a in\n      let base = \"\" in let l x = x ^ sep in List.fold_left f base l;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type (string -> string) list\n       but an expression was expected of type string list\n       Type string -> string is not compatible with type string \n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = \"\" in\n      let l = [(fun x  -> x ^ sep)] in List.fold_left f base l;;\n"]}
{"fix": ["let stringOfList f l = \nmatch l with\n| []    -> \"[]\"\n| x::xs ->\nlet g a x = a ^ \"; \" ^ (f x) in\nlet base = f x in\nList.fold_left g base xs"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type 'a -> string\n       but an expression was expected of type 'a -> 'b -> 'a\n       Type string is not compatible with type 'b -> 'a \n"], "bad": ["\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::xs ->\n      let g a x = a ^ (\"; \" ^ (f x)) in\n      let base = f x in List.fold_left f base xs;;\n"]}
{"fix": ["let rec clone x n =\nlet rec clone_RT acc n =\nif n <= 0 then \nacc\nelse \nclone_RT (x::acc) (n-1)\nin\nclone_RT [] n"], "hw": "hw3", "problem": "clone", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec clone x n =\n  let rec clone_RT acc n = if n <= 0 then acc else clone (x :: acc) (n - 1) in\n  clone_RT [] n;;\n", "\nlet rec clone x n =\n  let rec clone_RT acc n = if n <= 0 then acc else clone (x :: acc) (n - 1) in\n  clone_RT [] n;;\n"]}
{"fix": ["let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nlet diff = len1 - len2 in\nif diff < 0 then\n(List.append (clone 0 (-diff)) l1, l2)\nelse\n(List.append (clone 0 diff) l2, l1)"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then List.append ((List.append ((clone 0 (- diff)), len1)), len2)\n  else List.append ((List.append ((clone 0 diff), len2)), len1);;\n", "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then List.append ((List.append ((clone 0 (- diff)), len1)), len2);;\n", "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append ((clone 0 (- diff)), len1)), len2)\n  else ((List.append ((clone 0 diff), len2)), len1);;\n", "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) len1), len2)\n  else ((List.append (clone 0 diff) len2), len1);;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = ([0], [0]) in\nlet base = ([0], [0]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'a\n       but an expression was expected of type 'b list\n", "Error: This expression has type int but an expression was expected of type\n         int * int\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = 0 in\n    let base = 0 in\n    let args = (l1, l1) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (1, 2) in\n    let base = 0 in\n    let args = (l1, l1) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, 0) in\n    let base = (0, 0) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, 0) in\n    let base = (0, 0) in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (0, []) in\nlet base = (0, []) in\nlet args = (clone 0 (List.length l1)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * int\n       but an expression was expected of type 'b list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int * int list\n       but an expression was expected of type 'a list\n"], "bad": ["\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([0], [0]) in\n    let base = ([0], [0]) in\n    let args = (l1, 2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([0], [0]) in\n    let base = ([0], [0]) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([0], [0]) in\n    let base = (0, 0) in\n    let args = (0, (clone 0 List.length l1)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([0], [0]) in\n    let base = (0, []) in\n    let args = (0, (clone 0 List.length l1)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, []) in\n    let base = (0, []) in\n    let args = (0, (clone 0 List.length l1)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, []) in\n    let base = (0, []) in\n    let args = (0, (clone 0 (List.length l1))) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \n(t, (h + x)::y)\nin\nlet base = (List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value List.reverse\n", "Error: Unbound value List.reverse\n"], "bad": ["\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with | ([],y) -> ([], y) | (h::t,y) -> (t, ((h + x) :: y)) in\n    let base = ((List.reverse l1), []) in\n    let args = List.reverse l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with | ([],y) -> ([], y) | (h::t,y) -> (t, ((h + x) :: y)) in\n    let base = ((List.rev l1), []) in\n    let args = List.reverse l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([], _), y) -> (([], 0), y) \n| ((h::t, carry), y) -> \nlet sum = h + x in\n((t, sum / 10), (sum mod 10)::y)\nin\nlet base = ((List.rev l1, 0), []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value carry\n"], "bad": ["\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (([],_),y) -> (([], 0), y)\n      | ((h::t,carry),y) ->\n          let sum = h + x in ((t, (sum / 10)), ((sum mod 10) :: y)) in\n    let base = (((List.rev l1), carry), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([], _), y) -> (([], 0), y) \n| ((h::t, carry), y) -> \nlet sum = h + x + carry in\n((t, sum / 10), (sum mod 10)::y)\nin\nlet base = ((0::(List.rev l1), 0), []) in\nlet args = 0::(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"], "bad": ["\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (([],_),y) -> (([], 0), y)\n      | ((h::t,carry),y) ->\n          let sum = (h + x) + carry in ((t, (sum / 10)), ((sum mod 10) :: y)) in\n    let base = ((0 :: ((List.rev l1), 0)), []) in\n    let args = 0 :: (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([], _), y) -> (([], 0), y) \n| ((h::t, carry), y) -> \nlet sum = h + x + carry in\n((t, sum / 10), (sum mod 10)::y)\nin\nlet base = ((List.rev (0::l1), 0), []) in\nlet args = List.rev (0::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (([],_),y) -> (([], 0), y)\n      | ((h::t,carry),y) ->\n          let sum = (h + x) + carry in ((t, (sum / 10)), ((sum mod 10) :: y)) in\n    let base = ((((List.rev 0) :: l1), 0), []) in\n    let args = (List.rev 0) :: l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let rec mulByDigit i l = \nlet rec mulByDigit_RT i acc =\nif i = 1 then acc\nelse mulByDigit_RT (i-1) (bigAdd acc l)\nin\nmulByDigit_RT i []"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: Unbound value mulByDigit_RT\nHint: Did you mean mulByDigit?\n"], "bad": ["\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (([],_),y) -> (([], 0), y)\n      | ((h::t,carry),y) ->\n          let sum = (h + x) + carry in ((t, (sum / 10)), ((sum mod 10) :: y)) in\n    let base = (((List.rev (0 :: l1)), 0), []) in\n    let args = List.rev (0 :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let mulByDigit_RT i acc =\n    if i = 1 then acc else mulByDigit_RT (i - 1) (bigAdd acc l) in\n  mulByDigit_RT i [];;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = match a with\n| (i, acc) -> \nlet digmul = mulByDigit (i * x) l2 in\n(i * 10, bigAdd digmul acc)\n| _ -> failwith \"wtf\" in\nlet base = (1, []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int * 'a list\n       but an expression was expected of type 'b list * 'c\n       Type int is not compatible with type 'b list \n"], "bad": ["\nlet bigMul l1 l2 =\n  let f a x = match a with | (i,acc) -> ([], acc) | _ -> failwith \"wtf\" in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let stringOfList f l = \n\"[\" ^ (stringOfList f (List.map f l)) ^ \"]\""], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type ('a -> string) list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type string list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type string list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n", "Error: This expression has type string but an expression was expected of type\n         string list\n", "Error: This expression has type (string list -> string) list\n       but an expression was expected of type string\n", "Error: This expression has type string list\n       but an expression was expected of type string\n", "Error: This expression has type 'a list\n       but an expression was expected of type string\n", "Error: This expression has type 'a list\n       but an expression was expected of type string\n", "Error: This expression has type 'a list -> 'b list\n       but an expression was expected of type string\n", "Error: This expression has type 'a list\n       but an expression was expected of type string\n", "Error: This expression has type 'a list -> 'b list\n       but an expression was expected of type string\n", "Error: This expression has type 'a list\n       but an expression was expected of type string\n", "Error: This expression has type 'a list\n       but an expression was expected of type string\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b -> string\n"], "bad": ["\nlet stringOfList f l =\n  let g a x = a ^ (\"; \" ^ (f x)) in \"[\" ^ ((List.map g l) \"]\");;\n", "\nlet stringOfList f l = let g x = (f x) ^ \"; \" in \"[\" ^ ((List.map g l) \"]\");;\n", "\nlet stringOfList f l = \"[\" ^ ((List.map (fun x  -> x ^ \"; \") l) \"]\");;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((List.map \";\" sepConcat) ^ \"]\");;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((List.map sepConcat \";\") ^ \"]\");;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((List.map sepConcat l) ^ \"]\");;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((List.map (sepConcat \"; \") l) ^ \"]\");;\n", "\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n", "\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n", "\nlet stringOfList f l = \"[\" ^ ((List.map f) ^ \"]\");;\n", "\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n", "\nlet stringOfList f l = \"[\" ^ ((List.map f) ^ \"]\");;\n", "\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n", "\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n", "\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::xs ->\n      let g a x = a ^ (\"; \" ^ (f x)) in\n      let base = \"[\" ^ (f x) in (List.fold_left g base xs) ^ \"]\";;\n\nlet stringOfList f l = \"[\" ^ ((stringOfList (List.map f l)) ^ \"]\");;\n"]}
{"fix": [], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type string\n"], "bad": ["\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n"]}
{"fix": [], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type string\n", "Error: This expression has type 'a list\n       but an expression was expected of type string\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"; \" [[1; 0]; [2]; [3]];;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"; \" [[1; 0]; [2]; [3]];;\n"]}
{"fix": ["let stringOfList f l = List.map f l"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type int -> string\n       but an expression was expected of type string -> string\n       Type int is not compatible with type string \n", "Error: This expression has type int -> string\n       but an expression was expected of type string -> string\n       Type int is not compatible with type string \n", "Error: This expression has type int -> string\n       but an expression was expected of type string -> string\n       Type int is not compatible with type string \n", "Error: This expression has type int -> string\n       but an expression was expected of type string -> string\n       Type int is not compatible with type string \n", "Error: This expression has type int -> string\n       but an expression was expected of type string -> string\n       Type int is not compatible with type string \n", "Error: This expression has type 'a list\n       but an expression was expected of type string\n", "Error: This expression has type 'a list\n       but an expression was expected of type string\n", "Error: This expression has type 'a list\n       but an expression was expected of type string\n", "Error: This expression has type 'a list\n       but an expression was expected of type string\n", "Error: This expression has type 'a list\n       but an expression was expected of type string\n"], "bad": ["\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::xs ->\n      let g a x = a ^ (\"; \" ^ (f x)) in\n      let base = \"[\" ^ (f x) in (List.fold_left g base xs) ^ \"]\";;\n\nlet stringOfList f l = \"[\" ^ ((stringOfList f (List.map f l)) ^ \"]\");;\n\nlet _ = List.map (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n", "\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::xs ->\n      let g a x = a ^ (\"; \" ^ (f x)) in\n      let base = \"[\" ^ (f x) in (List.fold_left g base xs) ^ \"]\";;\n\nlet stringOfList f l = \"[\" ^ ((stringOfList f (List.map f l)) ^ \"]\");;\n\nlet _ = List.map (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n", "\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::xs ->\n      let g a x = a ^ (\"; \" ^ (f x)) in\n      let base = \"[\" ^ (f x) in (List.fold_left g base xs) ^ \"]\";;\n\nlet stringOfList f l = \"[\" ^ ((stringOfList f (List.map f l)) ^ \"]\");;\n\nlet _ = List.map (stringOfList string_of_int);;\n", "\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::xs ->\n      let g a x = a ^ (\"; \" ^ (f x)) in\n      let base = \"[\" ^ (f x) in (List.fold_left g base xs) ^ \"]\";;\n\nlet stringOfList f l = \"[\" ^ ((stringOfList f (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int;;\n", "\nlet stringOfList f l =\n  match l with\n  | [] -> \"[]\"\n  | x::xs ->\n      let g a x = a ^ (\"; \" ^ (f x)) in\n      let base = \"[\" ^ (f x) in (List.fold_left g base xs) ^ \"]\";;\n\nlet stringOfList f l = \"[\" ^ ((stringOfList f (List.map f l)) ^ \"]\");;\n\nlet _ = stringOfList string_of_int;;\n", "\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n", "\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n", "\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n", "\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n", "\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n"]}
{"fix": ["let stringOfList f l = (List.map f l);"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type string\n"], "bad": ["\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigMul", "message": ["Error: Unbound value mulByDigit\n"], "bad": ["\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n"]}
{"fix": [], "hw": "hw3", "problem": "sqsum", "message": ["Error: Unbound value bigMul\n"], "bad": ["\nlet _ =\n  bigMul [1; 9; 4; 5; 2; 3; 7; 4; 8; 1; 2; 9; 5; 8; 1; 0; 0; 5; 4; 6] [];;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n <= 0 then []\nelse n mod 10 :: digitsOfInt (n/10)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n"]}
{"fix": ["let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10\n  then 0\n  else\n    (let myList = digits n in\n     let num = sumList n in num + (additivePersistence num));;\n"]}
{"fix": ["let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet counter = 0;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10\n  then counter\n  else\n    (let myList = digits n in\n     let num = sumList myList in\n     let counter = 0 in\n     counter = ((counter + (1 num)) + (additivePersistence num)));;\n"]}
{"fix": ["let rec additivePersistence n = \nif (n < 10) \nthen []\nelse \nlet myList = digits n in\n(*let num = sumList myList in*)\nmyList"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10\n  then []\n  else\n    (let myList = digits n in\n     let num = sumList myList in num + (additivePersistence num));;\n"]}
{"fix": ["let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \nlet myList = digits n in\nlet num = sumList myList in\nlet sum = num + additivePersistence num in\n1 + additivePersistence num"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type bool but an expression was expected of type\n         int\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet counter = 0;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10\n  then 0\n  else\n    (let myList = digits n in\n     let num = sumList myList in\n     let sum = num + (additivePersistence num) in\n     counter = ((additivePersistence num) + 1));;\n"]}
{"fix": ["let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \n1 + additivePersistence (sumList (digits n))"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence sumList (digits n));;\n"]}
{"fix": ["let rec digitalRoot n = \nif (n < 10)\nthen n\nelse\nadditivePersistence ( sumList (digits n))"], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: Unbound value digRoot\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value digRoot\n", "Error: Unbound value root\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value root\n", "Error: Unbound value root\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value root\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if n < 10 then digRoot = n else additivePersistence (sumList (digits n));;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if n < 10 then root = n else additivePersistence (sumList (digits n));;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if n < 10 then root = n else additivePersistence (sumList (digits n));;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n <= 0 then []\nelse [n mod 10]::digitsOfInt (n/10)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [digitsOfInt (n / 10); n mod 10];;\n"]}
{"fix": ["let rec listReverse l = match l with \n| [] -> []\n| h::t -> []"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec listReverse l = match l with | [] -> [] | h::t -> 0;;\n"]}
{"fix": ["let rec listReverse l = match l with \n| [] -> []\n| h::[] -> l\n| h::t -> listReverse (append t [h] )"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec listReverse l =\n  match l with | [] -> [] | h::[] -> l | h::t -> (listReverse t) :: h;;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | h::[] -> l | h::t -> (listReverse t) :: h;;\n", "\nlet rec append list1 list2 = match list1 with | [] -> [] | h::t -> h :: list2;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::[] -> l | h::t -> listReverse (append (t [h]));;\n", "\nlet rec append list1 list2 = match list1 with | [] -> [] | h::t -> h :: list2;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::[] -> l | h::t -> listReverse append (t [h]);;\n", "\nlet rec append list1 list2 = match list1 with | [] -> [] | h::t -> h :: list2;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::[] -> l | h::t -> listReverse (append (t [h]));;\n"]}
{"fix": ["let rec listReverse l = match l with \n| [] -> l\n| h::t -> listReverse (append t [h])"], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value append\n", "Error: Unbound value append\n", "Error: Unbound value listReverse\n"], "bad": ["\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append [listReverse t; h];;\n", "\nlet rec listReverse l = match l with | [] -> [] | h::t -> append (t [h]);;\n", "\nlet _ = listReverse [1; 2; 3; 4];;\n"]}
{"fix": [], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value listReverse\n", "Error: Unbound value listReverse\n"], "bad": ["\nlet _ = listReverse [1; 2; 3; 4];;\n", "\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value digitsOfInt\n"], "bad": ["\nlet _ = digitsOfInt 3124;;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlistReverse ([(n mod 10)] append digitsOfInt (n/10) )"], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value listReverse\n"], "bad": ["\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlistReverse (append [n mod 10] (digitsOfInt (n/10)) )"], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value listReverse\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else listReverse ([n mod 10] append digitsOfInt (n / 10));;\n"]}
{"fix": [], "hw": "hw1", "problem": "palindrome", "message": ["Error: Unbound value reverseList\n"], "bad": ["\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w =\n  match w with\n  | \"\" -> true\n  | _ ->\n      let myString = explode w in\n      let reverseString = reverseList myString in\n      if myString = reverseString then true else false;;\n"]}
{"fix": ["let rec assoc (d,k,l) = failwith \"hue\""], "hw": "hw2", "problem": "assoc", "message": ["Error: This expression has type 'a but an expression was expected of type\n         'b -> 'c -> 'a * 'd * ('d * 'a) list\n       The type variable 'a occurs inside\n       'b -> 'c -> 'a * 'd * ('d * 'a) list\n"], "bad": ["\nlet rec assoc (d,k,l) =\n  match d k l with\n  | (d,k,l) ->\n      if l = []\n      then d\n      else\n        (match l with\n         | hd::tl ->\n             (match hd with | (a,b) -> if a = k then b else assoc (d, k, t)));;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((fun x -> let b = (f x) in (b, b != x)),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let check = f b in\n  match check with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile (fun x  -> let b = f x in ((b, (b != x)), b));;\n"]}
{"fix": ["let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t  -> \"x\"\n| VarY\t\t  -> \"y\"\n| Sine(t)\t  -> (\"sin(pi*\"^(expr t)^\")\")\n| Cosine(t)\t  -> (\"cos(pi*\"^(expr t)^\")\")\n| Average(s, t) -> (\"((\"^(expr s)^\"+\"^(expr t)^\")/2)\" )\n| Times(s, t) -> ((expr s)^\"*\"^(expr t))\n| Thresh(s, t, u, v) -> (\"(\"^(expr s)^\"<\"^(expr t)^\"?\"^(expr u)^\":\"^(expr v)^\")\")"], "hw": "hw2", "problem": "exprToString", "message": ["Error: Unbound value ex\n", "Error: Unbound value ex\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let expr = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine t -> \"sin(pi*\" ^ ((expr t) ^ \")\")\n  | Cosine t -> \"cos(pi*\" ^ ((expr t) ^ \")\")\n  | Average (s,t) -> \"((\" ^ ((ex s) ^ (\"+\" ^ ((ex t) ^ \")/2)\")))\n  | Times (s,t) -> (ex s) ^ (\"*\" ^ (ex t))\n  | Thresh (s,t,u,v) ->\n      \"(\" ^\n        ((ex s) ^\n           (\"<\" ^ ((ex t) ^ (\"?\" ^ ((ex u) ^ (\":\" ^ ((ex v) ^ \")\")))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let expr = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine t -> \"sin(pi*\" ^ ((expr t) ^ \")\")\n  | Cosine t -> \"cos(pi*\" ^ ((expr t) ^ \")\")\n  | Average (s,t) -> \"((\" ^ ((expr s) ^ (\"+\" ^ ((expr t) ^ \")/2)\")))\n  | Times (s,t) -> (ex s) ^ (\"*\" ^ (expr t))\n  | Thresh (s,t,u,v) ->\n      \"(\" ^\n        ((expr s) ^\n           (\"<\" ^ ((expr t) ^ (\"?\" ^ ((expr u) ^ (\":\" ^ ((expr v) ^ \")\")))))));;\n"]}
{"fix": ["let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t      -> \"x\"\n| VarY\t\t      -> \"y\"\n| Sine a\t      -> (\"sin(pi*\"^(expr a)^\")\")\n| Cosine a\t      -> (\"cos(pi*\"^(expr a)^\")\")\n| Average (a, b)      -> (\"((\"^(expr a)^\"+\"^(expr b)^\")/2)\" )\n| Times (a, b)\t      -> ((expr a)^\"*\"^(expr b))\n| Thresh (a, b, c, d) -> (\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\")"], "hw": "hw2", "problem": "exprToString", "message": ["Error: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let expr = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((expr a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((expr a) ^ \")\")\n  | (Average a,b) -> \"((\" ^ ((expr a) ^ (\"+\" ^ ((expr b) ^ \")/2)\")))\n  | (Times a,b) -> (expr a) ^ (\"*\" ^ (expr b))\n  | (Thresh a,b,c,d) ->\n      \"(\" ^\n        ((expr a) ^\n           (\"<\" ^ ((expr b) ^ (\"?\" ^ ((expr c) ^ (\":\" ^ ((expr d) ^ \")\")))))));;\n"]}
{"fix": ["let rec wwhile (f,b) = \nmatch (f, b) with\n| (b', y) -> \nif y = false\nthen b'\nelse wwhile (f, b')"], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value b'\n", "Error: Unbound value b'\n", "Error: Unbound value b'\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let check = (f, b') in\n  match check with | (b',y) -> if y = false then b' else wwhile (f, b');;\n", "\nlet rec wwhile (f,b) =\n  let check = f b' in\n  match check with | (b',y) -> if y = false then b' else wwhile (f, b');;\n", "\nlet rec wwhile (f,b) =\n  let check = f b' in\n  match check with | (b',y) -> if y = false then b' else wwhile (f, b');;\n"]}
{"fix": ["let rec wwhile (f,b) = \nmatch (f, b) with\n| (x, y) -> \nif y = false\nthen x\nelse wwhile (f, x)"], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type int -> int * bool\n       but an expression was expected of type bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match (f, b) with | (b',y) -> if y = false then b' else wwhile (f, b');;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n"]}
{"fix": ["let rec wwhile (f,b) = \nlet check = (f b) in\nmatch check with\n| (x, y) -> \nif y = false\nthen x\nelse wwhile (f, x)"], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type bool -> 'a\n       but an expression was expected of type bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let check = f b in\n  match (f, b) with | (x,y) -> if y = false then x else wwhile (f, x);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((fun x ->\nlet b = (f x) in\n(b, b != x)),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let check = f b in\n  match check with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile (fun x  -> let b = f x in ((b, (b != x)), b));;\n", "\nlet rec wwhile (f,b) =\n  let check = f b in\n  match check with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile (fun x  -> let b = f x in ((b, (b != x)), b));;\n"]}
{"fix": ["let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t      -> \"x\"\n| VarY\t\t      -> \"y\"  \n| Sine a\t      -> \"sin(pi*\"^(expr a)^\")\"\n| Cosine a\t      -> \"cos(pi*\"^(expr a)^\")\"\n| Average (a, b)      -> \"((\"^(expr a)^\"+\"^(expr b)^\")/2)\"\n| Times (a, b)\t      -> (expr a)^\"*\"^(expr b)\n| Thresh (a, b, c, d) -> \n\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: Unbound value expr\nHint: Did you mean exp?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((expr a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((expr a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((expr a) ^ (\"+\" ^ ((expr b) ^ \")/2)\")))\n  | Times (a,b) -> (expr a) ^ (\"*\" ^ (expr b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((expr a) ^\n           (\"<\" ^ ((expr b) ^ (\"?\" ^ ((expr c) ^ (\":\" ^ ((expr d) ^ \")\")))))));;\n"]}
{"fix": ["let rec assoc (d,k,l) = \nif l = [] then d else\nmatch l with h::t ->\nmatch h with (a, b) ->\nif a = k then b\nelse assoc (d, k, t)"], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value dkl\n", "Error: Unbound value matchl\n"], "bad": ["\nlet rec assoc (d,k,l) =\n  match dkl with | (d,k,l) -> if l = [] then d else matchl;;\n", "\nlet rec assoc (d,k,l) = if l = [] then d else matchl;;\n"]}
{"fix": ["let rec assoc (d,k,l) =\nmatch (d, k, l) with\n| (d, k, l) ->\nif l = [] \nthen d\nelse\nmatch l with h::t ->\nmatch h with (a, b) ->\nif a = k \nthen b\nelse assoc (d, k, t)"], "hw": "hw2", "problem": "assoc", "message": ["Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b * 'c * 'd\n"], "bad": ["\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | [] -> 0\n  | (d,k,l) ->\n      if l = []\n      then d\n      else\n        (match l with\n         | h::t ->\n             (match h with | (a,b) -> if a = k then b else assoc (d, k, t)));;\n"]}
{"fix": ["let rec wwhile (f,b) = \nlet check = (f b) in\nmatch check with\n| (x', y) -> \nif y = false\nthen x'\nelse wwhile (f, x')"], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type int -> int * bool\n       but an expression was expected of type bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match (f, b) with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen = false\nthen h :: seen\nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen cons [h] else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"]}
{"fix": ["let rec build (rand, depth) = if depth > 0 then \n\nlet r = (rand (0, 5)) in \nlet d = (depth - 1) in \n\nmatch r with\n| 0 -> buildSine((build (rand, d)))\n| 1 -> buildCosine((build (rand, d)))\n| 2 -> buildAverage((build (rand, d)), (build (rand, d)))\n| 3 -> buildTimes((build (rand, d)), (build (rand, d)))\n| 4 -> buildThresh((build (rand, d)), (build (rand, d)), (build (rand, d)), (build (rand, d)))\n\nelse \n\nlet r = (rand (0, 2)) in \n\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type int but an expression was expected of type\n         int * int -> int\n", "Error: Unbound value rand\nHint: Did you mean land?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let r = rand (0, 5) in\n    let d = depth - 1 in\n    match r with\n    | 0 -> buildSine (build (rand, d))\n    | 1 -> buildCosine (build (rand, d))\n    | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n    | 4 ->\n        buildThresh\n          ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n            (build (rand, d)))\n  else\n    (let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ());;\n\nlet g1 () = build (2, 2);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let r = rand (0, 5) in\n    let d = depth - 1 in\n    match r with\n    | 0 -> buildSine (build (rand, d))\n    | 1 -> buildCosine (build (rand, d))\n    | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n    | 4 ->\n        buildThresh\n          ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n            (build (rand, d)))\n  else\n    (let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ());;\n\nlet g1 () = build ((rand (0, 5)), 2);;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type (int * int -> int) * int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let r = rand (0, 5) in\n    let d = depth - 1 in\n    match r with\n    | 0 -> buildSine (build (rand, d))\n    | 1 -> buildCosine (build (rand, d))\n    | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n    | 4 ->\n        buildThresh\n          ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n            (build (rand, d)))\n  else\n    (let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ());;\n\nlet g2 () = build (3, 4, 5);;\n"]}
{"fix": ["let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n(eval(a, x, y) *. eval(a, x, y)) +. (eval(b, x, y) *. eval(c, x, y))\n| Tan a -> sin (pi *. eval(a, x, y)) /. cos (pi *. eval(a, x, y))"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type float\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Poly (a,b,c) ->\n      (eval ((a, x, y) *. (a, x, y))) + ((b, x, y) *. (c, x, y));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Poly (a,b,c) ->\n      ((eval (a, x, y)) *. (eval (a, x, y))) +\n        ((eval (b, x, y)) *. (eval (c, x, y)));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Poly (a,b,c) ->\n      ((eval (a, x, y)) * (eval (a, x, y))) +\n        ((eval (b, x, y)) *. (eval (c, x, y)));;\n"]}
{"fix": ["let rec build (rand, depth) = \nif depth < 0 \nthen \nlet r = (rand (0, 2)) in \nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\nelse \nlet d = depth - 1 in \nmatch rand(0, 7) with\n| 0 -> buildSine(build (rand, d))\n| 1 -> buildCosine(build (rand, d))\n| 2 -> buildAverage(build (rand, d), build (rand, d))\n| 3 -> buildTimes(build (rand, d), build (rand, d))\n| 4 -> buildThresh(build (rand, d),\nbuild (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| 5 -> buildPoly(build (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| 6 -> buildTan( build (rand, d))\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up \""], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildPoly (e1,e2,e3) = Poly (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildTan e = Tan e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 0\n  then\n    let r = rand (0, 2) in\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\n  else\n    (let d = depth - 1 in\n     match rand (0, 7) with\n     | 0 -> buildSine (build (rand, d))\n     | 1 -> buildCosine (build (rand, d))\n     | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n     | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n     | 4 ->\n         buildThresh\n           ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n             (build (rand, d)))\n     | 5 ->\n         buildPoly ((build (rand, d)), (build (rand, d)), (build (rand, d)))\n     | 6 -> buildTan ((build (rand, d)), (build (rand, d)))\n     | _ -> failwith \"Make the non-exhaustve pattern match warning shut up \");;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun b -> x(a b) in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value y\n"], "bad": ["\nlet pipe fs =\n  let f a x b = x (a y) in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun b -> x(a b) in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value c\n"], "bad": ["\nlet pipe fs =\n  let f a x b = c (a b) in let base c = c in List.fold_left f base fs;;\n"]}
{"fix": ["let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\""], "hw": "hw3", "problem": "stringOfList", "message": ["Error: Unbound value sep\n", "Error: This expression has type string but an expression was expected of type\n         bool\n"], "bad": ["\nlet stringOfList f l = (\"[\" ^ (sep \"; \" (List.map f l))) & \"]\";;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = (\"[\" ^ (sepConcat \"; \" (List.map f l))) & \"]\";;\n"]}
{"fix": ["let padZero l1 l2 = \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (l1, l2)\nelse if a < b\nthen (clone 0 (b - a) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (a, b)\n  else\n    if a < b\n    then (((clone 0 (a - b)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (a, b)\n  else\n    if a < b\n    then (((clone 0 (a - b)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (a, b)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (a, b)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n"]}
{"fix": ["let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h = 0\nthen removeZero t\nelse l"], "hw": "hw3", "problem": "removeZero", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else 1;;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (x1, x2) = x in\nlet res = x1 + x2 + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 :: [])\n| h::t -> (newCarry, newCarry :: res mod 10 :: t) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type 'a list\n       but an expression was expected of type int * int list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int * int list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int * int list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (l1, l2)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let c = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + c) / 10) :: (h + (c mod 10)) :: t\n      | _ -> [c / 10; c mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (l1, l2)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,result) = a in\n      let (x1,x2) = x in\n      let res = (x1 + x2) + carry in\n      let newCarry = res / 10 in\n      match result with\n      | [] -> (newCarry, [newCarry; res mod 10])\n      | h::t -> (newCarry, (newCarry :: (res mod 10) :: t)) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (l1, l2)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,result) = a in\n      let (x1,x2) = x in\n      let res = (x1 + x2) + carry in\n      let newCarry = res / 10 in\n      match result with\n      | [] -> (newCarry, [newCarry; res mod 10])\n      | h::t -> (newCarry, (newCarry :: (res mod 10) :: t)) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (l1, l2)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,result) = a in\n      let (x1,x2) = x in\n      let res = (x1 + x2) + carry in\n      let newCarry = res / 10 in\n      match result with\n      | [] -> (newCarry, [newCarry; res mod 10])\n      | h::t -> (newCarry, (newCarry :: (res mod 10) :: t)) in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if List.length l1 < List.length l2\nthen (clone 0 (List.length l2 - List.length l1)) @ l1, l2\nelse l1, (clone 0 (List.length l1 - List.length l2)) @ l2"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, (clone 0 (((List.length l1) - (List.length l2)) @ l2)));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, (clone 0 (((List.length l1) - (List.length l2)) @ l2)));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, (clone 0 (((List.length l1) - (List.length l2)) @ l2)));;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = let (b, c) = a in\nlet (_, d) = x in\nlet res = bigAdd (mulByDigit d l1 @ clone 0 b) c in\n(b + 1, res)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: Unbound value b\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value b\n", "Error: This expression has type int but an expression was expected of type\n         int list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,result) = a in\n      let (x1,x2) = x in\n      let res = (x1 + x2) + carry in\n      let newCarry = res / 10 in\n      match result with\n      | [] -> (newCarry, [newCarry; res mod 10])\n      | h::t -> (newCarry, (newCarry :: (res mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let c = x * i in\n    match a with\n    | h::t -> ((h + c) / 10) :: ((h + c) mod 10) :: t\n    | _ -> [c / 10; c mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let a = (b, c) in\n    let (_,d) = x in\n    let y = bigAdd ((mulByDigit d l1) @ (clone c b)) c in ((b + 1), c) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,result) = a in\n      let (x1,x2) = x in\n      let res = (x1 + x2) + carry in\n      let newCarry = res / 10 in\n      match result with\n      | [] -> (newCarry, [newCarry; res mod 10])\n      | h::t -> (newCarry, (newCarry :: (res mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let c = x * i in\n    match a with\n    | h::t -> ((h + c) / 10) :: ((h + c) mod 10) :: t\n    | _ -> [c / 10; c mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (b,c) = a in\n    let (_,d) = x in\n    let y = bigAdd ((mulByDigit d l1) @ (clone c b)) c in ((b + 1), c) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (b, c) = x in\nlet res = b + c + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 :: [])\n| h::t -> (newCarry, newCarry :: res mod 10 :: t) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,result) = a in\n      let (b,c) = x in\n      let res = (x + x) + carry in\n      let newCarry = res / 10 in\n      match result with\n      | [] -> (newCarry, [newCarry; res mod 10])\n      | h::t -> (newCarry, (newCarry :: (res mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (addC, resOfAdd) = a in\nlet (i1, i2) = x in\nlet result = i1 + i2 + addC in\nlet nextCarry = result / 10 in\nmatch resOfAdd with \n| [] -> (nextCarry, [nextCarry] @ [result mod 10] @ [])\n| h::t -> (nextCarry, [nextCarry] @ [result mod 10] @ t) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (addC,resOfAdd) = a in\n      let (i1,i2) = x in\n      let result = (i1 + i2) + addC in\n      let nextCarry = result / 10 in\n      match resOfAdd with\n      | [] -> (nextCarry, (nextCarry @ ([result mod 10] @ [])))\n      | h::t -> (nextCarry, (nextCarry @ ([result mod 10] @ t))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = let (b, c) = a in\nlet (_, d) = x in\nlet e = bigAdd (mulByDigit d l1 @ clone 0 b) c in\n(b + 1, e)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This function has type 'a list -> 'b list -> ('a * 'b) list\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This function has type 'a list -> 'b list -> ('a * 'b) list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (addC,resOfAdd) = a in\n      let (i1,i2) = x in\n      let result = (i1 + i2) + addC in\n      let nextCarry = result / 10 in\n      match resOfAdd with\n      | [] -> (nextCarry, ([nextCarry] @ ([result mod 10] @ [])))\n      | h::t -> (nextCarry, ([nextCarry] @ ([result mod 10] @ t))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let b = x * i in\n    match a with\n    | h::t -> [(h + b) / 10] @ ([(h + b) mod 10] @ t)\n    | _ -> [b / 10] @ [b mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (b,c) = a in\n    let (_,d) = x in\n    let e = bigAdd ((mulByDigit d l1) @ (clone 0 b)) c in ((b + 1), e) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) List.rev l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let rec sumList xs = \nList.fold_left (+) xs"], "hw": "hw1", "problem": "sumList", "message": ["Error: Unbound value int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec sumList xs = function | [] -> int;;\n", "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + t;;\n", "\nlet _ = let rec sumList xs = match xs with | [] -> 0 | h::t -> h + t in xs;;\n"]}
{"fix": ["let rec sumList xs = match xs with\n[] -> 0"], "hw": "hw1", "problem": "sumList", "message": ["Error: This expression has type 'a -> 'b list -> 'a\n       but an expression was expected of type int\n"], "bad": ["\nlet rec sumList xs =\n  match xs with | [] -> 0 | x::xs -> (List.fold_left x) + xs;;\n"]}
{"fix": ["let rec sumList xs = match xs with\n[] -> 0\n| h::t -> 1"], "hw": "hw1", "problem": "sumList", "message": ["Error: Unbound value sum\n"], "bad": ["\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sum t);;\n"]}
{"fix": ["let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs"], "hw": "hw1", "problem": "sumList", "message": ["Error: Unbound value int\n"], "bad": ["\nlet rec sumList xs = match xs with | [] -> int | h::t -> 1;;\n"]}
{"fix": ["let rec digitsOfInt n =\nif n < 0 then []\nelse match n /10 with\n0 -> [0]\n| _ -> digitsOfInt n"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value digitsOfIn\nHint: Did you mean digitsOfInt?\n", "Error: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 0 then [] else (match n / 10 with | 0 -> [0] | _ -> digitsOfIn n []);;\n", "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n / 10 with | 0 -> [0] | _ -> digitsOfInt n []);;\n"]}
{"fix": ["let rec digitsOfInt n =\nif n < 0 then []\nelse let rec loop (n/10) (n mod 10::lis) = match n with\n0 -> [0]\n| _ -> loop n []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: Unbound value digitOfInt\nHint: Did you mean digitsOfInt?\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 0 then [] else (match n mod 10 with | _ -> [digitsOfInt (n / 10)]);;\n", "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (match n mod 10 with | _ -> [digitsOfInt (n / 10)]);;\n", "\nlet rec digitsOfInt n = if n < 0 then [] else [digitOfInt (n / 10)];;\n", "\nlet rec digitsOfInt n = if n < 0 then [] else [digitsOfInt (n / 10)];;\n"]}
{"fix": ["let rec digitsOfInt n =\nif n < 0 then []\nelse let rec loop n x = \nif n = 0 then x\nelse loop (n/10) (n mod 10:: x) in match n with\n0 -> [0]\n| _ -> loop n []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) :: ((n mod 10) []);;\n"]}
{"fix": ["let rec digitsOfInt n =\nif n < 0 then []\nelse let rec loop n x = \nif n = 0 then x\nelse match n with\n0 -> [0]\n| _ -> loop (n/10) (n mod 10::[])"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11] ((1 mod 10) :: 4);;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: Unbound value m\n", "Error: Unbound value r_digital\n", "Error: Unbound value m\n"], "bad": ["\nlet rec digitalRoot n =\n  if n = 0\n  then 0\n  else\n    (let rec r_digitalRoot n m =\n       if n = 0 then m else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> m | _ -> r_digitalRoot n 0);;\n", "\nlet rec digitalRoot n =\n  if n = 0\n  then 0\n  else\n    (let rec r_digitalRoot n m =\n       if n = 0 then m else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> r_digital root m 0 | _ -> r_digitalRoot n 0);;\n", "\nlet rec digitalRoot n =\n  if n = 0\n  then 0\n  else\n    (let rec r_digitalRoot n m =\n       if n = 0 then m else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> r_digitalRoot m 0 | _ -> r_digitalRoot n 0);;\n"]}
{"fix": [], "hw": "hw1", "problem": "sumList", "message": ["Error: Unbound value m\n"], "bad": ["\nlet rec digitalRoot n =\n  if n = 0\n  then 0\n  else\n    (let rec r_digitalRoot n m =\n       if n < 9 then n else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> 0 | _ -> r_digitalRoot n m);;\n"]}
{"fix": ["let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n <= 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 0\n| _ -> r_digitalRoot n 0"], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: This expression has type int -> int -> int\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitalRoot n =\n  if n = 0\n  then 0\n  else\n    (let rec r_digitalRoot n m =\n       if n <= 9 then n else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> r_digitalRoot | _ -> r_digitalRoot n (n mod 10));;\n"]}
{"fix": ["let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif n = 0 then 0\nelse r_digitalRoot (n/10) (n mod 10 + m) \nin match n with\n0 -> 0\n| _ -> r_digitalRoot n 0"], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitalRoot n =\n  if n <= 9\n  then n\n  else\n    (let rec r_digitalRoot n m =\n       if n <= 9 then n else r_digitalRoot (n / 10) ((n mod 10) + m) in\n     match n with | 0 -> 123 | _ -> (r_digitalRoot n) - 1);;\n"]}
{"fix": [], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) :: h;;\n"]}
{"fix": [], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec listReverse l = match l with | [] -> [] | h::t -> (listReverse t) @ h;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0, then [0]\nelse _ -> digitsOfInt (n / 10) @ (n mod 10)::[]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | h::t -> [] @ (h @ (digitsOfInt t)));;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n < 0 then []\nelse let rec r_digitsOfInt n x = \nif n = 0 then x\nelse r_digitsOfInt (n / 10) (n mod 10 :: [])"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else [digitsOfInt (n / 10); n mod 10];;\n"]}
{"fix": [], "hw": "hw1", "problem": "palindrome", "message": ["Error: Unbound value orig_Esplode\n", "Error: This variant expression is expected to have type unit\n       The constructor true does not belong to type unit\n"], "bad": ["\nlet palindrome w = orig_Esplode = (esplode w);;\n", "\nlet palindrome w = if w = [] then true;;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n < 0 then []\nelse match n with \n| 0 -> [0]\n| _ -> \nif (n /10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This pattern matches values of type int\n       but a pattern was expected which matches values of type 'a list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  match n with\n  | [] -> []\n  | 0 -> [0]\n  | _ -> (digitsOfInt (n / 10)) @ (n mod 10);;\n", "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | _ -> (digitsOfInt (n / 10)) @ (n mod 10));;\n", "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | _ -> (digitsOfInt (n / 10)) :: (n mod 10));;\n", "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | _ -> [digitsOfInt (n / 10); n mod 10]);;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n < 0 then []\nelse match n with \n| 0 -> [0]\n| _ -> \nif (n /10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])\nelse []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int list\n       but an expression was expected of type unit\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (match n with\n     | 0 -> [0]\n     | _ -> if (n / 10) != 0 then (digitsOfInt (n / 10)) @ [n mod 10]);;\n"]}
{"fix": ["let rec additivePersistence n = \nif n < 9 then 0\nelse if sumList (digitsOfInt n) < 9 then 1\nelse 1 + additivePersistence (sumList (digitsOfInt n))"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (match n with\n     | 0 -> [0]\n     | _ ->\n         if (n / 10) != 0\n         then (digitsOfInt (n / 10)) @ [n mod 10]\n         else [n mod 10]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList digitsOfInt n) < 9\n  then 0\n  else 1 + (additivePersistence sumList n);;\n", "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (match n with\n     | 0 -> [0]\n     | _ ->\n         if (n / 10) != 0\n         then (digitsOfInt (n / 10)) @ [n mod 10]\n         else [n mod 10]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) < 9\n  then 0\n  else 1 + (additivePersistence sumList n);;\n", "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (match n with\n     | 0 -> [0]\n     | _ ->\n         if (n / 10) != 0\n         then (digitsOfInt (n / 10)) @ [n mod 10]\n         else [n mod 10]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) < 9\n  then 0\n  else 1 + (additivePersistence (sumList n));;\n"]}
{"fix": [], "hw": "hw1", "problem": "palindrome", "message": ["Error: Unbound value esplode\nHint: Did you mean explode?\nError: Unbound value esplode\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value esplode\nHint: Did you mean explode?\n", "Error: Unbound value esplode\nHint: Did you mean explode?\n", "Error: Unbound value reverseList\n", "Error: Unbound value reverseList\n"], "bad": ["\nlet palindrome w =\n  let rec r_palindrome ex rev_ex =\n    match (ex, rev_ex) with\n    | ([],[]) -> true\n    | (h1::t1,h2::t2) -> if h1 = h2 then r_palindrome t1 t2 else false\n    | (ex,rev_ex) -> false in\n  r_palindrome (esplode w) (reverseList (esplode w));;\n", "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w =\n  let rec r_palindrome ex rev_ex =\n    match (ex, rev_ex) with\n    | ([],[]) -> true\n    | (h1::t1,h2::t2) -> if h1 = h2 then r_palindrome t1 t2 else false\n    | (ex,rev_ex) -> false in\n  r_palindrome (esplode w) (reverseList (explode w));;\n", "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w =\n  let rec r_palindrome ex rev_ex =\n    match (ex, rev_ex) with\n    | ([],[]) -> true\n    | (h1::t1,h2::t2) -> if h1 = h2 then r_palindrome t1 t2 else false\n    | (ex,rev_ex) -> false in\n  r_palindrome (explode w) (reverseList (explode w));;\n", "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w =\n  let rec r_palindrome ex rev_ex =\n    match (ex, rev_ex) with\n    | ([],[]) -> true\n    | (h1::t1,h2::t2) -> if h1 = h2 then r_palindrome t1 t2 else false\n    | (ex,rev_ex) -> false in\n  r_palindrome (explode w) (reverseList (explode w));;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n <= 0 then []\nelse append (digitsOfInt (n / 10)) (n mod 10 :: [])"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This function has type int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet append x l = match l with | [] -> [x] | _ -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10) [n mod 10]);;\n", "\nlet append x l = match l with | [] -> [x] | _ -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n", "\nlet append x l = match l with | [] -> [x] | _ -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n", "\nlet append x l = match l with | [] -> [x] | _ -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n", "\nlet append x l = match l with | [] -> [x] | _ -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n"]}
{"fix": [], "hw": "hw1", "problem": "listReverse", "message": ["Error: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet append x l =\n  let rec helper x acc =\n    match x with | [] -> acc | h::t -> helper t (h :: acc) in\n  helper x l;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append listReverse t [h];;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen \nthen helper (seen, t) \nelse helper (h::seen, t) in\nlet rest' = helper (seen', t) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: Unbound value seen'\nHint: Did you mean seen?\n", "Error: This expression has type ('a * 'b) list -> bool\n       but an expression was expected of type bool\n", "Error: This expression has type 'a list\n       but an expression was expected of type unit\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = helper ((h :: seen'), t) in\n        let rest' = helper (seen', t) in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h, seen) then helper ((h :: seen), t) in\n        let rest' = helper (seen', t) in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then helper ((h :: seen), t) in\n        let rest' = helper (seen', t) in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then\nseen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: This expression has type 'a list -> bool\n       but an expression was expected of type bool\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen\nelse seen in \nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: Unbound value seen'\nHint: Did you mean seen?\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen' else h :: seen' in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen \nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type unit\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"]}
{"fix": ["let rec wwhile (f,b) =\nlet (b', c') = f b in \nmatch c' with\n| false -> b'\n| true  -> wwhile (f, b')"], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound constructor False\nHint: Did you mean false?\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | False  -> b' | True  -> wwhile (f, b');;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | true  -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value failWith\nHint: Did you mean failwith?\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | true  -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (failWith, b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ( if b' = b in let (b', c') = f b, b"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value le\n", "Error: Unbound value le\n"], "bad": ["\nlet _ = le;;\n", "\nlet _ = le;;\n"]}
{"fix": ["let rec exprToString e = match e with\n| VarX                       -> \"x\"\n| VarY                       -> \"y\"\n| Sine  (ex)                 -> \"sin (pi*)\" ^ exprToString ex ^ \")\"\n| Cosine  (ex)               -> \"cos (pi*)\" ^ exprToString ex ^ \")\"\n| Average (ex1, ex2)         -> \"((\" ^ exprToString ex1 ^ \"+\" ^ exprToString ex2 ^ \")/2)\" \n| Times (ex1, ex2)           -> exprToString ex1 ^ \"*\" ^ exprToString ex2\n| Thresh (ex1, ex2, ex3, ex4) -> \"(\" ^ exprToString ex1 ^ \"<\" ^ exprToString ex2 ^ \"?\" ^ exprToString ex3 ^ \":\" ^ exprToString ex4 ^ \")\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: This variant pattern is expected to have type expr\n       The constructor Tresh does not belong to type expr\nHint: Did you mean Thresh?\n", "Error: Unbound value exprToSring\nHint: Did you mean exprToString?\n", "Error: Unbound value expr1\nHint: Did you mean expm1?\n", "Error: Unbound value expr1\nHint: Did you mean expm1?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin (pi*)\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos (pi*)\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToSring ex1) ^ (\" + \" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString expr1) ^ (\" * \" ^ (exprToString expr2))\n  | Tresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString expr1) ^\n           (\"<\" ^\n              ((exprToString expr2) ^\n                 (\" ? \" ^\n                    ((exprToString expr3) ^\n                       (\" : \" ^ ((exprToString expr4) ^ \")\")))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin (pi*)\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos (pi*)\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToSring ex1) ^ (\" + \" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString expr1) ^ (\" * \" ^ (exprToString expr2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString expr1) ^\n           (\"<\" ^\n              ((exprToString expr2) ^\n                 (\" ? \" ^\n                    ((exprToString expr3) ^\n                       (\" : \" ^ ((exprToString expr4) ^ \")\")))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin (pi*)\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos (pi*)\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\" + \" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString expr1) ^ (\" * \" ^ (exprToString expr2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString expr1) ^\n           (\"<\" ^\n              ((exprToString expr2) ^\n                 (\" ? \" ^\n                    ((exprToString expr3) ^\n                       (\" : \" ^ ((exprToString expr4) ^ \")\")))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin (pi*)\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos (pi*)\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\" + \" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\" * \" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString expr1) ^\n           (\"<\" ^\n              ((exprToString expr2) ^\n                 (\" ? \" ^\n                    ((exprToString expr3) ^\n                       (\" : \" ^ ((exprToString expr4) ^ \")\")))))));;\n"]}
{"fix": ["let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi * (eval (ex, x, y)))\n  | Cosine ex -> cos (pi * (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) + (eval (ex2, x, y))) / 2\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) * (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi * (eval (ex, x, y)))\n  | Cosine ex -> cos (pi * (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) + (eval (ex2, x, y))) / 2\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) * (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> let ex1 = eval (ex, x, y) in sin (pi * ex1)\n  | Cosine ex -> cos (pi * (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) + (eval (ex2, x, y))) / 2\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) * (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi * (eval (ex, x, y)))\n  | Cosine ex -> cos (pi * (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) + (eval (ex2, x, y))) / 2\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) * (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) + (eval (ex2, x, y))) / 2\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) * (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) + (eval (ex2, x, y))) / 2\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) * (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) / 2\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) * (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) * (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) / 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) * (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) * (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n"]}
{"fix": ["let rec build (rand, depth) = \nif depth = 0 then \nlet x = rand(0,1) in\nmatch x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand (0,4) in match r with\n| 0 -> buildSine(build (rand, depth-1))\n| 1 -> buildCosine( build (rand, depth-1))\n| 2 -> buildAverage( build (rand, depth -1), build (rand, depth -1))\n| 3 -> buildTimes( build (rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build (rand, depth-1),build (rand, depth-1),build (rand, depth-1),build (rand, depth-1))"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value buildTresh\nHint: Did you mean buildThresh?\nError: Unbound value buildTresh\nHint: Did you mean buildTimes?\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value buildTresh\nHint: Did you mean buildThresh?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (1, 5) in\n     match r with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"]}
{"fix": ["assoc\n(-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"], "hw": "hw2", "problem": "assoc", "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n"], "bad": ["\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with | (k1,v1) -> if k = k1 then v1 else assoc (d, k, t));;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)])\n    23;;\n"]}
{"fix": [], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ =\n  removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9] [1; 6; 2; 4; 12; 13; 9];;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value rand\nHint: Did you mean land?\n", "Error: Unbound value rand\nHint: Did you mean land?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (0, 4) in\n     match r with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet sam = exprToString (build (rand, 3));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (0, 4) in\n     match r with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet sam = build (rand, 3);;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value eval\n"], "bad": ["\nlet _ = eval ((NewExprA (VarX, Vary)), 1., (-1.));;\n"]}
{"fix": ["let rec exprToString e = match e with\n| VarX                      -> \"x\"\n| VarY                      -> \"y\"\n| Sine (e)                 -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine (e)               -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, e2)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\" \n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| NewExprA (e1,e2) -> \"(\" ^ exprToString e1 ^ \">\" ^exprToString e2 ^ \"?\" ^ exprToString e1 ^ \":\" ^ exprToString e2 ^ \")\"s\n| NewExprB (e1,e2,e3) -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"+\" ^ exprToString e3 ^ \")\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: Unbound value ex\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | NewExprA (e1,e2) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e1, x, y)\n      else eval (e2, x, y)\n  | NewExprB (e1,e2,e3) ->\n      ((eval (e1, x, y)) + (eval (e2, x, y))) + (eval (e3, x, y));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | NewExprA (e1,e2) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 ((\"?\" exprToString e1) ^ (\":\" exprToString e2)))))\n  | NewExprB (e1,e2,e3) ->\n      (\"(\" exprToString e1) ^\n        (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString ex) ^ \")\"))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | NewExprA (e1,e2) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^ ((exprToString e1) ^ (\":\" exprToString e2))))))\n  | NewExprB (e1,e2,e3) ->\n      (\"(\" exprToString e1) ^\n        (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString ex) ^ \")\"))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | NewExprA (e1,e2) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^ ((exprToString e1) ^ (\":\" ^ (exprToString e2)))))))\n  | NewExprB (e1,e2,e3) ->\n      (\"(\" exprToString e1) ^\n        (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString ex) ^ \")\"))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | NewExprA (e1,e2) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^ ((exprToString e1) ^ (\":\" ^ (exprToString e2)))))))\n  | NewExprB (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString ex) ^ \")\")))));;\n"]}
{"fix": ["let rec exprToString e = match e with\n| VarX                      -> \"x\"\n| VarY                      -> \"y\"\n| Sine (e)                 -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine (e)               -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, e2)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\" \n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| NewExprA (e1,e2) -> \"(\" ^ exprToString e1 ^ \">\" ^exprToString e2 ^ \"?\" ^ exprToString e1 ^ \":\" ^ exprToString e2 ^ \")\"\n| NewExprB (e1,e2,e3) -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"-\" ^ exprToString e3 ^ \")\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | NewExprA (e1,e2) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\">\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e1) ^\n                       (\":\" ^ ((exprToString e2) ^ (\")\" s))))))))\n  | NewExprB (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\"+\" ^ ((exprToString e3) ^ \")\")))));;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (e)   -> sin(pi *. (eval (e,x,y)))\n| Cosine (e) -> cos(pi *. eval (e,x,y))\n| Average (e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\n| Times (e1,e2)   -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2, e3, e4) -> if eval (e1,x,y) < eval (e2,x,y) then eval (e3,x,y) else eval (e4,x,y)\n| NewExprA (e1,e2) -> if eval(e1,x,y) > eval(e2,x,y) then eval (e1,x,y) else eval(e2,x,y)\n| NewExprB (e1,e2,e3) -> eval(e1,x,y) +. eval(e2,x,y) -. eval(e3,x,y)"], "hw": "hw2", "problem": "eval", "message": ["Error: Unbound value eval\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\nlet _ = eval ((NewExprA (VarX, Vary)), 1., (-1.));;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun a -> x in\nlet base = fun y -> y in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value f\n", "Error: Unbound value x\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = f a in let base = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base = [] in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun f a -> x in\nlet base = fun y -> y in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'd -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'd -> 'c\n"], "bad": ["\nlet pipe fs =\n  let f a x f x = f a in let base y = y in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun f x -> fun f a -> f a x in\nlet base = fun y -> y in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'd -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'd -> 'c\n", "Error: Unbound value z\n", "Error: Unbound value w\n"], "bad": ["\nlet pipe fs =\n  let f a x f x = f a in let base y = y in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x f a f x = f z in let base y = z in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x f a f x = f w in let base y = z in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun z -> x (a z) in\nlet base = fun z -> z in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> 'b\n       but an expression was expected of type\n         'a -> 'b -> ('c -> 'b -> 'd) -> 'c -> 'd\n       The type variable 'b occurs inside ('c -> 'b -> 'd) -> 'c -> 'd\n", "Error: This expression has type 'a -> 'b -> ('c -> 'd) -> ('a -> 'c) -> 'd\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('c -> 'd) -> ('a -> 'c) -> 'd\n", "Error: Unbound value f\n"], "bad": ["\nlet pipe fs =\n  let f a x f x f a = f a x in let base y z = z in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x f x = f (x a) in let base z = z in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x z = f (x a) in let base z = z in List.fold_left f base fs;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type string but an expression was expected of type\n         string list\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = h in let l = \"\" in List.fold_left f base l;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a x in\n      let base = \"\" in let l = h in List.fold_left f base l;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ sep in\n      let base = h ^ sep in let l = h in List.fold_left f base l;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = sl in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type string but an expression was expected of type\n         string list\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = \"\" in List.fold_left f base l;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = sep in\nlet l = sl in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type string\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = t in let l = sl in List.fold_left f base l;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sep ^ a in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type string list -> string\n       but an expression was expected of type string\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = sep ^ x in\n      let base = \"\" in let l = sl in List.fold_left f base;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep ^ a in\nlet base = sep in\nlet l = sl in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type string\n", "Error: Unbound value a\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ a) in\n      let base = [] in let l = sl in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ a) in\n      let base = a in let l = sl in List.fold_left f base l;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type string\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = [] in let l = sl in List.fold_left f base l;;\n"]}
{"fix": ["let stringOfList f l = List.map sepConcat l"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = (List.map \"[\") ^ ((sepConcat l) ^ \"]\");;\n"]}
{"fix": [], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type string but an expression was expected of type\n         'a list\n", "Error: This expression has type string list -> string\n       but an expression was expected of type 'a list\n", "Error: This expression has type string but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat \"\" l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f (sepConcat \"\" l);;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f (sepConcat l);;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f (sepConcat \"\" l);;\n"]}
{"fix": ["let stringOfList f l = (List.map f l)"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type string\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (List.map f l);;\n"]}
{"fix": ["let rec clone x n = \nif n <= 0 then []\nelse\nclone (x) (n-1)"], "hw": "hw3", "problem": "clone", "message": ["Error: This expression has type 'a -> 'b list\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside 'a -> 'b list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec clone x n = if x <= 0 then [] else [clone x];;\n", "\nlet rec clone x n = if x <= 0 then [] else clone [x] (n - 1);;\n", "\nlet rec clone x n = if n <= 0 then [] else clone [x] (n - 1);;\n", "\nlet rec clone x n = if n <= 0 then x else clone [x] (n - 1);;\n"]}
{"fix": ["let rec clone x n = \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> h::clone t (n-1)"], "hw": "hw3", "problem": "clone", "message": ["Error: Unbound value n\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet _ =\n  let rec clone x n = if n <= 0 then [] else clone x (n - 1) in clone [] n;;\n", "\nlet rec clone x n =\n  if n <= 0\n  then []\n  else (match x with | [] -> x | h::t -> (clone h) :: (x (n - 1)));;\n"]}
{"fix": ["let rec clone x n = \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> h :: clone t (n-1)"], "hw": "hw3", "problem": "clone", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec clone x n =\n  if n <= 0\n  then []\n  else (match x with | [] -> x | h::t -> (clone t (n - 1)) :: h);;\n", "\nlet rec clone x n =\n  if n <= 0\n  then []\n  else (match x with | [] -> x | h::t -> [clone t (n - 1); h]);;\n"]}
{"fix": [], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0 then (((clone (-1)) * (l l2)), l2) else (l1, (clone l l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l2), l2)\n  else (l1, ((clone 0 l) :: l2));;\n"]}
{"fix": ["let padZero l1 l2 = \nlet l = List.length l1 - List.length l2 in\nif l < 0 then ((clone 0 ((-1)*l) @ l2), l2)\nelse (l1, clone 0 l @ l2)"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l2), l2)\n  else (l1, ((clone 0 l) :: l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "padZero", "message": ["Error: Unbound value clone\n"], "bad": ["\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "sqsum", "message": ["Error: Unbound value clone\n"], "bad": ["\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: Unbound value a\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = 0 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = (a + x) mod 10 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a + x) mod 10 in\n    let base = 0 in\n    let args = 1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a + x) mod 10 in\n    let base = [] in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a + x) mod 10 in\n    let base = [] in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a + x) mod 10 in\n    let base = 0 in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a + x) mod 10 in\n    let base = 0 in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type int but an expression was expected of type\n         'a * 'b\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a + x) mod 10 in\n    let base = 0 in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"\" in\nlet base = failwith \"\" in\nlet args = failwith \"\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type string -> 'a\n       but an expression was expected of type 'b list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith in\n    let base = failwith in\n    let args = failwith in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value a\n", "Error: Unbound value x\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x + a in\n    let base = 0 in\n    let args = (a + x) mod 10 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x + a in\n    let base = 0 in\n    let args = x mod 10 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x + a in\n    let base = 0 in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type ('a * 'b) list\n       but an expression was expected of type int list\n       Type 'a * 'b is not compatible with type int \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type int list\n       Type 'a * 'b is not compatible with type int \n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x + a in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x + a in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x + a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int -> int list -> int list\n       but an expression was expected of type int -> int list -> int\n       Type int list is not compatible with type int \n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int -> int list -> int list\n       but an expression was expected of type int -> int list -> int\n       Type int list is not compatible with type int \n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int * int\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | _ -> a mod 10 | h::t -> (a + h) mod 10 in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with | _ -> [a mod 10] | h::t -> ((a + h) mod 10) :: t in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | _ -> a mod 10 | h::t -> (a + h) mod 10 in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | _ -> [a mod 10] | h::t -> [(a + h) mod 10] in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | _ -> [a mod 10]\n      | h::t -> ((a + h) mod 10) :: ((a + h) / 10) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | _ -> [a mod 10]\n      | h::t -> ((a + h) mod 10) :: ((a + h) / 10) in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | _ -> a mod 10 | h::t -> (a + h) mod 10 in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | _ -> a mod 10 | h::t -> (a + h) mod 10 in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | _ -> a mod 10 | h::t -> (a + h) mod 10 in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match x with\n| (add1, add2) -> (add1 + add2 + a)/ 10   in\nlet base = 0 in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int * 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: Unbound value t\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int -> int * int -> int list\n       but an expression was expected of type int -> int * int -> int\n       Type int list is not compatible with type int \n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int -> int * int -> int * int\n       but an expression was expected of type int -> int * int -> int\n       Type int * int is not compatible with type int \n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (add1,add2) -> (add1 + add2) + a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (add1,add2) -> (add1 + add2) + a in\n    let base = 0 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with | (add1,add2) -> (((add1 + add2) + a) mod 10) :: t in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (add1,add2) -> ((add1 + add2) + a) mod 10 in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (add1,add2) -> ((add1 + add2) + a) mod 10 in\n    let base = 0 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (add1,add2) -> ((add1 + add2) + a) mod 10 in\n    let base = 0 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (add1,add2) -> [((add1 + add2) + a) mod 10] in\n    let base = 0 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (add1,add2) -> ((add1 + add2) + a) mod 10 in\n    let base = 0 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (add1,add2) ->\n          ((((add1 + add2) + a) mod 10), (((add1 + add2) + a) / 10)) in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (add1,add2) -> ((add1 + add2) + a) / 10 in\n    let base = 0 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (add1,add2) -> ((add1 + add2) + a) / 10 in\n    let base = 0 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)  in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n", "Error: Unbound value reest\nHint: Did you mean rest?\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (add1,add2) -> ((add1 + add2) + a) / 10 in\n    let base = 0 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               ((((add1 + add2) + a) / 10), ((((add1 + add2) + a) mod 10) ::\n                 reest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               ((((add1 + add2) + carry) / 10),\n                 ((((add1 + add2) + carry) mod 10) :: reest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This pattern matches values of type unit\n       but a pattern was expected which matches values of type 'a * 'b\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               ((((add1 + add2) + carry) / 10),\n                 ((((add1 + add2) + carry) mod 10) :: rest))\n           | () -> ((carry / 10), ((carry mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nif x = (,) then a\nelse\nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type unit\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (_,_) -> carry :: rest\n           | (add1,add2) ->\n               ((((add1 + add2) + carry) / 10),\n                 ((((add1 + add2) + carry) mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if x = ()\n      then a\n      else\n        (match a with\n         | (carry,rest) ->\n             (match x with\n              | (add1,add2) ->\n                  ((((add1 + add2) + carry) / 10),\n                    ((((add1 + add2) + carry) mod 10) :: rest)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nlet carry = \nmatch a with\n| (x,y) -> x in\nmatch x with \n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound constructor Nil\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if x = (Nil, Nil)\n      then a\n      else\n        (match a with\n         | (carry,rest) ->\n             (match x with\n              | (add1,add2) ->\n                  ((((add1 + add2) + carry) / 10),\n                    ((((add1 + add2) + carry) mod 10) :: rest)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \nif List.length rest = List.length l1 || List.length rest = List.length l2 then\n(0, carry::rest)\nelse\n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               if\n                 ((List.length x) = (List.length l1)) or\n                   ((List.length x) = (List.length l2))\n               then carry :: rest\n               else\n                 ((((add1 + add2) + carry) / 10),\n                   ((((add1 + add2) + carry) mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               if\n                 ((List.length rest) = (List.length l1)) or\n                   ((List.length rest) = (List.length l2))\n               then carry :: rest\n               else\n                 ((((add1 + add2) + carry) / 10),\n                   ((((add1 + add2) + carry) mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) ->\n((add1 + add2 + carry)/ 10, \n((add1 + add2 + carry) mod 10)::rest) \nif List.length rest >= List.length l1 || \nList.length rest >= List.length l2 \nthen\n(0, ((add1 + add2 + carry)/ 10,)::rest)in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value =>\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          if\n            ((List.length rest) => (List.length l1)) ||\n              ((List.length rest) => (List.length l2))\n          then (0, (carry :: rest))\n          else\n            (match x with\n             | (add1,add2) ->\n                 ((((add1 + add2) + carry) / 10),\n                   ((((add1 + add2) + carry) mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) ->\nlet new_carry = (add1 + add2 + carry) / 10 in\nlet result = (add1 + add2 + carry) mod 10 :: rest in\nif(List.length result >= List.length l1 ||\nList.length result >= List.length l2) then\n(0, carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value rest\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet f a x = match x with | (add1,add2) -> ((add1 + add2) + a) / 10;;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet _ =\n  let bigAdd l1 l2 =\n    let add (l1,l2) =\n      let f a x =\n        match a with\n        | (carry,rest) ->\n            (match x with\n             | (add1,add2) ->\n                 ((((add1 + add2) + carry) / 10),\n                   ((((add1 + add2) + carry) mod 10) :: rest))) in\n      if\n        ((List.length rest) >= (List.length l1)) ||\n          ((List.length rest) >= (List.length l2))\n      then (0, ((((add1 + add2) + carry) / 10) :: rest)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let rec mulByDigit i l = \nlet f a x = match a with\n| (carry, rest) -> \nlet new_carry = ((i * x) + carry) / 10 in\nlet result = (((i * x) + carry) mod 10) :: rest in\nif List.length result = List.length l && new_carry = 1 then\n(0, new_carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nList.fold_left f base (List.rev l)"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: Unbound value add1\n", "Error: Unbound value l1\n"], "bad": ["\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (carry,rest) ->\n        (match x with\n         | (mul1,mul2) ->\n             let new_carry = ((mul1 * mul2) + carry) / 10 in\n             let result = (((add1 + add2) + carry) mod 10) :: rest in\n             if\n               (((List.length result) = (List.length l1)) ||\n                  ((List.length result) = (List.length l2)))\n                 && (new_carry = 1)\n             then (0, (new_carry :: result))\n             else (new_carry, result)) in\n  let base = (0, []) in List.fold_left f base (List.rev l);;\n", "\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (carry,rest) ->\n        (match x with\n         | (mul1,mul2) ->\n             let new_carry = ((mul1 * mul2) + carry) / 10 in\n             let result = (((mul1 * mul2) + carry) mod 10) :: rest in\n             if\n               (((List.length result) = (List.length l1)) ||\n                  ((List.length result) = (List.length l2)))\n                 && (new_carry = 1)\n             then (0, (new_carry :: result))\n             else (new_carry, result)) in\n  let base = (0, []) in List.fold_left f base (List.rev l);;\n"]}
{"fix": ["let rec mulByDigit i l = \nlet f a x = match a with\n| (carry, rest) -> \nlet new_carry = ((i * x) + carry) / 10 in\nlet result = (((i * x) + carry) mod 10) :: rest in\nif List.length result = List.length l && new_carry > 0 then\n(0, new_carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nlet (_, res) = List.fold_right f base (List.rev l) in res"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int * int list -> int -> int * int list\n       but an expression was expected of type int * int list -> int -> int\n       Type int * int list is not compatible with type int \n", "Error: This expression has type int list * int list\n       but an expression was expected of type int list\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list * int list\n       but an expression was expected of type int list\n", "Error: This function has type int list -> int list -> int list * int list\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This function has type int list -> int list -> int list * int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int list * int list\n       but an expression was expected of type int list\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list * int list\n       but an expression was expected of type int list\n", "Error: This expression has type int list * int list\n       but an expression was expected of type int list\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list * int list\n       but an expression was expected of type int list\n"], "bad": ["\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (carry,rest) ->\n        let new_carry = ((i * x) + carry) / 10 in\n        let result = (((i * x) + carry) mod 10) :: rest in\n        if ((List.length result) = (List.length l)) && (new_carry > 0)\n        then (0, (new_carry :: result))\n        else (new_carry, result) in\n  let base = (0, []) in let (_,res) = List.fold_right f base l in res;;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               let new_carry = ((add1 + add2) + carry) / 10 in\n               let result = (((add1 + add2) + carry) mod 10) :: rest in\n               if\n                 (((List.length result) = (List.length l1)) ||\n                    ((List.length result) = (List.length l2)))\n                   && (new_carry = 1)\n               then (0, (new_carry :: result))\n               else (new_carry, result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (carry,rest) ->\n        let new_carry = ((i * x) + carry) / 10 in\n        let result = (((i * x) + carry) mod 10) :: rest in\n        if ((List.length result) = (List.length l)) && (new_carry > 0)\n        then (0, (new_carry :: result))\n        else (new_carry, result) in\n  let base = (0, []) in\n  let (_,res) = List.fold_left f base (List.rev l) in res;;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (index,rest) ->\n        ((index + 1), (bigAdd (padZero (mulByDigit x l1) rest))) in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               let new_carry = ((add1 + add2) + carry) / 10 in\n               let result = (((add1 + add2) + carry) mod 10) :: rest in\n               if\n                 (((List.length result) = (List.length l1)) ||\n                    ((List.length result) = (List.length l2)))\n                   && (new_carry = 1)\n               then (0, (new_carry :: result))\n               else (new_carry, result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (carry,rest) ->\n        let new_carry = ((i * x) + carry) / 10 in\n        let result = (((i * x) + carry) mod 10) :: rest in\n        if ((List.length result) = (List.length l)) && (new_carry > 0)\n        then (0, (new_carry :: result))\n        else (new_carry, result) in\n  let base = (0, []) in\n  let (_,res) = List.fold_left f base (List.rev l) in res;;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (index,rest) -> ((index + 1), (bigAdd (padZero rest mulByDigit x l1))) in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               let new_carry = ((add1 + add2) + carry) / 10 in\n               let result = (((add1 + add2) + carry) mod 10) :: rest in\n               if\n                 (((List.length result) = (List.length l1)) ||\n                    ((List.length result) = (List.length l2)))\n                   && (new_carry = 1)\n               then (0, (new_carry :: result))\n               else (new_carry, result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (carry,rest) ->\n        let new_carry = ((i * x) + carry) / 10 in\n        let result = (((i * x) + carry) mod 10) :: rest in\n        if ((List.length result) = (List.length l)) && (new_carry > 0)\n        then (0, (new_carry :: result))\n        else (new_carry, result) in\n  let base = (0, []) in\n  let (_,res) = List.fold_left f base (List.rev l) in res;;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (index,rest) ->\n        ((index + 1), (bigAdd (padZero rest (mulByDigit x l1)))) in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               let new_carry = ((add1 + add2) + carry) / 10 in\n               let result = (((add1 + add2) + carry) mod 10) :: rest in\n               if\n                 (((List.length result) = (List.length l1)) ||\n                    ((List.length result) = (List.length l2)))\n                   && (new_carry = 1)\n               then (0, (new_carry :: result))\n               else (new_carry, result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (carry,rest) ->\n        let new_carry = ((i * x) + carry) / 10 in\n        let result = (((i * x) + carry) mod 10) :: rest in\n        if ((List.length result) = (List.length l)) && (new_carry > 0)\n        then (0, (new_carry :: result))\n        else (new_carry, result) in\n  let base = (0, []) in\n  let (_,res) = List.fold_left f base (List.rev l) in res;;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (index,rest) ->\n        ((index + 1), (bigAdd (padZero rest (mulByDigit x l1)))) in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": [], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int list * int list\n       but an expression was expected of type int list\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list * int list\n       but an expression was expected of type int list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               let new_carry = ((add1 + add2) + carry) / 10 in\n               let result = (((add1 + add2) + carry) mod 10) :: rest in\n               if\n                 (((List.length result) = (List.length l1)) ||\n                    ((List.length result) = (List.length l2)))\n                   && (new_carry = 1)\n               then (0, (new_carry :: result))\n               else (new_carry, result)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (carry,rest) ->\n        let new_carry = ((i * x) + carry) / 10 in\n        let result = (((i * x) + carry) mod 10) :: rest in\n        if ((List.length result) = (List.length l)) && (new_carry > 0)\n        then (0, (new_carry :: result))\n        else (new_carry, result) in\n  let base = (0, []) in\n  let (_,res) = List.fold_left f base (List.rev l) in res;;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet _ = bigAdd (padZero [] (mulByDigit 9 [9; 9; 9; 9]));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigMul", "message": ["Error: Unbound value l1\n"], "bad": ["\nlet f a x = match x with | (add1,add2) -> ((add1 + add2) + a) / 10;;\n\nlet _ =\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let rec sumList xs = \nmatch xs with\n[] -> 0\n| xs -> List.hd xs + (sumList (List.tl xs))"], "hw": "hw1", "problem": "sumList", "message": ["Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList List.tl xs);;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n < 0 then []\nelse  digitsOfInt (n/10) @ [n mod 10]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ (n mod 10);;\n"]}
{"fix": [], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: Unbound value additivePersistence\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet additivePersistence n =\n  if n > 9\n  then additivePersistence (List.fold_left (+) (digitsOfInt n))\n  else n;;\n"]}
{"fix": ["let rec additiveHelper n acc = \nif n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)\nelse acc"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value additiveHelper\n", "Error: Unbound value additiveHelper\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet additiveHelper n acc =\n  if n > 9 then additiveHelper (sumList (digitsOfInt n)) (acc + 1) else acc;;\n", "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet additiveHelper n acc =\n  if n > 9 then additiveHelper (sumList (digitsOfInt n)) (acc + 1) else acc;;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse append (digitsOfInt (n / 10)) [n mod 10]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec append first second =\n  match first with | [] -> second | h::t -> h :: (append t second);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else append ((digitsOfInt (n / 10)) [n mod 10]);;\n", "\nlet rec append first second =\n  match first with | [] -> second | h::t -> h :: (append t second);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else append ((digitsOfInt (n / 10)) [n mod 10]);;\n", "\nlet rec append first second =\n  match first with | [] -> second | h::t -> h :: (append t second);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else append ((digitsOfInt (n / 10)) [n mod 10]);;\n"]}
{"fix": ["let rec assoc (d,k,l) = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if lk = lk then lv else assoc (d,k,ls)"], "hw": "hw2", "problem": "assoc", "message": ["Error: This expression has type 'a but an expression was expected of type\n         ('a * 'b) list\n       The type variable 'a occurs inside ('a * 'b) list\n", "Error: This expression has type 'a but an expression was expected of type\n         ('a * 'b) list\n       The type variable 'a occurs inside ('a * 'b) list\n", "Error: This expression has type 'a but an expression was expected of type\n         ('a * 'b) list\n       The type variable 'a occurs inside ('a * 'b) list\n", "Error: This expression has type 'a but an expression was expected of type\n         ('a * 'b) list\n       The type variable 'a occurs inside ('a * 'b) list\n", "Error: This expression has type 'a but an expression was expected of type\n         ('a * 'b) list\n       The type variable 'a occurs inside ('a * 'b) list\n", "Error: This expression has type 'a but an expression was expected of type\n         ('a * 'b) list\n       The type variable 'a occurs inside ('a * 'b) list\n", "Error: This expression has type 'a -> 'b -> 'c\n       but an expression was expected of type\n         ('a -> 'b -> 'c) * ('d * ('a -> 'b -> 'c)) list * 'e\n"], "bad": ["\nlet rec assoc (d,k,l) =\n  match k with\n  | [] -> d\n  | (lk,lv)::ls ->\n      if k = lk then lv else assoc d k ls uncomment after implementing assoc;;\n", "\nlet rec assoc (d,k,l) =\n  match k with | [] -> d | (lk,lv)::ls -> if k = lk then lv else assoc d k ls;;\n", "\nlet rec assoc d k l =\n  match k with | [] -> d | (lk,lv)::ls -> if k = lk then lv else assoc d k ls;;\n", "\nlet rec assoc (d,k,l) =\n  match k with\n  | [] -> d\n  | (lk,lv)::ls -> if k = lk then lv else assoc (d, k, ls);;\n", "\nlet rec assoc (d,k,l) =\n  match k with\n  | [] -> d\n  | (lk,lv)::ls -> if k = lk then lv else assoc (d, k, ls);;\n", "\nlet rec assoc (d,k,l) =\n  match k with | [] -> d | (lk,lv)::ls -> if k = lk then lv else assoc d k ls;;\n", "\nlet rec assoc (d,k,l) =\n  match k with\n  | [] -> d\n  | (lk,lv)::ls -> if lk = lk then lv else assoc d k ls;;\n"]}
{"fix": ["let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)"], "hw": "hw2", "problem": "assoc", "message": ["Error: This expression has type 'a but an expression was expected of type\n         ('a * 'b) list\n       The type variable 'a occurs inside ('a * 'b) list\n"], "bad": ["\nlet rec assoc (d,k,l) =\n  match k with\n  | [] -> d\n  | (lk,lv)::ls -> if k = lk then lv else assoc (d, k, ls);;\n"]}
{"fix": ["let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)"], "hw": "hw2", "problem": "assoc", "message": ["Error: This expression has type 'a -> 'b -> 'c\n       but an expression was expected of type\n         ('a -> 'b -> 'c) * 'd * ('d * ('a -> 'b -> 'c)) list\n"], "bad": ["\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (lk,lv)::ls -> if k = lk then lv else assoc d k ls;;\n"]}
{"fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "Error: This expression has type unit but an expression was expected of type\n         'a -> 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if not c' then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (((f b) != b), b);;\n", "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if not c' then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) != b)), b);;\n", "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if not c' then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((if (f b) = b then b else f b), b);;\n", "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if not c' then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((), b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type unit but an expression was expected of type\n         'a -> 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if not c' then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((f b),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n", "Error: This expression has type 'a but an expression was expected of type\n         (('a -> 'a) * 'a) * bool\n       The type variable 'a occurs inside (('a -> 'a) * 'a) * bool\n", "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((fun (f,b)  -> if (f b) = b then b else f b), b);;\n", "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((f (f b)), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((fun f' -> if f b = b then (b,true) else (b, false)),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (((f b) = b), b);;\n", "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (((f b), ((f b) = b)), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((fun f' -> if f b = b then (b,false) else (f b, true)),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  wwhile ((fun f'  -> if (f b) = b then (b, false) else ((f b), true)), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((fun rec f'-> if f b = b then (b,false) else (f b, true)),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) * 'a\n       The type variable 'a occurs inside ('a -> 'a) * 'a\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile ((fun (f,b)  -> if (f b) = b then (b, false) else ((f b), true)), b);;\n"]}
{"fix": ["let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value wwhile2\n", "Error: Unbound value wwhile2\n", "Error: Unbound value wwhile2\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile2 (f, 2);;\n", "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile2 (f, 2);;\n", "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile2 (f, 2);;\n", "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) * 'a\n       The type variable 'a occurs inside ('a -> 'a) * 'a\n", "Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) * 'a\n       The type variable 'a occurs inside ('a -> 'a) * 'a\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile ((fun (f,b)  -> if (f b) = b then (b, false) else ((f b), true)), b);;\n", "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((fun (f,b)  -> if (f b) = b then ((f b), false) else ((f b), true)), b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) * 'a\n       The type variable 'a occurs inside ('a -> 'a) * 'a\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((fun (f,b)  -> match f b with | b -> ((f b), false) | _ -> ((f b), true)),\n      b);;\n"]}
{"fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fphelper f b = if (f b) = b then (b, false) else ((f b), true);;\n\nlet fixpoint (f,b) = wwhile (fphelper, b);;\n"]}
{"fix": ["let rec exprToString e = \nmatch e with\n| Thresh (w,x,y,z) -> \"(\" ^ exprToString(w) ^ \"<\" ^ exprToString(x) ^ \"?\" ^ exprToString(y) ^ \":\" ^ exprToString(z) ^ \")\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Average (x,y) -> \"(\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^ \")/2\"\n| Cosine x -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Sine x -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| VarX -> \"x\"\n| VarY -> \"y\"\n| _ -> \"\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: Unbound value exprToString\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n"]}
{"fix": ["let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) *. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'b\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'b\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: Unbound value eval\n", "Error: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\nError: Unbound value sampleExpr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,x,y,z) -> if (eval w) < (eval x) then eval y else eval z\n  | Times (x,y) -> (eval x) * (eval y)\n  | Average (x,y) -> ((eval x) * (eval y)) / 2\n  | Cosine x -> cos (pi * (eval x))\n  | Sine x -> sin (pi * (eval x))\n  | VarX  -> x\n  | VarY  -> y;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) -> if (eval w) < (eval t) then eval u else eval z\n  | Times (t,u) -> (eval t) * (eval u)\n  | Average (t,u) -> ((eval t) * (eval u)) / 2\n  | Cosine t -> cos (pi * (eval t))\n  | Sine t -> sin (pi * (eval t))\n  | VarX  -> x\n  | VarY  -> y;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) ->\n      if (eval (w, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (z, x, y)\n  | Times (t,u) -> (eval (t, x, y)) * (eval (u, x, y))\n  | Average (t,u) -> ((eval (t, x, y)) * (eval (u, x, y))) / 2\n  | Cosine t -> cos (pi * (eval (t, x, y)))\n  | Sine t -> sin (pi * (eval (t, x, y)))\n  | VarX  -> x\n  | VarY  -> y;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) ->\n      if (eval (w, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (z, x, y)\n  | Times (t,u) -> (eval (t, x, y)) * (eval (u, x, y))\n  | Average (t,u) -> ((eval (t, x, y)) * (eval (u, x, y))) / 2\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | VarX  -> x\n  | VarY  -> y;;\n", "\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) ->\n      if (eval (w, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (z, x, y)\n  | Times (t,u) -> (eval (t, x, y)) *. (eval (u, x, y))\n  | Average (t,u) -> ((eval (t, x, y)) *. (eval (u, x, y))) /. 2.0\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | VarX  -> x\n  | VarY  -> y;;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n"]}
{"fix": ["let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type int * int -> int\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type int * int -> int\n", "Error: This expression has type unit -> expr\n       but an expression was expected of type unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type unit -> expr\n       but an expression was expected of type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor VarX does not belong to type unit\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec buildHelper rand max_depth curr_depth =\n  if curr_depth < max_depth\n  then\n    match rand (0, 6) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (buildHelper (rand, max_depth, (curr_depth + 1)))\n    | 3 -> buildCosine (buildHelper (rand, max_depth, (curr_depth + 1)))\n    | 4 ->\n        buildAverage\n          ((buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))))\n    | 5 ->\n        buildTimes\n          ((buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))))\n    | 6 ->\n        buildThresh\n          ((buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec buildHelper rand max_depth curr_depth =\n  if curr_depth < max_depth\n  then\n    match rand (0, 6) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n    | 3 -> buildCosine (buildHelper (rand, max_depth, (curr_depth + 1)))\n    | 4 ->\n        buildAverage\n          ((buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))))\n    | 5 ->\n        buildTimes\n          ((buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))))\n    | 6 ->\n        buildThresh\n          ((buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec buildHelper rand max_depth curr_depth =\n  if curr_depth < max_depth\n  then\n    match rand (0, 6) with\n    | 0 -> buildX\n    | 1 -> buildY\n    | 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n    | 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n    | 4 ->\n        buildAverage\n          ((buildHelper rand max_depth (curr_depth + 1)),\n            (buildHelper rand max_depth (curr_depth + 1)))\n    | 5 ->\n        buildTimes (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 6 ->\n        buildThresh (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec buildHelper rand max_depth curr_depth =\n  if curr_depth < max_depth\n  then\n    match rand (0, 6) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n    | 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n    | 4 ->\n        buildAverage\n          ((buildHelper rand max_depth (curr_depth + 1)),\n            (buildHelper rand max_depth (curr_depth + 1)))\n    | 5 ->\n        buildTimes (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 6 ->\n        buildThresh (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec buildHelper rand max_depth curr_depth =\n  if curr_depth < max_depth\n  then\n    match rand (0, 6) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n    | 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n    | 4 ->\n        buildAverage (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 5 ->\n        buildTimes (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 6 ->\n        buildThresh (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec buildHelper rand max_depth curr_depth =\n  if curr_depth < max_depth\n  then\n    match rand (0, 6) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n    | 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n    | 4 ->\n        buildAverage (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 5 ->\n        buildTimes (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 6 ->\n        buildThresh (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec buildHelper rand max_depth curr_depth =\n  if curr_depth < max_depth\n  then\n    match rand (0, 6) with\n    | 0 -> buildX\n    | 1 -> buildY\n    | 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n    | 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n    | 4 ->\n        buildAverage (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 5 ->\n        buildTimes (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 6 ->\n        buildThresh (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec buildHelper rand max_depth curr_depth =\n  if curr_depth < max_depth\n  then\n    match rand (0, 6) with\n    | 0 -> VarX\n    | 1 -> VarY\n    | 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n    | 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n    | 4 ->\n        buildAverage (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 5 ->\n        buildTimes (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 6 ->\n        buildThresh (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1));;\n"]}
{"fix": ["let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"], "hw": "hw2", "problem": "build", "message": ["Error: This function has type (int * int -> int) * int -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (0, 6) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build rand (depth - 1))\n    | 3 -> buildCosine (build rand (depth - 1))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n"]}
{"fix": ["let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesMod (w,t,u) -> ((eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) (eval(u,x,y))))\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| Tan t -> tan(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type expr but an expression was expected of type\n         float\n", "Error: This function has type float -> float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type float -> float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesMod of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) ->\n      if (eval (w, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (z, x, y)\n  | TimesMod (w,t,u) ->\n      ((eval (w, x, y)) *. (eval (t, x, y))) /.\n        (mod_float ((eval (w, x, y)) *. (eval (t, x, y))) u)\n  | Times (t,u) -> (eval (t, x, y)) *. (eval (u, x, y))\n  | Average (t,u) -> ((eval (t, x, y)) +. (eval (u, x, y))) /. 2.0\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | VarX  -> x\n  | VarY  -> y;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesMod of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) ->\n      if (eval (w, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (z, x, y)\n  | TimesMod (w,t,u) ->\n      ((eval (w, x, y)) *. (eval (t, x, y))) /.\n        (mod_float ((eval (w, x, y)) *. (eval (t, x, y))) eval (u, x, y))\n  | Times (t,u) -> (eval (t, x, y)) *. (eval (u, x, y))\n  | Average (t,u) -> ((eval (t, x, y)) +. (eval (u, x, y))) /. 2.0\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | VarX  -> x\n  | VarY  -> y;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesMod of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) ->\n      if (eval (w, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (z, x, y)\n  | TimesMod (w,t,u) ->\n      ((eval (w, x, y)) *. (eval (t, x, y))) /.\n        (mod_float ((eval (w, x, y)) *. (eval (t, x, y))) eval (u, x, y))\n  | Times (t,u) -> (eval (t, x, y)) *. (eval (u, x, y))\n  | Average (t,u) -> ((eval (t, x, y)) +. (eval (u, x, y))) /. 2.0\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | VarX  -> x\n  | VarY  -> y;;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n", "Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n", "Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n", "Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list list\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: This expression has type int * ('a * 'b) list\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with | (x,y)::t -> ((x + y) / 10) :: ((x + y) mod 10) :: t in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) @ (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (x,y)::t -> ((x + y) / 10) :: ((x + y) mod 10) :: t\n      | _ -> a in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) @ (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (w,y)::t -> ((w + y) / 10) :: ((w + y) mod 10) :: t\n      | _ -> a in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) @ (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (w,y)::t -> ((w + y) / 10) :: ((w + y) mod 10) :: t\n      | _ -> a in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) @ (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (w,y)::t -> ((w + y) / 10) :: ((w + y) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) @ (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (w,y)::t -> ((w + y) / 10) :: ((w + y) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (w,y)::t -> ((w + y) / 10) :: ((w + y) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) :: (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add l1 l2 =\n    let f a x =\n      match x with\n      | (w,y)::t -> ((w + y) / 10) :: ((w + y) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) :: (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (w,y)::t -> ((w + y) / 10) :: a :: ((w + y) mod 10)\n      | _ -> a in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) :: (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (w,y)::t -> ((w + y) / 10) :: ((w + y) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) :: (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (w,y)::t -> ((w + y) / 10) :: ((w + y) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = [] in\n    let args = (0, (List.rev (List.combine l1 l2))) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = [] in\n    let args = failwith \"TBD\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = [] in\n    let args = failwith \"TBD\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  List.rev( List.combine l1 l2 ) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = [] in\n    let args = failwith \"TBD\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  List.rev((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = failwith \"TBD\" in\n    let args = List.rev ((List.combine l1 l2) @ (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = failwith \"TBD\" in\n    let args = List.rev ((List.combine l1 l2) :: (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  List.rev((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type (int * int) list\n       but an expression was expected of type 'a * 'b\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = [(0, 0)] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = failwith \"TBD\" in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n", "Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n", "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int * int\n", "Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n", "Error: This expression has type 'a list\n       but an expression was expected of type int * int\n", "Error: Unbound value c\n", "Error: This expression has type (int * int) list -> int * int -> int * int\n       but an expression was expected of type\n         (int * int) list -> int * int -> (int * int) list\n       Type int * int is not compatible with type (int * int) list \n", "Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type int list\n       but an expression was expected of type (int * int) list\n       Type int is not compatible with type int * int \n", "Error: This expression has type int list\n       but an expression was expected of type (int * int) list\n       Type int is not compatible with type int * int \n", "Error: This expression has type 'a list\n       but an expression was expected of type int * int list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,y)::t -> ((((w + z) + y) / 10), ((((w + y) + z) mod 10) :: t))\n      | [] -> [] in\n    let base = (c, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,y)::t -> (((w + z) + y) / 10) :: (((w + y) + z) mod 10) :: t\n      | [] -> [] in\n    let base = (c, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match x with\n      | (w,y)::t -> ((((w + z) + y) / 10), ((((w + y) + z) mod 10) :: t))\n      | [] -> [] in\n    let base = (c, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,y)::t -> ((((w + z) + y) / 10), ((((w + y) + z) mod 10) :: t))\n      | [] -> [] in\n    let base = (c, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,y)::t -> ((((w + z) + y) / 10), (((w + y) + z) mod 10))\n      | [] -> [] in\n    let base = (c, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,y)::t -> ((((w + z) + y) / 10), (((w + y) + z) mod 10))\n      | [] -> (0, 0) in\n    let base = (c, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,y)::t -> ((((w + z) + y) / 10), (((w + y) + z) mod 10))\n      | [] -> (0, 0) in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,y)::t -> ((((w + z) + y) / 10), ((((w + y) + z) mod 10) :: t))\n      | [] -> (0, 0) in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + z) / 10) :: ((h + z) mod 10) :: t\n      | _ -> (z / 10) :: (z mod 10) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + z) / 10) :: ((h + z) mod 10) :: t\n      | _ -> ((z / 10), [z mod 10]) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + z) / 10) :: ((h + z) mod 10) :: t\n      | _ -> [z / 10; z mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | h::t -> (((h + z) / 10), ((h + z) mod 10)) :: t\n      | _ -> ((z / 10), (z mod 10)) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | h::t -> (((h + z) / 10), ((h + z) mod 10)) :: t\n      | _ -> ((z / 10), (z mod 10)) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int * int\n       but an expression was expected of type int * int list\n       Type int is not compatible with type int list \n", "Error: Unbound value l\n", "Error: This expression has type 'a list\n       but an expression was expected of type int * int list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, l) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\n| _ -> ( ((z)/10), [z mod 10])\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value w\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y))\n      | _ -> (((w + z) / 10), ((w + z) mod 10)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y))\n      | _ -> ((z / 10), (z mod 10)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value l2aa\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2aa in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) )in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev ((List.combine l1 l2) @ (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev ((List.combine l1 l2) :: (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev ((List.combine l1 l2) :: ([0], [0])) in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w, [])   -> (w, (z/10)::[z mod 10])\n| (w, h::t) -> ( ((w+z)/10), ((w+z) mod 10)::t )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) )in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int * int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: Unbound value y\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,[]) -> (w, ((z / 10) :: (z mod 10)))\n      | (w,h::t) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,[]) -> (w, [z / 10; z mod 10])\n      | (w,h::t) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,[]) -> ( ((w+z)/10), 0::((w+z)mod 10)::[])\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) )in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value y\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,[]) -> (((w + z) / 10), (0 :: ((w + z) mod 10) :: y))\n      | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) ) @ [(0,0)]in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero(add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value removeZer\nHint: Did you mean removeZero?\nError: Unbound value removeZer\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value removeZer\nHint: Did you mean removeZero?\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZer (add (padZero l1 l2));;\n"]}
{"fix": ["let rec mulByDigit i l = \nlet l1 = List.rev l in\nlet l2 = [i] in\nlet mul (l1, l2) = \nlet f a x = let z = fst x * snd x in \nmatch a with\n| (w,y) -> (((w+z)/10), ((w+z) mod 10)::y)\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero(mul (padZero l1 l2))"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: Unbound value List.reverse\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet rec mulByDigit i l =\n  let l1 = List.reverse l in\n  let l2 = [i] in\n  let mul (l1,l2) =\n    let f a x =\n      let z = (fst x) * (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (mul (padZero l1 l2));;\n"]}
{"fix": ["let rec mulByDigit i l = \nlet rec helper i l acc = match i with\n| 0 -> [0]\n| 1 -> l\n| _ -> helper (i-1) l (bigAdd acc l)\nin \nhelper i l [0]"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc n lis =\n    match n with | 1 -> lis + acc | _ -> helper (n - 1) (bigAdd l lis) in\n  helper [] i l;;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc n lis =\n    match n with | 1 -> lis + acc | _ -> helper (n - 1) (bigAdd l lis) in\n  helper [0] i l;;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc n lis =\n    match n with | 1 -> bigAdd lis acc | _ -> helper (n - 1) (bigAdd l lis) in\n  helper [0] i l;;\n"]}
{"fix": [], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: Unbound value mulByDigit\n", "Error: Unbound value mulByDigit\n"], "bad": ["\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigMul", "message": ["Error: Unbound value mulByDigit\n"], "bad": ["\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n"]}
{"fix": ["let rec mulByDigit i l = \nlet rec adder n l' a = match n with\n| 0 -> [0]\n| 1 -> bigAdd l' a\n| _ -> adder (n-1) l' (bigAdd a l') \nin \nadder i l [0]"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: Unbound value mulByDigit\n", "Error: Unbound value bigAdd\n"], "bad": ["\nlet _ = mulByDigit 9999999 [9; 9; 9; 9];;\n", "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n"]}
{"fix": [], "hw": "hw3", "problem": "sqsum", "message": ["Error: Unbound value mulByDigit\n"], "bad": ["\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let rec adder n l' a =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd l' a\n    | _ -> adder (n - 1) l' (bigAdd a l') in\n  adder i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (w,y) -> (w, (bigAdd a (mulByDigit (clone x (List.length y)) l1))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let rec adder n l' a =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd l' a\n    | _ -> adder (n - 1) l' (bigAdd a l') in\n  adder i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (w,y) -> (w, (bigAdd y (mulByDigit (clone x (List.length y)) l1))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = failwith \"TBD\" in \nlet base = (0, []) in\nlet args = failwith \"tbd\" in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: Unbound value mulByDigit\n"], "bad": ["\nlet rec tensMul n =\n  match n with | 0 -> 0 | 1 -> 10 | _ -> 10 * (tensMul (n - 1));;\n\nlet rec bigCombiner l1 l2 acc n =\n  match l1 with\n  | [] -> acc\n  | h::t -> bigCombiner t l2 (acc @ (mulByDigit (h * (tensMul n)))) (n + 1);;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigMul", "message": ["Error: Unbound value mulByDigit\n"], "bad": ["\nlet rec mulByTen n =\n  match n with | 0 -> 0 | 1 -> 10 | _ -> 10 * (mulByTen (n - 1));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (la,lb) = x in\n    let (i,acc) = a in\n    match l1 with\n    | [] -> (i, acc)\n    | h::t ->\n        let temp = mulByDigit h lb in\n        ((i + 1), (bigAdd acc (temp * (mulByTen i)))) in\n  let base = (0, []) in\n  let args = ((List.rev l1), (List.rev l2)) in\n  let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value digitsOfInt\n"], "bad": ["\nlet digits n = digitsOfInt (abs n);;\n"]}
{"fix": [], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: Unbound value sumList\n", "Error: Unbound value sumList\n", "Error: Unbound value sumList\n"], "bad": ["\nlet rec additivePersistence (a,n) =\n  if n < 10\n  then (n, 0)\n  else additivePersistence ((a + 1), (sumList (digits n)));;\n", "\nlet rec additivePersistence (a,n) =\n  if n < 10\n  then (n, 0)\n  else additivePersistence ((a + 1), (sumList (digits n)));;\n", "\nlet rec additivePersistence (a,n) =\n  if n < 10\n  then (0, n)\n  else additivePersistence ((a + 1), (sumList (digits n)));;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: Unbound value sumList\n"], "bad": ["\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digits n));;\n"]}
{"fix": [], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: Unbound value sumList\n"], "bad": ["\nlet rec additivePersistence (a,n) =\n  if n < 10\n  then (a, n)\n  else additivePersistence ((a + 1), (sumList (digits n)));;\n"]}
{"fix": ["let rec additivePersistence (a, n) = \nlet intFun (a, n) = \nif n < 10\nthen (a, n)\nelse additivePersistence (a+1, sumList(digits n))\nin (4,5)"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type int but an expression was expected of type\n         int * int\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet rec additivePersistence (a,n) =\n  let intFun (a,n) =\n    if n < 10\n    then (a, n)\n    else additivePersistence ((a + 1), (sumList (digits n))) in\n  4;;\n"]}
{"fix": ["let rec additivePersistenceDigitalRoot (a, n) = \nif n < 10\nthen (a, n)\nelse additivePersistenceDigitalRoot (a+1, sumList(digits n))"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: Unbound value intFun\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs -> x + (sumList xs);;\n\nlet rec additivePersistence (a,n) =\n  let intFun (a,n) =\n    if n < 10 then (a, n) else intFun ((a + 1), (sumList (digits n))) in\n  (4, 5);;\n"]}
{"fix": ["let rec digitalRoot n = \nlet (a, b) = additivePersistenceDigitalRoot (0, n)\nin a"], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: Unbound value additivePersistenceDigital\n"], "bad": ["\nlet rec digitalRoot n = let (a,b) = additivePersistenceDigital (0, n) in a;;\n"]}
{"fix": ["let rec palindromeA (w, p) = \nif (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindromeA (w, p + 1)"], "hw": "hw1", "problem": "palindrome", "message": ["Error: Unbound value palindromeA\nHint: Did you mean palindrome?\nError: Unbound value palindromeA\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value palindromeA\nHint: Did you mean palindrome?\n", "Error: Unbound value palindromeA\nHint: Did you mean palindrome?\nError: Unbound value palindromeA\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value palindromeA\nHint: Did you mean palindrome?\n"], "bad": ["\nlet palindromeA (w,p) =\n  if\n    ((List.length w) > (2 * p)) &&\n      ((List.nth w p) = (List.nth w (((List.length w) - 1) - p)))\n  then true\n  else palindromeA (w, (p + 1));;\n", "\nlet palindromeA (w,p) =\n  if\n    ((List.length w) > (2 * p)) &&\n      ((List.nth w p) = (List.nth w (((List.length w) - 1) - p)))\n  then true\n  else palindromeA (w, (p + 1));;\n"]}
{"fix": ["let rec palindromeA (w, p) = \nif ((List.length w) < (2 * p)) && (((List.nth w p) = (List.nth w (List.length w - 1 - p))))\nthen true\nelse palindromeA (w, p + 1)"], "hw": "hw1", "problem": "palindrome", "message": ["Error: Unbound value palindromeA\n"], "bad": ["\nlet _ = palindromeA ([('a', 'b', 'c')], 0);;\n"]}
{"fix": [], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: Unbound value additivePersistence\n"], "bad": ["\nlet _ = additivePersistence 9876;;\n"]}
{"fix": ["let fixpoint (f,b) =\nwwhile (if f b = b then (f b, false) else (f b, true),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"], "bad": ["\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) != b)), b);;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) != b)), b);;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) = b)), b);;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f, true), b);;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((failwith \"asd\"), true), b);;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((failwith \"asd\"), (failwith \"asd\")), b);;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((failwith \"asd\"), undefined), b);;\n"]}
{"fix": ["let fixpoint (f,b) =\nwwhile ((if f b = b then (failwith \"asd\") else failwith \"asd\") ,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type bool -> bool * bool\n", "Error: This expression has type bool -> bool * bool\n       but an expression was expected of type bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"], "bad": ["\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (if (f b) = b then ((f b), false) else (((f b), true), b));;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (if (f b) = b then ((f b), false) else ((failwith \"asd\"), b));;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((if (f b) = b then ((f b), false) else failwith \"asd\"), b);;\n"]}
{"fix": ["let fixpoint (f,b) =\nwwhile ((if f b = b then (fun b''\n-> (f b, false)) else failwith \"asd\") ,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"], "bad": ["\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((if (f b) = b then ((failwith \"asd\"), true) else failwith \"asd\"), b);;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((if (f b) = b then (true, (failwith \"asd\")) else failwith \"asd\"), b);;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((if (f b) = b then (b, (failwith \"asd\")) else failwith \"asd\"), b);;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((if (f b) = b\n      then ((failwith \"Asd\"), (failwith \"asd\"))\n      else failwith \"asd\"), b);;\n"]}
{"fix": ["let fixpoint (f,b) =\nwwhile ((fun b' -> if f b' = b' \nthen (f b', false)\nelse (f b', true)), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  wwhile\n    ((fun b'  -> if (f b') = b' then ((f b), false) else ((f b), true)), b);;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) <. (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi * (eval (i, x, y)))\n  | Cosine i -> cos (pi * (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) + (eval (i2, x, y))) / 2.0;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi * (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) + (eval (i2, x, y))) / 2.0;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) + (eval (i2, x, y))) / 2.0;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) / 2.0;;\n"]}
{"fix": ["let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"], "hw": "hw2", "problem": "eval", "message": ["Error: Unbound value <.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) <. (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y);;\n"]}
{"fix": ["let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"], "hw": "hw2", "problem": "build", "message": ["Error: This function has type expr * expr -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type expr * expr -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  let r = rand (if depth = 0 then (6, 7) else (1, 5)) in\n  match r with\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | 2 -> buildCosine (build (rand, (depth - 1)))\n  | 3 -> buildAverage (build (rand, (depth - 1))) (build (rand, (depth - 1)))\n  | 4 -> buildTimes (build (rand, (depth - 1))) (build (rand, (depth - 1)))\n  | 5 ->\n      buildThresh (build (rand, (depth - 1))) (build (rand, (depth - 1)))\n        (build (rand, (depth - 1))) (build (rand, (depth - 1)))\n  | 6 -> VarX\n  | 7 -> VarY;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  let r = rand (if depth = 0 then (6, 7) else (1, 5)) in\n  match r with\n  | 1 -> buildSine (build (rand, (depth - 1)))\n  | 2 -> buildCosine (build (rand, (depth - 1)))\n  | 3 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 -> buildTimes (build (rand, (depth - 1))) (build (rand, (depth - 1)))\n  | 5 ->\n      buildThresh (build (rand, (depth - 1))) (build (rand, (depth - 1)))\n        (build (rand, (depth - 1))) (build (rand, (depth - 1)))\n  | 6 -> VarX\n  | 7 -> VarY;;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        - 1.0;;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type int but an expression was expected of type\n         expr\n", "Error: This expression has type float but an expression was expected of type\n         expr\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a,b,c) ->\n      if c < 0\n      then ((log (x *. 100)) ** (sin (x *. 100))) -. 1.0\n      else (-1.0) *. (((log (x *. 100)) ** (sin (x *. 100))) -. 1.0);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a,b,c) ->\n      if c < 0.0\n      then ((log (x *. 100)) ** (sin (x *. 100))) -. 1.0\n      else (-1.0) *. (((log (x *. 100)) ** (sin (x *. 100))) -. 1.0);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a,b,c) ->\n      if (eval (c, x, y)) < 0.0\n      then\n        ((log ((eval (a, x, y)) *. 100)) ** (sin ((eval (b, x, y)) *. 100)))\n          -. 1.0\n      else\n        (-1.0) *.\n          (((log ((eval (b, x, y)) *. 100)) **\n              (sin ((eval (a, x, y)) *. 100)))\n             -. 1.0);;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin\nif eval (c, x, y) < 0.0\nthen (log (a *. 100.0)) ** (sin (b *. 100.0)) -. 1.0\nelse -1.0 *. ((log (b *. 100.0)) ** (sin (a *. 100.0)) -. 1.0)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: Unbound value fabs\nHint: Did you mean abs?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a',b',c) ->\n      let a = abs (eval (a', x, y)) in\n      let b = abs (eval (b', x, y)) in\n      if (eval (c, x, y)) < 0.0\n      then ((log (a *. 100.0)) ** (sin (b *. 100.0))) -. 1.0\n      else (-1.0) *. (((log (b *. 100.0)) ** (sin (a *. 100.0))) -. 1.0);;\n", "\nlet _ = fabs;;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin let my_log = fun l' -> let l = (max 0.1 l') in (log l) /. (log 10.0)\nin\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type int ref\n       This is not a function; it cannot be applied.\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet max = ref 0;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let b = abs_float (eval (b', x, y)) in\n      let my_log l' = let l = max 0.1 l' in (log l) / (log 10.0) in\n      if (eval (c, x, y)) < 0.0\n      then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n      else\n        (-1.0) *.\n          (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let b = abs_float (eval (b', x, y)) in\n      let my_log l' = let l = min 0.1 l' in (log l) / (log 10.0) in\n      if (eval (c, x, y)) < 0.0\n      then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n      else\n        (-1.0) *.\n          (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0);;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin let max' = fun a b -> if a > b then a else b\nin let my_log = fun l' -> let l = (max' 0.1 l') in (log l) /. (log 10.0)\nin\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type int ref\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int ref\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet max = ref 0;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let b = abs_float (eval (b', x, y)) in\n      let my_log l' = let l = max 0.1 l' in (log l) /. (log 10.0) in\n      if (eval (c, x, y)) < 0.0\n      then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n      else\n        (-1.0) *.\n          (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet max = ref 0;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      (2.71 **\n         (((sin (pi *. (eval (a, x, y)))) +. (cos (pi *. (eval (b, x, y)))))\n            -. 1.0))\n        -. 1.0\n  | SinLog (a',b',c) ->\n      let a = abs_float (eval (a', x, y)) in\n      let b = abs_float (eval (b', x, y)) in\n      let max' a b = if a > b then a else b in\n      let my_log l' = let l = max 0.1 l' in (log l) /. (log 10.0) in\n      if (eval (c, x, y)) < 0.0\n      then ((my_log (a *. 100.0)) ** (sin ((pi *. b) *. 100.0))) -. 1.0\n      else\n        (-1.0) *.\n          (((my_log (b *. 100.0)) ** (pi *. (sin (a *. 100.0)))) -. 1.0);;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a\nin max' -1.0 (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> 1.0"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type int ref\n       but an expression was expected of type int\n", "Error: This expression has type int ref\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet max = ref 0;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      max -\n        (1.0\n           (min 1.0\n              ((2.71 **\n                  (((sin (pi *. (eval (a, x, y)))) +.\n                      (cos (pi *. (eval (b, x, y)))))\n                     -. 1.0))\n                 -. 1.0)))\n  | SinLog (a',b',c) -> 1.0;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet max = ref 0;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      max 1.0\n        (min 1.0\n           ((2.71 **\n               (((sin (pi *. (eval (a, x, y)))) +.\n                   (cos (pi *. (eval (b, x, y)))))\n                  -. 1.0))\n              -. 1.0))\n  | SinLog (a',b',c) -> 1.0;;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a\nin max' (0.0 -. 1.0) (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> 1.0"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type 'a -> 'a -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      let max' a b = if a < b then b else a in\n      max' -\n        (1.0\n           (min 1.0\n              ((2.71 **\n                  (((sin (pi *. (eval (a, x, y)))) +.\n                      (cos (pi *. (eval (b, x, y)))))\n                     -. 1.0))\n                 -. 1.0)))\n  | SinLog (a',b',c) -> 1.0;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | ECosSin of expr* expr\n  | SinLog of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine i -> sin (pi *. (eval (i, x, y)))\n  | Cosine i -> cos (pi *. (eval (i, x, y)))\n  | Average (i1,i2) -> ((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0\n  | Times (i1,i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n  | Thresh (i1,i2,i3,i4) ->\n      if (eval (i1, x, y)) < (eval (i2, x, y))\n      then eval (i3, x, y)\n      else eval (i4, x, y)\n  | ECosSin (a,b) ->\n      let max' a b = if a < b then b else a in\n      max' (0.0 - 1.0)\n        (min 1.0\n           ((2.71 **\n               (((sin (pi *. (eval (a, x, y)))) +.\n                   (cos (pi *. (eval (b, x, y)))))\n                  -. 1.0))\n              -. 1.0))\n  | SinLog (a',b',c) -> 1.0;;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value exprToString\n"], "bad": ["\nlet _ = exprToString sampleExpr1;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value f\n"], "bad": ["\nlet pipe fs =\n  let f a x y = f (x a) in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun y -> y in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base y = y in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = a in\nlet base = fun y -> y in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "bad": ["\nlet pipe fs = let f a x = 3 + a in let base y = y in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = 3 + a in let base y = y in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun g -> (x a) g in\nlet base = fun g -> g in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs =\n  let f a x g = g (x a) in let base g = g in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun g -> (x a) g in\nlet base = fun g -> g in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'a -> 'b) -> 'a -> 'a -> 'b\n       but an expression was expected of type\n         ('a -> 'a -> 'b) -> 'a -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'a) -> 'a -> 'a\n       but an expression was expected of type ('a -> 'a) -> 'a\n       The type variable 'a occurs inside 'a -> 'a\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type 'a -> 'b -> ('b -> 'a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('b -> 'a -> 'c) -> 'c\n", "Error: This expression has type 'a -> 'b -> ('a -> 'b -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'b -> 'c) -> 'c\n", "Error: This expression has type ('a -> 'a -> 'b) -> 'a -> 'a -> 'b\n       but an expression was expected of type\n         ('a -> 'a -> 'b) -> 'a -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs =\n  let f a x g = (a x) g in let base g = g in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x g = g (a x) in let base g = g in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x g = g (x a) in let base g = g in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x g = (g x) a in let base g = g in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x g = (g a) x in let base g = g in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x g = (a x) g in let base g = g in List.fold_left f base fs;;\n"]}
{"fix": ["let stringOfList f l = sepConcat \"; \" (List.map f l)"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: Unbound value map\nHint: Did you mean max?\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (map f l);;\n"]}
{"fix": ["let padZero l1 l2 = \nlet ll1 = List.length l1\nin let ll2 = List.length l2\nin ((clone 0 (ll2 - ll1)) @ l1, (clone 0 (ll1 - ll2)) @ l2)"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec clone x n =\n  match n with | 0 -> [] | _ -> if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let l1 = List.length l1 in\n  let l2 = List.length l2 in\n  (((clone 0 (l2 - l1)) @ l1), ((clone 0 (l1 - l2)) @ l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec clone x n =\n  match n with | 0 -> [] | _ -> if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let ll1 = List.length l1 in\n  let ll2 = List.length l2 in\n  (((clone 0 (ll2 - ll1)) @ l1), ((clone 0 (ll1 - ll2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | h::t -> if h == 0 then removeZero t else h :: t | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (c,ds) (x1,x2) = ((((c + x1) + x2) / 10), (((c + x1) + x2) mod 10)) in\n    let base = (0, 1) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) mod 10 :: ds) in\nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int * int\n       but an expression was expected of type int * int list\n       Type int is not compatible with type int list \n"], "bad": ["\nlet rec clone x n =\n  match n with | 0 -> [] | _ -> if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let ll1 = List.length l1 in\n  let ll2 = List.length l2 in\n  (((clone 0 (ll2 - ll1)) @ l1), ((clone 0 (ll1 - ll2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | h::t -> if h == 0 then removeZero t else h :: t | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (c,ds) (x1,x2) = ((((c + x1) + x2) / 10), (((c + x1) + x2) mod 10)) in\n    let base = (0, 1) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | _ -> if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let ll1 = List.length l1 in\n  let ll2 = List.length l2 in\n  (((clone 0 (ll2 - ll1)) @ l1), ((clone 0 (ll1 - ll2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | h::t -> if h == 0 then removeZero t else h :: t | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (c,ds) (x1,x2) =\n      ((((c + x1) + x2) / 10), ((((c + x1) + x2) mod 10) :: ds)) in\n    let base = (0, 1) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) :: ds) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value List.reverse\n"], "bad": ["\nlet rec clone x n =\n  match n with | 0 -> [] | _ -> if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let ll1 = List.length l1 in\n  let ll2 = List.length l2 in\n  (((clone 0 (ll2 - ll1)) @ l1), ((clone 0 (ll1 - ll2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | h::t -> if h == 0 then removeZero t else h :: t | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (c,ds) (x1,x2) = ((((c + x1) + x2) / 10), (((c + x1) + x2) :: ds)) in\n    let base = (0, []) in\n    let args = List.reverse (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = if List.length ds = List.length l1 \nthen (0, (c + x1 + x2) / 10 :: (c + x1 + x2) mod 10 :: ds)\nelse ((c + x1 + x2) / 10, (c + x1 + x2) mod 10 :: ds) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n =\n  match n with | 0 -> [] | _ -> if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let ll1 = List.length l1 in\n  let ll2 = List.length l2 in\n  (((clone 0 (ll2 - ll1)) @ l1), ((clone 0 (ll1 - ll2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | h::t -> if h == 0 then removeZero t else h :: t | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (c,ds) (x1,x2) =\n      if (List.length ds) = (List.length x1)\n      then (0, ((((c + x1) + x2) / 10) :: (((c + x1) + x2) mod 10) :: ds))\n      else ((((c + x1) + x2) / 10), ((((c + x1) + x2) mod 10) :: ds)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f (indent, acc) x = (0 :: indent, (List.fold_left bigAdd [] (clone l2 x)) @ indent) in\nlet base = ([], []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet padZero l1 l2 =\n  let ll1 = List.length l1 in\n  let ll2 = List.length l2 in\n  (((clone 0 (ll2 - ll1)) @ l1), ((clone 0 (ll1 - ll2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | h::t -> if h == 0 then removeZero t else h :: t | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (c,ds) (x1,x2) =\n      if (List.length ds) = ((List.length l1) - 1)\n      then (0, ((((c + x1) + x2) / 10) :: (((c + x1) + x2) mod 10) :: ds))\n      else ((((c + x1) + x2) / 10), ((((c + x1) + x2) mod 10) :: ds)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n =\n  match n with | 0 -> [] | _ -> if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet bigMul l1 l2 =\n  let f (indent,acc) x =\n    ((0 :: indent), ((List.fold_left bigAdd 0 (clone l2 x)) @ indent)) in\n  let base = ([], []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["failwith \"TBD:sumList\""], "hw": "hw1", "problem": "sumList", "message": ["Error: Unbound value sum\n"], "bad": ["\nlet rec sumList xs =\n  match xs with | [] -> [] | hd::tl -> sum = ((sum + hd) :: (sumLists tl));;\n"]}
{"fix": ["let rec sumList (l : int list): int =\nmatch l with\n[] -> 0\n| hd::tl -> hd + (sumList tl)"], "hw": "hw1", "problem": "sumList", "message": ["Error: Unbound value sum\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: Unbound type constructor xs\n", "Error: Unbound type constructor xs\n", "Error: This pattern matches values of type int\n       but a pattern was expected which matches values of type int list\n"], "bad": ["\nlet rec sumList xs =\n  match xs with | [] -> [] | hd::tl -> sum = ((sum + hd) :: (sumLists tl));;\n", "\nlet rec sumList xs = match xs with | [] -> [] | hd::tl -> hd + (sumList tl);;\n", "\nlet rec sumList (1 : xs) =\n  (match xs with | [] -> 0 | hd::tl -> hd + (sumList tl) : int);;\n", "\nlet rec sumList (1 : int xs) =\n  (match xs with | [] -> 0 | hd::tl -> hd + (sumList tl) : int);;\n", "\nlet rec sumList (1 : int list) =\n  (match 1 with | [] -> 0 | hd::tl -> hd + (sumList tl) : int);;\n"]}
{"fix": ["let rec sumList (l : int list): int =\nmatch l with\n[] -> 0\n| hd::tl -> hd + (sumList tl)"], "hw": "hw1", "problem": "sumList", "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec sumList (l : int list) =\n  (match l with\n   | [] -> 0\n   | hd::tl -> hd + ((sumList tl) failwith \"TBD:sumList\") : int);;\n"]}
{"fix": ["let rec sumList xs =\nmatch xs with\n| [] -> 0\n| hd::tl -> hd + (sumList tl)"], "hw": "hw1", "problem": "sumList", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec sumList (hd::tl) = match hd with | [] -> 0 | hd -> hd + (sumList tl);;\n"]}
{"fix": ["let digitsOfInt n = \nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n acc"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value sumList\n"], "bad": ["\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n"]}
{"fix": ["let digitsOfInt n = \nlet rec loop n tlist =\nif n = 0 then tlist\nelse loop (n/10) (n mod 10::tlist) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n [7]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value acc\n"], "bad": ["\nlet digitsOfInt n =\n  let rec loop n acc =\n    if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n  match n with | 0 -> [0] | _ -> loop n acc;;\n"]}
{"fix": [], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: Unbound value additivePersistence\n", "Error: Unbound value additivePersistence\n", "Error: Unbound value additivePersistence\n", "Error: Unbound value additivePersistence\n", "Error: Unbound value additivePersistence\n", "Error: Unbound value additivePersistence\n", "Error: Unbound value additivePersistence\n", "Error: Unbound value additivePersistence\n"], "bad": ["\nlet _ = additivePersistence 9876;;\n", "\nlet _ = additivePersistence 9876;;\n", "\nlet _ = additivePersistence 9876;;\n", "\nlet _ = additivePersistence 9876;;\n", "\nlet _ = additivePersistence 9876;;\n", "\nlet _ = additivePersistence 9876;;\n", "\nlet _ = additivePersistence 9876;;\n", "\nlet _ = additivePersistence 9876;;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: Unbound value additivePersistence\n", "Error: Unbound value digitalRoot\n"], "bad": ["\nlet _ = additivePersistence 9876;;\n", "\nlet _ = digitalRoot 9876;;\n"]}
{"fix": [], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: Unbound value digitalRoot\n", "Error: Unbound value additivePersistence\n", "Error: Unbound value additivePersistence\n", "Error: Unbound value additivePersistence\n", "Error: Unbound value additivePersistence\n", "Error: Unbound value additivePersistence\n", "Error: Unbound value additivePersistence\n", "Error: Unbound value additivePersistence\n", "Error: Unbound value additivePersistence\n", "Error: Unbound value additivePersistence\n", "Error: Unbound value additivePersistence\n", "Error: Unbound value additivePersistence\n", "Error: Unbound value additivePersistence\n"], "bad": ["\nlet _ = digitalRoot 789;;\n", "\nlet _ = additivePersistence 9876;;\n", "\nlet _ = additivePersistence 9876;;\n", "\nlet _ = additivePersistence 9876;;\n", "\nlet _ = additivePersistence 9876;;\n", "\nlet _ = additivePersistence 9876;;\n", "\nlet _ = additivePersistence 9876;;\n", "\nlet _ = additivePersistence 9876;;\n", "\nlet _ = additivePersistence 9876;;\n", "\nlet _ = additivePersistence 9876;;\n", "\nlet _ = additivePersistence 9876;;\n", "\nlet _ = additivePersistence 9876;;\n", "\nlet _ = additivePersistence 9876;;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: Unbound value additivePersistence\n"], "bad": ["\nlet _ = additivePersistence 9876;;\n"]}
{"fix": [], "hw": "hw1", "problem": "sumList", "message": ["Error: Unbound value digitalRoot\n"], "bad": ["\nlet _ = digitalRoot 9876;;\n"]}
{"fix": ["let rec listReverse n =\nmatch n with\n| [] -> []\n| hd::tl ->\n(listReverse tl) @ (hd)"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec listReverse n =\n  match n with\n  | [] -> []\n  | hd::tl -> if tl = [] then n else (listReverse tl) :: hd;;\n"]}
{"fix": ["let rec listReverse n =\nmatch n with\n| [] -> []\n| hd::tl -> (listReverse tl) :: [hd]"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec listReverse n =\n  match n with | [] -> [] | hd::tl -> (listReverse tl) @ hd;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = seen :: h in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = seen :: h in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem hd seen = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a list list\n       The type variable 'a occurs inside 'a list list\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list list\n       The type variable 'a occurs inside 'a list list\n", "Error: This expression has type int but an expression was expected of type\n         'a list list\n", "Error: This expression has type int but an expression was expected of type\n         'a list list\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list list\n       The type variable 'a occurs inside 'a list list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list list\n       The type variable 'a occurs inside 'a list list\n", "Error: Unbound value h\n", "Error: Unbound value h\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem tl hd) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem tl [hd]) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem tl hd) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem tl 2) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem tl 2) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem tl hd) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem tl [2]) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem tl hd) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem h tl) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem h seen) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"]}
{"fix": ["let rec wwhile (f,b) =\nlet rec wwhelper f b =\nlet (b', c') = f b in\nif (c' = false) then b'\nelse wwhelper f b'\nin wwhelper f b"], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr -> expr\n       but an expression was expected of type expr\n", "Error: This expression has type expr -> expr\n       but an expression was expected of type expr\n", "Error: This expression has type expr -> expr\n       but an expression was expected of type expr\n", "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> evalhelper buildSine p1 x y\n    | Cosine p1 -> evalhelper buildCosine p1 x y in\n  evalhelper e x y;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> evalhelper buildSine p1 x y\n    | Cosine p1 -> evalhelper buildCosine p1 x y in\n  evalhelper e x y;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> evalhelper (buildSine p1) x y\n    | Cosine p1 -> evalhelper buildCosine p1 x y in\n  evalhelper e x y;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> evalhelper Sine p1 x y\n    | Cosine p1 -> evalhelper buildCosine p1 x y in\n  evalhelper e x y;;\n"]}
{"fix": ["let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> float x\n| VarY -> float y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\nin\nevalhelper e x y"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type 'a -> 'a -> 'a\n       but an expression was expected of type float\n", "Error: This function has type int -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a -> 'a -> 'a\n       but an expression was expected of type float\n", "Error: This expression has type int -> int -> float\n       but an expression was expected of type float\n", "Error: This expression has type int -> int -> float\n       but an expression was expected of type float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi * (evalhelper p1))\n    | Cosine p1 -> evalhelper p1 in\n  evalhelper e x y;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1))\n    | Cosine p1 -> evalhelper p1 in\n  evalhelper e x y;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (float evalhelper p1))\n    | Cosine p1 -> evalhelper p1 in\n  evalhelper e x y;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1))\n    | Cosine p1 -> cos (pi *. (evalhelper p1)) in\n  evalhelper e x y;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> float x\n    | VarY  -> float y\n    | Sine p1 -> sin (pi *. (evalhelper p1))\n    | Cosine p1 -> cos (pi *. (evalhelper p1)) in\n  evalhelper e x y;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> float x\n    | VarY  -> float y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1)) in\n  evalhelper e x y;;\n"]}
{"fix": ["let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\n| Average(p1, p2) -> (evalhelper p1 x y *. evalhelper p2 x y) /. 2.0\nin\nevalhelper e x y"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) * (evalhelper p2 x y)) / 2 in\n  evalhelper e x y;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) * (evalhelper p2 x y)) /. 2.0 in\n  evalhelper e x y;;\n"]}
{"fix": ["let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\n| Average(p1, p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n| Times(p1, p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n| Thresh(p1, p2, p3, p4) ->\nif ((evalhelper p1 x y) < (evalhelper p2 x y))\nthen (evalhelper p3 x y)\nelse (evalhelper p4 x y)\nin\nevalhelper e x y"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type expr but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> p1 *. p2\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n"]}
{"fix": ["let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"Var\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ (buildhelper 0 (depth-1) expr) ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\""], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type string -> string\n       but an expression was expected of type int\n", "Error: This expression has type string -> string\n       but an expression was expected of type int\n"], "bad": ["\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"Var\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ (((buildhelper 0 depth) - (1 expr)) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ (((buildhelper 0 depth) - (1 expr)) ^ \")\")) in\n  buildhelper (rand 0 4) depth \"\";;\n", "\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"Var\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ (((buildhelper 0 depth) - (1 expr)) ^ \")\")) in\n  buildhelper (rand 0 4) depth \"\";;\n"]}
{"fix": ["let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand 0 1 = 0) then \nexpr ^ \"((\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"+\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"*\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr)\n| 4 -> \nexpr ^ \"(\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"<\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"?\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \":\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\""], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value eTShelper\n"], "bad": ["\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                  (\"+\" ^\n                     ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                        \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n               (\"*\" ^ (eTShelper p2 expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr)\n                            ^\n                            (\":\" ^\n                               ((buildhelper (rand 0 (depth - 1)) (depth - 1)\n                                   expr)\n                                  ^ \")\")))))))) in\n  buildhelper (rand 0 4) depth \"\";;\n"]}
{"fix": ["let rec build (rand, depth) = \nlet num =  rand(1,4) in \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\nin\nbuildhelper num depth \"\""], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n", "Error: This expression has type int but an expression was expected of type\n         int * int\n", "Error: This expression has type int but an expression was expected of type\n         int * int -> int\n", "Error: This expression has type int but an expression was expected of type\n         int * int -> int\n", "Error: This expression has type int but an expression was expected of type\n         int * int -> int\n", "Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n", "Error: This expression has type int but an expression was expected of type\n         int * int -> int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                  (\"+\" ^\n                     ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                        \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand 0 (depth - 1)) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr)\n                            ^\n                            (\":\" ^\n                               ((buildhelper (rand 0 (depth - 1)) (depth - 1)\n                                   expr)\n                                  ^ \")\")))))))) in\n  buildhelper (rand 0 4) depth \"\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (\"sin(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Cosine p1 -> expr ^ (\"cos(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/2)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\")))))))) in\n  eTShelper e \"\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (makeRand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (makeRand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (makeRand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand - 1) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand - 1) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand - 1) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand depth \"\";;\n", "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (makeRand (0, 1)) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (makeRand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (makeRand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand - 1) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand - 1) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand - 1) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand depth \"\";;\n", "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (makeRand (0, 1)) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (makeRand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (makeRand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (rand - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand depth \"\";;\n", "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    let temprand = makeRand (0, 1) in\n    match num with\n    | 0 -> if temprand = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (makeRand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (makeRand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (rand - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand depth \"\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                  (\"+\" ^\n                     ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                        \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand 0 (depth - 1)) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr)\n                            ^\n                            (\":\" ^\n                               ((buildhelper (rand 0 (depth - 1)) (depth - 1)\n                                   expr)\n                                  ^ \")\")))))))) in\n  buildhelper (rand 0 4) depth \"\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (\"sin(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Cosine p1 -> expr ^ (\"cos(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/2)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\")))))))) in\n  eTShelper e \"\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (makeRand (0, 1)) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (makeRand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (makeRand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (rand - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand depth \"\";;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         string\n", "Error: This expression has type 'a -> expr\n       but an expression was expected of type expr\n", "Error: This expression has type 'a -> expr\n       but an expression was expected of type expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (num - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (num - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (num - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (num - 1) (depth - 1) expr)))\n    | 3 -> expr ^ (buildhelper (num - 1) depth expr)\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (num - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (num - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (num - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (num - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand (1, 4) depth \"\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildSine (buildhelper 0 (depth - 1))\n        else buildCosine (buildhelper 0 (depth - 1))\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (num - 1) (depth - 1) expr),\n              (buildhelper (num - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (num - 1) (depth - 1) expr),\n              (buildhelper (num - 1) (depth - 1) expr))\n    | 3 -> buildhelper (num - 1) depth expr\n    | 4 ->\n        buildThresh\n          ((buildhelper (num - 2) (depth - 1) expr),\n            (buildhelper (num - 2) (depth - 1) expr),\n            (buildhelper (num - 2) (depth - 1) expr),\n            (buildhelper (num - 2) (depth - 1) expr)) in\n  buildhelper rand (1, 4) depth \"\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildSine (buildhelper 0 (depth - 1))\n        else buildCosine (buildhelper 0 (depth - 1))\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (num - 1) (depth - 1) expr),\n              (buildhelper (num - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (num - 1) (depth - 1) expr),\n              (buildhelper (num - 1) (depth - 1) expr))\n    | 3 -> buildhelper (num - 1) depth expr\n    | 4 ->\n        buildThresh\n          ((buildhelper (num - 2) (depth - 1) expr),\n            (buildhelper (num - 2) (depth - 1) expr),\n            (buildhelper (num - 2) (depth - 1) expr),\n            (buildhelper (num - 2) (depth - 1) expr)) in\n  buildhelper rand (1, 4) depth \"\";;\n"]}
{"fix": ["let rec build (rand, depth) = \n(*\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\n*)\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper 0 0 expr)\nelse buildCosine(buildhelper 0 0 expr)\n| 2 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 3 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 4 ->\nbuildThresh(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| _ ->\nbuildThresh(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nin\nbuildhelper (rand(1,4)) depth \"\""], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         string\n", "Error: This function has type int -> int -> 'a -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a * 'b * 'c * 'd\n       but an expression was expected of type expr * expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildCosine (buildhelper 0 (depth - 1) expr)\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (num - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (num - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (num - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (num - 1) (depth - 1) expr)))\n    | 3 -> expr ^ (buildhelper (num - 1) depth expr)\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (num - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (num - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (num - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (num - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  let num = rand (1, 4) in buildhelper num depth \"\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildSine (buildhelper (depth - 1) (depth - 1) expr)\n        else buildCosine (buildhelper 0 (depth - 1) (depth - 1) expr)\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 3 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 4 ->\n        buildTimes\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr))\n    | _ ->\n        buildTimes\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr)) in\n  buildhelper (rand (1, 4)) depth \"\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildSine (buildhelper 0 0 expr)\n        else buildCosine (buildhelper 0 0 expr)\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 3 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 4 ->\n        buildTimes\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr))\n    | _ ->\n        buildTimes\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr)) in\n  buildhelper (rand (1, 4)) depth \"\";;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: This function expects too many arguments, it should have type\n'a -> 'a * bool\n", "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: Unbound value fixpoint\n", "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"], "bad": ["\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let k x = (f x) != x in k b), b);;\n", "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let k x = (f x) != b in k b), b);;\n", "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 107);;\n", "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 107);;\n", "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((fun k  -> fun x  -> (f x) = x), b);;\n", "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let k x = (f x) = x in k b), b);;\n", "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let k x = (f x) != x in k b), b);;\n", "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile ((let k x = f x in (x, (x = b))), b);;\n", "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 1);;\n", "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let k x = (f x) = x in f b), b);;\n"]}
{"fix": ["let rec wwhile (f,b) =\nlet rec wwhelper f b =\nlet (b', c') = f b \nin\nif (c' = false) then b'\nelse wwhelper f b'\nin wwhelper f b"], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: Unbound value fixpoint\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: Unbound value fixpoint\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let k x = f x in (b, ((k b) != b))), b);;\n", "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 3);;\n", "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let k x = f x in (b, (b != b))), b);;\n", "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let k x = f x in ((b, (b != b)), b));;\n", "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let k x = (f x) = x in ((x, (x != x)), b));;\n", "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) =\n  wwhile (let k x = let y = f x in f x in ((x, (y != x)), b));;\n", "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 1);;\n", "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in ((x, (x < 100)), b));;\n", "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in (((g x), (x < 100)), b));;\n", "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n"]}
{"fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let g x = (f x) = x in ((g b), b));;\n"]}
{"fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n", "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in ((g b), b));;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let g x = (f x) != x in ((g b), b));;\n"]}
{"fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n", "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in ((g b), b));;\n\nlet _ = fixpoint (collatz, 1);;\n", "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in (((g b) != x), b));;\n", "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in (((g b) != b), b));;\n", "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in ((g b), b));;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in (((g b), ((g b) != b)), b));;\n", "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let xx = (x * x) * x in ((xx, (xx < 100)), b));;\n", "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let xx = (b * b) * b in ((xx, (xx < 100)), b));;\n"]}
{"fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let g x = f x in f), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile ((let g x = (f x) != x in (y, (y != x))), b);;\n", "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let g x = f x in f), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let g x = (f x) != x in g b), b);;\n"]}
{"fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let g x = f x in g b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((let g x = f x in g b), b);;\n\nlet _ = fixpoint (collatz, 1);;\n", "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g b), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile((let g b = let xx = f x in (xx, xx!=b) in g), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g b), b);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (b, (xx != b)) in g), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile((let g x = let xx = f xx in (xx, xx!=b) in g), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  wwhile ((let g b = let xx = f x in (xx, (xx != b)) in g), b);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f b in (xx, (xx != b)) in g), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g b), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f xx in (xx, (xx != b)) in g), b);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let g xx = let xx = f x in (xx, (xx != b)) in g), b);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=b) in inwwhile), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g b), b);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile((let inwwhile x = f x in (inwwhile b, (inwwhile b)!=b)), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  wwhile ((let inwwhile x = let xx = f x in (xx, (xx != b)) in inwwhile), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=(f b)) in inwwhile), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  wwhile ((let inwwhile x = f x in ((inwwhile b), ((inwwhile b) != b))), b);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let inwwhile x = f x in (x, ((inwwhile b) != b))), b);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let inwwhile x = let xx = f x in (xx, (xx != b)) in inwwhile), b);;\n"]}
{"fix": ["let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (res, res!=b) in helper), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 48);;\n", "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper x = let res = f x in (res, (res != (f b))) in helper), b);;\n", "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper x = let res = f x in ((f b), (res != (f b))) in helper), b);;\n", "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = let res = f x in ((f b), (res != b)) in helper), b);;\n"]}
{"fix": ["let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (res, res!=(f b)) in helper), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  wwhile ((let helper x = let res = f x in (res, (res != b)) in helper), b);;\n"]}
{"fix": ["let fixpoint (f,b) = \nwwhile((let helper x = (f b, (f x)=(f b)) in helper), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper x = let res = f x in (res, (res != (f b))) in helper), b);;\n", "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper x = let res = f x in (res, (res != (f b))) in\n      printf (\"%d\\n\", helper)), b);;\n", "\nlet fixpoint (f,b) =\n  ((wwhile (let helper x = (f x) != (f b) in helper b)), b);;\n", "\nlet fixpoint (f,b) = ((wwhile (let helper x = (f x) != (f b) in helper)), b);;\n", "\nlet fixpoint (f,b) =\n  ((wwhile (let helper x = ((f x), ((f x) != (f b))) in helper)), b);;\n", "\nlet fixpoint (f,b) =\n  ((wwhile (let helper x = ((f x), ((f x) = (f b))) in helper)), b);;\n", "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet fixpoint (f,b) =\n  wwhile (let helper x = ((f x), ((f x) = (f b))) in ((helper b), b));;\n", "\nlet fixpoint (f,b) =\n  wwhile (let helper x = ((f x), ((f x) = (f b))) in ((helper b), b));;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), ((f x) = (f b))) in helper b), b);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), ((f x) = (f b))) in helper b), b);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), ((f x) = (f b))) in helper), b);;\n"]}
{"fix": ["let fixpoint (f,b) = \nwwhile((let helper x = (f b, b!=f b) in helper), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f b), ((f x) = (f b))) in helper), b);;\n", "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f b), (b = (f b))) in helper), b);;\n", "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f b), (b = (f b))) in helper b), b);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f b), (b = (f b))) in helper), b);;\n"]}
{"fix": ["let fixpoint (f,b) = \nwwhile((let helper x = (f x, b!=f x) in helper), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f b), (b != (f b))) in helper), b);;\n"]}
{"fix": ["let fixpoint (f,b) = \nwwhile((let helper x = (f x, b=f x) in helper), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b != (f x))) in helper), b);;\n"]}
{"fix": ["let fixpoint (f,b) = \nwwhile((let helper x = (f x, b=f x) in helper b), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b = (f x))) in helper), b);;\n"]}
{"fix": ["let fixpoint (f,b) = \nwwhile((let helper x = (f x, f x = b) in helper), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b = (f x))) in helper b), b);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b = (f x))) in helper b), b);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b = (f x))) in helper b), b);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b = (f x))) in helper), b);;\n", "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 1);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b = (f x))) in helper b), b);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b = (f x))) in helper b), b);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b = (f x))) in helper b), b);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let helper b = ((f b), (b = (f x))) in helper), b);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let helper b = ((f b), (b = (f b))) in helper), b);;\n", "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet fixpoint (f,b) = wwhile ((let helper x = ((f x), (b < 10)) in helper), b);;\n"]}
{"fix": ["let fixpoint (f,b) = \nwwhile((let helper x = (f x, f x=x) in helper b), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), ((f x) = b)) in helper), b);;\n", "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), ((f x) = x)) in helper), b);;\n"]}
{"fix": ["let fixpoint (f,b) = \nwwhile((let helper x = (f b, x!=(f x)) in helper), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), ((f x) = x)) in helper b), b);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), ((f x) = x)) in helper b), b);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), ((f x) = x)) in helper), b);;\n", "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (x != (f x))) in helper b), b);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (x != (f x))) in helper), b);;\n", "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (x != (f x))) in helper b), b);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (x != (f x))) in helper b), b);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (x != (f x))) in helper), b);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b != (f x))) in helper), b);;\n"]}
{"fix": ["let fixpoint (f,b) = \nwwhile((let helper x = let xx = f x in (f x, x!=(f x)) in helper), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f b), (x != (f x))) in helper), b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper x = let xx = f x in ((f x), (x != (f x))) in helper), b);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = let xx = f x in (xx, (x != xx)) in helper), b);;\n", "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (x != (f x))) in helper), b);;\n"]}
{"fix": ["type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\n| Thresh2  of expr * expr\n| Thresh3  of expr * expr"], "hw": "hw2", "problem": "expr", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = (+)\nin\nlet base = f 2 xs\nin\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: Unbound value base\n", "Error: Unbound value base\n", "Error: Unbound value base\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: Unbound value int\n", "Error: Unbound value base\n", "Error: Unbound value a\n", "Error: Unbound value a\n", "Error: Unbound value base\n", "Error: Unbound value a\n", "Error: Unbound value base\n", "Error: Unbound value a\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type int but an expression was expected of type\n         int -> int -> int\n", "Error: Unbound value base\n", "Error: This expression has type int but an expression was expected of type\n         int -> int -> int\n", "Error: Unbound value base\n", "Error: Unbound value a\n", "Error: Unbound value a\n", "Error: Unbound value x\n"], "bad": ["\nlet sqsum xs =\n  let f a x = failwith \"to be implemented\" in\n  let base = base + (xs ** 2) in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = base ** 2 in let base = base + a in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = base ** 2 in let base = a in List.fold_left f base xs;;\n", "\nlet sqsum xs = let f a x = a ** 2 in let base = a in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = (int a) ** 2 in let base = a in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = a + base in let base = a in List.fold_left f base xs;;\n", "\nlet sqsum xs = let f a x = a in let base = a in List.fold_left f base xs;;\n", "\nlet sqsum xs = let f a x = (+) in let base = a in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = (+) in let base = base + (f a x) in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = (+) in let base = f a x in List.fold_left f base xs;;\n", "\nlet sqsum xs = let f a x = (+) in let base = base in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = (+) in let base = a ** 2 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = (+) in let base = 3 ** 2 in List.fold_left f base xs;;\n", "\nlet sqsum xs = let f a x = (+) in let base = 2 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = (+) in let base = base + 1 in List.fold_left f base xs;;\n", "\nlet sqsum xs = let f a x = (+) in let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = (+) in let base = base + (a ** 2) in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = (+) in let base = a ** 2 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = (+) in let base = (f a) ** (2 x) in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = (+) in let base = f 2 x in List.fold_left f base xs;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a in\nlet base = f 2 xs\nin\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type int but an expression was expected of type\n         float\n", "Error: Unbound value base\n"], "bad": ["\nlet sqsum xs =\n  let f a x = a ** 2 in let base = f 2 xs in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = a + base in let base = f 2 xs in List.fold_left f base xs;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a*a in\nlet base = f 2 xs\nin\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet sqsum xs = let f a x = a * a in let base = [] in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = a * a in\n  let base = match xs with | [] -> [] | x::xs' -> f x xs' in\n  List.fold_left f base xs;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a*a in\nlet base = 0\nin\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet sqsum xs =\n  let f a x = x * x in let base = f 2 xs in List.fold_left f base xs;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a*a in\nlet base = f 4 xs\nin\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: Unbound value f\n", "Error: Unbound value f\n", "Error: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n"], "bad": ["\nlet sqsum xs =\n  let f a x = match x with | hd::tl -> (hd * hd) + (f a tl) in\n  let base = f 4 xs in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = match x with | hd::tl -> (hd * hd) + (f a tl) in\n  let base = f 4 xs in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = match x with | hd::tl -> hd * hd in\n  let base = f 4 xs in List.fold_left f base xs;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a*a in\nlet base = f (f 0 xs) xs\nin\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: Unbound value a\n", "Error: Unbound value base\n", "Error: Unbound value a\n"], "bad": ["\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = f 4 xs in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = f 4 xs in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = a * a in let base = f a xs in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = a * a in let base = f base xs in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = a * a in let base = f (f a xs) xs in List.fold_left f base xs;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a*a in\nlet base = f 4 xs\nin\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: Unbound value thing\n"], "bad": ["\nlet sqsum xs =\n  let f a x = a * a in let base = f 4 thing in List.fold_left f base xs;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a*a in\nlet base = f 8 xs\nin\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: Unbound value base\n", "Error: Unbound value base\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = f 4 xs in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = a * a in let base = base + (f 4 xs) in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = a * a in let base = f base xs in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = a * a in let base = f xs xs in List.fold_left f base xs;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> 0\n| hd::tl -> f (f 0 hd) tl\nin\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: Unbound value base\n", "Error: Unbound value base\n"], "bad": ["\nlet sqsum xs =\n  let f a x = a * a in\n  let base = match xs with | [] -> base | hd::tl -> f (f base hd) tl in\n  List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = a * a in\n  let base = match xs with | [] -> 0 | hd::tl -> f (f base hd) tl in\n  List.fold_left f base xs;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> 4\n| hd::tl -> f (f 2 hd) tl\nin\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: Unbound value f\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet sqsum xs =\n  let f a x = match xs with | [] -> a | hd::tl -> f (f a hd) tl in\n  let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let rec f a x = match xs with | [] -> a | hd::tl -> f (f a hd) tl in\n  let base = 0 in List.fold_left f base xs;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a*a in\nlet base = f 2 xs\nin\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: Unbound value base\n"], "bad": ["\nlet sqsum xs =\n  let f a x = a * a in let base = base in List.fold_left f base xs;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a*a in\nlet base = f 9 xs\nin\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int\n"], "bad": ["\nlet sqsum xs =\n  let f a x = ((+) a) * a in let base = f 2 xs in List.fold_left f base xs;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> f 0 xs\n| hd::tl -> f (f hd hd) tl\nin\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: Unbound value base\n", "Error: Unbound value a\n"], "bad": ["\nlet sqsum xs =\n  let f a x = a * a in\n  let base = match xs with | [] -> f 0 xs | hd::tl -> f (f base hd) tl in\n  List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = a * a in\n  let base = match xs with | [] -> f 0 xs | hd::tl -> f (f a hd) tl in\n  List.fold_left f base xs;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| hd::tl -> f (f hd hd) tl\nin\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet sqsum xs =\n  let f a x = a * a in\n  let base = match xs with | [] -> xs | hd::tl -> f (f hd hd) tl in\n  List.fold_left f base xs;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| hd::tl -> f hd hd + f (f hd hd) tl\nin\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet sqsum xs =\n  let f a x = a * a in\n  let base = match xs with | hd::tl -> (f hd hd) + (f tl tl) in\n  List.fold_left f base xs;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = match xs with\n| [] -> a\n| hd::tl -> hd*hd in\nlet base = f 0 xs\nin\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: Unbound value f\n"], "bad": ["\nlet sqsum xs =\n  let f a x = match xs with | [] -> a | hd::tl -> f hd tl in\n  let base = f 0 xs in List.fold_left f base xs;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = \nmatch xs with\n| [] -> a\n| hd::tl -> a + hd*hd in\nlet base = f 4 xs\nin\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet sqsum xs =\n  let f a x = match xs with | [] -> a | hd::tl -> a + (hd * hd) in\n  let base = [] in List.fold_left f base xs;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a + x*x in\nlet base = match xs with\n| [] -> 0\n| hd::tl -> f 0 hd\nin\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet sqsum xs =\n  let f a x = match x with | [] -> a | hd::tl -> a + (hd * hd) in\n  let base = f 0 xs in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = match xs with | [] -> a | hd::tl -> a + (x * x) in\n  let base = f 0 xs in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = a + (x * x) in\n  let base = match xs with | [] -> [] | hd::tl -> f 0 hd in\n  List.fold_left f base xs;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a + x*x in\nlet base = \nmatch xs with\n| [] -> f 0 0\n| hd::tl -> f 0 hd\nin\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet sqsum xs =\n  let f a x = a + (x * x) in\n  let base = match xs with | [] -> f 0 [] | hd::tl -> f 0 hd in\n  List.fold_left f base xs;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a + x*x in\nlet base = \nmatch xs with\n| [] -> 0\n| hd::tl -> f 0 hd\nin\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type int -> int -> int\n       but an expression was expected of type int\n"], "bad": ["\nlet sqsum xs =\n  let f a x = a + (x * x) in\n  let base = match xs with | [] -> 0 | hd::tl -> f - (1 hd) in\n  List.fold_left f base xs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun x -> x\nin\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: Unbound value x\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x x = a x in let base = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun x -> x\nin\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n"], "bad": ["\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun x -> x\nin\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n", "Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n"], "bad": ["\nlet pipe fs = let f a x x = a in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun x -> 0\nin\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n", "Error: Unbound value a\n"], "bad": ["\nlet pipe fs = let f a x x = a x in let base = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x x = a x in let base x = a in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun y ->  a x in\nlet base = fun x -> x\nin\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> ('a -> 'b -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'b -> 'c) -> 'c\n"], "bad": ["\nlet pipe fs =\n  let f a x y = y a x in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun k -> x k(a) in\nlet base = fun x -> x\nin\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'c -> ('c -> 'a) -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'c -> 'a -> 'b\n       The type variable 'a occurs inside 'c -> 'a\n"], "bad": ["\nlet pipe fs =\n  let f a x y = a (y x) in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun k -> x k(k) in\nlet base = fun x -> x\nin\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value f\n"], "bad": ["\nlet pipe fs =\n  let f a x k = x k (f a k) in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun k -> a x in\nlet base = fun y -> y\nin\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b -> 'c) -> 'b -> 'a -> 'c\n       but an expression was expected of type\n         ('a -> 'b -> 'c) -> 'b -> 'a -> 'b -> 'c\n       The type variable 'c occurs inside 'b -> 'c\n"], "bad": ["\nlet pipe fs =\n  let f a x k = a k x in let base y = y in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun k -> x a k in\nlet base = fun y -> y\nin\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'a -> 'b) -> 'a -> 'a -> 'b\n       but an expression was expected of type\n         ('a -> 'a -> 'b) -> 'a -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs =\n  let f a x k = a x k in let base y = y in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun k -> x a (k) in\nlet base = fun x -> x\nin\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n"], "bad": ["\nlet pipe fs =\n  let f a x k = x a k in let base y = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun k -> x (a k) in\nlet base = fun y -> y\nin\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> ('b -> 'c) -> ('a -> 'b) -> 'c\n       but an expression was expected of type 'a -> ('b -> 'c) -> 'a\n       The type variable 'a occurs inside ('a -> 'b) -> 'c\n"], "bad": ["\nlet pipe fs =\n  let f a x k = x (k a) in let base y = y in List.fold_left f base fs;;\n"]}
{"fix": ["let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))"], "hw": "hw3", "problem": "clone", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n =\n  match n > 0 with | true  -> x :: ((clone x n) - 1) | false  -> x;;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: ((clone x n) - 1) | false  -> [x];;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x @ ((clone x n) - 1) | false  -> x @ [];;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x @ ((clone x n) - 1) | false  -> [];;\n", "\nlet rec clone x n =\n  match n = 0 with | true  -> x | false  -> x @ ((clone x n) - 1);;\n", "\nlet rec clone x n =\n  match n = 0 with | true  -> x | false  -> x @ ((clone x n) - 1);;\n", "\nlet rec clone x n =\n  match n = 0 with | true  -> [] | false  -> x @ ((clone x n) - 1);;\n", "\nlet rec clone x n =\n  match n = 0 with | true  -> [] | false  -> x :: ((clone x n) - 1);;\n", "\nlet rec clone x n =\n  match n = 0 with | true  -> [] | false  -> x @ ((clone x n) - 1);;\n", "\nlet rec clone x n =\n  match n = 0 with | true  -> [] | false  -> x :: ((clone x n) - 1);;\n", "\nlet rec clone x n =\n  match n = 0 with | true  -> [] | false  -> x :: ((clone x n) - 1);;\n"]}
{"fix": ["let rec clone x n =\nlet rec clonehelper tx tn =\nmatch (tn = 0) with\n| true -> []\n| false -> tx :: clonehelper tx (tn - 1)\nin\nclonehelper x (abs n)"], "hw": "hw3", "problem": "clone", "message": ["Error: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with | true  -> [] | false  -> tx :: (clone tx (tn - 1)) in\n  clonehelper x abs n;;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x abs n;;\n"]}
{"fix": ["let padZero l1 l2 =\nmatch List.length l1 > List.length l2 with\n| true -> (l1,((clone 0 (List.length l1 - List.length l2)) @ l2))\n| false -> (((clone 0 (List.length l2 - List.length l1)) @ l1),l2)"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type int list\n       but an expression was expected of type 'a list list\n       Type int is not compatible with type 'a list \n", "Error: This expression has type int list\n       but an expression was expected of type 'a list list\n       Type int is not compatible with type 'a list \n", "Error: This expression has type int list\n       but an expression was expected of type 'a list list\n       Type int is not compatible with type 'a list \n", "Error: This expression has type int list\n       but an expression was expected of type 'a list list\n       Type int is not compatible with type 'a list \n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type 'a list list\n       Type int is not compatible with type 'a list \n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (clone 0 ((List.length l1) - (List.length l2))) @ l2\n  else\n    if (List.length l1) < (List.length l2)\n    then (clone 0 ((List.length l2) - (List.length l1))) @ l1;;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (clone 0 ((List.length l1) - (List.length l2))) @ l2\n  else\n    if (List.length l1) < (List.length l2)\n    then (clone 0 ((List.length l2) - (List.length l1))) @ l1;;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (clone 0 ((List.length l1) - (List.length l2))) @ l2\n  else\n    if (List.length l1) < (List.length l2)\n    then (clone 0 ((List.length l2) - (List.length l1))) @ l1;;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (clone 0 ((List.length l1) - (List.length l2))) @ l2\n  else\n    if (List.length l1) < (List.length l2)\n    then (clone 0 ((List.length l2) - (List.length l1))) @ l1;;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (clone 0 ((List.length l1) - (List.length l2))) @ l2\n  else\n    if (List.length l1) < (List.length l2)\n    then (clone 0 ((List.length l2) - (List.length l1))) @ l1;;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then l1 :: ((clone 0 ((List.length l1) - (List.length l2))) @ l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (clone 0 ((List.length l2) - (List.length l1))) @ l1;;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then l1 :: ((clone 0 ((List.length l1) - (List.length l2))) @ l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then l2 :: ((clone 0 ((List.length l2) - (List.length l1))) @ l1);;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then l1 :: ((clone 0 ((List.length l1) - (List.length l2))) @ l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then l2 :: ((clone 0 ((List.length l2) - (List.length l1))) @ l1);;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then l1 :: ((clone 0 ((List.length l1) - (List.length l2))) @ l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then l2 :: ((clone 0 ((List.length l2) - (List.length l1))) @ l1);;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then l1 :: ((clone 0 ((List.length l1) - (List.length l2))) @ [l2])\n  else\n    if (List.length l1) < (List.length l2)\n    then l2 :: ((clone 0 ((List.length l2) - (List.length l1))) @ [l1]);;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then l1 :: ((clone 0 ((List.length l1) - (List.length l2))) @ [l2])\n  else\n    if (List.length l1) < (List.length l2)\n    then l2 :: ((clone 0 ((List.length l2) - (List.length l1))) @ [l1]);;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then l1 :: ((clone 0 ((List.length l1) - (List.length l2))) @ [l2])\n  else\n    if (List.length l1) < (List.length l2)\n    then l2 :: ((clone 0 ((List.length l2) - (List.length l1))) @ [l1]);;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then l1 :: ((clone 0 ((List.length l1) - (List.length l2))) @ [l2])\n  else\n    if (List.length l1) < (List.length l2)\n    then ((clone 0 ((List.length l2) - (List.length l1))) @ [l1]) :: l2;;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then l1 @ [(clone 0 ((List.length l1) - (List.length l2))) @ [l2]]\n  else\n    if (List.length l1) < (List.length l2)\n    then ((clone 0 ((List.length l2) - (List.length l1))) @ [l1]) :: l2;;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> l1 :: ((clone 0 ((List.length l1) - (List.length l2))) @ l2)\n  | false  -> ((clone 0 ((List.length l2) - (List.length l1))) @ [l1]) :: l2;;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ [l1]), l2);;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ [l1]), l2);;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type unit\n"], "bad": ["\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [0] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 9 in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = f l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = ([], []) in\n    let args = f l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([], []) in\n    let base = ([], []) in\n    let args = f l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = () in\n    let base = ([], []) in\n    let args = f l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let rec mulByDigit i l = \nlet comb a b =\nmatch b with\n| [] -> [a]\n| hd::tl -> [a + hd]\nin\nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i-9 != 0) then\n(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: Unbound value %\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec mulByDigit i l =\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if ((hd * i) / 10) != 0\n        then ((hd * i) % 10) :: (((hd * i) / 10) + (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "\nlet rec mulByDigit i l =\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if ((hd * i) / 10) != 0\n        then ((hd * i) mod 10) :: (((hd * i) / 10) + (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "\nlet rec mulByDigit i l =\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if ((hd * i) / 10) != 0\n        then ((hd * i) mod 10) :: (((hd * i) / 10) + (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "\nlet rec mulByDigit i l =\n  let rec mBDhelper i x =\n    match x with\n    | [] -> 0\n    | hd::tl ->\n        if ((hd * i) / 10) != 0\n        then ((hd * i) mod 10) :: (((hd * i) / 10) + (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "\nlet rec mulByDigit i l =\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if ((hd * i) - 9) != 0\n        then ((hd * i) / 10) :: (((hd * i) mod 10) + (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "\nlet rec mulByDigit i l =\n  let comb a (hd::tl) = a + hd in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if ((hd * i) - 9) != 0\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> a | hd::tl -> a + hd in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if ((hd * i) - 9) != 0\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> a | hd::tl -> a + hd in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if ((hd * i) - 9) != 0\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n"]}
{"fix": ["let rec mulByDigit i l = \nlet comb a b =\nmatch b with\n| [] -> [a]\n| hd::tl -> [a + hd]@tl\nin\nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i > 9) then\n(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> [a + hd] :: tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> [[a + hd]; tl] in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n", "\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> [a + hd] @ [tl] in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n"]}
{"fix": ["let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nlet carry =\nmatch a with\n| (x,y) -> x in\nmatch x with\n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list * 'b list\n       but an expression was expected of type unit\n"], "bad": ["\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = () in\n    let base = ([], []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\n(*let carry =\nmatch a with\n| (x, y) -> x\nin*)\nmatch x with\n| (addend_a,addend_b) ->\nlet carry = match a with\n| (x,y) -> x\nin\nlet new_carry = (carry + addend_a + addend_b) / 10 in\nlet digit = (carry + addend_a + addend_b) mod 10\nin\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value x\n", "Error: Unbound value carry\n"], "bad": ["\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet _ =\n  let bigAdd l1 l2 =\n    let add (l1,l2) =\n      let f a x = match a with | (carry,acc) -> carry in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,acc) -> (new_carry, (digit :: acc))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (carry,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nmatch x with\n| (addend_a,addend_b) ->\nlet prevcarry = \nmatch a with\n| (x, y) -> x in\nlet new_carry = (prevcarry + addend_a + addend_b) / 10 in\nlet digit = (prevcarry + addend_a + addend_b) mod 10\nin\nmatch a with\n| (x,[]) -> (new_carry, new_carry::[digit]) \n| (x, c::d::y) -> (new_carry, new_carry::digit::d::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,[]) -> (new_carry, (new_carry :: digit))\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,[]) -> (new_carry, (new_carry :: digit))\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,[]) -> (new_carry, (new_carry :: digit))\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let padZero l1 l2 =\nmatch List.length l1 > List.length l2 with\n| true -> (l1,(List.append (clone 0 (List.length l1 - List.length l2)) l2))\n| false -> ((List.append(clone 0 (List.length l2 - List.length l1)) l1),l2)"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1,\n        (List.append ((clone 0 ((List.length l1) - (List.length l2))) l2)))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = l1 in\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| hd::tl -> \nif (tl=[]) then [(x,hd) ]\nelse (x,hd)::(argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "bad": ["\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = ([], 1) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> (x, [])\n      | hd::tl -> List.append (x, hd) (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = ([], 1) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> (x, [])\n      | hd::tl -> List.append (x, [hd]) (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = ([], 1) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> (x, 0)\n      | hd::tl -> List.append (x, hd) (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> (x, [])\n      | hd::tl -> List.append (x, hd) (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> (x, [])\n      | hd::tl -> List.append (x, hd) (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | hd::tl -> if tl = [] then (x, hd) else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) @ (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type 'a list -> 'b list -> ('a * 'b) list\n       but an expression was expected of type 'a list -> 'b list -> 'a list\n       The type variable 'a occurs inside 'a * 'b\n", "Error: This expression has type 'a -> 'a list -> 'a list\n       but an expression was expected of type 'a -> 'a list -> 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet bigMul l1 l2 =\n  let f a x = List.combine a x in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet bigMul l1 l2 =\n  let f a x = a :: x in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int -> int list * int -> int list\n       but an expression was expected of type int -> int list * int -> int\n       Type int list is not compatible with type int \n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int * 'a list\n       but an expression was expected of type int list\n", "Error: This expression has type int -> int list * int -> int * int list\n       but an expression was expected of type int -> int list * int -> int\n       Type int * int list is not compatible with type int \n", "Error: This expression has type int -> int list * int -> int * int list\n       but an expression was expected of type int -> int list * int -> int\n       Type int * int list is not compatible with type int \n", "Error: This expression has type int -> int * int list -> int * int list\n       but an expression was expected of type int -> int * int list -> int\n       Type int * int list is not compatible with type int \n", "Error: This expression has type int -> int * int list -> int * int list\n       but an expression was expected of type int -> int * int list -> int\n       Type int * int list is not compatible with type int \n", "Error: This expression has type int -> int * int list -> int * int list\n       but an expression was expected of type int -> int * int list -> int\n       Type int * int list is not compatible with type int \n", "Error: This expression has type int -> int * int list -> int * int list\n       but an expression was expected of type int -> int * int list -> int\n       Type int * int list is not compatible with type int \n", "Error: This expression has type int list -> int * int list -> int * int list\n       but an expression was expected of type\n         int list -> int * int list -> int list\n       Type int * int list is not compatible with type int list \n", "Error: This expression has type int * 'a list\n       but an expression was expected of type int list\n", "Error: This expression has type int list -> int * int list -> int * int list\n       but an expression was expected of type\n         int list -> int * int list -> int list\n       Type int * int list is not compatible with type int list \n", "Error: This expression has type int list -> int * int list -> int * int list\n       but an expression was expected of type\n         int list -> int * int list -> int list\n       Type int * int list is not compatible with type int list \n"], "bad": ["\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (templ1,l2digit) ->\n        let multres = mulByDigit l2digit templ1 in bigAdd [a; 0] multres in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (templ1,l2digit) ->\n        let multres = mulByDigit l2digit templ1 in bigAdd (a :: 0) multres in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (templ1,l2digit) ->\n        let multres = mulByDigit l2digit templ1 in bigAdd (a @ [0]) multres in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (templ1,l2digit) ->\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd [a; 0] multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (templ1,l2digit) ->\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd [a; 0] multres)) in\n  let base = ([0], []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd [a; 0] multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd [a; 0] multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd [a; 0] multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd [a; 0] multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd (a @ [0]) multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let multres = mulByDigit l2digit templ1 in bigAdd (a @ [0]) multres in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd (a @ [0]) multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd (a @ [0]) multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let stringOfList f l =\n\"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\""], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f (sepConcat \"\" l);;\n"]}
{"fix": ["let rec digitsOfInt n = match n with \n[] -> []\n| h::t -> [h]::digitsOfInt t"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value t\n", "Error: Unbound value h\n", "Error: Unbound value digistOfInt\nHint: Did you mean digitsOfInt?\n", "Error: Unbound value digitstOfInt\nHint: Did you mean digitsOfInt?\n"], "bad": ["\nlet rec digitsOfInt n =\n  match n with | [] -> t | h::t -> [h] :: (digistOfInt t);;\n", "\nlet rec digitsOfInt n =\n  match n with | [] -> h | h::t -> [h] :: (digistOfInt t);;\n", "\nlet rec digitsOfInt n =\n  match n with | [] -> [] | h::t -> [h] :: (digistOfInt t);;\n", "\nlet rec digitsOfInt n =\n  match n with | [] -> [] | h::t -> [h] :: (digitstOfInt t);;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n >0 then n/10::[n mod 10]\nelse []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value %\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | n -> [n % 10] :: (digitsOfInt (n / 10));;\n", "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) :: (n mod 10) else [];;\n", "\nlet rec digitsOfInt n =\n  if n > 0 then ((digitsOfInt n) / 10) :: (n mod 10) else [];;\n", "\nlet rec digitsOfInt n = if n > 0 then (n / 10) :: (n mod 10) else [];;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n > 0 then [(digitsOfInt n) / 10; n mod 10] else [];;\n", "\nlet rec digitsOfInt n =\n  if n > 0 then [(digitsOfInt n) / 10; n mod 10] else [];;\n", "\nlet rec digitsOfInt n =\n  if n > 0 then ((digitsOfInt n) / 10) @ [n mod 10] else [];;\n", "\nlet rec digitsOfInt n =\n  if n > 0 then ((digitsOfInt n) / 10) @ [n mod 10] else [];;\n", "\nlet rec digitsOfInt n =\n  if n > 0 then [[(digitsOfInt n) / 10]; n mod 10] else [];;\n"]}
{"fix": [], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec listReverse l = match l with | [] -> [] | h::t -> [t; listReverse h];;\n"]}
{"fix": [], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec additivePersistence n =\n  match n with | [] -> [] | h::t -> h + (additivePersistence t);;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"], "bad": ["\nlet rec digitsOfInt n = if n > 0 then [n; n mod 10];;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"], "bad": ["\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt n) :: (n mod 10);;\n", "\nlet rec digitsOfInt n = if n > 0 then (n mod 10) :: (digitsOfInt (n / 10));;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n > 0 then (n mod 10) :: (digitsOfInt (n/10))\nelse []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value n\n"], "bad": ["\nlet rec listReverse l = failwith \"TBD\";;\n\nlet rec digitsOfInt n =\n  if n > 0 then (listReverse (n mod 10)) :: (digitsOfInt (n / 10)) else [];;\n\nlet _ = if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n > 0 then digitsOfInt(n/10) @ [(n mod 10)] \nelse []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: Unbound value digitsofInt\nHint: Did you mean digitsOfInt?\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n > 0 then [digitsOfInt (n / 10); n mod 10] else [];;\n", "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsofInt (n / 10)) :: (n mod 10) else [];;\n", "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) :: (n mod 10) else [];;\n", "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ (n mod 10) else [];;\n"]}
{"fix": ["let additivePersistence n = \nlet count = 0 in\nif n < 10 then count\nelse sumList(digitsOfInt n)"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: Unbound value count\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n", "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec additivePersistence n =\n  match n with | [] -> [] | h::t -> t + (digitsOfInt (additivePersistence h));;\n", "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n =\n  if n < 10 then count else ((sumList (digitsOfInt n)), (count + 1));;\n", "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n =\n  let count = 0 in\n  if n < 10 then count else ((sumList (digitsOfInt n)), (count + 1));;\n", "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n =\n  let count = 0 in\n  if n < 10 then count else (sumList (digitsOfInt n) count) + 1;;\n"]}
{"fix": ["let rec listReverse l = match l with\n| [] -> []\n| h::t -> listReverse t @ [h]"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec listReverse l = match l with | [] -> [] | h::t -> [t; listReverse h];;\n"]}
{"fix": ["let additivePersistence n = \nlet count = 0 in\nif n < 10 then 1\nelse 1 + sumList(digitsOfInt n)"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: Unbound value n\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n =\n  let count = 0 in\n  if n < 10 then count else count + (1 sumList (digitsOfInt n));;\n", "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet _ =\n  let additivePersistence n =\n    let count = 0 in if n < 10 then count else count + 1 in\n  sumList (digitsOfInt n);;\n"]}
{"fix": ["let rec additivePersistence n = \nif n < 10 then 1\nelse 1 + additivePersistence (sumList(digitsOfInt n))"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10 then 1 else 1 + (additivePersistence sumList (digitsOfInt n));;\n"]}
{"fix": ["let rec digitalRoot n = \nlet sum = 0 in\nif n < 10 then n\nelse digitalRoot(sumList(digitsOfInt n))"], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: This expression has type bool but an expression was expected of type\n         int\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let sum = 0 in\n  if n < 10 then n + sum else sum = (digitalRoot (sumList (digitsOfInt n)));;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then h::seen\nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: Unbound value et\n", "Error: Unbound value et\n", "Error: Unbound value et\n", "Error: Unbound value et\n", "Error: Unbound value et\n", "Error: Unbound value l\n", "Error: Unbound value et\n", "Error: Unbound value et\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ =\n  (et removeDuplicates l) =\n    (let rec helper (seen,rest) =\n       match rest with\n       | [] -> seen\n       | h::t ->\n           let seen' =\n             if ((List.mem h) = seen) = false then seen' @ [h] else seen in\n           let rest' = t in helper (seen', rest') in\n     List.rev (helper ([], l)));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ =\n  (et removeDuplicates l) =\n    (let rec helper (seen,rest) =\n       match rest with\n       | [] -> seen\n       | h::t ->\n           let seen' =\n             if ((List.mem h) = seen) = false then seen @ [h] else seen in\n           let rest' = t in helper (seen', rest') in\n     List.rev (helper ([], l)));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ =\n  (et removeDuplicates l) =\n    (let rec helper (seen,rest) =\n       match rest with\n       | [] -> seen\n       | h::t ->\n           let seen' =\n             if ((List.mem h) = seen) = false then seen @ [h] else seen in\n           let rest' = t in helper (seen', rest') in\n     List.rev (helper ([], l)));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ =\n  (et removeDuplicates l) =\n    (let rec helper (seen,rest) =\n       match rest with\n       | [] -> seen\n       | h::t ->\n           let seen' = if (List.mem h seen) = false then seen @ [h] else seen in\n           let rest' = t in helper (seen', rest') in\n     List.rev (helper ([], l)));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ =\n  (et removeDuplicates l) =\n    (let rec helper (seen,rest) =\n       match rest with\n       | [] -> seen\n       | h::t ->\n           let seen' = if (List.mem h seen) = false then seen @ [h] else seen in\n           let rest' = t in helper (seen', rest') in\n     List.rev (helper ([], l)));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ =\n  (removeDuplicates l) =\n    (let rec helper (seen,rest) =\n       match rest with\n       | [] -> seen\n       | h::t ->\n           let seen' = if (List.mem h seen) = false then seen @ [h] else seen in\n           let rest' = t in helper (seen', rest') in\n     List.rev (helper ([], l)));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ =\n  (et removeDuplicates l) =\n    (let rec helper (seen,rest) =\n       match rest with\n       | [] -> seen\n       | h::t ->\n           let seen' = if (List.mem h seen) = false then seen @ [h] else seen in\n           let rest' = t in helper (seen', rest') in\n     helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ =\n  (et removeDuplicates l) =\n    (let rec helper (seen,rest) =\n       match rest with\n       | [] -> seen\n       | h::t ->\n           let seen' = if (List.mem h seen) = false then h :: seen else seen in\n           let rest' = t in helper (seen', rest') in\n     List.rev (helper ([], l)));;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (eval (v, x, y))\n  | Cosine v -> cos (eval (v, x, y))\n  | Average (v,w) -> ((eval (v, x, y)) + (eval (w, x, y))) / 2.0\n  | Times (v,w) -> (eval (v, x, y)) * (eval (v, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (eval (v, x, y))\n  | Cosine v -> cos (eval (v, x, y))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) / 2.0\n  | Times (v,w) -> (eval (v, x, y)) * (eval (v, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (eval (v, x, y))\n  | Cosine v -> cos (eval (v, x, y))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) * (eval (v, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with \n| VarX ->            x\n| VarY ->\t     y\n| Sine(v) ->         sin(eval(v,x,y))\n| Cosine(v) ->       cos(eval(v,x,y))\n| Average(v,w) ->    (((eval(v,x,y) +. eval(w,x,y)))/.2.0)\n| Times(v,w) ->      eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if ((eval(a,x,y)) < (eval(b,x,y))) then (eval(c,x,y)) else (eval(d,x,y))"], "hw": "hw2", "problem": "eval", "message": ["Error: Unbound constructor Var\nHint: Did you mean VarX or VarY?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Var x -> x\n  | Var y -> y\n  | Sine v -> sin (eval (v, x, y))\n  | Cosine v -> cos (eval (v, x, y))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (v, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with \n| Sine(v) ->         sin(pi*.eval(v,x,y))\n| Cosine(v) ->       cos(pi*.eval(v,x,y))\n| Average(v,w) ->    (((eval(v,x,y) +. eval(w,x,y)))/.2.0)\n| Times(v,w) ->      eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if ((eval(a,x,y)) < (eval(b,x,y))) then (eval(c,x,y)) else (eval(d,x,y))\n| VarX ->\t     x\n| VarY ->\t     y"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (pi * (eval (v, x, y)))\n  | Cosine v -> cos (pi * (eval (v, x, y)))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (v, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | VarX  -> x\n  | VarY  -> y;;\n"]}
{"fix": ["let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value d\n", "Error: This expression has type bool but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         expr * expr\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr * expr * expr * expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet _ =\n  let rec build (rand,depth) = if depth > 0 then d = (d - 1) in\n  match rand (0, 4) with\n  | 0 -> buildSine (build (rand, d))\n  | 1 -> buildCosine (build (rand, d))\n  | 2 -> buildAverage (build (rand, d))\n  | 3 -> buildTimes (build (rand, d))\n  | 4 -> buildThresh (build (rand, d));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet _ =\n  let rec build (rand,depth) = if depth > 0 then depth = (depth - 1) in\n  match rand (0, 4) with\n  | 0 -> buildSine (build (rand, depth))\n  | 1 -> buildCosine (build (rand, depth))\n  | 2 -> buildAverage (build (rand, depth))\n  | 3 -> buildTimes (build (rand, depth))\n  | 4 -> buildThresh (build (rand, depth));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let depth = depth - 1 in\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, depth))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage (build (rand, depth))\n    | 3 -> buildTimes (build (rand, depth))\n    | 4 -> buildThresh (build (rand, depth));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let depth = depth - 1 in\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, depth))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage (build (rand, depth))\n    | 3 -> buildTimes (build (rand, depth))\n    | 4 -> buildThresh (build (rand, depth));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let d = depth - 1 in\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, d))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage (build (rand, depth))\n    | 3 -> buildTimes (build (rand, depth))\n    | 4 -> buildThresh (build (rand, depth));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let depth = depth - 1 in\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, depth))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage (build (rand, depth))\n    | 3 -> buildTimes (build (rand, depth))\n    | 4 -> buildThresh (build (rand, depth));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let depth = depth - 1 in\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, depth))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage (build (rand, depth))\n    | 3 -> buildTimes (build (rand, depth))\n    | 4 -> buildThresh (build (rand, depth))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let depth = depth - 1 in\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, depth))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n    | 3 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n    | 4 ->\n        buildThresh\n          ((build (rand, depth)), (build (rand, depth)),\n            (build (rand, depth)))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n"]}
{"fix": ["let rec exprToString e = match e with \n| VarX ->  \t     \"x\"\n| VarY ->            \"y\"\n| Sine(v) ->         \"sin(pi*\"^exprToString(v)^\")\"\n| Cosine(v) ->       \"cos(pi*\"^exprToString(v)^\")\"\n| Average(v,w) ->    \"((\"^exprToString(v)^\"+\"^exprToString(w)^\")/2)\"\n| Times(v,w) ->      exprToString(v)^\"*\"^exprToString(w)\n| Thresh(v,w,x,y) -> exprToString(v)^\"<\"^exprToString(w)^\"?\"^exprToString(x)^\":\"^exprToString(y)^\")\"\n| Plus(v,w) ->\t     \"(\"^exprToString(v)^\"+\"^exprToString(w)^\")\"\n| Cube(v,w,x) ->     \"(\"^exprToString(v)^\"*\"^exprToString(w)^\"*\"^exprToString(x)"], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Plus of expr* expr\n  | Cube of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Cosine v -> \"cos(pi*\" ^ ((exprToString v) ^ \")\")\n  | Average (v,w) ->\n      \"((\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")/2)\")))\n  | Times (v,w) -> (exprToString v) ^ (\"*\" ^ (exprToString w))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ ((exprToString y) ^ \")\"))))))\n  | Plus (v,w) -> \"(\" ^ ((exprToString v) ^ ((\"+\" exprToString w) ^ \")\"))\n  | Cube (v,w,x) ->\n      \"(\" ^\n        ((exprToString v) ^\n           (\"*\" ^ ((exprToString w) ^ (\"*\" ^ (exprToString x)))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  wwhile\n    ((let func v =\n        let result = f b in\n        if b = result then (result, false) else (result, true) in\n      v), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((fun x -> let x = (f v) in (x, x != v)),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) = wwhile ((fun v  -> let x = f v in (x, (x != v))), b);;\n"]}
{"fix": [], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type 'a list -> 'b list\n       but an expression was expected of type string\n", "Error: This expression has type string list -> string\n       but an expression was expected of type string\n", "Error: This expression has type 'a list -> 'b list\n       but an expression was expected of type string\n", "Error: This expression has type 'a list -> 'b list\n       but an expression was expected of type string\n", "Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = sl in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" [List.map (f l)]) ^ \"]\");;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = sl in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\") ^ ([List.map (f l)] ^ \"]\"));;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = sl in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" [List.map (f l)]) ^ \"]\");;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = sl in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" [List.map (f l)]) ^ \"]\");;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = sl in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" List.map (f l)) ^ \"]\");;\n"]}
{"fix": ["let stringOfList f l = \"[\"^(sepConcat \";\" (List.map f l))^\"]\""], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" List.map (f l)) ^ \"]\");;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat (\";\" List.map (f l))) ^ \"]\");;\n"]}
{"fix": [], "hw": "hw3", "problem": "clone", "message": ["Error: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet y = ((clone List.hd l1 ((List.length l1) - (List.length l2)) y), l2);;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet y = ((clone List.hd l1 ((List.length l1) - (List.length l2)) y), l2);;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet y = ((clone List.hd l1 ((List.length l1) - (List.length l2)) y), l2);;\n"]}
{"fix": ["let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y = clone (List.hd l1) (List.length l1 - List.length l2) in\n(y, l2)\nelse let z = clone (List.hd l2) (List.length l2 - List.length l1) in\n(z, l1)"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type 'a list list\n       but an expression was expected of type 'a list\n       The type variable 'a occurs inside 'a list\n", "Error: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (let y = clone l1 ((List.length l1) - (List.length l2)) in (y, l2))\n    else (let z = clone l2 ((List.length l2) - (List.length l1)) in (z, l1));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = clone List.hd l1 ((List.length l1) - (List.length l2)) in\n       (y, l2))\n    else\n      (let z = clone List.hd l2 ((List.length l2) - (List.length l1)) in\n       (z, l1));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = clone List.hd l1 ((List.length l1) - (List.length l2)) in\n       (y, l2))\n    else\n      (let z = clone List.hd l2 ((List.length l2) - (List.length l1)) in\n       (z, l1));;\n"]}
{"fix": ["let rec removeZero l = \nmatch l with \n| x::xs -> if x = 0 then removeZero(xs) else l"], "hw": "hw3", "problem": "removeZero", "message": ["Error: Unbound value xs\n"], "bad": ["\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs | [] -> xs;;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"tba\" in\n    let base = [] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)\nelse (0,(d1+d2)::result) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l = failwith \"to be implemented\";;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + 1) - 10) :: result))\n               else (0, ((d1 + d2) :: result))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1 List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l = failwith \"to be implemented\";;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + 1) - 10) :: result))\n               else (0, ((d1 + d2) :: result))) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev l1), (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)\nelse (0,(d1+d2+carry)::result) in\nlet base = (0,[]) in\nlet args = [(0,0)]@List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type int list\n       Type 'a * 'b is not compatible with type int \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type int list\n       Type 'a * 'b is not compatible with type int \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type int\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type int list\n       Type 'a * 'b is not compatible with type int \n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = 0 @ (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = 0 :: (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = [0] @ (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = [0] @ [List.combine (List.rev l1) (List.rev l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = [0] @ (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)\nelse (0,(d1+d2+carry)::result) in\nlet base = (0,[]) in\nlet args = (List.combine(List.rev l1)(List.rev l2))@[(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = [List.combine (List.rev l1) (List.rev l2); (0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = [List.combine (List.rev l1) (List.rev l2); (0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigMul l1 l2 = \nmatch l2 with\n| x::xs -> xs"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int -> int list -> int list\n       but an expression was expected of type int\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int -> int list -> int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (numzero,result) ->\n        ((numzero + 1),\n          (bigAdd ((mulByDigit * l1) :: (clone 0 numzero)) result)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (numzero,result) ->\n        ((numzero + 1),\n          (bigAdd ((mulByDigit l1 x) :: (clone 0 numzero)) result)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (numzero,result) ->\n        ((numzero + 1),\n          (bigAdd ((mulByDigit x l1) :: (clone 0 numzero)) result)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (numzero,result) ->\n        ((numzero + 1),\n          (bigAdd ((mulByDigit x l1) :: (clone 0 numzero)) result)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, (bigAdd((mulByDigit x l1) @ clone 0 numzero)) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: Unbound value l1\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value l1\n", "Error: Unbound value t\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value t\n", "Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet _ =\n  let bigMul l1 l2 = match l2 with | x::xs -> xs in\n  let f a x =\n    match a with\n    | (numzero,result) ->\n        ((numzero + 1),\n          (bigAdd ((mulByDigit x l1) :: (clone 0 numzero)) result)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet _ =\n  let bigMul l1 l2 = match l2 with | x::xs -> t in\n  let f a x =\n    match a with\n    | (numzero,result) ->\n        ((numzero + 1),\n          (bigAdd ((mulByDigit x l1) :: (clone 0 numzero)) result)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (numzero,result) ->\n        ((numzero + 1),\n          (bigAdd ((mulByDigit x l1) :: (clone 0 numzero)) result)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (numzero,result) ->\n        ((numzero + 1),\n          ((bigAdd ((mulByDigit x l1) :: (clone 0 numzero))) result)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let rec sumList xs = match xs with\n| [] -> 0\n| hd::tl -> hd + sumList tl"], "hw": "hw1", "problem": "sumList", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec sumList xs = match xs with | [] -> [] | hd::tl -> hd + (sumList tl);;\n", "\nlet rec sumList xs = match xs with | [] -> [] | hd::tl -> hd + (sumList tl);;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n <= 0\nthen []\nelse n - (n/10) * 10 :: digitsOfInt (n/10)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n - ((n / 10) * 10)) :: ((digitsOfInt n) / 10);;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This function has type 'a list -> 'a -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec append xs x =\n  match xs with | [] -> [x] | hd::tl -> hd :: (append tl x);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append digitsOfInt (n / 10) (n - ((n / 10) * 10));;\n"]}
{"fix": ["let rec additivePersistence n = \nif n < 10\nthen 0\nelse 1 + additivePersistence (sumList (digits n))"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList n));;\n"]}
{"fix": ["let palindrome w = match (explode w) with\n| [] -> true\n| head::[] -> true\n| head::tail -> \nif head = List.hd (listReverse tail)\nthen palindrome (List.tl (listReverse tail))\nelse false"], "hw": "hw1", "problem": "palindrome", "message": ["Error: Unbound value hd\n", "Error: Unbound value hd\n", "Error: This expression has type string but an expression was expected of type\n         'a list\n", "Error: This expression has type string but an expression was expected of type\n         char\n"], "bad": ["\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w = failwith \"TBD\";;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | head::[] -> true\n  | head::tail ->\n      if head = (hd (listReverse w))\n      then palindrome (tl (listReverse tail))\n      else false;;\n", "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w = failwith \"TBD\";;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | head::[] -> true\n  | head::tail ->\n      if head = (hd (listReverse w))\n      then palindrome (tl (listReverse tail))\n      else false;;\n", "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w = failwith \"TBD\";;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | head::[] -> true\n  | head::tail ->\n      if head = (List.hd (listReverse w))\n      then palindrome (List.tl (listReverse tail))\n      else false;;\n", "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w = failwith \"TBD\";;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | head::[] -> true\n  | head::tail ->\n      if head = (List.hd (listReverse [w]))\n      then palindrome (List.tl (listReverse [tail]))\n      else false;;\n"]}
{"fix": ["let palindrome w = \nlet rec palHelper xs =\nmatch xs with\n| [] -> true\n| hd::tl -> match (listReverse tl) with\n| [] -> true\n| hdr::tlr ->\nif hdr = hd\nthen palHelper tlr\nelse false\nin \npalHelper (explode w)"], "hw": "hw1", "problem": "palindrome", "message": ["Error: This expression has type char list\n       but an expression was expected of type string\n", "Error: This expression has type 'a list\n       but an expression was expected of type string\n", "Error: This expression has type 'a list\n       but an expression was expected of type string\n"], "bad": ["\nlet palindrome w = failwith \"TBD\";;\n\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | head::[] -> true\n  | head::tail ->\n      if head = (List.hd (listReverse tail))\n      then palindrome (List.tl (listReverse tail))\n      else false;;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | hd::[] -> true\n  | hd::tl ->\n      (match listReverse tl with\n       | hdr::tlr -> if hdr = hd then palindrome tlr else false);;\n", "\nlet palindrome w = failwith \"TBD\";;\n\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | head::[] -> true\n  | head::tail ->\n      if head = (List.hd (listReverse tail))\n      then palindrome (List.tl (listReverse tail))\n      else false;;\n\nlet palindrome w =\n  let rec palHelper xs =\n    match xs with\n    | [] -> true\n    | hd::tl ->\n        (match listReverse tl with\n         | [] -> true\n         | hdr::tlr -> if hdr = hd then palindrome tlr else false) in\n  palHelper (explode w);;\n", "\nlet palindrome w = failwith \"TBD\";;\n\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | head::[] -> true\n  | head::tail ->\n      if head = (List.hd (listReverse tail))\n      then palindrome (List.tl (listReverse tail))\n      else false;;\n\nlet palindrome w =\n  let rec palHelper xs =\n    match xs with\n    | [] -> true\n    | hd::tl ->\n        (match listReverse tl with\n         | [] -> true\n         | hdr::tlr -> if hdr = hd then palindrome tlr else false) in\n  palHelper (explode w);;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen\nthen seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: This expression has type ('a * 'b) list -> bool\n       but an expression was expected of type bool\n", "Error: This expression has type 'a list -> bool\n       but an expression was expected of type bool\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h, seen) then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value f\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value f\n"], "bad": ["\nlet fixpoint (f,b) = wwhile (let g a = ((f a), ((f a) != a)) in (g, b));;\n\nlet rec wwhile (f,b) =\n  match f b with | (k,tf) -> if tf = false then k else wwhile (f, k);;\n\nlet _ =\n  (fixpoint (f, b)) = (wwhile (let g a = ((f a), ((f a) != a)) in (g, b)));;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((fun a -> f a, f a != a), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (k,tf) -> if tf = false then k else wwhile (f, k);;\n\nlet fixpoint (f,b) = wwhile (fun a  -> ((f a), ((f a) != a), b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (k,tf) -> if tf = false then k else wwhile (f, k);;\n\nlet fixpoint (f,b) = wwhile (fun a  -> ((f a), ((f a) != a), b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (k,tf) -> if tf = false then k else wwhile (f, k);;\n\nlet fixpoint (f,b) = wwhile (fun a  -> ((f a), ((f a) != a), b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (k,tf) -> if tf = false then k else wwhile (f, k);;\n\nlet fixpoint (f,b) = wwhile (fun a  -> ((f a), ((f a) != a), b));;\n"]}
{"fix": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"pi* \" ^ exprToString s"], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type string but an expression was expected of type\n         int\n", "Error: This expression has type 'a list\n       but an expression was expected of type string\n", "Error: Unbound value sep\n", "Error: This expression has type string list -> string\n       but an expression was expected of type string\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"pi* \" exprToString s;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"pi* \" + (exprToString s);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> String.concat [\"pi* \"; exprToString s];;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> String.concat sep [\"pi* \"; exprToString s];;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> (String.concat \"pi* \") ^ (exprToString s);;\n"]}
{"fix": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ exprToString s ^ \")\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ (exprToString s \")\");;\n"]}
{"fix": ["let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine e' -> \n\"sin(pi*\" ^ exprToString e' ^ \")\"\n| Cosine e' -> \n\"cos(pi*\" ^ exprToString e' ^ \")\"\n| Average (e1, e2) -> \n\"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1, e2) -> \nexprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \nexprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ \nexprToString e3 ^ \"?\" ^ exprToString e4"], "hw": "hw2", "problem": "exprToString", "message": ["Error: This variant pattern is expected to have type expr\n       The constructor Threshold does not belong to type expr\nHint: Did you mean Thresh?\n", "Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Threshold (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        (\"<\" ^\n           ((exprToString e2 \"?\") ^\n              ((exprToString e3) ^ (\"?\" exprToString e4))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        (\"<\" ^\n           ((exprToString e2 \"?\") ^\n              ((exprToString e3) ^ (\"?\" exprToString e4))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        (\"<\" ^\n           ((exprToString e2 \"?\") ^\n              ((exprToString e3) ^ (\"?\" exprToString e4))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> \"sin(pi*\" ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> \"cos(pi*\" ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        (\"<\" ^\n           ((exprToString e2) ^\n              (\"?\" ^ ((exprToString e3) ^ (\"?\" exprToString e4)))));;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi *. eval (e,0.0,0.0))"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e -> sin (pi *. (eval e));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e -> sin (pi * (eval e));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e -> sin (pi *. (eval e));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, 0, 0)));;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) *. eval (e2,x,y)) /. 2.0)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) * (eval (e2, x, y))) / 2;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y))) / 2;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y))) /. 2;;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.0"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) /. 2.0;;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.0\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * float * float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval e1) *. (eval e2);;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX -> \nx\n| VarY -> \ny\n| Sine e1 -> \nsin(pi *. eval (e1,x,y))\n| Cosine e1 -> \ncos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> \n(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0\n| Times (e1,e2) -> \neval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif (eval(e1,x,y)<eval(e2,x,y))\nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Log e1 ->\nlet b = eval (e1,x,y)\nin\nif (b > 1.0)\nthen log(b)\nelse 0.0"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Log of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Log e1 -> let b = eval (e1, x, y) in if b > 1.0 then log b else 0;;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX -> \nx\n| VarY -> \ny\n| Sine e1 -> \nsin(pi *. eval (e1,x,y))\n| Cosine e1 -> \ncos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> \n(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0\n| Times (e1,e2) -> \neval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif (eval(e1,x,y)<eval(e2,x,y))\nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Log e1 ->\nlet b = eval (e1,x,y)\nin\nif (b > 1.0)\nthen log(b)\nelse 0.0\n| SumOfSquares (e1,e2,e3) ->\n(eval(e1,x,y) ** 2.0) +. (eval(e2,x,y) ** 2.0) +. (eval(e3,x,y) ** 2.0)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: Unbound value **.\nHint: Did you mean *. or **?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Log of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Log e1 -> let b = eval (e1, x, y) in if b > 1.0 then log b else 0.0\n  | SumOfSquares (e1,e2,e3) ->\n      (((eval (e1, x, y)) ** 2.0) + ((eval (e2, x, y)) ** 2.0)) +\n        ((eval (e3, x, y)) ** 2.0);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Log of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Log e1 -> let b = eval (e1, x, y) in if b > 1.0 then log b else 0.0\n  | SumOfSquares (e1,e2,e3) ->\n      (((eval (e1, x, y)) **. 2.0) + ((eval (e2, x, y)) **. 2.0)) +\n        ((eval (e3, x, y)) **. 2.0);;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This variant pattern is expected to have type expr\n       The constructor ModF does not belong to type expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Log of expr\n  | SumOfSquares of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | ModF e1 -> (match modf ((eval (e1, x, y)) *. 10) with | (f,i) -> f)\n  | SumOfSquares (e1,e2,e3) ->\n      ((((eval (e1, x, y)) ** 2.0) +. ((eval (e2, x, y)) ** 2.0)) +.\n         ((eval (e3, x, y)) ** 2.0))\n        /. 3.0;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = x**2.0 in\nlet base = 0.0 in\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: Unbound value **.\nHint: Did you mean *. or **?\n"], "bad": ["\nlet sqsum xs = let f a x = x ** 2 in let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = x ** 2.0 in let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = x **. 2.0 in let base = 0 in List.fold_left f base xs;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = x*x in\nlet base = 0 in\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: Unbound value base\n"], "bad": ["\nlet sqsum xs =\n  let f a x = base + x in let base = x * x in List.fold_left f base xs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value a\n", "Error: Unbound value z\n", "Error: Unbound value x\n", "Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = z in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun a->a in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun c->x c in\nlet base = fun b->b in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n"], "bad": ["\nlet pipe fs = let f a x x = x a in let base b = b in List.fold_left f base fs;;\n"]}
{"fix": ["let stringOfList f l = sepConcat \"; \" (List.map f l)"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat \";\" l;;\n"]}
{"fix": ["let padZero l1 l2 = \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif (length1 > length2)\nthen List.append (clone 0 (length1 - length2)), length2\nelse List.append (clone 0 (length2 - length1)), length1"], "hw": "hw3", "problem": "padZero", "message": ["Error: Unbound value lenth1\nHint: Did you mean length1?\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if lenth1 > length2\n  then ((List.append (clone 0 (length1 - length2))), length2)\n  else ((List.append (clone 0 (length2 - length1))), length1);;\n"]}
{"fix": ["let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t"], "hw": "hw1", "problem": "sumList", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec sumList xs = match xs with | [] -> [] | h::t -> h + (sumList t);;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n < 0\nthen true\nelse false"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: Unbound constructor Nil\n", "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor true does not belong to type unit\n"], "bad": ["\nlet rec digitsOfInt n = match n with | [] -> [] | n -> if n > 0 then 0;;\n", "\nlet rec digitsOfInt n = match n with | Nil  -> [] | n -> if n > 0 then 0;;\n", "\nlet rec digitsOfInt n = if n < 0 then [];;\n", "\nlet rec digitsOfInt n = if n < 0 then true;;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n > 0\nthen []\nelse if (n mod 10) < 10\nthen []\nelse (n mod 10)::(digitsOfInt (n / 10))"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value x\n", "Error: Unbound value x\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n > 0\n  then []\n  else if (n mod 10) < 10 then [x] else x :: (digitsOfInt (n / 10));;\n", "\nlet rec digitsOfInt n =\n  if n > 0\n  then []\n  else if (n mod 10) < 10 then [] else x :: (digitsOfInt (n / 10));;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else x @ (digitsOfInt y));;\n"]}
{"fix": ["let rec additivePersistence n = \nlet x = sumList n in\nif x < 10\nthen countlist n\nelse additivePersistence [x]"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec countlist x = match x with | [] -> 0 | h::t -> 1 + (countlist t);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let x = sumList n in if x < 10 then countlist n else additivePersistence x;;\n", "\nlet rec countlist x = match x with | [] -> 0 | h::t -> 1 + (countlist t);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let x = sumList n in if x < 10 then countlist n else additivePersistence x;;\n"]}
{"fix": ["let rec additivePersistence n = \nif sumList (digits n) < 10\nthen numdigits (digits n)\nelse additivePersistence (sumList (digits n))"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec numdigits x = match x with | [] -> 0 | h::t -> 1 + (numdigits x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digits n)) < 10\n  then numdigits n\n  else additivePersistence sumList n;;\n", "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec numdigits x = match x with | [] -> 0 | h::t -> 1 + (numdigits x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digits n)) < 10\n  then numdigits (digits n)\n  else additivePersistence sumList n;;\n", "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec numdigits x = match x with | [] -> 0 | h::t -> 1 + (numdigits x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digits n)) < 10\n  then numdigits (digits n)\n  else additivePersistence (sumList n);;\n"]}
{"fix": ["let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> let (a,b) = h in\nif a = k\nthen b\nelse\nassoc (d,k,t)"], "hw": "hw2", "problem": "assoc", "message": ["Error: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type unit\n"], "bad": ["\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with | () -> d | (a,b) -> if a = k then b else assoc (d, k, t));;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =  if List.mem h seen then seen else h::seen in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: Unbound value list\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = if list.mem h seen then rest else h :: rest in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = if List.mem h seen then rest else h :: rest in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n"]}
{"fix": ["let rec wwhile (f,b) =\nlet (b',c') = f b in\nif c'\nthen wwhile (f, b')\nelse\nb'"], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then f b' else b';;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((fun x -> if (x=b) then (b,false) else (f x,true)),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"], "bad": ["\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (fun x  -> if (f x) = x then (b, false) else (((f x), true), b));;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (fun x  -> if x = b then (b, false) else (((f x), true), b));;\n"]}
{"fix": ["let rec exprToString e = match e with \nVarX -> 1\n| VarY-> 1\n| Sine x -> 1\n| Cosine  x -> 1\n| Average (x,y) -> 1\n| Times  (x,y)  -> 1\n| Thresh  (x,y,z,w) -> 1"], "hw": "hw2", "problem": "exprToString", "message": ["Error: Unbound value printf\n", "Error: Unbound value printf\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> printf \"A\"\n  | VarY  -> printf \"A\"\n  | Sine x -> printf \"A\"\n  | Cosine x -> printf \"A\"\n  | Average (x,y) -> printf \"A\"\n  | Times (x,y) -> printf \"A\"\n  | Thresh (x,y,z,w) -> printf \"A\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.printf \"A\"\n  | VarY  -> printf \"A\"\n  | Sine x -> printf \"A\"\n  | Cosine x -> printf \"A\"\n  | Average (x,y) -> printf \"A\"\n  | Times (x,y) -> printf \"A\"\n  | Thresh (x,y,z,w) -> printf \"A\";;\n"]}
{"fix": ["let rec exprToString e = match e with \nVarX -> Printf.sprintf \"x\"\n| VarY-> Printf.sprintf \"y\"\n| Sine x ->Printf.sprintf \"\"\n| Cosine  x -> Printf.sprintf \"\"\n| Average (x,y) -> Printf.sprintf \"\"\n| Times  (x,y)  -> Printf.sprintf \"\"\n| Thresh  (x,y,z,w) -> Printf.sprintf \"%s<%s?%s:\" (exprToString x) (exprToString y) (exprToString z)"], "hw": "hw2", "problem": "exprToString", "message": ["Error: Unbound value sprintf\n", "Error: Unbound value sprintf\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type string\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type string\n", "Error: This expression has type expr but an expression was expected of type\n         string\n", "Error: This expression has type\n         ('a -> 'b -> 'c, unit, string, string, string, 'a -> 'b -> 'c)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b -> 'c, unit, string, string, string, string)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b -> 'c is not compatible with type string \n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> sprintf \"x\"\n  | VarY  -> sprintf \"x\"\n  | Sine x -> 3\n  | Cosine x -> 4\n  | Average (x,y) -> 5\n  | Times (x,y) -> 6\n  | Thresh (x,y,z,w) -> ((sprintf \"%s<%s?%s:\" x), y, z);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> sprintf \"x\"\n  | Sine x -> 3\n  | Cosine x -> 4\n  | Average (x,y) -> 5\n  | Times (x,y) -> 6\n  | Thresh (x,y,z,w) -> ((sprintf \"%s<%s?%s:\" x), y, z);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"x\"\n  | Sine x -> Printf.sprintf \"\"\n  | Cosine x -> Printf.sprintf \"\"\n  | Average (x,y) -> Printf.sprintf \"\"\n  | Times (x,y) -> Printf.sprintf \"\"\n  | Thresh (x,y,z,w) -> ((Printf.sprintf \"%s<%s?%s:\" x), y, z);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"x\"\n  | Sine x -> Printf.sprintf \"\"\n  | Cosine x -> Printf.sprintf \"\"\n  | Average (x,y) -> Printf.sprintf \"\"\n  | Times (x,y) -> Printf.sprintf \"\"\n  | Thresh (x,y,z,w) -> ((Printf.sprintf \"%s<%s?%s:\" x), y, z);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"x\"\n  | Sine x -> Printf.sprintf \"\"\n  | Cosine x -> Printf.sprintf \"\"\n  | Average (x,y) -> Printf.sprintf \"\"\n  | Times (x,y) -> Printf.sprintf \"\"\n  | Thresh (x,y,z,w) -> Printf.sprintf \"%s<%s?%s:\" x y z;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"\"\n  | Cosine x -> Printf.sprintf \"\"\n  | Average (x,y) -> Printf.sprintf \"\"\n  | Times (x,y) -> Printf.sprintf \"\"\n  | Thresh (x,y,z,w) ->\n      Printf.sprintf \"%s<%s?%s:\" exprToString x exprToString y exprToStringz;;\n"]}
{"fix": ["let rec exprToString e = match e with \nVarX -> Printf.sprintf \"x\"\n| VarY-> Printf.sprintf \"y\"\n| Sine x ->Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n| Cosine  x -> Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n| Average (x,y) -> Printf.sprintf \"((%s+%s)/2) \" (exprToString x) (exprToString y)\n| Times  (x,y)  -> Printf.sprintf \"%s*%s\" (exprToString x) (exprToString y)\n| Thresh  (x,y,z,w) -> Printf.sprintf \"%s<%s?%s:\" (exprToString x) (exprToString y) (exprToString z)"], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type\n         ('a -> 'b -> 'c, unit, string, string, string, 'a -> 'b -> 'c)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b -> 'c, unit, string, string, string, string)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b -> 'c is not compatible with type string \n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n  | Cosine x -> Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n  | Average (x,y) ->\n      Printf.sprintf \"((%s+%s)/2) \" (exprToString x) (exprToString y)\n  | Times (x,y) -> Printf.sprintf \"e*e\" (exprToString x) (exprToString y)\n  | Thresh (x,y,z,w) ->\n      Printf.sprintf \"%s<%s?%s:\" (exprToString x) (exprToString y)\n        (exprToString z);;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet buildX () = VarX;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval ((buildX ()), a, y))\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n"]}
{"fix": ["eval(Sine(VarX),0.,0.)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\nlet a = (1, 2);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n\nlet _ = eval (Sine 0);;\n", "\nlet a = (1, 2);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n\nlet _ = eval ((Sine VarX), 0, 0);;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y))\n| Cosine a -> x\n| Average (a,b) -> x\n| Times (a,b) -> x\n| Thresh (a,b,c,d) -> x"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) * pi)\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y)*.pi)\n| Cosine a -> x\n| Average (a,b) -> x\n| Times (a,b) -> x\n| Thresh (a,b,c,d) -> x"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int * int\n       but an expression was expected of type expr\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) * 2.)\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n\nlet _ = (eval (a, x, y)) * 2.;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) * 2.)\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y)*.pi)\n| Cosine a -> cos(eval(a,x,y)*.pi)\n| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y) /. 2.)\n| Times (a,b) -> x\n| Thresh (a,b,c,d) -> x"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) *. pi)\n  | Cosine a -> cos ((eval (a, x, y)) *. pi)\n  | Average (a,b) -> (eval (a, x, y)) +. ((eval (b, x, y)) /. 2)\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n"]}
{"fix": ["let rec build (rand, depth) = \n\nfailwith \"to be implemented\""], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value rand\nHint: Did you mean land?\n", "Error: This expression has type expr but an expression was expected of type\n         int\n", "Error: This expression has type expr but an expression was expected of type\n         int\n"], "bad": ["\nlet rec build (rand,depth) = depth;;\n\nlet _ = build (rand, 1);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet (c,d) = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) *. pi)\n  | Cosine a -> cos ((eval (a, x, y)) *. pi)\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = depth;;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n  | Cosine x -> Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n  | Average (x,y) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString x) (exprToString y)\n  | Times (x,y) -> Printf.sprintf \"%s*%s\" (exprToString x) (exprToString y)\n  | Thresh (x,y,z,w) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString x) (exprToString y)\n        (exprToString z) (exprToString w);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet (c,d) = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) *. pi)\n  | Cosine a -> cos ((eval (a, x, y)) *. pi)\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = depth;;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n  | Cosine x -> Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n  | Average (x,y) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString x) (exprToString y)\n  | Times (x,y) -> Printf.sprintf \"%s*%s\" (exprToString x) (exprToString y)\n  | Thresh (x,y,z,w) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString x) (exprToString y)\n        (exprToString z) (exprToString w);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"]}
{"fix": ["let rec build (rand, depth) = \nif depth<2\nthen let x=rand(0,2) in\nmatch x with\n|0 -> buildX()\n|1 -> buildY()\nelse\nlet x=rand(0,5) in\nmatch x with\n|0 -> buildSine(build(rand,depth))\n|1 -> buildCosine(build(rand,depth))"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value buildSin\nHint: Did you mean buildSine?\nError: Unbound value buildSin\nHint: Did you mean build, buildY or buildX?\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value buildSin\nHint: Did you mean buildSine?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 2\n  then let x = rand (0, 2) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (0, 5) in\n     match x with\n     | 0 -> buildSin (build (rand, depth))\n     | 1 -> buildCosin (build (rand, depth)));;\n"]}
{"fix": ["let rec build (rand, depth) = \nif depth<2\nthen let x=rand(0,2) in\nmatch x with\n|0 -> buildX()\n|1 -> buildY()\nelse\nlet x=rand(0,5) in\nmatch x with\n|0 -> buildSine(build(rand,depth-1))\n|1 -> buildCosine(build(rand,depth-1))\n|2 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n|3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type int * int\n       but an expression was expected of type expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 2\n  then let x = rand (0, 2) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (0, 5) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 -> buildThresh (a, b, a_less, b_less));;\n"]}
{"fix": ["let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value rand\nHint: Did you mean land?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 2) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (0, 5) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet _ = build (rand, 1);;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value eval\n"], "bad": ["\nlet _ = eval ((Clamp VarX.VarY), 1, 2);;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: Unbound value eval\n", "Error: Unbound value eval\n", "Error: Unbound value eval\n", "Error: Unbound value eval\n", "Error: Unbound value eval\n"], "bad": ["\nlet _ = eval ((Clamp ((Sine Varx), VarX, VarY)), 1, 2);;\n", "\nlet _ = eval ((Clamp ((Sine VarX), VarX, VarY)), 1, 2);;\n", "\nlet _ = eval ((Clamp ((Sine VarX), VarX, VarY)), 1., 2.);;\n", "\nlet _ = eval ((Clamp ((Sine 0.), VarX, VarY)), 1., 2.);;\n", "\nlet _ = eval ((Clamp ((Sine VarX), VarX, VarY)), 0., 2.);;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = f 0 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value a\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = a in\nlet base = fun a -> a in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base a = a in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun z -> a (x z) in\nlet base = fun a-> f a in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base a = f a in List.fold_left f base fs;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base =  sepConcat sep t in\nlet l =  h in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type string -> string -> string\n       but an expression was expected of type string list\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = sepConcat sep t in let l = f in List.fold_left f base l;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \"\" in\nlet base =  sepConcat sep t in\nlet l =  h in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type string but an expression was expected of type\n         string list\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = sepConcat sep t in let l = \"\" in List.fold_left f base l;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^a in\nlet base =  sepConcat sep t in\nlet l =  t in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n", "Error: This expression has type string but an expression was expected of type\n         'a list\n", "Error: This expression has type string but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = \"\" in\n      let base = sepConcat sep t in let l = \"\" in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = \"\" in\n      let base = sepConcat sep [] in let l = \"\" in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = \"\" in\n      let base = \"\" in let l = \"\" in List.fold_left f base l;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  if t=[] then \"A\" else \"\" in\nlet l =  sl in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type bool\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = if t then \"\" else \"a\" in\n      let l = sl in List.fold_left f base l;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  if t=[] then \"A\" else h in\nlet l =  sl in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type string\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = if t = [] then \"A\" else t in\n      let l = sl in List.fold_left f base l;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x in\nlet base =  if t=[] then sep else h in\nlet l =  sl in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type string list\n       but an expression was expected of type string\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type string but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = if t = sep then sep else h ^ sep in\n      let l = sl in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = if t = sep then sep else h in\n      let l = sl in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = if t = \"\" then sep else h in\n      let l = sl in List.fold_left f base l;;\n"]}
{"fix": ["let stringOfList f l = List.map (sepConcat \"\") l"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n", "Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n", "Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n", "Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n", "Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n", "Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n", "Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n", "Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n", "Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n", "Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n", "Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n", "Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n", "Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n", "Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n", "Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type string\n", "Error: Unbound value asd\nHint: Did you mean asd_ or asr?\nError: Unbound value asd\nHint: Did you mean asr?\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value asd\nHint: Did you mean asd_ or asr?\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = failwith List.map sepConcat f l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = failwith List.map sepConcat l;;\n", "\nlet stringOfList f l = failwith List.map;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = failwith List.map (sepConcat \"\") l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = failwith List.map (sepConcat \" \") l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = failwith List.map (sepConcat \" \") l;;\n", "\nlet stringOfList f l = failwith List.map ~l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = failwith List.map (fun x  -> sepConcat \"\" x) l;;\n", "\nlet stringOfList f l = failwith List.map (fun x  -> x ^ x) l;;\n", "\nlet stringOfList f l = failwith List.map (fun x  -> x) l;;\n", "\nlet stringOfList f l = failwith List.map (fun x  -> \"\") l;;\n", "\nlet stringOfList f l = failwith List.map (fun x  -> \"\") l;;\n", "\nlet stringOfList f l = failwith List.map (fun x  -> \"\") l;;\n", "\nlet stringOfList f l = failwith List.map (fun x  -> x) l;;\n", "\nlet stringOfList f l = failwith List.map asd l;;\n", "\nlet stringOfList f l = List.map asd l;;\n"]}
{"fix": ["let stringOfList f l = List.map (sepConcat \"\") l"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: Unbound record field string\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \" \") l.string;;\n"]}
{"fix": ["let stringOfList f l = List.map (fun x->x) l"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: Unbound record field string\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (fun x  -> sepConcat x.string []) l;;\n"]}
{"fix": [], "hw": "hw3", "problem": "clone", "message": ["Error: This expression has type 'a list list\n       but an expression was expected of type int\n", "Error: This expression has type int -> 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside int -> 'a list\n", "Error: This expression has type int -> 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside int -> 'a list\n"], "bad": ["\nlet rec clone x n =\n  let acc = [] in if x = 0 then acc else acc :: ((clone x n) - 1);;\n", "\nlet rec clone x n =\n  let acc = [] in if n = 0 then acc else (clone x) :: ((acc n) - 1);;\n", "\nlet rec clone x n =\n  let acc = [] in if n = 0 then acc else (clone x) :: ((acc n) - 1);;\n"]}
{"fix": ["let rec clone x n =\nlet accum=[] in\nif n<1\nthen []\nelse clone x n"], "hw": "hw3", "problem": "clone", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: Unbound value ne\n"], "bad": ["\nlet rec clone x n = let accum = [] in if n < 1 then [] else (clone x n) - 1;;\n", "\nlet rec clone x n = let accum = [] in if n < 1 then [] else clone x ne;;\n"]}
{"fix": ["let rec clone x n =\nlet accum=[] in\nif n<1\nthen []\nelse clone x (n-1)"], "hw": "hw3", "problem": "clone", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n = let accum = [] in if n < 1 then [] else (clone x n) - 1;;\n"]}
{"fix": [], "hw": "hw3", "problem": "clone", "message": ["Error: This expression has type int -> 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside int -> 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec clone x n =\n  let accum = [] in if n < 1 then [] else (clone x) :: (accum (n - 1));;\n", "\nlet rec clone x n =\n  let accum = [] in if n < 1 then [] else clone (x :: accum) (n - 1);;\n", "\nlet rec clone x n =\n  let accum = [] in if n < 1 then [] else clone (x :: accum) (n - 1);;\n"]}
{"fix": ["let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\na"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type int but an expression was expected of type\n         bool\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type 'a list\n       but an expression was expected of type unit\n"], "bad": ["\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2));;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then List.append (clone 0 (b - a)) l1\n  else if b < a then List.append (clone 0 (a - b)) l2;;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then List.append (clone 0 (b - a)) l1\n  else if b < a then List.append (clone 0 (a - b)) l2;;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then List.append (clone 0 (b - a)) l1\n  else if b < a then List.append (clone 0 (a - b)) l2;;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b then List.append (clone 0 (b - a)) l1;;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b then List.append (clone 0 (b - a)) l1;;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b then List.append ((clone 0 b) - a) l1;;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b then List.append (clone 0 1) l1;;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if 1 then List.append (clone 0 1) l1;;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if true then List.append (clone 0 1) l1;;\n", "\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if true then List.append l1 l1;;\n"]}
{"fix": ["let padZero l1 l2 = List.length l1"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type string but an expression was expected of type\n         unit\n"], "bad": ["\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in if a < b then a;;\n", "\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in if a < b then 1;;\n", "\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in if a < b then 1;;\n", "\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in if a < b then \"\";;\n"]}
{"fix": ["let padZero l1 l2 = let a = List.length l1 in\nlet b= List.length l2 in\nif (1<2)\nthen 1\nelse 2"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n"], "bad": ["\nlet padZero l1 l2 =\n  let a = List.length l1 in let b = List.length l2 in if a < b then a;;\n", "\nlet padZero l1 l2 =\n  let a = List.length l1 in let b = List.length l2 in if 1 < 2 then 1;;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in let b = List.length l2 in if 1 < 2 then clone 0 1;;\n"]}
{"fix": ["let stringOfList f l = sepConcat \",\" (List.map (f) l)"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (\" \" (List.map f l));;\n"]}
{"fix": ["let stringOfList f l = (sepConcat \";\" (List.map (f) l))"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n", "Error: This expression has type string but an expression was expected of type\n         string list\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = (List.append \"[\") ::\n  ((sepConcat \";\" (List.map f l)) \"]\");;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" :: (sepConcat \";\" (List.map f l));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"], "bad": ["\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x + 1) :: a in\n    let base = [] in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x + 1) :: a in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a  in\nlet base = ([],[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "bad": ["\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'b list * 'c\n", "Error: This expression has type int list * int -> int -> bool\n       but an expression was expected of type\n         int list * int -> int -> int list * int\n       Type bool is not compatible with type int list * int \n", "Error: This expression has type int list * 'a -> int -> int\n       but an expression was expected of type\n         int list * 'a -> int -> int list * 'a\n       Type int is not compatible with type int list * 'a \n", "Error: This expression has type int list * 'a -> int -> int * 'b list\n       but an expression was expected of type\n         int list * 'a -> int -> int list * 'a\n       Type int is not compatible with type int list \n"], "bad": ["\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in a = ((t, (h + x)) :: a) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in a = (l1, (h + x)) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in x + h in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ((x + h), []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list * 'b\n       but an expression was expected of type (int * int) list\n", "Error: This expression has type 'a list * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type 'a list * 'b\n       but an expression was expected of type int list list\n", "Error: This expression has type 'a list * 'b\n       but an expression was expected of type int list list list\n", "Error: This expression has type 'a list * 'b\n       but an expression was expected of type ('c list * 'd list) list\n", "Error: This expression has type 'a list * 'b\n       but an expression was expected of type ('c list * int) list\n", "Error: This expression has type 'a list * 'b\n       but an expression was expected of type ('c list * int) list list\n", "Error: This expression has type 'a list * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type 'a list * 'b\n       but an expression was expected of type 'c list list\n", "Error: This expression has type int list * int list -> int -> bool\n       but an expression was expected of type\n         int list * int list -> int -> int list * int list\n       Type bool is not compatible with type int list * int list \n", "Error: This expression has type 'a list * 'b -> 'c -> bool\n       but an expression was expected of type\n         'a list * 'b -> 'c -> 'a list * 'b\n       Type bool is not compatible with type 'a list * 'b \n", "Error: This expression has type 'a list * 'b list -> 'c -> bool\n       but an expression was expected of type\n         'a list * 'b list -> 'c -> 'a list * 'b list\n       Type bool is not compatible with type 'a list * 'b list \n", "Error: This expression has type 'a list * 'b list -> 'c -> bool\n       but an expression was expected of type\n         'a list * 'b list -> 'c -> 'a list * 'b list\n       Type bool is not compatible with type 'a list * 'b list \n"], "bad": ["\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in (0, 0) :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in 0 :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in [0; 0] :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in [[0]; [0]] :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], []) :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], 0) :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in [([], 0)] :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], (0 :: a)) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in [] :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,b) = a in a = (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,b) = a in a = (t, b) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,b) = a in a = ([], []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in a = ([], []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list * 'b list -> 'c -> bool\n       but an expression was expected of type\n         'a list * 'b list -> 'c -> 'a list * 'b list\n       Type bool is not compatible with type 'a list * 'b list \n"], "bad": ["\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,b) = a in a = (l1, []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\nlet (_,asd4)=padZero asd3 (asd2::b) in\n(asd3,asd4)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int list * int list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int list * int list\n"], "bad": ["\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then let asd = (x / h) :: t in (asd, (padZero (asd, ((x + h) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then let asd = (x / h) :: t in (asd, (padZero (asd, ((x + h) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in (asd3, (padZero (asd3, asd2)))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in (asd3, (padZero (asd3 asd2)))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in (asd3, (padZero asd3 asd2))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in (asd3, ((padZero asd3 asd2) :: b))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in (asd3, (padZero asd3 (asd2 :: b)))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in (asd3, (padZero asd3 (asd2 :: b)))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[] & (x+h)>9)\nthen\nlet asd2=x+h-10 in\nlet asd3=asd2::b in\n([],1::asd3)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value h2\n"], "bad": ["\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        let asd2 = (x + h) - 10 in\n        let h2::t2 = t in let asd3 = (h2 + 1) :: t2 in (asd3, (asd2 :: b))\n      else\n        if t = []\n        then\n          (let asd2 = (x + h) - 10 in\n           let asd3 = t in let asd3 = (h2 + 1) :: t2 in ([], (asd2 :: b)))\n        else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) = a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[] && (x+h)>9)\nthen\nlet asd2=x+h-10 in\n([],1::asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev (0::l1),[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        let asd2 = (x + h) - 10 in\n        let h2::t2 = t in let asd3 = (h2 + 1) :: t2 in (asd3, (asd2 :: b))\n      else\n        if (t = []) && ((x + h) > 9)\n        then (let asd2 = (x + h) - 10 in ([], (1 :: asd2 :: b)))\n        else (t, ((x + h) :: b)) in\n    let base = (((List.rev 0) :: l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let rec mulByDigit i l = \nlet accum = [] in\nlet rec helper x l accum= \nif(x != 0)\nthen\nhelper (x-1) l (bigAdd l accum)\nelse accum\nin\nmulByDigit i (helper i l accum)"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: Unbound value ~=\n", "Error: Unbound value list\n", "Error: This expression has type 'a -> 'b -> 'c\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper i l accum =\n    if i (~= 0)\n    then\n      match l with\n      | h::t -> list.concat ((helper i) - (1 t (bigAdd h h))) accum\n    else accum in\n  helper;;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper i l accum =\n    if i != 0\n    then\n      match l with\n      | h::t -> list.concat ((helper i) - (1 t (bigAdd h h))) accum\n    else accum in\n  helper;;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then (helper x) - (1 l (bigAdd l accum)) else accum in\n  mulByDigit (helper i l accum);;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  mulByDigit (helper i l accum);;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(mulByDigit x q,[]) in \nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int list * 'a -> int -> int list\n       but an expression was expected of type\n         int list * 'a -> int -> int list * 'a\n       Type int list is not compatible with type int list * 'a \n", "Error: This expression has type int list * 'a -> int -> int list\n       but an expression was expected of type\n         int list * 'a -> int -> int list * 'a\n       Type int list is not compatible with type int list * 'a \n"], "bad": ["\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul l1 l2 =\n  let f a x = let (q,w) = a in mulByDigit x q in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul l1 l2 =\n  let f a x = let (q,w) = a in mulByDigit x q in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(q+1,mulByDigit x l1) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type\n         int list * 'a -> int -> (int -> int) * int list\n       but an expression was expected of type\n         int list * 'a -> int -> int list * 'a\n       Type int -> int is not compatible with type int list \n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul l1 l2 =\n  let f a x = let (q,w) = a in (((+) 1), (mulByDigit x q)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul l1 l2 =\n  let f a x = let (q,w) = a in ((q + 1), (mulByDigit x q)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h :: tail -> sumList tail + h"], "hw": "hw1", "problem": "sumList", "message": ["Error: Unbound value x\n"], "bad": ["\nlet rec sumList xs = match x with | [] -> 0 | h::tail -> (sumList tail) + h;;\n"]}
{"fix": ["let rec digitsOfInt n = \n(n mod 10) :: digitsOfInt (n/10)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n = [(digitsOfInt n) / 10] @ [n mod 10];;\n", "\nlet rec digitsOfInt n = ((digitsOfInt n) / 10) @ [n mod 10];;\n", "\nlet rec digitsOfInt n = ((digitsOfInt n) / 10) @ [n mod 10];;\n", "\nlet rec digitsOfInt n = (n mod 10) :: ((digitsOfInt n) / 10);;\n"]}
{"fix": [], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: Unbound value x\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::tail -> (sumList tail) + h;;\n\nlet rec additivePersistence n = x = (sumList (digits n));;\n"]}
{"fix": ["let palindrome w = \nlistReverse (explode w) == explode w"], "hw": "hw1", "problem": "palindrome", "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type string but an expression was expected of type\n         char list\n"], "bad": ["\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w = (listReverse explode w) == w;;\n", "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w = (listReverse (explode w)) == w;;\n"]}
{"fix": ["let rec wwhile (f,b) =   \nlet (b', c') = f b in \nif c' then \nwwhile (f,b') \nelse \nb'"], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value return\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' then wwhile (f, b') else return b';;\n"]}
{"fix": ["let fixpoint (f,b) =  wwhile (let w b' = let fb  = f b' in \n(fb,fb<>b') in  w ,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "\nlet fixpoint (f,b) = wwhile ((let fb = f b in (fb, (fb = b))), b);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let w b = let fb = f b in (fb, (fb = b)) in f b), b);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let w b' = let fb = f b' in (fb, (fb = b')) in f b), b);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let w b' = let fb = f b' in (fb, (fb = b')) in f b'), b);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let w b' = let fb = f b' in (fb, (fb = b')) in f b), b);;\n", "\nlet fixpoint (f,b) =\n  let w b' = let fb = f b' in (fb, (fb = b')) in wwhile (w, b);;\n", "\nlet fixpoint (f,b) =\n  wwhile (let w b' = let fb = f b' in (fb, (fb = b')) in (w, b));;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  wwhile (let w b' = let fb = f b' in (fb, (fb <> b')) in (w, b));;\n"]}
{"fix": [], "hw": "hw2", "problem": "expr", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\nError: Unbound constructor Average\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float x\n  | VarY  -> float y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n"]}
{"fix": ["let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (1,3) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(1,5) with\n| 1 -> buildSine(b)\n| 2 -> buildCosine(b)\n| 3 -> buildAverage(b,build(rand,depth-1))\n| 4 -> buildTimes(b,build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"], "hw": "hw2", "problem": "build", "message": ["Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int * int -> int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (x,y,z,w) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ ((exprToString w) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = exprToString build (makeRand, 5);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand 1 2 in (if x = 1 then buildX () else buildY ())\n  else\n    (let b = build (rand, (depth - 1)) in\n     match rand 1 5 with\n     | 1 -> buildSine b\n     | 2 -> buildCosine b\n     | 3 -> buildAverage (b, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (b, (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (x,y,z,w) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ ((exprToString w) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = exprToString build (makeRand, 5);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand 1 2 in (if x = 1 then buildX () else buildY ())\n  else\n    (let b = build (rand, (depth - 1)) in\n     match rand 1 5 with\n     | 1 -> buildSine b\n     | 2 -> buildCosine b\n     | 3 -> buildAverage (b, (build (rand, (depth - 1))))\n     | 4 -> buildTimes (b, (build (rand, (depth - 1))))\n     | _ ->\n         buildThresh\n           (b, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (x,y,z,w) ->\n      \"(\" ^\n        ((exprToString x) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString z) ^ (\":\" ^ ((exprToString w) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = exprToString (build (makeRand, 5));;\n"]}
{"fix": ["let rec eval (e,x,y) = \nmatch e with\n| VarX             ->   x\n| VarY             ->   y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Sigmoid a        -> 1./.(1. -. exp (-1*.a))\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sigmoid of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sigmoid a -> 1. /. (1. - (exp ((-1) *. a)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"]}
{"fix": ["let rec eval (e,x,y) = \nmatch e with\n| VarX             ->   x\n| VarY             ->   y\n| Sine a           -> sin(pi*. eval (a,x,y) )\n| Cosine a         -> cos(pi*. eval (a,x,y) )\n| Sigmoid a        -> 1./.(1. +.exp(-1.  *. eval (a,x,y)))\n| Average (a,b)    -> (( eval (a,x,y) +. eval (b,x,y))/.2.)\n| Tanh (a,b,c)     -> tanh(( eval (a,x,y) +. eval (b,x,y)))\n| Times (a,b)      -> eval (a,x,y) *. eval (b,x,y)\n| Thresh (a,b,c,d) -> \nif eval (a,x,y) < eval (b,x,y)  then \neval (c,x,y) \nelse\neval (d,x,y)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\nlet _ = tanh ((-0.5) + 0.9);;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = (a*a)+ x  in\nlet base = 0 in\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type string\n", "Error: This expression has type int but an expression was expected of type\n         string\n", "Error: This expression has type float but an expression was expected of type\n         string\n", "Error: This expression has type int -> int list -> int list\n       but an expression was expected of type int -> int list -> int\n       Type int list is not compatible with type int \n"], "bad": ["\nlet sqsum xs =\n  let f a x = a ^ (2 :: x) in let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = (a ^ 2) :: x in let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = (a ^ 2.) :: x in let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = (a * a) :: x in let base = 0 in List.fold_left f base xs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a  in\nlet base = f   in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value a\n", "Error: Unbound value a\n", "Error: This expression has type 'a but an expression was expected of type\n         ((('a -> 'b) -> 'b) -> ('a -> 'b) -> 'b) list\n       The type variable 'a occurs inside\n       ((('a -> 'b) -> 'b) -> ('a -> 'b) -> 'b) list\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = f a in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = f fs in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x   in\nlet base = f   in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a but an expression was expected of type\n         ((('a -> 'b) -> 'b) -> ('a -> 'b) -> 'b) list\n       The type variable 'a occurs inside\n       ((('a -> 'b) -> 'b) -> ('a -> 'b) -> 'b) list\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = f fs in List.fold_left f base fs;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type string\n"], "bad": ["\nlet sqsum xs =\n  let f a x = a ^ (2 :: x) in let base = 0 in List.fold_left f base xs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = function y -> y  in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value xs\n"], "bad": ["\nlet pipe fs =\n  let f a x = x a in let base = function | y -> y in List.fold_left f base xs;;\n"]}
{"fix": ["let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\""], "hw": "hw3", "problem": "stringOfList", "message": ["Error: Unbound value map\nHint: Did you mean max?\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (map f l)) ^ \"]\");;\n"]}
{"fix": ["let padZero l1 l2 = \nlet len1=List.length l1 in \nlet len2=List.length l2 in\nif len1>len2 then\nl1\nelse\nl2"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n"], "bad": ["\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2 then (((clone 0 (len1 - len2)) @ len2), len1);;\n"]}
{"fix": ["let padZero l1 l2 = \nlet len1=List.length l1 in \nlet len2=List.length l2 in\nif len1>len2 then\nlen1\nelse\nlen2"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n"], "bad": ["\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2 then (((clone 0 (len1 - len2)) @ l2), l1);;\n"]}
{"fix": ["let padZero l1 l2 = \nlet len1=List.length l1 in \nlet len2=List.length l2 in\nif len1>len2 then\n(clone 0 (len1-len2)) \nelse\n(clone 0 (len2-len1))"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"], "bad": ["\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then clone 0 (len1 - len2)\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1,x2)=x in \nlet (a1,a2)=a in \nlet xx= x1+x2+a1 in \nif xx>9 then\n(1,(xx-10)::a2)\nelse\n(0,xx::a2)\nin\nlet base = (0,[]) in\nlet args = List.combine (0::(List.rev l1)) (0::(List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | t -> t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let xx = (x1 + x2) + a1 in\n      if xx > 9 then (1, ((xx - 10) :: a2)) else (0, (xx :: a2)) in\n    let base = (0, []) in\n    let args = (List.combine 0) :: ((List.rev l1) 0) :: (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1,x2)=x in \nlet (a1,a2)=a in \nlet xx= x1+x2+a1 in \nif xx>9 then\n(1,(xx-10)::a2)\nelse\n(0,xx::a2)\nin\nlet base = (0,[]) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | t -> t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let xx = (x1 + x2) + a1 in\n      if xx > 9 then (1, ((xx - 10) :: a2)) else (0, (xx :: a2)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev 0) :: l1) (0 :: (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = \nlet (v,l)=x in\nlet (ac,la)=a in\nlet mul= mulByDigit v l in\nlet shift= mulByDigit ac mul in \n(ac*10,bigAdd shift la)\nin\nlet base = (1,[]) in\nlet args = List.map (fun x -> (x,(List.rev l2))) l1 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int * 'a\n       but an expression was expected of type int list\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | t -> t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let xx = (x1 + x2) + a1 in\n      if xx > 9 then (1, ((xx - 10) :: a2)) else (0, (xx :: a2)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i l acc s =\n    let l2 = List.rev l in\n    match l2 with\n    | [] -> s :: acc\n    | h::t ->\n        let n = (i * h) + s in\n        if n > 9\n        then helper i t ((n mod 10) :: acc) (n / 10)\n        else helper i t (n :: acc) 0 in\n  helper i l [] 0;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (v,l) = x in\n    let (ac,la) = a in\n    let mul = mulByDigit v l in\n    let shift = mulByDigit ac a in ((ac * 10), (bigAdd mul shift)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, l2)) l1 in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | t -> t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let xx = (x1 + x2) + a1 in\n      if xx > 9 then (1, ((xx - 10) :: a2)) else (0, (xx :: a2)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i l acc s =\n    let l2 = List.rev l in\n    match l2 with\n    | [] -> s :: acc\n    | h::t ->\n        let n = (i * h) + s in\n        if n > 9\n        then helper i t ((n mod 10) :: acc) (n / 10)\n        else helper i t (n :: acc) 0 in\n  helper i l [] 0;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (v,l) = x in\n    let (ac,la) = a in\n    let mul = mulByDigit v l in\n    let shift = mulByDigit mul ac in ((ac * 10), (bigAdd shift la)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, (List.rev l2))) l1 in\n  let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x(a) in\nlet base = function [] -> 0 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value y\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = y in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x =  x(a) in\nlet base = function y ->y in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n"], "bad": ["\nlet pipe fs =\n  let f a x = function | _ -> x a in let base = 0 in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = function v ->  x (a v) in\nlet base = function y ->y in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> ('b -> 'a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('b -> 'a -> 'c) -> 'c\n", "Error: This expression has type 'a -> ('b -> 'c) -> ('a -> 'b) -> 'c\n       but an expression was expected of type 'a -> ('b -> 'c) -> 'a\n       The type variable 'a occurs inside ('a -> 'b) -> 'c\n"], "bad": ["\nlet pipe fs =\n  let f a x = function | f' -> f' x a in\n  let base = function | y -> y in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = function | f' -> x (f' a) in\n  let base = function | y -> y in List.fold_left f base fs;;\n"]}
{"fix": ["let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (n mod 10) :: (helper (n / 10)) in\nhelper n"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | n -> (n mod 10) @ (helper (n / 10)) in\n  helper n;;\n"]}
{"fix": ["let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  helper (n / 10) @ [(n mod 10)] in\nhelper n"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound record field reverse\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | n -> (n mod 10) :: (helper (n / 10)) in\n  (helper n).reverse;;\n", "\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | n -> (n mod 10) :: (helper (n / 10)) in\n  let rec reverse xs =\n    match xs with | [] -> xs | hd::tl -> (reverse tl) :: hd in\n  reverse (helper n);;\n", "\nlet rec digitsOfInt n =\n  let rec helper x =\n    match x with | 0 -> [] | n -> (n mod 10) :: (helper (n / 10)) in\n  let rec reverse xs =\n    match xs with | [] -> [] | hd::tl -> (reverse tl) :: hd in\n  reverse (helper n);;\n", "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | n -> append (helper (n / 10)) (n mod 10) in\n  helper n;;\n", "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | n -> append [helper (n / 10)] [n mod 10] in\n  helper n;;\n", "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | n -> append [helper (n / 10)] [n mod 10] in\n  helper n;;\n", "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | n -> append [helper (n / 10)] [n mod 10] in\n  helper n;;\n", "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | n -> append [helper (n / 10)] [n mod 10] in\n  helper n;;\n"]}
{"fix": ["let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (append (helper (n / 10)) [(n mod 10)]) in\nhelper n"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | n -> append helper (n / 10) [n mod 10] in\n  helper n;;\n"]}
{"fix": ["let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> append tl (hd :: xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | m -> helper (append [m / 10] [m mod 10]) in\n  helper n;;\n"]}
{"fix": ["let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> hd :: append tl xs2 in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs2 with | [] -> xs1 | hd::tl -> append (xs1 :: hd) tl in\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n"]}
{"fix": [], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: Unbound value sumList\n", "Error: Unbound value sumList\n", "Error: Unbound value sumList\n"], "bad": ["\nlet rec additivePersistence n =\n  let rec helper count x =\n    if x < 10 then count else helper (count + 1) (sumList (digits n)) in\n  helper 0 n;;\n", "\nlet rec additivePersistence n =\n  let rec helper count x =\n    if x < 10 then count else helper (count + 1) (sumList (digits n)) in\n  helper 0 n;;\n", "\nlet rec additivePersistence n =\n  let rec helper count x =\n    if x < 10 then count else helper (count + 1) (sumList (digits n)) in\n  helper 0 n;;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value digitsOfInt\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int -> int list\n       but an expression was expected of type int\n"], "bad": ["\nlet digits n = digitsOfInt (abs n);;\n\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n\nlet digits n = digitsOfInt (abs n) digits (-23422) is [(2, 3, 4, 2, 2)];;\n", "\nlet rec digitsOfInt n =\n  let rec append xs1 xs2 =\n    match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2) in\n  let rec helper x =\n    match x with | 0 -> [] | m -> append (helper (m / 10)) [m mod 10] in\n  helper n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet _ = (digits - 23422) = [(2, 3, 4, 2, 2)];;\n"]}
{"fix": ["let rec sumList xs = \nmatch xs with \n| [] -> 0\n| hd :: tl -> hd + sumList tl"], "hw": "hw1", "problem": "sumList", "message": ["Error: Unbound value import\n"], "bad": ["\nlet _ = import math;;\n"]}
{"fix": [], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: Unbound value additivePersistence\n", "Error: Unbound value additivePersistence\n", "Error: Unbound value additivePersistence\n", "Error: Unbound value sumList\n", "Error: Unbound value additivePersistence\n", "Error: Unbound value sumlist\n", "Error: Unbound value additivePersistence\n", "Error: Unbound value sumList\n", "Error: Unbound value additivePersistence\n"], "bad": ["\nlet _ = additivePersistence 9876;;\n", "\nlet _ = additivePersistence 9876;;\n", "\nlet _ = additivePersistence 9876;;\n", "\nlet rec additivePersistence n =\n  let rec helper count x =\n    if count = 2 then x else helper (count + 1) (sumList (digits x)) in\n  helper 0 n;;\n", "\nlet _ = additivePersistence 9876;;\n", "\nlet rec additivePersistence n =\n  let rec helper count x =\n    let next = sumlist (digits x) in\n    if next < 10 then x else helper (count + 1) next in\n  helper 0 n;;\n", "\nlet _ = additivePersistence 9876;;\n", "\nlet rec additivePersistence n =\n  let rec helper count x =\n    let next = sumList (digits x) in\n    if next < 10 then count else helper (count + 1) next in\n  helper 0 n;;\n", "\nlet _ = additivePersistence 9876;;\n"]}
{"fix": ["let rec digitalRoot n = \nlet rec helper x =\nif (x < 10) then x else helper (sumList (digits x)) in\nhelper n"], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: Unbound value additivePersistence\n", "Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound value sumList\n", "Error: Unbound value sumList\n"], "bad": ["\nlet _ = additivePersistence 9876;;\n", "\nlet rec digitalRoot n =\n  let rec helper x = if x < 10 then x else helper sumList digits x in\n  helper n;;\n", "\nlet rec digitalRoot n =\n  let rec helper x = if x < 10 then x else helper (sumList digits x) in\n  helper n;;\n", "\nlet rec digitalRoot n =\n  let rec helper x = if x < 10 then x else helper (sumList (digits x)) in\n  helper n;;\n"]}
{"fix": ["let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value digitalRoot\n"], "bad": ["\nlet _ = digitalRoot 9876;;\n"]}
{"fix": [], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: Unbound value xs\n", "Error: Unbound value xs\n"], "bad": ["\nlet rec listReverse l =\n  let rec helper xs result =\n    match xs with | [] -> result | hd::tl -> tl (hd :: result) in\n  helper xs [];;\n", "\nlet rec listReverse l =\n  let rec helper xs result =\n    match xs with | [] -> result | hd::tl -> helper tl (hd :: result) in\n  helper xs [];;\n", "\nlet rec listReverse l =\n  let rec helper xs result =\n    match xs with | [] -> result | hd::tl -> helper tl (hd :: result) in\n  helper xs [];;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) = xx)),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value x\n", "Error: Unbound value xx\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = wwhile (let xx = f x in ((x, ((f x) = x)), b));;\n", "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = wwhile (let xx = f xx in ((xx, ((f xx) = xx)), b));;\n", "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = wwhile (fun xx  -> ((xx, ((f xx) = xx)), b));;\n", "\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = wwhile (fun xx  -> ((xx, ((f xx) = xx)), b));;\n"]}
{"fix": ["fixpoint (g,0)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type\n         ('a -> 'b -> 'c -> 'd) -> 'a -> 'b -> 'c -> 'd\n       Type int is not compatible with type 'a -> 'b -> 'c -> 'd \n"], "bad": ["\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = wwhile ((fun xx  -> (xx, ((f xx) = xx))), b);;\n\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0) should return 739085;;\n"]}
{"fix": ["fixpoint (g,0)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' in\n  acc b;;\n\nlet fixpoint (f,b) = ((wwhile (fun xx  -> (xx, ((f xx) = xx)))), b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) = wwhile ((fun xx  -> (xx, (not ((f xx) = xx)))), b);;\n"]}
{"fix": ["let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let rec acc result =\n    let res = f result in\n    match res with | (b',c') -> if c' then acc b' else b' | b' -> b' in\n  acc b;;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((fun xx -> (f xx, (f xx) != xx)),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n"], "bad": ["\nlet fixpoint (f,b) = wwhile ((fun xx  -> (xx, ((f xx) = xx))), b);;\n", "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 100);;\n", "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in\n  fixpoint (g, 739085);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n", "Error: Unbound value pi\n"], "bad": ["\nlet fixpoint (f,b) = wwhile ((fun xx  -> ((f xx), ((f xx) != xx))), b);;\n", "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in\n  fixpoint (g, 739080);;\n", "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "\nlet fixpoint (f,b) = wwhile ((fun xx  -> ((f xx), ((f xx) != xx))), b);;\n", "\nlet _ = pi /. (sqrt 2.0);;\n"]}
{"fix": [], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value removeDuplicates\n"], "bad": ["\nlet _ = removeDuplicates [\"moo\"; \"cow\"; \"moo\"; \"bar\"];;\n"]}
{"fix": [], "hw": "hw2", "problem": "exprToString", "message": ["Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX x -> sprintf x | VarY y -> sprintf y in\n  acc e exprToString VarX;;\n"]}
{"fix": [], "hw": "hw2", "problem": "expr", "message": ["Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX x -> sprintf x | VarY y -> sprintf y in\n  acc e exprToString VarX;;\n"]}
{"fix": ["exprToString VarX"], "hw": "hw2", "problem": "exprToString", "message": ["Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: The constructor VarY expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: The constructor VarY expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: Unbound value sprintf\n", "Error: Unbound value sprintf\n", "Error: Unbound value printf\n", "Error: Unbound value sprintf\n", "Error: This function has type expr -> 'a -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type expr -> 'a -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type expr -> 'a -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type expr -> 'a -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX x -> sprintf x | VarY y -> sprintf y in\n  acc e exprToString VarX;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX x -> sprintf \"%s\" x | VarY y -> sprintf \"%s\" y in\n  acc e exprToString VarX;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX x -> sprintf \"%s\" x | VarY y -> sprintf \"%s\" y in\n  acc e \"\" exprToString VarX;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX  -> sprintf \"x\" | VarY y -> sprintf \"y\" in\n  acc e \"\" exprToString VarX;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX  -> sprintf \"x\" | VarY y -> sprintf \"y\" in\n  acc e \"\" exprToString VarX;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX  -> sprintf \"x\" | VarY  -> sprintf \"y\" in\n  acc e \"\" exprToString VarX;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX  -> sprintf \"x\" | VarY  -> sprintf \"y\" in\n  acc e \"\" exprToString VarX;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX  -> printf \"x\" | VarY  -> printf \"y\" in\n  acc e \"\" exprToString VarX;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with | VarX  -> Printf.sprintf \"x\" | VarY  -> sprintf \"y\" in\n  acc e \"\" exprToString VarX;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let acc curr result =\n    match curr with\n    | VarX  -> Printf.sprintf \"x\"\n    | VarY  -> Printf.sprintf \"y\" in\n  acc e \"\" exprToString VarX;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let rec acc curr result =\n    match curr with\n    | VarX  -> Printf.sprintf \"x\"\n    | VarY  -> Printf.sprintf \"y\" in\n  acc e \"\" exprToString VarX;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let rec acc curr result =\n    match curr with\n    | VarX  -> Printf.sprintf \"x\"\n    | VarY  -> Printf.sprintf \"y\" in\n  acc e \"\" exprToString VarX;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let rec accu curr result =\n    match curr with\n    | VarX  -> Printf.sprintf \"x\"\n    | VarY  -> Printf.sprintf \"y\" in\n  accu e \"\" exprToString VarX;;\n"]}
{"fix": ["exprToString VarX"], "hw": "hw2", "problem": "exprToString", "message": ["Error: Unbound value Printf.srprintf\nHint: Did you mean sprintf?\n", "Error: This expression has type\n         ('a -> 'b, unit, string, string, string, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, unit, string, string, string, string)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type string \n", "Error: This expression has type\n         ('a -> 'b, unit, string, string, string, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, unit, string, string, string, string)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type string \n", "Error: This expression has type\n         ('a -> 'b, unit, string, string, string, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, unit, string, string, string, string)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type string \n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.srprintf \"Sine(%s)\" exprToString x;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" exprToString x;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"Sine\\\\(%s\\\\)\" exprToString x;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" exprToString x;;\n"]}
{"fix": ["let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> Printf.sprintf \"Sine(%s)\" (exprToString x)\n\nexprToString Sine(VarX)"], "hw": "hw2", "problem": "exprToString", "message": ["Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type\n         ('a -> 'b, unit, string, string, string, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, unit, string, string, string, string)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type string \n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" (exprToString x);;\n\nlet _ = exprToString Sine VarX;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" (exprToString x);;\n\nlet _ = exprToString Sine VarX;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" (exprToString x);;\n\nlet _ = exprToString Sine VarX;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" exprToString x;;\n"]}
{"fix": ["exprToString Sine(VarX)"], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type\n         ('a -> 'b -> 'c -> 'd, unit, string, string, string,\n          'a -> 'b -> 'c -> 'd)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b -> 'c -> 'd, unit, string, string, string, string)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b -> 'c -> 'd is not compatible with type string \n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x ->\n      Printf.sprintf \"Sine(%s)\" (exprToString x) exprToString Sine VarX;;\n"]}
{"fix": ["exprToString Sine(VarX)"], "hw": "hw2", "problem": "exprToString", "message": ["Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" (exprToString x);;\n\nlet _ = exprToString Sine VarX;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" (exprToString x);;\n\nlet _ = exprToString Sine VarX;;\n"]}
{"fix": ["let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> Printf.sprintf \"Sine(pi*%s)\" (exprToString x)\n| \n| _ -> failwith \"are we writing a lisp compiler now\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> Printf.sprintf \"Sine(%s)\" (exprToString x)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n\nlet _ = exprToString Sine VarX;;\n"]}
{"fix": ["let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| Thresh (e1, e2, e3, e4) -> Printf.sprintf \"(%s<%s?%s:%s)\"\n(exprToString e1)\n(exprToString e2)\n(exprToString e3)\n(exprToString e4)\n| _ -> failwith \"are we writing a lisp compiler now\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: The constructor Times expects 2 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: This expression has type\n         ('a -> 'b -> 'c, unit, string, string, string, 'a -> 'b -> 'c)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b -> 'c, unit, string, string, string, string)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b -> 'c is not compatible with type string \n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times ()|_ -> failwith \"are we writing a lisp compiler now\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) -> Printf.sprintf \"%s*%s\" exprToString e1 exprToString e2\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n"]}
{"fix": ["let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*eval(e', x, y))\n| Cosine(e') -> cos(pi*eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\""], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (eval (e', x, y))\n  | Cosine e' -> cos (eval (e', x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n"]}
{"fix": ["let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi * (eval (e', x, y)))\n  | Cosine e' -> cos (pi * (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a * 'b * ('b * ('c -> 'd -> 'e)) list\n       The type variable 'a occurs inside\n       'a * 'b * ('b * ('c -> 'd -> 'e)) list\n"], "bad": ["\nlet rec assoc (d,k,l) =\n  match l with\n  | (k',v')::tl -> if k' = k then v' else assoc d k tl\n  | [] -> d\n  | _ -> failwith \"This ain't your mom's hashmap\";;\n"]}
{"fix": ["let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value result\n"], "bad": ["\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet rec wwhile (f,b) =\n  let res = f result in\n  match res with | (b',c') -> if c' then wwhile (f, b') else b';;\n"]}
{"fix": [], "hw": "hw2", "problem": "exprToString", "message": ["Error: Unbound value ^.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> (abs (eval e)) ^. 0.5\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: Unbound value ^.\n", "Error: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: Unbound value absF\nHint: Did you mean abs?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> (abs (eval e)) ^. 0.5\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs (eval e))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs (eval (e, x, y)))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (absF (eval (e, x, y)))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n"]}
{"fix": [], "hw": "hw2", "problem": "exprToString", "message": ["Error: Unbound value pow\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (pow (((eval (e1, x, y)) + (eval (e2, x, y))), 2)) + (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: Unbound value pow\n", "Error: Unbound module Math\n", "Error: Unbound value math\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: Unbound value **.\nHint: Did you mean *. or **?\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (pow (((eval (e1, x, y)) + (eval (e2, x, y))), 2)) + (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (Math.pow (((eval (e1, x, y)) + (eval (e2, x, y))), 2)) +\n        (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (math.pow (((eval (e1, x, y)) + (eval (e2, x, y))), 2)) +\n        (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (((eval (e1, x, y)) + (eval (e2, x, y))) ** 2) + (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (((eval (e1, x, y)) + (eval (e2, x, y))) ** 2) + (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (((eval (e1, x, y)) + (eval (e2, x, y))) **. 2) + (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (((eval (e1, x, y)) + (eval (e2, x, y))) ** 2) + (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (((eval (e1, x, y)) +. (eval (e2, x, y))) ** 2) +. (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (((eval (e1, x, y)) +. (eval (e2, x, y))) ** 2) +. (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (((eval (e1, x, y)) ** 2.0) +. ((eval (e1, x, y)) * (eval (e2, x, y))))\n        +. (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float\n       This is not a function; it cannot be applied.\n", "Error: The constructor Gauss expects 3 argument(s),\n       but is applied here to 0 argument(s)\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: The constructor Gauss expects 3 argument(s),\n       but is applied here to 0 argument(s)\n"], "bad": ["\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n               (eval (e3, x, y)))))\n        -. 1.0\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in\n  assert (((-1.0) <= rv) && (rv <= 1.0)); rv eval_fn Gauss (1, 1);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n               (eval (e3, x, y)))))\n        -. 1.0\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet _ = eval_fn Gauss (1.0, 1.0);;\n"]}
{"fix": ["let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)"], "hw": "hw2", "problem": "build", "message": ["Error: This function has type expr * expr -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type expr\n       This is not a function; it cannot be applied.\n", "Error: This function has type expr * expr -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> VarX\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage next next\n       | 4 -> buildTimes next next\n       | 5 -> buildThresh next next next next\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss next next next);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> VarX\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next next)\n       | 4 -> buildTimes next next\n       | 5 -> buildThresh next next next next\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss next next next);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> VarX\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes next next\n       | 5 -> buildThresh next next next next\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss next next next);;\n"]}
{"fix": ["let rec build (rand, depth) = match depth with\n| 0 -> match rand (1, 2) with\n| 1 -> buildX\n| 2 -> buildY\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)"], "hw": "hw2", "problem": "build", "message": ["Error: This function has type expr * expr * expr -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This function has type expr * expr * expr -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n               (eval (e3, x, y)))))\n        -. 1.0\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> VarX\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes (next, next)\n       | 5 -> buildThresh (next, next, next, next)\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss (next, next, next));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Gauss (e1,e2,e3) ->\n      Printf.sprintf \"2*(e^(%s-%s)^2/%s) - 1\" (exprToString e1)\n        (exprToString e2) (exprToString e3)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> VarX\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes (next, next)\n       | 5 -> buildThresh (next, next, next, next)\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss (next, next, next) doRandomGray (7, 150, 200));;\n"]}
{"fix": [")\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type unit -> expr\n       but an expression was expected of type expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      (match rand (1, 2) with\n       | 1 -> buildX\n       | 2 -> buildY\n       | _ ->\n           let next = build (rand, (depth - 1)) in\n           (match rand (1, 7) with\n            | 1 -> buildSine next\n            | 2 -> buildCosine next\n            | 3 -> buildAverage (next, next)\n            | 4 -> buildTimes (next, next)\n            | 5 -> buildThresh (next, next, next, next)\n            | 6 -> buildSqrt next\n            | 7 -> buildGauss (next, next, next)));;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type unit -> expr\n       but an expression was expected of type expr\n", "Error: This expression has type unit -> expr\n       but an expression was expected of type expr\n", "Error: This expression has type unit -> expr\n       but an expression was expected of type expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      (match rand (1, 2) with\n       | 1 -> buildX\n       | 2 -> buildY\n       | _ ->\n           let next = build (rand, (depth - 1)) in\n           (match rand (1, 7) with\n            | 1 -> buildSine next\n            | 2 -> buildCosine next\n            | 3 -> buildAverage (next, next)\n            | 4 -> buildTimes (next, next)\n            | 5 -> buildThresh (next, next, next, next)\n            | 6 -> buildSqrt next\n            | 7 -> buildGauss (next, next, next)));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> buildX | 2 -> buildY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes (next, next)\n       | 5 -> buildThresh (next, next, next, next)\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss (next, next, next));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt (Abs e);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> buildX | 2 -> buildY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 7) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 -> buildAverage (next, next)\n       | 4 -> buildTimes (next, next)\n       | 5 -> buildThresh (next, next, next, next)\n       | 6 -> buildSqrt next\n       | 7 -> buildGauss (next, next, next));;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type ('a, unit, string) format -> 'a\n       but an expression was expected of type string\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n               (eval (e3, x, y)))))\n        -. 1.0\n  | _ -> failwith Printf.sprintf \"Expression %s\" e;;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: This expression has type ('a, unit, string) format -> 'a\n       but an expression was expected of type string\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n               (eval (e3, x, y)))))\n        -. 1.0\n  | _ -> failwith Printf.sprintf e;;\n"]}
{"fix": ["let buildAbs(e)\t\t\t   = Abs(e)"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value x\n"], "bad": ["\nlet _ = abs_float x;;\n"]}
{"fix": ["let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildGauss (e1,e2,e3) = Gauss (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildSqrt e = Sqrt e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 2) with | 0 -> VarX | 1 -> VarY | _ -> VarY)\n  | _ ->\n      let next = build (rand, (depth - 1)) in\n      (match rand (1, 8) with\n       | 1 -> buildSine next\n       | 2 -> buildCosine next\n       | 3 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 -> buildTimes (next, (build (rand, (depth - 1))))\n       | 5 ->\n           buildThresh\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 6 -> buildSqrt next\n       | 7 ->\n           buildGauss\n             (next, (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ -> abs next);;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float -> float\n       but an expression was expected of type float\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      ((2.0 *. exp) -\n         ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n            (eval (e3, x, y))))\n        -. 1.0\n  | _ -> failwith \"error\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            (-\n               ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n                  (eval (e3, x, y))))))\n        -. 1.0\n  | _ -> failwith \"error\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            (-\n               ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n                  (eval (e3, x, y))))))\n        -. 1.0\n  | _ -> failwith \"error\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      2.0 *.\n        (exp\n           (((- ((eval (e1, x, y)) -. (eval (e2, x, y)))) ** 2.0) /.\n              (eval (e3, x, y))));;\n"]}
{"fix": ["let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \nexp ~-.(\n((eval (e1, x, y) -. \neval (e2, x, y)) /. \neval (e3, x,y))** 2.0) /. (eval (e3, x, y) *. sqrt (2.0 *. pi))\n-. 1.0\n\n| _ -> failwith \"error\""], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      ((exp\n          (-.\n             ((((eval (e1, x, y)) -. (eval (e2, x, y))) /. (eval (e3, x, y)))\n                ** 2.0)))\n         /. ((eval (e3, x, y)) * (sqrt (2 *. pi))))\n        -. 1.0\n  | _ -> failwith \"error\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      ((exp\n          (-.\n             ((((eval (e1, x, y)) -. (eval (e2, x, y))) /. (eval (e3, x, y)))\n                ** 2.0)))\n         /. ((eval (e3, x, y)) *. (sqrt (2 *. pi))))\n        -. 1.0\n  | _ -> failwith \"error\";;\n"]}
{"fix": [], "hw": "hw2", "problem": "exprToString", "message": ["Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e' -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n  | Cosine e' -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n  | Average (e1,e2) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString e1) (exprToString e2)\n  | Times (e1,e2) ->\n      Printf.sprintf \"%s*%s\" (exprToString e1) (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString e1) (exprToString e2)\n        (exprToString e3) (exprToString e4)\n  | Sqrt e -> Printf.sprintf \"(%s)^0.5\" (exprToString (Abs e))\n  | Abs e -> Printf.sprintf \"|%s|\" (exprToString e)\n  | Logistic (e1,e2,e3) ->\n      Printf.sprintf \"(2/(1 - e^(-%s*%s)) - 1)^|%s|\" (exprToString e1)\n        (exprToString e2) (exprToString Abs e3)\n  | _ -> failwith \"are we writing a lisp compiler now\";;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         string\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      (2.0 /.\n         ((1 - (exp (-. ((eval (e1, x, y)) *. (eval (e2, x, y)))))) -. 1.0))\n        ^ (eval (e3, x, y))\n  | _ -> failwith \"error\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      (2.0 /.\n         ((1.0 -. (exp (-. ((eval (e1, x, y)) *. (eval (e2, x, y)))))) -. 1.0))\n        ^ (eval (e3, x, y))\n  | _ -> failwith \"error\";;\n"]}
{"fix": [], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type float but an expression was expected of type\n         string\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      (2.0 /.\n         ((1.0 -. (exp (-. ((eval (e1, x, y)) *. (eval (e2, x, y)))))) -. 1.0))\n        ^ (eval (e3, x, y))\n  | _ -> failwith \"error\";;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         string\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      (2.0 /.\n         ((1.0 -. (exp (-. ((eval (e1, x, y)) *. (eval (e2, x, y)))))) -. 1.0))\n        ^ (eval (e3, x, y))\n  | _ -> failwith \"error\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      (2.0 /.\n         ((1.0 -. (exp (-. ((eval (e1, x, y)) *. (eval (e2, x, y)))))) -. 1.0))\n        * (8 eval (e3, x, y))\n  | _ -> failwith \"error\";;\n"]}
{"fix": ["let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Logistic (e1, e2, e3) -> \n(2.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y) *. eval(e3, x, y )))\n-. 1.0))\n| _ -> failwith \"error\""], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      2.0 /.\n        (((1.0 -. (exp (-. ((eval (e1, x, y)) *. (eval (e2, x, y)))))) -. 1.0)\n           ** (eval (e3, x, y)))\n  | _ -> failwith \"error\";;\n\nlet _ = eval ((Logistic (VarX, VarY, VarX)), 1, 0.5);;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type int but an expression was expected of type\n         string\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\nlet sqsum xs =\n  let f a x = (a + x) ^ 2 in let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = a +. (x ** 2) in let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = a +. (x ** 2.0) in let base = 0 in List.fold_left f base xs;;\n"]}
{"fix": ["let pipe fs =\nlet rec iter acc curr = \nmatch curr with \n|[] -> acc\n| h::tl -> iter (h acc) tl in\niter (fun y-> y) fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n", "Error: Unbound value x\n", "Error: This expression has type 'a -> 'a -> 'a\n       but an expression was expected of type 'a list\n", "Error: This expression has type ('a -> 'b) list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b) list\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = fs (a x) in let base = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = fs (a x) in let base y = y in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let rec iter acc curr =\n    match curr with | [] -> acc | h::tl -> iter (h curr) tl in\n  iter (fun y  -> y) fs;;\n"]}
{"fix": ["let stringOfList f l = \n\"[\" ^ List.fold_left (^) \n\"\"\n(List.map f l) ^ \"]\""], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type string\n"], "bad": ["\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n"]}
{"fix": ["let stringOfList f l = \n\"[\" ^\nList.fold_left (fun x acc -> x ^ \"; \" ^ acc) \n\"\"\n(List.map f l) ^ \"]\""], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet stringOfList f l =\n  (\"[\" (fun x  -> fun acc  -> x ^ (\"; \" ^ acc)) List.fold_left (^) \"\"\n     (List.map f l))\n    ^ \"]\";;\n"]}
{"fix": ["let stringOfList f l = \n\"[\" ^\n(List.fold_right (fun x acc -> x ^ \"; \" ^ acc) \n(List.map f l) \n\"\")\n^ \"]\""], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type string but an expression was expected of type\n         string list\n"], "bad": ["\nlet stringOfList f l =\n  \"[\" ^\n    ((List.fold_right (fun x  -> fun acc  -> x ^ (\"; \" ^ acc)) \"\"\n        (List.map f l))\n       ^ \"]\");;\n"]}
{"fix": ["let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\n( clone 0 (len2 - len1) @ l1,\nclone 0 (len1 - len2)@  l2)"], "hw": "hw3", "problem": "padZero", "message": ["Error: Unbound value List.len\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.len l1 in\n  let len2 = List.len l2 in\n  (((clone 0 (len2 - len1)) @ l1), ((clone 0 (len1 - len2)) @ l2));;\n"]}
{"fix": ["let padZero l1 l2 = \nlet diff = (List.length l2) - (List.length l1) in\n( clone 0 diff @ l1,\nclone 0 (-diff) @  l2)"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), (((clone 0) - diff) @ l2));;\n"]}
{"fix": ["let rec removeZero l = match l with\n| [] -> l\n| h :: t -> if (h = 0) then removeZero t \nelse l"], "hw": "hw3", "problem": "removeZero", "message": ["Error: Unbound value removeZer\nHint: Did you mean removeZero?\n"], "bad": ["\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZer t else l;;\n"]}
{"fix": ["let bigAdd l1 l2 = failwith \"moo\""], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: Unbound value failWith\nHint: Did you mean failwith?\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: Unbound value failWith\nHint: Did you mean failwith?\n", "Error: Unbound value failWith\nHint: Did you mean failwith?\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((x / 10), 1) in\n    let base = (0, 0) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failWith \"\" in\n    let base = (0, 0) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"\" in\n    let base = (0, 0) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet bigAdd l1 l2 = failWith \"moo\";;\n", "\nlet bigAdd l1 l2 = failWith \"moo\";;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int * int list\n", "Error: This expression has type int but an expression was expected of type\n         int * int list\n", "Error: This expression has type int * int list\n       but an expression was expected of type int list\n", "Error: This expression has type int * int list\n       but an expression was expected of type int list\n", "Error: This expression has type int * int list\n       but an expression was expected of type int list\n", "Error: This expression has type int * int list\n       but an expression was expected of type int list\n", "Error: This expression has type int * int list\n       but an expression was expected of type int list\n", "Error: This expression has type int * int list\n       but an expression was expected of type int list\n", "Error: This expression has type int * int list\n       but an expression was expected of type int list\n", "Error: This expression has type int list * int list\n       but an expression was expected of type int list\n", "Error: This expression has type int list * int list\n       but an expression was expected of type int list\n", "Error: This expression has type int * int list\n       but an expression was expected of type int list\n", "Error: This expression has type int * int list\n       but an expression was expected of type int list\n", "Error: This expression has type int * int list\n       but an expression was expected of type int list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"\" in\n    let base = (0, 0) in\n    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          (match x with\n           | (carry,num) ->\n               let addit = ((List.hd l1) + (List.hd l2)) + carry in\n               if addit > 10 then addit mod 10 else (0, ((addit / 10) :: x))) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          (match x with\n           | (carry,num) ->\n               let addit = ((List.hd l1) + (List.hd l2)) + carry in\n               if addit > 10 then addit mod 10 else (0, ((addit / 10) :: x))) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          (match x with\n           | (carry,num) ->\n               let addit = ((List.hd l1) + (List.hd l2)) + carry in\n               ((if addit > 10 then addit mod 10 else 0), ((addit / 10) ::\n                 x))) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          (match x with\n           | (carry,num) ->\n               let addit = ((List.hd l1) + (List.hd l2)) + carry in\n               ((if addit > 10 then addit mod 10 else 0), ((addit / 10) ::\n                 x))) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          (match x with\n           | (carry,num) ->\n               let addit = ((List.hd l1) + (List.hd l2)) + carry in\n               ((if addit > 10 then addit mod 10 else 0), ((addit / 10) ::\n                 x))) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = x in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: x)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = x in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: x)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = x in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: x)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = x in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: x)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: x)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: x)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: a)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: a)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: a)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int * int list\n       but an expression was expected of type int list\n", "Error: This expression has type int * int\n       but an expression was expected of type int * int list\n       Type int is not compatible with type int list \n", "Error: This expression has type int * int\n       but an expression was expected of type int * int list\n       Type int is not compatible with type int list \n", "Error: This expression has type int list * int list\n       but an expression was expected of type int list list * int list list\n       Type int is not compatible with type int list \n", "Error: This expression has type int list * int list\n       but an expression was expected of type int list list * int list list\n       Type int is not compatible with type int list \n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: a)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int list * int list\n       but an expression was expected of type int list list * int list list\n       Type int is not compatible with type int list \n", "Error: This expression has type int list * int list\n       but an expression was expected of type int list list * int list list\n       Type int is not compatible with type int list \n", "Error: This expression has type int list * int list\n       but an expression was expected of type int list list * int list list\n       Type int is not compatible with type int list \n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      match x with\n      | ([],[]) -> (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      match x with\n      | ([],[]) -> (0, (if carry > 0 then carry :: num else num))\n      | (l1',l2') ->\n          let addit = ((List.hd l1') + (List.hd l2')) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      match x with\n      | ([],[]) -> (0, (if carry > 0 then carry :: num else num))\n      | (l1',l2') ->\n          let addit = ((List.hd l1') + (List.hd l2')) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      match x with\n      | ([],[]) -> (0, (if carry > 0 then carry :: num else num))\n      | (l1',l2') ->\n          let addit = (l1' + l2') + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      match x with\n      | [] -> (0, (if carry > 0 then carry :: num else num))\n      | h::t ->\n          let (l1',l2') = h in\n          let addit = (l1' + l2') + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f x a = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n((if (addit > 10) then 1 else 0), \n( addit mod 10 :: num))  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_right f args base in res\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int * int list -> int * int -> int * int list\n       but an expression was expected of type\n         int * int list -> int * int -> int * int\n       Type int list is not compatible with type int \n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((if addit > 10 then 1 else 0), ((addit mod 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_right f args base in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, ((addit mod 10) :: num)) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type\n         ((int -> unit) -> int -> int) * int list ->\n         int * int -> int * int list\n       but an expression was expected of type\n         ((int -> unit) -> int -> int) * int list ->\n         int * int -> ((int -> unit) -> int -> int) * int list\n       Type int is not compatible with type (int -> unit) -> int -> int \n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + (carry print_int l1') in\n      ((addit / 10), ((addit mod 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, ((addit mod 10) :: num)) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int * int -> int * int list -> int * int list\n       but an expression was expected of type\n         int * int -> int * int list -> int * int\n       Type int list is not compatible with type int \n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = x in\n      let (l1',l2') = a in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), ((addit mod 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  \nlet (carry, num) = a in \nlet (l1, l2) = x in\n(0, l1 :: num)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list -> 'a -> int * 'a list\n       but an expression was expected of type 'a list -> 'a -> 'a list\n       Type int * 'a list is not compatible with type 'a list \n", "Error: This expression has type 'a list -> 'a -> int * 'a list\n       but an expression was expected of type 'a list -> 'a -> 'a list\n       Type int * 'a list is not compatible with type 'a list \n", "Error: This expression has type 'a list -> 'b * 'a -> int * 'a list\n       but an expression was expected of type 'a list -> 'b * 'a -> 'a list\n       Type int * 'a list is not compatible with type 'a list \n", "Error: This expression has type 'a list -> 'b * 'a -> int * 'a list\n       but an expression was expected of type 'a list -> 'b * 'a -> 'a list\n       Type int * 'a list is not compatible with type 'a list \n", "Error: This expression has type 'a list -> 'a * 'b -> int * 'a list\n       but an expression was expected of type 'a list -> 'a * 'b -> 'a list\n       Type int * 'a list is not compatible with type 'a list \n", "Error: Unbound value num\nHint: Did you mean nume?\n", "Error: Unbound value num\nHint: Did you mean nume?\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, (x :: a)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, (x :: a)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (l1,l2) = x in (0, (l2 :: a)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (l1,l2) = x in (0, (l2 :: a)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (l1,l2) = x in (0, (l1 :: a)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (carry,nume) = a in let (l1,l2) = x in (0, (l1 :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (carry,nume) = a in let (l1,l2) = x in (0, (l1 :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ [(addit mod 10)]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), (num @ (addit mod 10))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), (num @ (addit mod 10))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), (num @ (addit mod 10))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ [(addit mod 10)]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value removeZeros\nHint: Did you mean removeZero?\nError: Unbound value removeZeros\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value removeZeros\nHint: Did you mean removeZero?\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (car,res) = List.fold_left f base args in res in\n  removeZeros (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      if addit >= 10 then 1 else (0, (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      if addit >= 10 then 1 else (0, (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int list * int list\n       but an expression was expected of type int * int\n       Type int list is not compatible with type int \n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine [0; l1] [0; l2] in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nfailwith (Printf.sprintf \"hi %d\" addit)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value printf\n", "Error: This expression has type ('a, unit, string) format -> 'a\n       but an expression was expected of type string\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      failwith printf.sprintf \"hi %d\" addit\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      failwith Printf.sprintf \"hi %d\" addit\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type\n         ('a -> 'b, out_channel, unit, unit, unit, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, out_channel, unit, unit, unit, unit)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type unit \n", "Error: Unbound value car\n", "Error: Unbound value car\n", "Error: Unbound value car\n", "Error: This expression has type unit\n       This is not a function; it cannot be applied.\n", "Error: This expression has type unit\n       This is not a function; it cannot be applied.\n", "Error: This expression has type unit\n       This is not a function; it cannot be applied.\n", "Error: This expression has type string but an expression was expected of type\n         string -> 'a\n", "Error: This expression has type unit\n       This is not a function; it cannot be applied.\n", "Error: This expression has type unit\n       This is not a function; it cannot be applied.\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type unit\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"hi %d\" car\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.printf \"hi %d\" car)\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"hi %d\" car;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.printf \"hi %d\" car)\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.printf \"hi %d\" carry)\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.printf \"hi %d\" carry)\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.printf \"hi %d\" carry)\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.kprintf \"hi %d\" carry)\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.printf \"hi %d\" carry)\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.printf \"hi %d\" carry)\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.printf (\"hi %d\" carry))\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.printf \"hi %d\" carry)\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\\n\" addit; in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         string\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"hi %s\" carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf \"%d\";\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int -> unit\n       but an expression was expected of type unit\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      let () = Printf.printf \"%d\" in\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf \"%d\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type\n         ('c, out_channel, unit) format =\n           ('c, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf (\"%d\\n\" addit);\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf (\"%d\\n\", addit);\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%8d%8d%8d\\n\"; l1'; l2'; carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%8d%8d%8d\\n\";\n      l1' l2' carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf; Printf.sprintf \"%8d%8d%8d\\n\"; l1'; l2'; carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type ('a, unit, string) format -> 'a\n       but an expression was expected of type\n         ('b -> 'c, out_channel, unit) format =\n           ('b -> 'c, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf Printf.sprintf \"%8d%8d%8d\\n\";\n      l1';\n      l2';\n      carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type ('a, unit, string) format -> 'a\n       but an expression was expected of type\n         ('b -> 'c -> 'd -> 'e -> 'f, out_channel, unit) format =\n           ('b -> 'c -> 'd -> 'e -> 'f, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n", "Error: This expression has type string but an expression was expected of type\n         ('a, out_channel, unit) format =\n           ('a, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf (Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry);\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\"; Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type\n         ('a -> 'b -> 'c -> 'd -> 'e, out_channel, unit, unit, unit,\n          'a -> 'b -> 'c -> 'd -> 'e)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b -> 'c -> 'd -> 'e, out_channel, unit, unit, unit, unit)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b -> 'c -> 'd -> 'e is not compatible with type unit \n", "Error: This expression has type\n         ('a -> 'b -> 'c -> 'd -> 'e, out_channel, unit, unit, unit,\n          'a -> 'b -> 'c -> 'd -> 'e)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b -> 'c -> 'd -> 'e, out_channel, unit, unit, unit, unit)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b -> 'c -> 'd -> 'e is not compatible with type unit \n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s \" Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\" Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = Printf.printf \"%d\\n\" addit in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type\n         ('a -> 'b, out_channel, unit, unit, unit, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, out_channel, unit, unit, unit, unit)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type unit \n", "Error: This expression has type int but an expression was expected of type\n         string\n", "Error: This expression has type int but an expression was expected of type\n         string\n", "Error: This expression has type int but an expression was expected of type\n         string\n", "Error: This expression has type int but an expression was expected of type\n         string\n", "Error: This expression has type int but an expression was expected of type\n         string\n", "Error: This expression has type int but an expression was expected of type\n         string\n", "Error: This expression has type int but an expression was expected of type\n         string\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\\n\" addit\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\\n\" addit;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\\n\" addit;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\\n\" addit;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\\n\" addit;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\\n\" addit;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\\n\" addit;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\\n\" addit;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int -> string\n       but an expression was expected of type\n         ('a -> 'b, out_channel, unit) format =\n           ('a -> 'b, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n", "Error: This expression has type string but an expression was expected of type\n         ('a, out_channel, unit) format =\n           ('a, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n", "Error: This expression has type string but an expression was expected of type\n         ('a, out_channel, unit) format =\n           ('a, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      let _ = Printf.printf string_of_int addit in\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      let _ = Printf.printf (string_of_int addit) in\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      let _ = Printf.printf (string_of_int addit) in\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine (List.rev ([0] @ l1)) (List.rev ([0]@ l2)) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value List.reverse\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args =\n      List.combine (List.reverse ([0] @ l1)) (List.Reverse ([0] @ l2)) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine (List.rev ([0] @ l1)) (List.rev ([0]@ l2)) in\nlet (car, res) = List.fold_left f base args in \nList.rev res\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value List.reve\nHint: Did you mean rev?\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine (List.rev ([0] @ l1)) (List.rev ([0] @ l2)) in\n    let (car,res) = List.fold_left f base args in List.reve res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let rec mulByDigit i l = if i = 0 then 0\nelse if i = 1 then l \nelse (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)\nelse bigAdd l (mulByDibit (i - 1) l)"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: Unbound value mulByDigit\n", "Error: Unbound value mulByDigit\n"], "bad": ["\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value bigAdd\n"], "bad": ["\nlet rec mulByDigit i l =\n  if i = 0\n  then 0\n  else\n    if i = 1\n    then l\n    else\n      if (i mod 2) = 0\n      then mulByDigit (i / 2) (bigAdd l l)\n      else bigAdd l (mulByDibit (i - 1) l);;\n"]}
{"fix": [], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: Unbound value bigAdd\n"], "bad": ["\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "\nlet rec mulByDigit i l =\n  if i = 0\n  then 0\n  else\n    if i = 1\n    then l\n    else\n      if (i mod 2) = 0\n      then mulByDigit (i / 2) (bigAdd l l)\n      else bigAdd l (mulByDibit (i - 1) l);;\n", "\nlet rec mulByDigit i l =\n  if i = 0\n  then 0\n  else\n    if i = 1\n    then l\n    else\n      if (i mod 2) = 0\n      then mulByDigit (i / 2) (bigAdd l l)\n      else bigAdd l (mulByDibit (i - 1) l);;\n", "\nlet rec mulByDigit i l =\n  if i = 0\n  then 0\n  else\n    if i = 1\n    then l\n    else\n      if (i mod 2) = 0\n      then mulByDigit (i / 2) (bigAdd l l)\n      else bigAdd l (mulByDigit (i - 1) l);;\n", "\nlet rec mulByDigit i l = if i = 0 then 0 else if i = 1 then l else l;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "\nlet rec mulByDigit i l = if i = 0 then 0 else if i = 1 then l else l;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "\nlet rec mulByDigit i l = if i = 0 then 0 else if i = 1 then l else l;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else\n      if (i mod 2) = 0\n      then mulByDigit (i / 2) (bigAdd l l)\n      else bigAdd l (mulByDigit (i - 1) l);;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(place + 1 ,bigAdd num (mulByDigit (x * placement) l1)) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: Unbound value addit\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n"], "bad": ["\nlet rec mulByDigit i l = if i = 0 then 0 else if i = 1 then l else l;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,num) = a in\n    let placement = 10 ** place in ((addit / 10), ((addit mod 10) :: num)) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,num) = a in\n    let placement =\n      ((float_of_int 10) ** (float_of_int place)) |> int_of_float in\n    ((addit / 10), ((addit mod 10) :: num)) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec mulByDigit i l = if i = 0 then 0 else if i = 1 then l else l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,num) = a in\n    let placement =\n      ((float_of_int 10) ** (float_of_int place)) |> int_of_float in\n    bigAdd a mulByDigit (x * place) l1 in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec mulByDigit i l = if i = 0 then 0 else if i = 1 then l else l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,num) = a in\n    let placement =\n      ((float_of_int 10) ** (float_of_int place)) |> int_of_float in\n    bigAdd a mulByDigit ((x * place) l1) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec mulByDigit i l = if i = 0 then 0 else if i = 1 then l else l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,num) = a in\n    let placement =\n      ((float_of_int 10) ** (float_of_int place)) |> int_of_float in\n    bigAdd a (mulByDigit (x * place) l1) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec mulByDigit i l = if i = 0 then 0 else if i = 1 then l else l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,num) = a in\n    let placement =\n      ((float_of_int 10) ** (float_of_int place)) |> int_of_float in\n    ((place + 1), (bigAdd num (mulByDigit (x * place) l1))) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let rec sumList xs = match xs with\n| []     -> 0 \n| hd::tl -> hd + sumList tl"], "hw": "hw1", "problem": "sumList", "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet _ = digitsOfInt - 12;;\n"]}
{"fix": ["let rec addPHelper n pos =\nlet sum = sumList pos in \nif sum < 10\nthen sum\nelse addPHelper sum pos"], "hw": "hw1", "problem": "sumList", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digithelper n l =\n  let x = n / 10 in\n  let y = n mod 10 in if x = 0 then y :: l else digithelper x (y :: l);;\n\nlet digitsOfInt n = if n <= 0 then [] else digithelper n [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPHelper n =\n  let lst = digitsOfInt n in\n  let sum = sumList lst in if sum < 10 then sum else addPHelper sum;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet additivePersistence n = let pos = digits n in addPHelper pos;;\n"]}
{"fix": [], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: This expression has type bool but an expression was expected of type\n         'a list\n", "Error: This expression has type bool but an expression was expected of type\n         'a list\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in let rest' = List.mem h l in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = [h] in let rest' = List.mem h l in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"]}
{"fix": ["let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value buildX\nHint: Did you mean build?\n", "Error: Unbound value buildX\nHint: Did you mean build?\n", "Error: Unbound value buildX\nHint: Did you mean build?\n"], "bad": ["\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX\n  | 1 -> buildSine (build (rand, (depth - (depth - 1))))\n  | 2 ->\n      buildTimes\n        ((build (rand, (depth - (depth - 2)))),\n          (build (rand, (depth - (depth - 2)))));;\n", "\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX\n  | 1 -> build (rand, (depth - (depth - 1)))\n  | 2 ->\n      buildTimes\n        ((build (rand, (depth - (depth - 2)))),\n          (build (rand, (depth - (depth - 2)))));;\n", "\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX\n  | 1 -> build (rand, (depth - (depth - 1)))\n  | 2 ->\n      buildTimes\n        ((build (rand, (depth - (depth - 2)))),\n          (build (rand, (depth - (depth - 2)))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value eval\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | PowerUp of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.5, 0.2);;\n"]}
{"fix": ["eval (sampleExprSquare2, -1.,0.5)"], "hw": "hw2", "problem": "eval", "message": ["Error: Unbound constructor BuildX\n", "Error: Unbound value eval\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | PowerUp of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | BuildX () -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Square2 (e1,e2,e3) ->\n      (sqrt\n         ((((eval (e1, x, y)) ** 2.) +. ((eval (e2, x, y)) ** 2.)) +.\n            ((eval (e3, x, y)) ** 2.)))\n        /. 2.\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | PowerUp of expr* expr\n  | Square2 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = eval (sampleExpr1, 0.5, 0.2);;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: Unbound value eval\n", "Error: Unbound value eval\n"], "bad": ["\nlet _ = eval (sampleExprTangent, (-1.), 0.5);;\n", "\nlet _ = eval (sampleExprTangent, (-1.), 0.5);;\n"]}
{"fix": [], "hw": "hw2", "problem": "expr", "message": ["Error: Unbound value eval\n"], "bad": ["\nlet _ = eval (sampleExprTangent, (-1.), 0.5);;\n"]}
{"fix": [], "hw": "hw2", "problem": "exprToString", "message": ["Error: Unbound value exprToString\n"], "bad": ["\nlet _ = exprToString sampleExprDiff2;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x (a+1) in\nlet base = 0 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet pipe fs = let f a x = [fs a] in let base = 0 in List.fold_left f base fs;;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if ( List.mem  h t ) then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev(helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: This expression has type ('a -> 'b) list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b) list\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h t) then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"]}
{"fix": ["let rec wwhile (f,b) = \nlet ( a , b ) = (f b) in\n5"], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type 'a -> 'b * bool\n       but an expression was expected of type ('a -> 'b * bool) * 'a\n", "Error: This expression has type 'a -> 'b * bool\n       but an expression was expected of type ('a -> 'b * bool) * 'a\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type ('a -> 'a * bool) * 'a\n"], "bad": ["\nlet rec wwhile (f,b) = let (a,b) = f b in if b then wwhile f a else a;;\n", "\nlet rec wwhile (f,b) = let (a,b) = f b in if b then wwhile f a else a;;\n", "\nlet rec wwhile (f,b) = let (a,b) = f b in if b then wwhile (f a) else a;;\n"]}
{"fix": ["let rec wwhile (f,b) = \nlet ( b' , c' ) = f b in\nif c' then wwhile ( f, b' ) else b'"], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type ('a -> 'a * bool) * 'a\n", "Error: This expression has type 'a -> 'b * bool\n       but an expression was expected of type ('a -> 'b * bool) * 'a\n"], "bad": ["\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then f b' else b';;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f b') else b';;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile f b' else b';;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: This expression has type expr but an expression was expected of type\n         unit -> expr\n", "Error: This expression has type expr but an expression was expected of type\n         unit -> expr\n", "Error: This expression has type expr -> expr\n       but an expression was expected of type\n         ('a -> 'b, out_channel, unit) format =\n           ('a -> 'b, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n", "Error: This expression has type expr -> expr\n       but an expression was expected of type\n         ('a -> 'b, Format.formatter, unit) format =\n           ('a -> 'b, Format.formatter, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX x -> x | VarY y -> y | Sine s -> Sine (exprToString s);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> buildX\n  | VarY  -> buildY\n  | Sine s -> Sine (exprToString s);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine s -> buildSine s;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> buildX\n  | VarY  -> buildY\n  | Sine s -> Printf.printf buildSine s;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> buildX\n  | VarY  -> buildY\n  | Sine s -> Format.printf buildSine s;;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: This expression has type expr -> expr\n       but an expression was expected of type unit -> expr\n       Type expr is not compatible with type unit \n", "Error: Unbound value assoc\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine s -> buildSine;;\n", "\nlet assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n"]}
{"fix": [], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type string but an expression was expected of type\n         ('a, unit, string) format =\n           ('a, unit, string, string, string, string)\n           CamlinternalFormatBasics.format6\n", "Error: This expression has type\n         ('a -> 'b, unit, string, string, string, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, unit, string, string, string, string)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type string \n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> (Format.sprintf \"sin(pi*\") ^ ((exprToString e') ^ \")\")\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf (exprToString e1)) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> Format.sprintf \"sin(pi*%s)\" exprToString e'\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf (exprToString e1)) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.sprintf \"x\"\n  | VarY  -> Format.sprintf \"y\"\n  | Sine e' -> Format.sprintf (\"sin(pi*%s)\" exprToString e')\n  | Cosine e' -> (Format.sprintf \"cos(pi*\") ^ ((exprToString e') ^ \")\")\n  | Average (e1,e2) ->\n      (Format.sprintf \"((\") ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      (Format.sprintf (exprToString e1)) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (a,b,a_less,b_less) ->\n      (Format.sprintf \"(\") ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^\n                    ((exprToString a_less) ^\n                       (\":\" ^ ((exprToString b_less) ^ \")\")))))));;\n"]}
{"fix": ["let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)\n", "Error: This expression has type expr\n       This is not a function; it cannot be applied.\n", "Error: This function has type expr * float * float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This function has type expr * float * float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type expr\n       This is not a function; it cannot be applied.\n", "Error: This expression has type expr\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval e' x y))\n  | Cosine e' -> cos (pi *. (eval e' x y))\n  | Average (e1,e2) -> ((eval e1 x y) +. (eval e2 x y)) /. 2\n  | Times (e1,e2) -> (eval e1 x y) *. (eval e2 x y)\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a x y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e' x y)))\n  | Cosine e' -> cos (pi *. (eval e' x y))\n  | Average (e1,e2) -> ((eval e1 x y) +. (eval e2 x y)) /. 2\n  | Times (e1,e2) -> (eval e1 x y) *. (eval e2 x y)\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a x y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval e' x y))\n  | Average (e1,e2) -> ((eval e1 x y) +. (eval e2 x y)) /. 2\n  | Times (e1,e2) -> (eval e1 x y) *. (eval e2 x y)\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a x y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval e1 x y) *. (eval e2 x y)\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a x y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval e1 x y) *. (eval e2 x y)\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a x y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a x y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b x y))\n      then eval (a_less x y)\n      else eval (b_less x y);;\n"]}
{"fix": ["let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value emitGrayscale\nError: Unbound constructor Average\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value emitGrayscale\n"], "bad": ["\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = emitGrayscale ((eval_fn sampleExpr), 150, \"sample\");;\n"]}
{"fix": ["let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         unit\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let x = rand (0, 6) in\n    match x with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value doRandomColor\n"], "bad": ["\nlet _ = doRandomColor (12, 9239, 32432);;\n"]}
{"fix": [], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * float * float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n\nlet rec factorial x acc = if x = 0 then acc else factorial (x - 1) (x * acc);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Factorial e' -> factorial (eval e')\n  | Sum3 (e1,e2,e3) -> ((eval e1) + (eval e2)) + (eval e3);;\n"]}
{"fix": ["type expr = \nVarX\n| VarY\n| Sine      of expr\n| Cosine    of expr\n| Average   of expr * expr\n| Times     of expr * expr\n| Thresh    of expr * expr * expr * expr\t\n| Factorial of expr\n| Sum3      of expr * expr * expr"], "hw": "hw2", "problem": "expr", "message": ["Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\nlet rec factorial x acc =\n  if x = 0 then acc else factorial (x -. 1.0) (x *. acc);;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )\n| Factorial e'\n-> factorial( eval( e', x, y ), 1 )\n| Sum3( e1, e2, e3 )\n-> eval( e1, x, y ) +. eval( e2, x, y ) +. eval( e3, x, y )"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n\nlet rec factorial x acc =\n  if x = 0.0 then acc else factorial (x -. 1.0) (x *. acc);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Factorial e' -> factorial (eval e')\n  | Sum3 (e1,e2,e3) -> ((eval e1) +. (eval e2)) +. (eval e3);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n\nlet rec factorial x acc =\n  if x = 0.0 then acc else factorial (x -. 1.0) (x *. acc);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Factorial e' -> factorial ((eval e'), 1)\n  | Sum3 (e1,e2,e3) -> ((eval e1) +. (eval e2)) +. (eval e3);;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This function has type float -> float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Factorial of expr\n  | Sum3 of expr* expr* expr;;\n\nlet rec factorial x acc =\n  if x = 0.0 then acc else factorial (x -. 1.0) (x *. acc);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Factorial e' -> factorial eval (e', x, y) 1\n  | Sum3 (e1,e2,e3) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y));;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ( (f, ( ( f b ) = b ))), b"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"], "bad": ["\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ =\n  let fixpoint (f,b) = let b' = f b in if b' = b then b' else wwhile (f, b') in\n  wwhile (f, b);;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) = b)), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ( (f b) = b , b )"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a * 'b\n       The type variable 'a occurs inside 'a * 'b\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"], "bad": ["\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = ((wwhile (f, (b, ((f b) = b)))), b);;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ = fixpoint (collatz, 9001);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type ('d -> 'd * bool) * 'd\n", "Error: Unbound value b'\n", "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type int but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"], "bad": ["\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((f b) = b), b);;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, ((f b) = b), b);;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' b' = f b in ((b' = b), b));;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let b' = f b in ((b' = b), b));;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let f x = let xx = (x * x) * x in (xx, (xx < 512)) in\n     ((wwhile (f, 2)), b));;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f x = (x * x) * x in ((xx, (xx < 512)), b));;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let b' = f b in ((f, (b' = b)), b));;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let b' = f b in wwhile ((f, (b' = b)), b);;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let b' = f b in wwhile ((f, (b' = b)), b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type ('d -> 'd * bool) * 'd\n"], "bad": ["\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let b' = f b in wwhile (f, (b' = b), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ( \nlet f' b' = ( f, b = b' ) in f b\n, b )"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"], "bad": ["\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' b' = f b in ((f, (b' = b)), b));;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' b' = f b in ((f', (b' = b)), b));;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let b' = f b in ((f, (b' = b)), b));;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let b' = f b in ((f, (b' = b)), b));;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ( \nlet f' = ( f, b = f b ) in f b\n, b )"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value b'\n"], "bad": ["\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let b' = (f, (b = b')) in ((f b), b));;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "Error: This expression has type (('a -> 'a * bool) -> 'a -> 'a * bool) * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside\n       (('a -> 'a * bool) -> 'a -> 'a * bool) * bool\n", "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "Error: Unbound value b'\n"], "bad": ["\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' = (f, (b = (f b))) in ((f b), b));;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' = (f, (b = (f b))) in ((f b), b));;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f, (b = (f b))), b);;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' = (f, (b = (f b))) in ((f b), b));;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' = (f, (b = (f b))) in ((f b), b));;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' = (f, (b = (f b))) in ((f b), f'));;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' = (f, ((f b) = b)) in ((f b), b));;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' b' = (f, ((f b) = b)) in ((f b), b));;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' b' = (f, ((f b) = b)) in ((f b), b'));;\n"]}
{"fix": ["wwhile (f,2)"], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let f' b = (f, ((f b) = b)) in ((f b), b));;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value b\n", "Error: Unbound value b\n", "Error: Unbound value b\n", "Error: Unbound value b\n", "Error: Unbound value b\n", "Error: Unbound value b\n"], "bad": ["\nlet f x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet f' b' = let bb = f b in (bb, (bb = (f b)));;\n", "\nlet f x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet f' b' = let bb = f b in (bb, (bb = (f b)));;\n", "\nlet f x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet f' b' = let bb = f b in (bb, (bb = (f b)));;\n", "\nlet f x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet f' b' = let bb = f b in (bb, (bb = (f b)));;\n", "\nlet f x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet f' b' = let bb = f b in (bb, (bb = (f b)));;\n", "\nlet f x = let xx = (x * x) * x in (xx, (xx < 512));;\n\nlet f' b' = let bb = f b in (bb, (bb = (f b)));;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  wwhile\n    (let f' b' = let bb = f b in (bb, (bb = (f b))) in ((wwhile (f', b)), b));;\n", "\nlet fixpoint (f,b) = wwhile (let f' b' = f b in ((f, ((f b) = b)), b));;\n"]}
{"fix": ["wwhile (f,2)"], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) = wwhile (let f' = f b in ((f', ((f b) = b)), b));;\n"]}
{"fix": [], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a\n", "Error: Unbound value a\n", "Error: This expression has type int -> 'a -> int\n       but an expression was expected of type 'a list\n", "Error: This expression has type int -> int\n       but an expression was expected of type 'a list\n", "Error: This expression has type 'a -> int\n       but an expression was expected of type 'a list\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = fs a in let base = fs x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = fs a in let base = fs in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = fs a x in let base = fs a in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = fs a x in let base = 0 in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = fs a in let base = 0 in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = fs x in let base = 0 in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs y = \nlet f a x = x a in\nlet base = y in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value a\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs y = \nlet f a x = x a in\nlet base = y in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value y\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = y in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = a  in\nlet base = fun x -> x  in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "bad": ["\nlet pipe fs = let f a x = a + x in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x  in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type ('a -> 'b) -> int\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b) -> int\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = a + (x a) in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = (a x) + (x a) in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun a -> x a  in\nlet base = fun x -> x  in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type int -> (int -> int) -> 'a -> 'b -> int\n       but an expression was expected of type int -> (int -> int) -> int\n       Type 'a -> 'b -> int is not compatible with type int \n"], "bad": ["\nlet pipe fs =\n  let f a x x' y = (x a) + a in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs y = \nlet f a x = x a in\nlet base = y  in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> int\n       but an expression was expected of type int\n"], "bad": ["\nlet pipe fs =\n  let f a x a = (x a) + x in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": [], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet cat = pipe [(fun x  -> x + x)];;\n", "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet cat = pipe [(fun x  -> x + x)];;\n", "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet cat = pipe [(fun x  -> x + x)];;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep ^ a in\nlet base = sepConcat sep t in\nlet l = t in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ a) in\n      let base = \"\" in let l = sepConcat sep t in List.fold_left f base l;;\n"]}
{"fix": ["let stringOfList f l = match l with\n[] -> \"\"\n| h::t -> \nlet f' a x = x ^ a in\nlet base = f h in\nlet l = t in\nList.fold_left f' base l"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: Unbound value stringOfList\n"], "bad": ["\nlet stringOfList f l =\n  match l with | [] -> \"\" | h::t -> (f h) ^ (stringOfList f t);;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet cat = pipe [(fun x  -> x + x)];;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type ('a -> 'a) -> 'a -> 'a\n       but an expression was expected of type 'b list\n"], "bad": ["\nlet pipe fs =\n  let f a x = x (x a) in let base x = x in List.fold_left f base fs;;\n\nlet cat = pipe [(fun x  -> x + x)];;\n", "\nlet pipe fs = let f a x = fs a in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value a\n", "Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun y -> y in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type (int -> int) -> int -> int\n       but an expression was expected of type\n         (int -> int) -> int -> int -> int\n       Type int is not compatible with type int -> int \n", "Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n", "Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"], "bad": ["\nlet pipe fs = let f a x = a + x in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = (a x) + x in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x x = a in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x y = a in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun y -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> 'a * 'b\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'a * 'b\n", "Error: This expression has type 'a -> 'b -> 'c -> 'd -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'd -> 'a\n"], "bad": ["\nlet pipe fs =\n  let f a x = (a, x) in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x y x = a in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun y -> x ( a y ) in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "bad": ["\nlet pipe fs = let f a x y = x a in let base x = x in List.fold_left f base fs;;\n\nlet cat = pipe [(fun x  -> x + x)];;\n", "\nlet pipe fs = let f a x y = x a in let base x = x in List.fold_left f base fs;;\n\nlet cat = pipe [(fun x  -> x + x)] 3;;\n"]}
{"fix": [], "hw": "hw3", "problem": "padZero", "message": ["Error: Unbound value List.size\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.size l1) > (List.size l2)\n  then (l1, (List.append ((clone 0 ((List.size l1) - (List.size l2))), l2)))\n  else\n    if (List.size l1) < (List.size l2)\n    then ((List.append (clone 0 ((List.size l2) - (List.size l1)) l1)), l2)\n    else (l1, l2);;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    (l1, (List.append ((clone 0 ((List.length l1) - (List.length l2))), l2)))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      ((List.append (clone 0 ((List.length l2) - (List.length l1)) l1)), l2)\n    else (l1, l2);;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    (l1, (List.append ((clone 0 (List.length l1)) - (List.length l2))), l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      ((List.append (clone 0 ((List.length l2) - (List.length l1)) l1)), l2)\n    else (l1, l2);;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    (l1, (List.append ((clone 0 ((List.length l1) - (List.length l2))), l2)))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      ((List.append (clone 0 ((List.length l2) - (List.length l1)) l1)), l2)\n    else (l1, l2);;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append clone 0 ((List.length l1) - (List.length l2))), l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      ((List.append (clone 0 ((List.length l2) - (List.length l1)) l1)), l2)\n    else (l1, l2);;\n"]}
{"fix": ["clone 0 5"], "hw": "hw3", "problem": "clone", "message": ["Error: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet a = [1; 2; 3];;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet _ = List.append clone 0 5 a;;\n", "\nlet a = [1; 2; 3];;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet _ = List.append clone (0 5) a;;\n"]}
{"fix": ["let rec padZero l1 l2 = \nlet diffsize = List.length l1 - List.length l2 in\nif diffsize > 0 then\n( l1, List.append (clone 0 diffsize) l2 )\nelse\n( (List.append (clone 0 ((List.length l1) - (List.length l2))) l1),  l2 )"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type\n         'c list * (int list -> int list) * 'd list\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type 'a list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type\n         'c list * (int list -> int list) * 'd list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type\n         'c list * (int list -> int list) * 'd list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    (l1, (List.append (clone 0 ((List.length l1) - (List.length l2)))), l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      ((List.append (clone 0 ((List.length l2) - (List.length l1)) l1)), l2)\n    else (l1, l2);;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    (l1, (List.append (clone 0 ((List.length l1) - (List.length l2)))), l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      ((List.append (clone 0 ((List.length l1) - (List.length l2)))), l1, l2)\n    else (l1, l2);;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    (l1, (List.append (clone 0 ((List.length l1) - (List.length l2)))), l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      ((List.append (clone 0 ((List.length l1) - (List.length l2))) l1), l2)\n    else (l1, l2);;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    (l1, (List.append (clone 0 ((List.length l1) - (List.length l2)))), l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      ((List.append (clone 0 ((List.length l1) - (List.length l2))) l1), l2)\n    else (l1, l2);;\n"]}
{"fix": ["let rec padZero l1 l2 = \nlet diffsize = List.length l1 - List.length l2 in\nif diffsize > 0 then\n( l1, List.append (clone 0 diffsize) l2 )\nelse\n( List.append (clone 0 ( -1 * diffsize )) l1,  l2 )"], "hw": "hw3", "problem": "padZero", "message": ["Error: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append clone 0 ((-1) * diffsize) l1), l2);;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type\n         int list -> int list * int list -> 'a list * int list\n       but an expression was expected of type\n         int list -> int list * int list -> int list\n       Type 'a list * int list is not compatible with type int list \n", "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type int list * int list\n       but an expression was expected of type int list list * int list list\n       Type int is not compatible with type int list \n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type int list\n", "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type int list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1::t1,h2::t2) -> ((h1 + h2) / 10) :: ((h1 + h2) mod 10) :: a\n      | _ -> a in\n    let base = [0] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1::t1,h2::t2) ->\n          ([], (((h1 + h2) / 10) :: ((h1 + h2) mod 10) :: a))\n      | _ -> ([], a) in\n    let base = [0] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1::t1,h2::t2) -> ((h1 + h2) / 10) :: ((h1 + h2) mod 10) :: a\n      | _ -> a in\n    let base = [0] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1::t1,h2::t2) -> ((h1 + h2) / 10) :: ((h1 + h2) mod 10) :: a\n      | _ -> a in\n    let base = [0] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> ((h1 + h2) / 10) :: ((h1 + h2) mod 10) :: a\n      | _ -> a in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> ((h1 + h2) / 10) :: ((h1 + h2) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> ((h1 + h2) / 10) :: ((h1 + h2) mod 10) :: a\n      | _ -> a in\n    let base = ([], []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int list list\n       but an expression was expected of type int list\n       Type int list is not compatible with type int \n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> (removeZero (((h1 + h2) / 10) :: ((h1 + h2) mod 10))) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> (removeZero (((h1 + h2) / 10) :: ((h1 + h2) mod 10))) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> (removeZero (((h1 + h2) / 10) :: ((h1 + h2) mod 10))) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> (removeZero (((h1 + h2) / 10) :: ((h1 + h2) mod 10))) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (h1,h2) -> (removeZero [(h1 + h2) / 10; (h1 + h2) mod 10]) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This function has type int list -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = (bigAdd l l) + (mulByDigit (i - 1) l);;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = bigAdd bigAdd (l l) (mulByDigit (i - 1) l);;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = bigAdd ((bigAdd (l l)), (mulByDigit (i - 1) l));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = bigAdd (bigAdd (l l)) (mulByDigit (i - 1) l);;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = match x with\n| (x1, x2) -> match a with\n( h1, h2::t2) -> let mul = x1 * x2 * h1 + h2 in\n( ( h1 + 1 ) , (mul / 10)::( mul mod 10 )::t2)\n| (_,_) -> (0,[0]) in\nlet base = (1,[0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int but an expression was expected of type\n         int * int\n", "Error: This expression has type int but an expression was expected of type\n         int * int\n"], "bad": ["\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (x1,x2) ->\n        (match a with\n         | (h1,h2::t2) ->\n             let mul = ((x1 * x2) * h1) + h2 in ((h1 + 1), (mul / 10)) ::\n               (mul mod 10) :: t2\n         | (_,_) -> (0, [0])) in\n  let base = (1, [0]) in\n  let args = List.rev (List.combine l1 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (x1,x2) ->\n        (match a with\n         | (h1,h2::t2) ->\n             let mul = ((x1 * x2) * h1) + h2 in ((h1 + 1), (mul / 10)) ::\n               (mul mod 10) :: t2\n         | (_,_) -> (0, [0])) in\n  let base = (1, [0]) in\n  let args = List.rev (List.combine l1 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = \nlet ( l1', l2' ) = x in\nlet ( pos, total ) = a in\nmatch l2' with\n[] -> []\n| h::t -> ( (pos + 1),  (\\total ) in\nlet base = (0,[0]) in\nlet args = (List.rev l1, List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',l2') = x in\n    let (pos,total) = a in\n    match l2' with\n    | [] -> []\n    | h::t -> ((pos + 1), (bigAdd (mulByDigit ((10 ** pos) * h) l2) total)) in\n  let base = (0, [0]) in\n  let args = ((List.rev l1), (List.rev l2)) in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',l2') = x in\n    let (pos,total) = a in\n    match l2' with\n    | [] -> []\n    | h::t -> ((pos + 1), (bigAdd (mulByDigit ((10 ** pos) * h) l2) total)) in\n  let base = (0, [0]) in\n  let args = ((List.rev l1), (List.rev l2)) in\n  let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "bad": ["\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',l2') = x in\n    let (pos,total) = a in\n    match l2' with | [] -> [] | h::t -> ((pos + 1), total) in\n  let base = (0, [0]) in\n  let args = ((List.rev l1), (List.rev l2)) in\n  let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = \nlet ( pos, total ) = a in\n( pos + 1, mulByDigit (int_of_float (10.0 ** float_of_int pos)) l2 ) in \nlet base = (0,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = let (pos,total) = a in ((pos + 1), (mulByDigit (10 ** pos) l2)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pos,total) = a in ((pos + 1), (mulByDigit (10.0 ** pos) l2)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  let diffsize = (List.length l1) - (List.length l2) in\n  if diffsize > 0\n  then (l1, (List.append (clone 0 diffsize) l2))\n  else ((List.append (clone 0 ((-1) * diffsize)) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (_,h2::t2) ->\n               let sum = (x1 + x2) + h2 in\n               ((sum / 10), ((sum / 10) :: (sum mod 10) :: t2))\n           | (_,_) -> (0, [0])) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (pos,total) = a in\n    ((pos + 1), (mulByDigit (10.0 ** (float_of_int pos)) l2)) in\n  let base = (0, [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value %\n"], "bad": ["\nlet rec digitsOfInt n = if (n % 2) = 0 then 1 else [];;\n"]}
{"fix": ["let rec sumList xs = \nif xs = [] then 0\nelse let h::t = xs in\nh + (sumList t)"], "hw": "hw1", "problem": "sumList", "message": ["Error: Unbound value hd\n", "Error: Unbound value hd\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec sumList xs =\n  if (hd xs) = [] then 0 else (let h::t = xs in h + (sumList t));;\n", "\nlet rec sumList xs =\n  if (xs hd xs) = [] then 0 else (let h::t = xs in h + (sumList t));;\n", "\nlet rec sumList xs =\n  if (List.hd xs) = [] then 0 else (let h::t = xs in h + (sumList t));;\n"]}
{"fix": ["let rec additivePersistence n = \nif (n / 10) = 0 then n\nelse additivePersistence (sumList (digits n))"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec digitsOfInt n =\n  if ((n mod 2) = 0) && (n > 0)\n  then\n    let rec loop input =\n      if input = 0 then [] else (loop (input / 10)) @ [input mod 10] in\n    loop n\n  else [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs =\n  if xs = [] then 0 else (let h::t = xs in h + (sumList t));;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0 then n else additivePersistence (sumList digits n);;\n"]}
{"fix": ["let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if ((List.tl lst) = lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false"], "hw": "hw1", "problem": "palindrome", "message": ["Error: Unbound value List.size\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.size lst) < 2\n    then []\n    else\n      if (List.hd lst) = (List.tl lst)\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.size (palHelper wEx)) = 0 then true else false;;\n", "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.length lst) < 2\n    then []\n    else\n      if (List.hd lst) = (List.tl lst)\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.length (palHelper wEx)) = 0 then true else false;;\n", "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.length lst) < 2\n    then []\n    else\n      if (List.hd lst) = (List.tl lst)\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.length (palHelper wEx)) = 0 then true else false;;\n", "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.length lst) < 2\n    then []\n    else\n      if (List.tl lst) = (List.hd lst)\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.length (palHelper wEx)) = 0 then true else false;;\n", "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.length lst) < 2\n    then []\n    else\n      if (List.tl lst) == (List.hd lst)\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.length (palHelper wEx)) = 0 then true else false;;\n", "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.length lst) < 2\n    then []\n    else\n      if (List.tl lst) = (List.hd lst)\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.length (palHelper wEx)) = 0 then true else false;;\n"]}
{"fix": ["let rec digitsOfInt n = \nif (n mod 2 = 0) && (n > 0) then\nlet rec loop input =\nif input < 10 then [input]\nelse let [y] = (loop (input / 10)) in\ny::[(input mod 10)]\nin loop n\nelse []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  if ((n mod 2) = 0) && (n > 0)\n  then\n    let rec loop input =\n      if input < 10 then input else [loop (input / 10); input mod 10] in\n    loop n\n  else [];;\n"]}
{"fix": ["let fixpoint (f,b) = \nlet y = (f b) in match y with\n| (aPrime, _) -> \nif b = aPrime then b\nelse fixpoint (f, aPrime)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet fixpoint (f,b) = if b = (f b) then b else fixpoint (f, (f b));;\n", "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet fixpoint (f,b) = let y = f b in if b = y then b else fixpoint (f, y);;\n", "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet fixpoint (f,b) = let y = f b in if b = y then b else fixpoint (f, y);;\n", "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet fixpoint (f,b) = let y = f b in if b = y then b else fixpoint (f, y);;\n", "\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet fixpoint (f,b) =\n  let y = f b in\n  match y with | aPrime -> if b = aPrime then b else fixpoint (f, aPrime);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile( f,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"], "bad": ["\nlet rec wwhile (f,b) =\n  let y = f b in match y with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet fixpoint (f,b) =\n  let y = f b in\n  match y with | (aPrime,_) -> if b = aPrime then b else fixpoint (f, aPrime);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| Thresh (e1,e2,e3,e4) ->\nif (eval (e1,x,y)) < (eval (e2,x,y))\nthen (eval (e3,x,y))\nelse (eval (e4,x,y))\n| Times (e1,e2) -> (eval (e1,x,y)) *. (eval (e2,x,y))\n| Average (e1,e2) -> ( (eval (e1,x,y)) +. (eval (e2,x,y)) ) /. 2.0\n| Cosine (e1) -> cos ( 3.142 *. (eval (e1,x,y)) )\n| Sine (e1) -> sin ( 3.142 *. (eval (e1,x,y)) )\n| VarY -> y\n| VarX -> x"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2.0\n  | Cosine e1 -> cos (3.142 *. (eval (e1, x, y)))\n  | Sine e1 -> sin (3.142 *. (eval (e1, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      if y = 2\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if y = 3\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if y = 4\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if y = 5\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if y = 6\n              then\n                buildThresh\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                    (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      if y = 2\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if y = 3\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if y = 4\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if y = 5\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      if y = 2\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if y = 3\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if y = 4\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if y = 5\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if y = 6\n              then\n                buildThresh\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                    (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      if y = 2 then buildSine (build (rand, (depth - 1)));;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let temp = (rand (0, 1)) = 0 in if temp then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      if y = 2\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if y = 3\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if y = 4\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if y = 5\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if y = 6\n              then\n                buildThresh\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                    (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      if y = 2\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if y = 3\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if y = 4\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if y = 5\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if y = 6\n              then\n                buildThresh\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                    (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"]}
{"fix": ["let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in build(rand , y-1)"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      if y = 2 then buildSine (build (rand, (depth - 1)));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      if y = 2 then buildSine (build (rand, (depth - 1)));;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ ->\n      let y = rand (2, 6) in\n      if y = 2\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if y = 3\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if y = 4\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if y = 5\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if y = 6\n              then\n                buildThresh\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                    (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ -> let y = rand (2, 6) in if y = 2 then buildX ();;\n"]}
{"fix": ["let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nbuildX()"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type int but an expression was expected of type\n         expr\n", "Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type int but an expression was expected of type\n         unit\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ -> let y = rand (2, 6) in if y = 2 then buildX ();;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ -> let y = rand (2, 6) in if y == 2 then buildX ();;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ -> let y = rand (2, 6) in if y = 2 then 5;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ -> let y = rand (2, 6) in y;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n  | _ -> let y = rand (2, 6) in if y = 2 then y;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in if y = 2 then y);;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         unit\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in if y = 2 then buildX ());;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type bool but an expression was expected of type\n         expr\n", "Error: This expression has type int but an expression was expected of type\n         unit\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in if y = 2 then y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in y = 2);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in if y = 2 then y);;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type int but an expression was expected of type\n         unit\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in if y = 2 then y);;\n"]}
{"fix": ["buildX()"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type int but an expression was expected of type\n         unit\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then VarX else VarY)\n  else (let y = rand (2, 6) in if y = 2 then y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then VarX else VarY)\n  else (let y = rand (2, 6) in if y = 2 then y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in if y = 2 then y);;\n"]}
{"fix": ["let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in\nbuildX()"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: Unbound value depth\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0 then (if (rand (0, 1)) = 0 then buildX () else buildY ());;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rand (a,b) = if a < b then a else b;;\n\nlet _ =\n  if depth = 0 then (if (rand (0, 1)) = 0 then buildX () else buildY ());;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0 then (if (rand (0, 1)) = 0 then buildX () else buildY ());;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else (let y = rand (2, 6) in if y = 2 then y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0 then (if (rand (0, 1)) = 0 then buildX () else buildY ());;\n"]}
{"fix": ["let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in\nbuildX()"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         unit\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0 then (if (rand (0, 1)) = 0 then buildX () else buildY ());;\n"]}
{"fix": [], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> (('a -> 'b) -> 'a) -> 'b\n       but an expression was expected of type\n         ('a -> 'b) -> (('a -> 'b) -> 'a) -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs =\n  let f a x = a (x a) in let base y = y in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base y = y in List.fold_left f base fs;;\n"]}
{"fix": ["let stringOfList f l = sepConcat \"; \" (List.append (\"[\"::List.map f l) [\"]\"])"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type string\n", "Error: This expression has type 'a list\n       but an expression was expected of type string\n", "Error: This expression has type string but an expression was expected of type\n         string list\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" [\"[\"; List.map f l; \"]\"];;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" [[\"[\"]; List.map f l; [\"]\"]];;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  sepConcat \"; \" (List.append (\"[\" :: (List.map f l)) \"]\");;\n"]}
{"fix": ["let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\""], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" List.map f l) ^ \"]\");;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([],r) , acc) -> failwith \"should never reach here\"\n| ((h::[],r), acc) -> (([],0), r::acc)\n| ((h::t,r) , acc) -> \nlet sum = h+x+r in\n((t,sum/10), (sum mod 10)::acc)\nin\nlet (pad1, pad2) = padZero l1 l2 in\nlet base = ((List.rev pad1,0) , []) in\nlet args = (List.rev pad2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value %\n", "Error: Unbound value %\n", "Error: Unbound value %\n", "Error: This expression has type 'a list\n       but an expression was expected of type int * int list\n", "Error: This expression has type int list * int list\n       but an expression was expected of type int * int\n       Type int list is not compatible with type int \n", "Error: This expression has type int list * int list\n       but an expression was expected of type int * int\n       Type int list is not compatible with type int \n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type int * int list\n       Type 'a list is not compatible with type int \n", "Error: This expression has type int list * int list\n       but an expression was expected of type int * int\n       Type int list is not compatible with type int \n", "Error: This expression has type int list * int list\n       but an expression was expected of type int * int\n       Type int list is not compatible with type int \n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int list\n       but an expression was expected of type int list * int list\n", "Error: This expression has type 'a * int list -> int list -> int list\n       but an expression was expected of type\n         'a * int list -> int list -> 'a * int list\n       Type int list is not compatible with type 'a * int list \n", "Error: This expression has type int list * int list\n       but an expression was expected of type int * int\n       Type int list is not compatible with type int \n", "Error: This expression has type int list * int list\n       but an expression was expected of type int * int\n       Type int list is not compatible with type int \n", "Error: This expression has type int list * 'a list\n       but an expression was expected of type (int list * int) * int list\n       Type int list is not compatible with type int list * int \n"], "bad": ["\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,acc) ->\n          let (padded1,padded2) = padZero acc x in\n          let rec helper acc2 r lst1 lst2 =\n            match lst1 with\n            | [] -> (match r with | 0 -> acc2 | _ -> List.append acc2 [r])\n            | h1::t1 ->\n                (match lst2 with\n                 | [] -> failwith \"Should never reach here!\"\n                 | h2::t2 ->\n                     let sum = (h1 + h2) + r in\n                     helper ((sum % 10) :: acc2) (sum / 10) t1 t2) in\n          (0, (helper [] 0 padded1 padded2)) in\n    let base = [] in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,acc) ->\n          let (padded1,padded2) = padZero acc x in\n          let rec helper acc2 r lst1 lst2 =\n            match lst1 with\n            | [] -> (match r with | 0 -> acc2 | _ -> List.append acc2 [r])\n            | h1::t1 ->\n                (match lst2 with\n                 | [] -> failwith \"Should never reach here!\"\n                 | h2::t2 ->\n                     let sum = (h1 + h2) + r in\n                     helper ((sum % 10) :: acc2) (sum / 10) t1 t2) in\n          (0, (helper [] 0 padded1 padded2)) in\n    let base = [] in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,acc) ->\n          let (padded1,padded2) = padZero acc x in\n          let rec helper acc2 r lst1 lst2 =\n            match lst1 with\n            | [] -> (match r with | 0 -> acc2 | _ -> List.append acc2 [r])\n            | h1::t1 ->\n                (match lst2 with\n                 | [] -> failwith \"Should never reach here!\"\n                 | h2::t2 ->\n                     let sum = (h1 + h2) + r in\n                     helper ((sum % 10) :: acc2) (sum / 10) t1 t2) in\n          (0, (helper [] 0 padded1 padded2)) in\n    let base = [] in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,acc) ->\n          let (padded1,padded2) = padZero acc x in\n          let rec helper acc2 r lst1 lst2 =\n            match lst1 with\n            | [] -> (match r with | 0 -> acc2 | _ -> List.append acc2 [r])\n            | h1::t1 ->\n                (match lst2 with\n                 | [] -> failwith \"Should never reach here!\"\n                 | h2::t2 ->\n                     let sum = (h1 + h2) + r in\n                     helper ((sum mod 10) :: acc2) (sum / 10) t1 t2) in\n          (0, (helper [] 0 padded1 padded2)) in\n    let base = [] in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,acc) ->\n          let (padded1,padded2) = padZero acc x in\n          let rec helper acc2 r lst1 lst2 =\n            match lst1 with\n            | [] -> (match r with | 0 -> acc2 | _ -> List.append acc2 [r])\n            | h1::t1 ->\n                (match lst2 with\n                 | [] -> failwith \"Should never reach here!\"\n                 | h2::t2 ->\n                     let sum = (h1 + h2) + r in\n                     helper ((sum mod 10) :: acc2) (sum / 10) t1 t2) in\n          (0, (helper [] 0 padded1 padded2)) in\n    let base = (0, []) in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,acc) ->\n          let (padded1,padded2) = padZero acc x in\n          let rec helper acc2 r lst1 lst2 =\n            match lst1 with\n            | [] -> (match r with | 0 -> acc2 | _ -> List.append acc2 [r])\n            | h1::t1 ->\n                (match lst2 with\n                 | [] -> failwith \"Should never reach here!\"\n                 | h2::t2 ->\n                     let sum = (h1 + h2) + r in\n                     helper ((sum mod 10) :: acc2) (sum / 10) t1 t2) in\n          (0, (helper [] 0 padded1 padded2)) in\n    let base = (0, []) in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,acc) ->\n          let (padded1,padded2) = padZero acc x in\n          let rec helper acc2 r lst1 lst2 =\n            match lst1 with\n            | [] -> (match r with | 0 -> acc2 | _ -> List.append acc2 [r])\n            | h1::t1 ->\n                (match lst2 with\n                 | [] -> failwith \"Should never reach here!\"\n                 | h2::t2 ->\n                     let sum = (h1 + h2) + r in\n                     helper ((sum mod 10) :: acc2) (sum / 10) t1 t2) in\n          (0, (helper [] 0 padded1 padded2)) in\n    let base = ([], []) in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,acc) ->\n          let (padded1,padded2) = padZero acc x in\n          let rec helper acc2 r lst1 lst2 =\n            match lst1 with\n            | [] -> (match r with | 0 -> acc2 | _ -> List.append acc2 [r])\n            | h1::t1 ->\n                (match lst2 with\n                 | [] -> failwith \"Should never reach here!\"\n                 | h2::t2 ->\n                     let sum = (h1 + h2) + r in\n                     helper ((sum mod 10) :: acc2) (sum / 10) t1 t2) in\n          ([], (helper [] 0 padded1 padded2)) in\n    let base = ([], []) in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,acc) ->\n          let (padded1,padded2) = padZero acc x in\n          let rec helper acc2 r lst1 lst2 =\n            match lst1 with\n            | [] -> (match r with | 0 -> acc2 | _ -> List.append acc2 [r])\n            | h1::t1 ->\n                (match lst2 with\n                 | [] -> failwith \"Should never reach here!\"\n                 | h2::t2 ->\n                     let sum = (h1 + h2) + r in\n                     helper ((sum mod 10) :: acc2) (sum / 10) t1 t2) in\n          ([], (helper [] 0 (List.rev padded1) (List.rev padded2))) in\n    let base = ([], []) in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let g =\n        (fun (c,d)  -> List.rev c; List.rev d)\n          (padZero ((fun (a,b)  -> b) a) x) in\n      let rec helper acc r (lst1,lst2) =\n        if lst1 = []\n        then acc\n        else\n          (let h1::t1 = lst1 in\n           let h2::t2 = lst2 in\n           let sum = (h1 + h2) + r in (helper (sum mod 10)) ::\n             (acc (sum / 10) (t1, t2))) in\n      helper [] 0 g in\n    let base = ([], []) in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let g =\n        (fun (c,d)  -> List.rev c; List.rev d)\n          (padZero ((fun (a,b)  -> b) a) x) in\n      let rec helper acc r (lst1,lst2) =\n        if lst1 = []\n        then acc\n        else\n          (let h1::t1 = lst1 in\n           let h2::t2 = lst2 in\n           let sum = (h1 + h2) + r in\n           helper ((sum mod 10) :: acc) (sum / 10) (t1, t2)) in\n      helper [] 0 g in\n    let base = ([], []) in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let g =\n        (fun (c,d)  -> ((List.rev c), (List.rev d)))\n          (padZero ((fun (a,b)  -> b) a) x) in\n      let rec helper acc r (lst1,lst2) =\n        if lst1 = []\n        then acc\n        else\n          (let h1::t1 = lst1 in\n           let h2::t2 = lst2 in\n           let sum = (h1 + h2) + r in\n           helper ((sum mod 10) :: acc) (sum / 10) (t1, t2)) in\n      helper [] 0 g in\n    let base = ([], []) in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let g =\n        (fun (c,d)  -> ((List.rev c), (List.rev d)))\n          (padZero ((fun (a,b)  -> b) a) x) in\n      let rec helper acc r (lst1,lst2) =\n        if lst1 = []\n        then acc\n        else\n          (let h1::t1 = lst1 in\n           let h2::t2 = lst2 in\n           let sum = (h1 + h2) + r in\n           helper ((sum mod 10) :: acc) (sum / 10) (t1, t2)) in\n      ([], (helper [] 0 g)) in\n    let base = ([], []) in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let g =\n        (fun (c,d)  -> ((List.rev c), (List.rev d)))\n          (padZero ((fun (q,r)  -> r) a) x) in\n      let rec helper acc r (lst1,lst2) =\n        if lst1 = []\n        then acc\n        else\n          (let h1::t1 = lst1 in\n           let h2::t2 = lst2 in\n           let sum = (h1 + h2) + r in\n           helper ((sum mod 10) :: acc) (sum / 10) (t1, t2)) in\n      ([], (helper [] 0 g)) in\n    let base = ([], []) in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (([],r),acc) -> failwith \"should never reach here\"\n      | ((h::[],r),acc) -> (([], 0), (r :: acc))\n      | ((h::t,r),acc) ->\n          let sum = (h + x) + r in ((t, (sum / 10)), ((sum mod 10) :: acc)) in\n    let (pad1,pad2) = padZero l1 l2 in\n    let base = ((List.rev pad1), []) in\n    let args = List.rev pad2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigMul l1 l2 = \nif (l1 = [] || l2 = []) then []\nelse\nlet f a x = match a with\n| ((lst,decPlace), acc) ->\n((lst,decPlace+1), bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in\nlet base = ((l1,0), []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type 'a * int\n       This is not a function; it cannot be applied.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a * int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a * int\n       This is not a function; it cannot be applied.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a * int\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (([],r),acc) -> failwith \"should never reach here\"\n      | ((h::[],r),acc) ->\n          let sum = (h + x) + r in\n          (([], 0), ((sum / 10) :: (sum mod 10) :: acc))\n      | ((h::t,r),acc) ->\n          let sum = (h + x) + r in ((t, (sum / 10)), ((sum mod 10) :: acc)) in\n    let (pad1,pad2) = padZero l1 l2 in\n    let base = (((List.rev pad1), 0), []) in\n    let args = List.rev pad2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (([],_),acc) -> failwith \"should never reach here\"\n    | ((h::[],r),acc) ->\n        let sum = (h * i) + r in\n        (([], 0), ((sum / 10) :: (sum mod 10) :: acc))\n    | ((h::t,r),acc) ->\n        let sum = (h * i) + r in ((t, (sum / 10)), ((sum mod 10) :: acc)) in\n  let base = (((List.rev l), 0), []) in\n  let args = List.rev l in\n  let (_,res) = List.fold_left f base args in removeZero res;;\n\nlet bigMul l1 l2 =\n  if (l1 = []) || (l2 = [])\n  then []\n  else\n    (let f a x =\n       match a with\n       | ((lst,decPlace),acc) ->\n           (lst, (decPlace + 1)) bigAdd acc\n             (List.append (mulByDigit x lst) (clone 0 decPlace)) in\n     let base = (l1, []) in\n     let args = l2 in let (_,res) = List.fold_left f base args in res);;\n", "\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (([],r),acc) -> failwith \"should never reach here\"\n      | ((h::[],r),acc) ->\n          let sum = (h + x) + r in\n          (([], 0), ((sum / 10) :: (sum mod 10) :: acc))\n      | ((h::t,r),acc) ->\n          let sum = (h + x) + r in ((t, (sum / 10)), ((sum mod 10) :: acc)) in\n    let (pad1,pad2) = padZero l1 l2 in\n    let base = (((List.rev pad1), 0), []) in\n    let args = List.rev pad2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | (([],_),acc) -> failwith \"should never reach here\"\n    | ((h::[],r),acc) ->\n        let sum = (h * i) + r in\n        (([], 0), ((sum / 10) :: (sum mod 10) :: acc))\n    | ((h::t,r),acc) ->\n        let sum = (h * i) + r in ((t, (sum / 10)), ((sum mod 10) :: acc)) in\n  let base = (((List.rev l), 0), []) in\n  let args = List.rev l in\n  let (_,res) = List.fold_left f base args in removeZero res;;\n\nlet bigMul l1 l2 =\n  if (l1 = []) || (l2 = [])\n  then []\n  else\n    (let f a x =\n       match a with\n       | ((lst,decPlace),acc) ->\n           (lst, (decPlace + 1)) bigAdd acc\n             (List.append (mulByDigit x lst) (clone 0 decPlace)) in\n     let base = ((l1, 0), []) in\n     let args = l2 in let (_,res) = List.fold_left f base args in res);;\n"]}
{"fix": ["let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt (n/10)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value digitsofInt\nHint: Did you mean digitsOfInt?\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: ((digitsofInt n) / (10 s));;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: ((digitsOfInt n) / (10 s));;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: ((digitsOfInt n) / 10);;\n"]}
{"fix": ["let rec digitsOfInt n = if n <= 0 then [] else n mod 10 :: digitsOfInt (n/10)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) @ (digitsOfInt (n / 10));;\n"]}
{"fix": ["let digitsOfInt n = \nlet rec digitsHelper n l = if n = 0 then l else digitsHelper (n/10) (n mod 10::l)\nin\nif n<=0 then [] else digitsHelper n []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value digitsHelper\n", "Error: Unbound value digitsHelper\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec digitsOfInt n = if n <= 0 then [] else digitsHelper n [];;\n", "\nlet rec digitsOfInt n = if n <= 0 then [] else digitsHelper n [];;\n", "\nlet digitsOfInt n =\n  let rec digitsHelper n l = if n = 0 then l else (((n / 10) n) mod 10) :: l in\n  if n <= 0 then [] else digitsHelper n [];;\n", "\nlet digitsOfInt n =\n  let rec digitsHelper n l = if n = 0 then l else (n / 10) ((n mod 10) :: l) in\n  if n <= 0 then [] else digitsHelper n [];;\n"]}
{"fix": ["let rec digitalRoot n = \nlet rec digHelper n = if n < 10 then n else digHelper (sumList (digitsOfInt n))\nin\ndigHelper n"], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let rec digHelper n = if n < 10 then n else digHelper (sumList n) in\n  digHelper n;;\n"]}
{"fix": ["let rec listReverse l = \nlet rec listHelper l l2 = match l with\n| [] -> l2 \n| h::t -> listHelper t (h::l2)\nin\nlistHelper l []"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec listReverse l =\n  let rec listHelper l l2 =\n    match l with | [] -> l2 | h::t -> (listHelper t h) :: l2 in\n  listHelper l [];;\n"]}
{"fix": ["let palindrome w = if (listReverse (explode w)) = explode w then true else false"], "hw": "hw1", "problem": "palindrome", "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec listHelper l l2 =\n    match l with | [] -> l2 | h::t -> listHelper t (h :: l2) in\n  listHelper l [];;\n\nlet palindrome w =\n  if (listReverse explode w) = (explode w) then true else false;;\n"]}
{"fix": ["let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t"], "hw": "hw1", "problem": "sumList", "message": ["Error: This expression has type int list -> int\n       but an expression was expected of type int\n"], "bad": ["\nlet rec sumList xs = function | [] -> 0 | h::t -> h + (sumList t);;\n"]}
{"fix": ["let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> if fst h = k then snd h else assoc (d, k, t)"], "hw": "hw2", "problem": "assoc", "message": ["Error: This function has type bool * 'a * ('a * 'b) list -> bool\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type bool\n       This is not a function; it cannot be applied.\n", "Error: This expression has type ('a * ('a -> 'b -> 'c)) list\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside ('a * ('a -> 'b -> 'c)) list\n", "Error: This expression has type ('a * ('a -> 'b -> 'c)) list\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside ('a * ('a -> 'b -> 'c)) list\n", "Error: This expression has type ('a * ('a -> 'b -> 'c)) list\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside ('a * ('a -> 'b -> 'c)) list\n", "Error: This expression has type ('a * ('a -> 'b -> 'c)) list\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside ('a * ('a -> 'b -> 'c)) list\n"], "bad": ["\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then true else assoc d k t;;\n", "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then true else assoc (d k t);;\n", "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d k t);;\n", "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | ((s,i) as h)::t -> if s = k then i else assoc (d k t);;\n", "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | ((s,i) as h)::t -> if s = k then i else assoc (d k t);;\n", "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> if (fst h) = k then snd h else assoc (d k t);;\n"]}
{"fix": ["let rec wwhile (f,b) = if snd (f b) then wwhile (f, fst (f b)) else fst (f b)"], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type 'a * ('b -> bool)\n       but an expression was expected of type ('a * ('b -> bool)) * 'b\n"], "bad": ["\nlet rec wwhile (f,b) = if snd f b then wwhile f fst f b else fst f b;;\n"]}
{"fix": ["let rec wwhile (f,b) = \nlet (b',c') = f b in \nif c' then wwhile (f,b') else b'"], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type 'a -> 'b * bool\n       but an expression was expected of type ('a -> 'b * bool) * 'a\n"], "bad": ["\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile f b' else b';;\n"]}
{"fix": ["let fixpoint (f,b) = let fx b' = (f b', f b' = b') in\nwwhile(fx,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type ('d -> 'd * bool) * 'd\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type bool -> bool * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"], "bad": ["\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((if (f b) = b then (true, b) else (false, b)), b);;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((((f b) = b), (f b)), b);;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f b), ((f b) = b), b);;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (if (f b) = b then ((f b), true) else (((f b), false), b));;\n", "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((if (f b) = b then ((f b), true) else ((f b), false)), b);;\n"]}
{"fix": ["let fixpoint (f,b) = \nlet fx b = (f b, not f b = b) in\nwwhile(fx,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) = let fx = ((f b), ((f b) = b)) in wwhile (fx, b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This function has type bool -> bool\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet fixpoint (f,b) = let fx b = ((f b), ((not f b) = b)) in wwhile (fx, b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "expr", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "\nlet fixpoint (f,b) = wwhile (fun x  -> ((f x), (not ((f x) = x)), b));;\n", "\nlet fixpoint (f,b) = wwhile (fun x  -> (((f x), (not ((f x) = x))), b));;\n", "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "\nlet fixpoint (f,b) = wwhile (fun x  -> ((f x not ((f x) = x)), b));;\n", "\nlet fixpoint (f,b) = wwhile ((fun x  -> f x not ((f x) = x)), b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "expr", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type string but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (exprToString e1))\n  | Cosine e1 -> cos (pi * (exprToString e1))\n  | Average (e1,e2) -> ((exprToString e1) + (exprToString e2)) / 2\n  | Times (e1,e2) -> (exprToString e1) * (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      ((exprToString e1) < (exprToString e2 ?exprToString e3) : exprToString\n                                                                  e4);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (exprToString e1))\n  | Cosine e1 -> cos (pi *. (exprToString e1))\n  | Average (e1,e2) -> ((exprToString e1) +. (exprToString e2)) /. 2\n  | Times (e1,e2) -> (exprToString e1) *. (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      ((exprToString e1) < (exprToString e2 ?exprToString e3) : exprToString\n                                                                  e4);;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: This expression has type expr/1050\n       but an expression was expected of type expr/1298\nError: This expression has type expr/1576\n       but an expression was expected of type expr/1596\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type expr/1050\n       but an expression was expected of type expr/1298\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr/1050\n       but an expression was expected of type expr/1650\nError: This expression has type expr/1703\n       but an expression was expected of type expr/1723\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type expr/1050\n       but an expression was expected of type expr/1650\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n"]}
{"fix": ["let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))"], "hw": "hw2", "problem": "build", "message": ["Error: This function has type int * int -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int * int -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "Error: Unbound value n\n", "Error: Unbound value n\n", "Error: Unbound value n\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let expChooser (r,d) =\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (d - 1)))\n    | 3 -> buildCosine (build (rand, (d - 1)))\n    | 4 -> buildAverage ((build (rand, (d - 1))), (build (rand, (d - 1))))\n    | 5 -> buildTimes ((build (rand, (d - 1))), (build (rand, (d - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (d - 1))), (build (rand, (d - 1))),\n            (build (rand, (d - 1))), (build (rand, (d - 1)))) in\n  if depth < 1 then expChooser rand (0, 2) else expChooser rand (2, 7);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let expChooser (r,d) =\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (d - 1)))\n    | 3 -> buildCosine (build (rand, (d - 1)))\n    | 4 -> buildAverage ((build (rand, (d - 1))), (build (rand, (d - 1))))\n    | 5 -> buildTimes ((build (rand, (d - 1))), (build (rand, (d - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (d - 1))), (build (rand, (d - 1))),\n            (build (rand, (d - 1))), (build (rand, (d - 1)))) in\n  if depth < 1\n  then expChooser rand (0, 2) depth\n  else expChooser rand (2, 7) depth;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let expChooser (r,d) =\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (d - 1)))\n    | 3 -> buildCosine (build (rand, (d - 1)))\n    | 4 -> buildAverage ((build (rand, (d - 1))), (build (rand, (d - 1))))\n    | 5 -> buildTimes ((build (rand, (d - 1))), (build (rand, (d - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (d - 1))), (build (rand, (d - 1))),\n            (build (rand, (d - 1))), (build (rand, (d - 1)))) in\n  if depth < 1\n  then ((expChooser (rand (0, 2))), depth)\n  else ((expChooser (rand (2, 7))), depth);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let expChooser (r,d) =\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (d - 1)))\n    | 3 -> buildCosine (build (rand, (d - 1)))\n    | 4 -> buildAverage ((build (rand, (d - 1))), (build (rand, (d - 1))))\n    | 5 -> buildTimes ((build (rand, (d - 1))), (build (rand, (d - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (d - 1))), (build (rand, (d - 1))),\n            (build (rand, (d - 1))), (build (rand, (d - 1)))) in\n  if depth < 1\n  then ((expChooser (rand (0, 2))), depth)\n  else ((expChooser (rand (2, 7))), depth);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  match n with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2 -> buildSine (build (rand, (depth - 1)))\n  | 3 -> buildCosine (build (rand, (depth - 1)))\n  | 4 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let n =\n    match n with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1)))) in\n  if depth < 1 then rand (0, 2) else rand (2, 7);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let n =\n    match n with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1)))) in\n  n = (if depth < 1 then rand (0, 2) else rand (2, 7));;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))\n| Power (e1,e2) -> eval (e1,x,y) ** abs_float (eval (e2,x,y))\n| Comp (e1,e2,e3) -> (float_of_int (-1)) *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This function has type float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Comp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) ** (abs (eval (e2, x, y)))\n  | Comp (e1,e2,e3) ->\n      (((float_of_int (-1)) *. (eval (e1, x, y))) *. (eval (e2, x, y))) *.\n        (eval (e3, x, y));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Comp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) ** (abs_float eval (e2, x, y))\n  | Comp (e1,e2,e3) ->\n      (((float_of_int (-1)) *. (eval (e1, x, y))) *. (eval (e2, x, y))) *.\n        (eval (e3, x, y));;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base =  1 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value f\n", "Error: Unbound value f\n", "Error: Unbound value x\n"], "bad": ["\nlet pipe fs =\n  let f a x = a + (f x) in let base = 0 in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = a + (f x) in let base = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = a + (x a) in let base = x in List.fold_left f base fs;;\n"]}
{"fix": [], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value base\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type bool\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type bool\n"], "bad": ["\nlet pipe fs = let f a x = a = (x a) in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = a = (x a) in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = a = (x a) in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": [], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type bool\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type bool\n"], "bad": ["\nlet pipe fs =\n  let f a x = a = (x a) in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = a = (x a) in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in \nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type bool\n", "Error: This expression has type int but an expression was expected of type\n         bool\n", "Error: Unbound value f\n", "Error: Unbound value y\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type bool\n"], "bad": ["\nlet pipe fs =\n  let f a x = a = (x a) in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = a = (x a) in let base = 0 in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = a = (f (a y)) in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = a = (x (a y)) in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = a = (x a) in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x =  x a in \nlet base = fun x -> x in \nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type (('a -> 'b) -> 'a -> 'b) -> 'c -> bool\n       but an expression was expected of type\n         (('a -> 'b) -> 'a -> 'b) -> 'c -> ('a -> 'b) -> 'a -> 'b\n       Type bool is not compatible with type ('a -> 'b) -> 'a -> 'b \n", "Error: This expression has type\n         (('a -> 'b) -> ('c -> 'a) -> 'c -> 'b) -> 'd -> bool\n       but an expression was expected of type\n         (('a -> 'b) -> ('c -> 'a) -> 'c -> 'b) ->\n         'd -> ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b\n       Type bool is not compatible with type\n         ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b \n", "Error: This expression has type ('a -> 'b) -> 'c\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b) -> 'c\n", "Error: This expression has type ('a -> 'b) -> ('b -> 'b) -> bool\n       but an expression was expected of type\n         ('a -> 'b) -> ('b -> 'b) -> 'a -> 'b\n       Type bool is not compatible with type 'a -> 'b \n"], "bad": ["\nlet pipe fs =\n  let f a x = a = (fun x  -> fun a  -> x a) in\n  let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = a = (fun x  -> fun a  -> fun t  -> x (a t)) in\n  let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = a = (fun x  -> fun y  -> x (a y)) in\n  let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = a = (fun y  -> x (a y)) in\n  let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x =  fun y -> x (a y) in \nlet base = fun x -> x in \nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let stringOfList f l = \"[\" ^ (sepConcat \";\" (List.map f l)) ^ \"]\""], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((List.map sepConcat \";\" l) ^ \"]\");;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" List.map f l) ^ \"]\");;\n"]}
{"fix": ["let rec clone x n = \nlet rec cloneHelper (x,n,acc) = if (n < 0) then acc else cloneHelper(x,n-1,x::acc) in\ncloneHelper(x,n,[])"], "hw": "hw3", "problem": "clone", "message": ["Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * 'b * 'c\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * 'b * 'c\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * 'b * 'c\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * 'b * 'c\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * 'b\n", "Error: Unbound value cloneHelper\n"], "bad": ["\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else ((cloneHelper x n) - (1 x)) :: acc in\n  cloneHelper x n [];;\n", "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper (x, (n - 1), (x :: acc)) in\n  cloneHelper x n [];;\n", "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper (x, (n - 1), (x :: acc)) in\n  cloneHelper x n [];;\n", "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper (x, (n - 1), (x :: acc)) in\n  cloneHelper (x, n, []);;\n", "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper (x, (n - 1), (x :: acc)) in\n  cloneHelper (x, n, []);;\n", "\nlet rec clone x n = if n < 0 then [] else (clone x n) - 1;;\n", "\nlet rec clone x n = if n < 0 then [] else clone (x, (n - 1));;\n", "\nlet rec clone x n =\n  let cloneHelper (x,n,acc) =\n    if n < 0 then acc else cloneHelper (x, (n - 1), (x :: acc)) in\n  cloneHelper (x, n, []);;\n"]}
{"fix": ["let rec clone x n = \nlet rec cloneHelper (x,n,acc) = if (n < 0) then acc else cloneHelper (x,n-1, x::acc) in\ncloneHelper (x,n,[])"], "hw": "hw3", "problem": "clone", "message": ["Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else ((cloneHelper x n) - (1 x)) :: acc in\n  cloneHelper x n [];;\n"]}
{"fix": ["let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append (clone 0 (abs diff)) l1 else l2"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n"], "bad": ["\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then List.append (clone 0 (abs diff)) l1\n  else if diff > 0 then List.append (clone 0 diff) l2;;\n", "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then List.append ((clone 0 (abs diff)) l1)\n  else if diff > 0 then List.append ((clone 0 diff) l2);;\n", "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then List.append ((clone 0 (abs diff)), l1)\n  else if diff > 0 then List.append ((clone 0 diff), l2);;\n", "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append ((clone 0 (abs diff)), l1)), l2)\n  else if diff > 0 then (l1, (List.append ((clone 0 diff), l2)));;\n", "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.combine ((clone 0 (abs diff)), l1)), l2)\n  else if diff > 0 then (l1, (List.combine ((clone 0 diff), l2)));;\n", "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then List.append (clone 0 (abs diff)) l1\n  else if diff > 0 then List.append (clone 0 diff) l2;;\n", "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then List.append (clone 0 (abs diff)) l1\n  else if diff > 0 then List.append (clone 0 diff) l2;;\n", "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0 then List.append (clone 0 (abs diff)) l1;;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) mod 10 in\n(sum/10, sum mod 10) in\nlet base = (0,0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres::[] \nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + (((fst x) + (snd x)) mod 10) in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + (((fst x) + (snd x)) mod 10) in\n      ((sum / 10), (sum mod 10)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int * int list -> int * int -> int * int list\n       but an expression was expected of type\n         int * int list -> int * int -> int * int\n       Type int list is not compatible with type int \n"], "bad": ["\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_right f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nList.rev res\nin \nremoveZero (add (padZero (0::l1) (0::l2)))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This function has type 'a list -> 'b list -> ('a * 'b) list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound value List.reverse\n", "Error: Unbound value List.reverse\n", "Error: This expression has type 'a list\n       but an expression was expected of type int list * int list\n"], "bad": ["\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine List.reverse l1 List.reverse l2 in\n    let (_,res) = List.fold_left f base args in List.reverse res in\n  removeZero (add ((padZero 0) :: (l1 0) :: l2));;\n", "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine (List.reverse l1) (List.reverse l2) in\n    let (_,res) = List.fold_left f base args in List.reverse res in\n  removeZero (add ((padZero 0) :: (l1 0) :: l2));;\n", "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in List.reverse res in\n  removeZero (add ((padZero 0) :: (l1 0) :: l2));;\n", "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in List.rev res in\n  removeZero (add ((padZero 0) :: (l1 0) :: l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero (0::l1) (0::l2)))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound type constructor l1\n"], "bad": ["\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero (0 : l1) (0 : l2)));;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = (fst a + 1, bigAdd (snd a) (List.append l1 (clone 0 (fst a)))) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This function has type int list -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This function has type int list -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero (0 :: l1) (0 :: l2)));;\n\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    (((fst a) + 1), (bigAdd snd a (List.append l1 (clone 0 (fst a))))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n < 1 then []\nelse n mod 10 :: digitsOfInt(n/10)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value digitsofInt\nHint: Did you mean digitsOfInt?\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 1 then [] else (n mod 10) :: (digitsofInt (n / 10));;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n < 1 then []\nelse digitsOfInt(n/10) @ [n mod 10]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n"]}
{"fix": ["let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\nadditivePersistence(addList(digitsOfInt(n)))"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: Unbound record field length\n", "Error: This function has type 'a list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound value digitsofInt\nHint: Did you mean digitsOfInt?\n", "Error: Unbound value digitsofInt\nHint: Did you mean digitsOfInt?\n"], "bad": ["\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (digitsOfInt n.length) = 1\n  then count\n  else additivePersistence (addList (digitsofInt n));;\n", "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length digitsOfInt n) = 1\n  then count\n  else additivePersistence (addList (digitsofInt n));;\n", "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length digitsOfInt n) = 1\n  then count\n  else additivePersistence (addList (digitsofInt n));;\n", "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1\n  then count\n  else additivePersistence (addList (digitsofInt n));;\n", "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1\n  then count\n  else additivePersistence (addList (digitsofInt n));;\n"]}
{"fix": [], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: Unbound value inc\nHint: Did you mean incr?\n", "Error: This function has type int ref -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int ref -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int ref -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int but an expression was expected of type\n         int ref\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value digitsOfInt\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1\n  then count\n  else inc count additivePersistence (addList (digitsOfInt n));;\n", "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1\n  then count\n  else incr count additivePersistence (addList (digitsOfInt n));;\n", "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1\n  then count\n  else incr count additivePersistence (addList (digitsOfInt n));;\n", "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1\n  then count\n  else incr count additivePersistence (addList (digitsOfInt n));;\n", "\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1 then count else incr count;;\n", "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1\n  then count\n  else count = (count + (1 additivePersistence (addList (digitsOfInt n))));;\n", "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1\n  then count\n  else additivePersistence (addList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet _ = additivePersistence addList digitsOfInt n;;\n"]}
{"fix": ["let rec addNum n = \nif n < 10 then n\nelse \naddList(digitsOfInt(n))"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This function has type 'a * int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a * int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: Unbound value n\n"], "bad": ["\nlet rec addList (f,xs) =\n  match xs with | [] -> 0 | h::t -> h + (addList (f, t));;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet _ = addList digitsOfInt 5;;\n", "\nlet rec addList (f,xs) =\n  match xs with | [] -> 0 | h::t -> h + (addList (f, t));;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet _ = addList digitsOfInt 5;;\n", "\nlet rec addList (f,xs) =\n  match xs with | [] -> 0 | h::t -> h + (addList (f, t));;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet _ = addList (digitsOfInt, 5);;\n", "\nlet rec addList (f,xs) =\n  match xs with | [] -> 0 | h::t -> h + (addList (f, t));;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet _ = addList (digitsOfInt, 5);;\n", "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec addNum = if n < 10 then n else addList (digitsOfInt n);;\n"]}
{"fix": ["let palindrome w = \nlet l = explode w in\nif listReverse(l) = l then\ntrue\nelse\nfalse"], "hw": "hw1", "problem": "palindrome", "message": ["Error: Unbound value s\n"], "bad": ["\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  let l = explode s in if (listReverse l) = l then true else false;;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =\nif List.mem h seen\nthen\nseen\nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: Unbound value seem\nHint: Did you mean seen?\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seem else h :: seem in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"]}
{"fix": ["let rec wwhile (f,b) = \nlet a', b' = f b in  \nif b' = true \nthen wwhile (f, b')\nelse a'"], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type bool but an expression was expected of type\n         int\n", "Error: This expression has type bool but an expression was expected of type\n         string\n", "Error: Unbound value b'\n", "Error: Unbound value b'\n", "Error: Unbound value b'\n", "Error: Unbound value q\n", "Error: Unbound value q\n", "Error: Unbound value w\n"], "bad": ["\nlet (x,y) = (\"5\", 5);;\n\nlet rec wwhile (f,b) =\n  let f b = (x, y) in if y = true then wwhile (f, x) else x;;\n", "\nlet (x,y) = (\"5\", 5);;\n\nlet rec wwhile (f,b) =\n  let f b = (x, y) in if x = true then wwhile (f, x) else x;;\n", "\nlet (x,y) = (\"5\", 5);;\n\nlet rec wwhile (f,b) =\n  let f b = (b', c') in if c' = true then wwhile (f, b') else x;;\n", "\nlet (x,y) = (\"5\", 5);;\n\nlet rec wwhile (f,b) =\n  let f b = (b', c') in if c' = true then wwhile (f, b') else x;;\n", "\nlet (x,y) = (\"5\", 5);;\n\nlet rec wwhile (f,b) =\n  let f b = (b', c') in if c' = true then wwhile (f, b') else x;;\n", "\nlet (x,y) = (\"5\", 5);;\n\nlet rec wwhile (f,b) =\n  let f b = (q, x) in if c' = true then wwhile (f, b') else x;;\n", "\nlet (x,y) = (\"5\", 5);;\n\nlet rec wwhile (f,b) =\n  let f b = (q, x) in if c' = true then wwhile (f, b') else x;;\n", "\nlet (x,y) = (\"5\", 5);;\n\nlet rec wwhile (f,b) = let f b = w in if c' = true then wwhile (f, b') else x;;\n"]}
{"fix": ["let rec wwhile (f,b) = \nlet b', c' = f b in  \nif c' = true \nthen wwhile (f, b')\nelse b'"], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type int -> int * bool\n       but an expression was expected of type bool -> 'a * bool\n       Type int is not compatible with type bool \n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (a',b') = f b in if b' = true then wwhile (f, b') else a';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n"]}
{"fix": ["let fixpoint (f,b) = \nlet f' b' = \nif f(b') = b'\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  let f' = if (f b) = b then (b, true) else (b, false) in wwhile (f', b);;\n"]}
{"fix": ["let rec exprToString e = match e with\n| VarX\t\t  -> \"x\"\n| VarY\t\t  -> \"y\"\n| Sine e1\t  -> \"(sin\"^ exprToString e1 ^\")\"\n| Cosine e1\t  -> \"(cos\"^exprToString e1 ^ \")\"\n| Average (e1, e2)-> \"(\"^ exprToString e1 ^\"+\" ^ exprToString e2 ^ \")/2\"\n| Times (e1, e2)  -> \"(\"^ exprToString e1 ^\"*\"^exprToString e2 ^\")\"\n| Thresh (e1, e2, e3, e4) -> \"(\"^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \")?(\"^ exprToString e3 ^ \"):(\"^exprToString e4 ^ \")\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"(\" ^ ((exprToString e1) ^ \")\");;\n\nlet _ = exprToString Sine VarX;;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)"], "hw": "hw2", "problem": "eval", "message": ["Error: Unbound constructor BuildSine\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> BuildSine (eval e);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin (eval e);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin (eval e1);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin (eval e1);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin (eval e1);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e1 -> sin ((eval e1), x, y);;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)/. 2.0)\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> (eval(e1, x, y) < eval(e2, x, y) ? eval(e3, x, y) : eval(e4, x, y)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (eval (e1, x, y))\n  | Cosine e1 -> cos (eval (e1, x, y))\n  | Average (e1,e2) -> (eval (e1, x, y)) + ((eval (e2, x, y)) / 2);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (eval (e1, x, y))\n  | Cosine e1 -> cos (eval (e1, x, y))\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2);;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\nError: Unbound value sampleExpr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\n", "Error: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\nError: Unbound value sampleExpr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (eval (e1, x, y))\n  | Cosine e1 -> cos (eval (e1, x, y))\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.0)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.0)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n"]}
{"fix": [], "hw": "hw2", "problem": "exprToString", "message": ["Error: The constructor Weird expects 3 argument(s),\n       but is applied here to 4 argument(s)\n", "Error: The constructor Weird expects 3 argument(s),\n       but is applied here to 4 argument(s)\n", "Error: The constructor Weird expects 3 argument(s),\n       but is applied here to 4 argument(s)\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Magic of expr\n  | Weird of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      \"\" ^ ((exprToString e1) ^ (\"*\" ^ ((exprToString e2) ^ \"\")))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Magic e1 -> \"tan(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Weird (e1,e2,e3,e4) ->\n      \"(tan(\" ^\n        ((exprToString e1) ^\n           (\"*\" ^ ((exprToString e2) ^ (\"*\" ^ ((exprToString e3) ^ \"))\")))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Magic of expr\n  | Weird of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      \"\" ^ ((exprToString e1) ^ (\"*\" ^ ((exprToString e2) ^ \"\")))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Magic e1 -> \"tan(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Weird (e1,e2,e3,e4) ->\n      \"(tan(\" ^\n        ((exprToString e1) ^\n           (\"*\" ^ ((exprToString e2) ^ (\"*\" ^ ((exprToString e3) ^ \"))\")))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Magic of expr\n  | Weird of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) ->\n      \"\" ^ ((exprToString e1) ^ (\"*\" ^ ((exprToString e2) ^ \"\")))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Magic e1 -> \"tan(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Weird (e1,e2,e3,e4) ->\n      \"(tan(\" ^\n        ((exprToString e1) ^\n           (\"*\" ^ ((exprToString e2) ^ (\"*\" ^ ((exprToString e3) ^ \"))\")))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr * expr * expr * 'd\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Magic of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMagic e1 = Magic e1;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (e1,e2,e3,e4) = Weird (e1, e2, e3);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (match rand (1, 10) with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 -> buildX ()\n     | 7 -> buildY ()\n     | 8 -> buildMagic (build (rand, (depth - 1)))\n     | 9 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | _ -> buildX ());;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value u2\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"], "bad": ["\nlet _ = u2;;\n", "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (fun b  -> (((f b), ((f b) = b)), b));;\n"]}
{"fix": ["let rec assoc (d,k,l) = match l with \n| [] -> d\n| (key, value)::t ->\nif key = k then\nvalue\nelse\nassoc( d, k, t)"], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n"]}
{"fix": ["let pipe fs = \nlet f a x = (x a) in\nlet base = fun g x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n", "Error: Unbound value a\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n"]}
{"fix": [], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base g x = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base g x = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base g x = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base g x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let rec clone x n = match n with\n| 0 -> []\n| _ -> x::(clone x (n-1))"], "hw": "hw3", "problem": "clone", "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         int -> int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n = match n with | 0 -> [] | _ -> x :: ((clone n) - 1);;\n", "\nlet rec clone x n = match n with | 0 -> [] | _ -> x :: (clone ((x n) - 1));;\n", "\nlet rec clone x n = match n with | 0 -> [] | _ -> x :: ((clone x n) - 1);;\n"]}
{"fix": ["let padZero l1 l2 =\nlet lenl1 = List.length l1 in\nlet lenl2 = List.length l2 in\nif lenl1 > lenl2\nthen (l1, (clone 0 (lenl1-lenl2))@l2)\nelse ((clone 0 (lenl2-lenl1))@l1, l2)"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, (((clone 0 lenl1) - lenl2) @ l2))\n  else ((((clone 0 lenl2) - lenl1) @ l1), l2);;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rem = match a with\n| (x, y) -> x in\nmatch x with \n| (add_a, add_b) -> let new_carry = (rem + add_a + add_b)/10 in\nlet digit = (rem + add_a + add_b) mod 10 in\nmatch a with\n| (x, y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rem = match a with | (x,y) -> x in\n      match x with\n      | (add_a,add_b) ->\n          let new_carry = ((rem + add_a) + add_b) / 10 in\n          let digit = ((rem + add_a) + add_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (l1, l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int list\n", "Error: This expression has type int -> int\n       but an expression was expected of type int list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet y x = x + 1;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,_) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      (new_rem, (norm_sum :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet y x = x + 1;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,_) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      (new_rem, (norm_sum :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let rec removeZero l = match l with\n| []      -> []\n| h::t    -> \nif h = 0 \nthen removeZero(t)\nelse h::t"], "hw": "hw3", "problem": "removeZero", "message": ["Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t ->\n      if h = 0 then removeZero t else h :: (t List.combine ([1; 2] [3; 4]));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\nif ((List.length acc) = (List.length l1)) || (List.length acc = List.length l2)\nthen if rem = 1\nthen (0, 1::acc) \nelse (0, acc)\nelse\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: Unbound record field length\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      if x = []\n      then (if rem = 1 then (0, (1 :: acc)) else (0, acc))\n      else\n        (let (el1,el2) = x in\n         let new_sum = (rem + el1) + el2 in\n         let new_rem = if new_sum > 9 then 1 else 0 in\n         let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n         (new_rem, (norm_sum :: acc))) in\n    let base = (0, []) in\n    let args = List.rev ([] @ (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      if (acc.length = l1.length) || (acc.length = l2.length)\n      then (if rem = 1 then (0, (1 :: acc)) else (0, acc))\n      else\n        (let (el1,el2) = x in\n         let new_sum = (rem + el1) + el2 in\n         let new_rem = if new_sum > 9 then 1 else 0 in\n         let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n         (new_rem, (norm_sum :: acc))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\nif ((List.length acc) = (List.length l1)-1) || (List.length acc = (List.length l2)-1)\nthen if rem = 1\nthen (0, [1;0]@acc) \nelse (0, acc)\nelse\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      if\n        ((List.length acc) = ((List.length l1) - 1)) ||\n          ((List.length acc) = ((List.length l2) - 1))\n      then (if rem = 1 then (0, ([1; 0] :: acc)) else (0, acc))\n      else\n        (let (el1,el2) = x in\n         let new_sum = (rem + el1) + el2 in\n         let new_rem = if new_sum > 9 then 1 else 0 in\n         let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n         (new_rem, (norm_sum :: acc))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This function has type 'a list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int list * int list\n       but an expression was expected of type 'a list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      if (List.length acc) = ((List.length List.combine (padZero l1 l2)) - 1)\n      then (if rem = 1 then (0, ([1; 0] @ acc)) else (0, acc))\n      else\n        (let (el1,el2) = x in\n         let new_sum = (rem + el1) + el2 in\n         let new_rem = if new_sum > 9 then 1 else 0 in\n         let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n         (new_rem, (norm_sum :: acc))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      if\n        (List.length acc) =\n          ((List.length (List.combine (padZero l1 l2))) - 1)\n      then (if rem = 1 then (0, ([1; 0] @ acc)) else (0, acc))\n      else\n        (let (el1,el2) = x in\n         let new_sum = (rem + el1) + el2 in\n         let new_rem = if new_sum > 9 then 1 else 0 in\n         let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n         (new_rem, (norm_sum :: acc))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\n\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \nlet larger = if List.length l1 > List.length l2 then l1 else l2 in\nif ((List.length acc) = (List.length larger)-1)\nthen if rem = 1\nthen (0, [1;norm_sum]@acc) \nelse (0, norm_sum::acc)\nelse\n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then\n        (if rem = 1\n         then (0, ([1; norm_sum] @ acc))\n         else (0, (norm_sum @ acc)))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let rec mulByDigit i l = match i with\n| 1 -> l\n| _ -> bigAdd (mulByDigit (i-1) l) l"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then\n        (if rem = 1\n         then (0, ([1; norm_sum] @ acc))\n         else (0, (norm_sum :: acc)))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> l | _ -> bigAdd ((mulByDigit i) - 1) l;;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then\n        (if rem = 1\n         then (0, ([1; norm_sum] @ acc))\n         else (0, (norm_sum :: acc)))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 1 -> l | _ -> bigAdd ((mulByDigit i) - 1) l;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = \nlet (place, acc) = a in\n(place+1, bigAdd ((mulByDigit x l1)@(clone 0 place)) acc) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type 'a list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list -> int list\n       but an expression was expected of type 'a list\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type 'a list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list -> int list\n       but an expression was expected of type 'a list\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type 'a list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list -> int list\n       but an expression was expected of type 'a list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then\n        (if new_rem = 1\n         then (0, ([1; norm_sum] @ acc))\n         else (0, (norm_sum :: acc)))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | 1 -> l | _ -> bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd (mulByDigit x l1) a in\n  let base = [] in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then\n        (if new_rem = 1\n         then (0, ([1; norm_sum] @ acc))\n         else (0, (norm_sum :: acc)))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | 1 -> l | _ -> bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,acc) = a in\n    ((place + 1), (((bigAdd (mulByDigit x l1)) @ (clone 0 place)) acc)) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then\n        (if new_rem = 1\n         then (0, ([1; norm_sum] @ acc))\n         else (0, (norm_sum :: acc)))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | 1 -> l | _ -> bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,acc) = a in\n    ((place + 1), (((bigAdd (mulByDigit x l1)) @ (clone (0 place))) acc)) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then\n        (if new_rem = 1\n         then (0, ([1; norm_sum] @ acc))\n         else (0, (norm_sum :: acc)))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | 1 -> l | _ -> bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,acc) = a in\n    ((place + 1), ((bigAdd (mulByDigit x l1)) @ (clone (0 place) acc))) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digits n digitList = \nif n = 0 then digitList\nelse digits (n/10) ((n mod 10)::digitList) in\nmatch n with\n| 0 -> [0]\n| _ -> digits n []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    if (n mod 10) = 0\n    then 0 :: (digitsOfInt (n / 10))\n    else\n      if ((n - 1) mod 10) = 0\n      then 1 :: (digitsOfInt ((n - 1) / 10))\n      else\n        if ((n - 2) mod 10) = 0\n        then 1 :: (digitsOfInt ((n - 2) / 10))\n        else\n          if ((n - 3) mod 10) = 0\n          then 1 :: (digitsOfInt ((n - 3) / 10))\n          else\n            if ((n - 4) mod 10) = 0\n            then 1 :: (digitsOfInt ((n - 4) / 10))\n            else\n              if ((n - 5) mod 10) = 0\n              then 1 :: (digitsOfInt ((n - 5) / 10))\n              else\n                if ((n - 6) mod 10) = 0\n                then 1 :: (digitsOfInt ((n - 6) / 10))\n                else\n                  if ((n - 7) mod 10) = 0\n                  then 1 :: (digitsOfInt ((n - 7) / 10))\n                  else\n                    if ((n - 8) mod 10) = 0\n                    then 1 :: (digitsOfInt ((n - 8) / 10))\n                    else\n                      if ((n - 9) mod 10) = 0\n                      then 1 :: (digitsOfInt ((n - 9) / 10));;\n", "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    if (n mod 10) = 0\n    then 0 :: (digitsOfInt (n / 10))\n    else\n      if ((n - 1) mod 10) = 0\n      then 1 :: (digitsOfInt ((n - 1) / 10))\n      else\n        if ((n - 2) mod 10) = 0\n        then 2 :: (digitsOfInt ((n - 2) / 10))\n        else\n          if ((n - 3) mod 10) = 0\n          then 3 :: (digitsOfInt ((n - 3) / 10))\n          else\n            if ((n - 4) mod 10) = 0\n            then 4 :: (digitsOfInt ((n - 4) / 10))\n            else\n              if ((n - 5) mod 10) = 0\n              then 5 :: (digitsOfInt ((n - 5) / 10))\n              else\n                if ((n - 6) mod 10) = 0\n                then 6 :: (digitsOfInt ((n - 6) / 10))\n                else\n                  if ((n - 7) mod 10) = 0\n                  then 7 :: (digitsOfInt ((n - 7) / 10))\n                  else\n                    if ((n - 8) mod 10) = 0\n                    then 8 :: (digitsOfInt ((n - 8) / 10))\n                    else\n                      if ((n - 9) mod 10) = 0\n                      then 9 :: (digitsOfInt ((n - 9) / 10));;\n", "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    if (n mod 10) = 0\n    then 0 :: (digitsOfInt (n / 10))\n    else\n      if ((n - 1) mod 10) = 0\n      then 1 :: (digitsOfInt ((n - 1) / 10))\n      else\n        if ((n - 2) mod 10) = 0\n        then 2 :: (digitsOfInt ((n - 2) / 10))\n        else\n          if ((n - 3) mod 10) = 0\n          then 3 :: (digitsOfInt ((n - 3) / 10))\n          else\n            if ((n - 4) mod 10) = 0\n            then 4 :: (digitsOfInt ((n - 4) / 10))\n            else\n              if ((n - 5) mod 10) = 0\n              then 5 :: (digitsOfInt ((n - 5) / 10))\n              else\n                if ((n - 6) mod 10) = 0\n                then 6 :: (digitsOfInt ((n - 6) / 10))\n                else\n                  if ((n - 7) mod 10) = 0\n                  then 7 :: (digitsOfInt ((n - 7) / 10))\n                  else\n                    if ((n - 8) mod 10) = 0\n                    then 8 :: (digitsOfInt ((n - 8) / 10))\n                    else\n                      if ((n - 9) mod 10) = 0\n                      then 9 :: (digitsOfInt ((n - 9) / 10));;\n", "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    if (n mod 10) = 0\n    then 0 :: (digitsOfInt (n / 10))\n    else if ((n - 1) mod 10) = 0 then 1 :: (digitsOfInt ((n - 1) / 10));;\n", "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    if (n mod 10) = 0\n    then 0 :: (digitsOfInt (n / 10))\n    else if ((n - 1) mod 10) = 0 then 1 :: (digitsOfInt ((n - 1) / 10));;\n"]}
{"fix": ["let rec listReverse l =\nmatch l with\n| []     -> l\n| (h::t) -> (listReverse t)@[h]"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec listReverse l = match l with | [] -> l | h::t -> [listReverse t; h];;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (x,false ) -> x | (x,true ) -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (x,false ) -> x | (x,true ) -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile (((f b), (b = (f b))), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile (let g x = let bb = f x in (bb, bb = x) in g, b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (x,false ) -> x | (x,true ) -> wwhile (f, x);;\n\nlet fixpoint (f,b) =\n  wwhile (let g = let bb = f b in (bb, (bb = b)) in (g, b));;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile (let g b = let bb = f b in (bb, bb = b) in g, b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value gx\n", "Error: Unbound value g\n", "Error: Unbound value g\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (x,false ) -> x | (x,true ) -> wwhile (f, x);;\n\nlet fixpoint (f,b) =\n  wwhile (let g x = let xx = gx in (xx, (xx = x)) in (g, b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (x,false ) -> x | (x,true ) -> wwhile (f, x);;\n\nlet fixpoint (f,b) =\n  wwhile (let g x = let xx = g x in (xx, (xx = x)) in (g, b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (x,false ) -> x | (x,true ) -> wwhile (f, x);;\n\nlet fixpoint (f,b) =\n  wwhile (let g b = let bb = g b in (bb, (bb = b)) in (g, b));;\n"]}
{"fix": [], "hw": "hw2", "problem": "expr", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n"]}
{"fix": ["let rec exprToString e = match e with\n| VarX -> x\n| VarY -> y"], "hw": "hw2", "problem": "exprToString", "message": ["Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX x -> Printf.printf \"x\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX x -> Printf.printf \"%s\" x;;\n"]}
{"fix": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ex -> sin exprToString ex"], "hw": "hw2", "problem": "exprToString", "message": ["Error: Unbound value x\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> x | VarY  -> y;;\n"]}
{"fix": ["let rec build (rand, depth) = \nif depth = 0 then \nmatch rand mod 2 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand mod 5 with\n| 2 -> buildSine(build (rand, depth-1))\n| 3 -> buildCosine(build (rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value i\n", "Error: Unbound value i\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match (rand i j) mod 2 with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match (rand i j) mod 5 with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match (rand (i, j)) mod 2 with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match (rand (i, j)) mod 5 with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Negate of expr\n  | Foo of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Negate e -> (eval (e, x, y)) *. (-1)\n  | Foo (e1,e2,e3) ->\n      ((eval (e1, x, y)) +. ((eval (e2, x, y)) *. (eval (e3, x, y)))) /. 2.0;;\n"]}
{"fix": ["let sqsum xs = \nlet rec f a x = match x with\n| []     -> a\n| (h::t) -> f (a+(h*h)) t in\nlet base = 0 in\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: Unbound value f\n", "Error: Unbound value sqsum\n", "Error: Unbound value f\n", "Error: Unbound value f\n", "Error: Unbound value f\n"], "bad": ["\nlet sqsum xs =\n  let f a x = match x with | [] -> a | h::t -> f (a + (h * h)) t in\n  let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = match x with | [] -> a | h::t -> sqsum (a + (h * h)) t in\n  let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = match x with | [] -> a | h::t -> f (a + (h * h)) t in\n  let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = match x with | [] -> a | h::t -> (f a) + ((h * h) t) in\n  let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = match x with | [] -> a | h::t -> f (a + (h * h)) t in\n  let base = 0 in List.fold_left f base xs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n", "Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n", "Error: Unbound value a\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = 3 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value a\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs num = \nlet f a x = x a in\nlet base = num in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value b\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = b in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b\n       but an expression was expected of type (('a -> 'b) -> 'a -> 'b) list\n", "Error: Unbound value base\n", "Error: This expression has type 'a list\n       but an expression was expected of type ('a -> 'a) list\n       The type variable 'a occurs inside 'a -> 'a\n"], "bad": ["\nlet pipe fs =\n  let f a x = x a in let base a = fs a in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = base in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = x a in let base = List.hd fs in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value int\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = int in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe = fun x -> fun2 (fun1 x)"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n", "Error: Unbound value base\n"], "bad": ["\nlet fun1 x = x + x;;\n\nlet fun2 x = x + 3;;\n\nlet pipe = let base = x in fun x  -> fun2 (fun1 base);;\n", "\nlet fun1 x = x + x;;\n\nlet fun2 x = x + 3;;\n\nlet pipe x = fun2 (fun1 base);;\n"]}
{"fix": ["let pipe = fun x -> fun2 (fun1 x)"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int\n", "Error: This expression has type int -> int\n       but an expression was expected of type int\n", "Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet fun1 x = x + x;;\n\nlet fun2 x = x + 3;;\n\nlet pipe = fun2 fun1;;\n", "\nlet fun1 x = x + x;;\n\nlet fun2 x = x + 3;;\n\nlet pipe x = fun2 fun1;;\n", "\nlet fun1 x = x + x;;\n\nlet fun2 x = x + 3;;\n\nlet pipe x = fun2 fun1 x;;\n"]}
{"fix": ["let pipe = fun x -> fun2 (fun1 x)"], "hw": "hw3", "problem": "pipe", "message": ["Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet fun1 x = x + x;;\n\nlet fun2 x = x + 3;;\n\nlet pipe x = fun2 x (fun1 x);;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = [] in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a list -> 'b list\n       but an expression was expected of type 'b list\n"], "bad": ["\nlet rec pipe fs = match fs with | [] -> [] | h::t -> pipe;;\n"]}
{"fix": ["let rec pipe fs = \nmatch fs with\n| [] -> 0\n| (h::t) -> h (pipe t)"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n", "Error: Unbound value x\n"], "bad": ["\nlet rec pipe fs =\n  let fsrev = List.rev fs in\n  match fsrev with | x::[] -> x | h::t -> h (pipe t);;\n", "\nlet rec pipe fs = match fs with | x::[] -> x | h::t -> h (pipe t);;\n", "\nlet rec pipe fs = match fs with | x::[] -> x | h::t -> h (pipe t);;\n", "\nlet rec pipe fs = match fs with | [] -> x | h::t -> h (pipe t);;\n"]}
{"fix": ["let stringOfList f l = sepConcat \"; \" (List.map f l)"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a list -> 'b list\n       but an expression was expected of type string\n", "Error: This expression has type 'a list -> 'b list\n       but an expression was expected of type string list\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f sepConcat l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (List.map f);;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f);;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type (int * int) list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type (int * int) list list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type (int * int) list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (a,b) ->\n          if (a + b) > 9 then 1 :: ((a + b) - 10) :: a else (a + b) :: a in\n    let base = [] in\n    let args = match List.rev (List.combine l1 l2) with | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (m,n) ->\n          if (m + n) > 9 then 1 :: ((m + n) - 10) :: a else (m + n) :: a in\n    let base = [] in\n    let args = match List.rev (List.combine l1 l2) with | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (m,n)::[] ->\n          if (m + n) > 9 then 1 :: ((m + n) - 10) :: a else (m + n) :: a in\n    let base = [] in\n    let args = match List.rev (List.combine l1 l2) with | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (m,n) ->\n          if (m + n) > 9 then 1 :: ((m + n) - 10) :: a else (m + n) :: a in\n    let base = [] in\n    let args = match List.rev (List.combine l1 l2) with | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet prevN (n1, n2) = n1 in\nlet prev = prevN a in\nlet sumlist (p1, p2) = p2 in\nlet sum = sumlist a in\nlet add (m,n) = m + n in\nlet digit = (add x) + prev in\nif digit > 10 then (1, (digit-10)::sum) else (0, (digit)::sum) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type int * int\n       but an expression was expected of type (int * int) list\n", "Error: This expression has type int * int\n       but an expression was expected of type (int * int) list\n", "Error: This expression has type int * int\n       but an expression was expected of type (int * int) list\n", "Error: This expression has type int * int\n       but an expression was expected of type (int * int) list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type (int * int) list\n", "Error: This expression has type int * int\n       but an expression was expected of type (int * int) list\n", "Error: This expression has type int * int\n       but an expression was expected of type 'a list\n", "Error: This expression has type int * int\n       but an expression was expected of type 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (m,n) -> (m + n) :: a in\n    let base = [] in\n    let args = match List.rev ((List.combine l1), l2) with | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (m,n) -> (m + n) :: a in\n    let base = [] in\n    let args =\n      match List.rev ((List.combine l1), l2) with | [] -> (0, 0) | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (m,n) -> (m + n) :: a in\n    let base = [] in\n    let args =\n      match List.rev (List.combine l1 l2) with | [] -> (0, 0) | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let add (m,n) = m + n in (add x) :: a in\n    let base = [] in\n    let args =\n      match List.rev (List.combine l1 l2) with | [] -> (0, 0) | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let add (m,n) = m + n in [add x] :: a in\n    let base = [] in\n    let args =\n      match List.rev (List.combine l1 l2) with | [] -> (0, 0) | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let add (m,n) = [m + n] in (add x) :: a in\n    let base = [] in\n    let args =\n      match List.rev (List.combine l1 l2) with | [] -> (0, 0) | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let add (m,n) = m + n in (add x) :: a in\n    let base = [] in\n    let args = match List.rev (List.combine l1 l2) with | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let add (m,n) = m + n in (add x) :: a in\n    let base = [] in\n    let args =\n      match List.rev (List.combine l1 l2) with | [] -> (0, 0) | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let add (m,n) = m + n in 0 :: a in\n    let base = [] in\n    let args =\n      match List.rev (List.combine l1 l2) with | [] -> (0, 0) | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let add (m,n) = m + n in a in\n    let base = [] in\n    let args =\n      match List.rev (List.combine l1 l2) with | [] -> (0, 0) | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = [] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let rec mulByDigit i l = \nif i = 0 then [0]\nelse bigAdd (mulByDigit (i-1) l) [0]"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type unit\n"], "bad": ["\nlet rec mulByDigit i l =\n  let revl = List.rev l in\n  match revl with\n  | [] -> 0\n  | h::t ->\n      let prod = h * i in\n      if prod > 9\n      then [(mulByDigit i t) + (prod / 10); prod mod 10]\n      else [mulByDigit i t; prod];;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let getTail l = match l with | [] -> [] | h::t -> t in\n      let getCarry (c,l) = c in\n      let carry = getCarry a in\n      let getSum (c,l) = l in\n      let sum = if carry = 1 then getTail (getSum a) else getSum a in\n      let add (m,n) = m + n in\n      let digit = (add x) + carry in\n      if digit > 9\n      then (1, (1 :: (digit - 10) :: sum))\n      else (0, (digit :: sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i > 0 then bigAdd (mulByDigit (i - 1) l);;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = \nlet getPos (p, l) = p in\nlet pos = getPos a in\nlet getProd (p, l) = l in\nlet prod = getProd a in\nif pos > 0 \nthen (pos+1, bigAdd (List.append (mulByDigit x l1) (clone 0 pos)) prod)\nelse (1, bigAdd (mulByDigit x l1) prod) in\nlet base = (0, [0]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int list\n       This is not a function; it cannot be applied.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let getTail l = match l with | [] -> [] | h::t -> t in\n      let getCarry (c,l) = c in\n      let carry = getCarry a in\n      let getSum (c,l) = l in\n      let sum = if carry = 1 then getTail (getSum a) else getSum a in\n      let add (m,n) = m + n in\n      let digit = (add x) + carry in\n      if digit > 9\n      then (1, (1 :: (digit - 10) :: sum))\n      else (0, (digit :: sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [0] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let getPos (p,l) = p in\n    let pos = getPos a in\n    let getProd (p,l) = l in\n    let prod = getProd a in\n    if pos > 0\n    then ((pos + 1), ((bigAdd (mulByDigit x l1)) :: ((clone 0 pos) prod)))\n    else (1, (bigAdd (mulByDigit x l1) prod)) in\n  let base = (0, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let rec digitsOfInt n =\nif n < 0 then []\nelse n :: digitsOfInt n"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value a\n"], "bad": ["\nlet rec digitsOfInt n = if n < 0 then [] else a :: (digitsOfInt n);;\n"]}
{"fix": ["let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n/10)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value %\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: Unbound value h\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n = if n < 0 then [] else n % 10;;\n", "\nlet rec digitsOfInt n = if n < 0 then [] else n mod 10;;\n", "\nlet rec digitsOfInt n = if n < 0 then [] else h :: ((digitsOfInt n) mod 10);;\n", "\nlet rec digitsOfInt n = if n < 0 then [] else (digitsOfInt n) mod 10;;\n", "\nlet rec digitsOfInt n = if n < 0 then [] else [(digitsOfInt (n / 10)) mod 10];;\n"]}
{"fix": [], "hw": "hw1", "problem": "sumList", "message": ["Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet _ =\n  let rec digitsOfInt n = if n < 0 then 1 else digitsOfInt (n mod 10) in\n  digitsOfInt [] n;;\n"]}
{"fix": ["let digitsOfInt n = \nlet rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value d\n", "Error: Unbound value d\n"], "bad": ["\nlet digitsOfInt n =\n  let rec digit acc d =\n    if d < 10 then d :: acc else digit ((d mod 10) :: acc) (d / 10) in\n  digit [] d;;\n", "\nlet digitsOfInt n =\n  let rec digit acc d =\n    if d < 10 then d :: acc else digit ((d mod 10) :: acc) (d / 10) in\n  digit [] d;;\n"]}
{"fix": ["let digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit ((n mod 10) :: acc) (n / 10) in\n     digit [] n);;\n", "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     digit [] n);;\n"]}
{"fix": ["let digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type char but an expression was expected of type\n         int\n"], "bad": ["\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit acc n =\n       if n < 10\n       then n :: acc\n       else if n == '-' then n :: acc else digit ((n mod 10) :: acc) (n / 10) in\n     digit [] n);;\n"]}
{"fix": ["let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     digit [] n);;\n", "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     n [] digit);;\n", "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     digit [] digit);;\n"]}
{"fix": ["let rec digitalRoot n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10)"], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: Unbound value n\n"], "bad": ["\nlet _ =\n  let rec digitalRoot n =\n    if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n  digitalRoot n;;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: Unbound value n\n", "Error: Unbound value n\n", "Error: Unbound value n\n", "Error: Unbound value n\n", "Error: Unbound value x\n", "Error: Unbound value n\n", "Error: Unbound value n\n", "Error: Unbound value n\n", "Error: Unbound value n\n"], "bad": ["\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n =\n      if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot n else n in\n  digitalRoot n;;\n", "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n =\n      if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot x else n in\n  digitalRoot n;;\n", "\nlet rec digitalRoot n =\n  if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10));;\n\nlet _ =\n  let digitalRoot n =\n    let rec digits n =\n      if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot x else n in\n  digitalRoot n;;\n", "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n =\n      if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot x else 1 in\n  digitalRoot n;;\n", "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n =\n      if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot x else 1 in\n  digitalRoot x;;\n", "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n =\n      if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n    let x = digits n in if x > 9 then 1 + (digitalRoot x) else 1 in\n  digitalRoot n;;\n", "\nlet _ =\n  let rec digitalRoot n =\n    if n < 10\n    then n\n    else\n      (let rec digits n =\n         if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n       let x = digits n in if x > 9 then digitalRoot x else 1) in\n  digitalRoot n;;\n", "\nlet rec digitalRoot n =\n  if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10));;\n\nlet _ =\n  let digitalRoot n =\n    if n < 10\n    then n\n    else\n      (let rec digits n =\n         if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n       let x = digits n in if x > 9 then digitalRoot x else 1) in\n  digitalRoot n;;\n", "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n =\n      if n <= 0 then 0 else (n mod 10) + (digitalRoot (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot x else 1 in\n  digitalRoot n;;\n"]}
{"fix": ["let digitalRoot n =\nif n < 10 then 0\nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then 1 + addTimes x\nelse 1 in\naddTimes n"], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: Unbound value n\n", "Error: Unbound value n\n", "Error: Unbound value x\n"], "bad": ["\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n = if n <= 0 then 0 else (n mod 10) + (digits (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot x else x in\n  digitalRoot n;;\n", "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n = if n <= 0 then 0 else (n mod 10) + (digits (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot x else x in\n  digitalRoot n;;\n", "\nlet _ =\n  let rec digitalRoot n =\n    let rec digits n = if n <= 0 then 0 else (n mod 10) + (digits (n / 10)) in\n    let x = digits n in if x > 9 then digitalRoot x else 1 in\n  digitalRoot x;;\n"]}
{"fix": ["let rec listReverse l = match l with\n| [] -> 0\n| _::tl -> 1 + listReverse _"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec listReverse l =\n  match l with | [] -> [] | hd::l' -> 1 + (listReverse l);;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::l' -> 1 + (listReverse l');;\n"]}
{"fix": ["let rec listReverse l = match l with\n| [] -> listReverse l\n| _::tl -> listReverse tl"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec listReverse l =\n  match l with | [] -> [] | _::tl -> (listReverse tl) + tl;;\n", "\nlet rec listReverse l =\n  match l with | 0 -> [] | _::tl -> (listReverse tl) + tl;;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | _::tl -> (listReverse tl) + tl;;\n"]}
{"fix": [], "hw": "hw1", "problem": "listReverse", "message": ["Error: This variant expression is expected to have type bool\n       The constructor [] does not belong to type bool\n", "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet listReverse l =\n  let rec reverseHelper acc = if [] then acc else reverseHelper (h :: acc) t in\n  reverseHelper [] l;;\n", "\nlet listReverse l =\n  let rec reverseHelper acc =\n    match acc with | [] -> acc | h::t -> reverseHelper (h :: acc) t in\n  reverseHelper [] l;;\n"]}
{"fix": [], "hw": "hw1", "problem": "palindrome", "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n", "Error: This expression has type string but an expression was expected of type\n         'a list\n"], "bad": ["\nlet listReverse l =\n  let rec reverseHelper acc =\n    function | [] -> acc | h::t -> reverseHelper (h :: acc) t in\n  reverseHelper [] l;;\n\nlet palindrome w = if w = (listReverse w) then true else false;;\n\nlet _ = palindrome \"malayalam\";;\n", "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec reverseHelper acc =\n    function | [] -> acc | h::t -> reverseHelper (h :: acc) t in\n  reverseHelper [] l;;\n\nlet palindrome w = if (explode w) = (listReverse w) then true else false;;\n"]}
{"fix": ["let listReverse l = \n(*let rec reverseHelper acc = function \n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l *)\nlet rec reverseHelper ln lo =\nmatch ln with\n| [] -> lo\n| h::t -> reverseHelper t (h::acc) in\nreverseHelper l []"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet listReverse l =\n  let rec reverseHelper acc =\n    match acc with | [] -> acc | h::t -> reverseHelper (h :: acc) t in\n  reverseHelper [] l;;\n"]}
{"fix": ["let listReverse l = \n(*let rec reverseHelper acc = function \n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l *)\nlet rec reverseHelper tl lo =\nmatch tl with\n| [] -> lo\n| h::t -> reverseHelper t (h::lo) in\nreverseHelper l []"], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value acc\n"], "bad": ["\nlet listReverse l =\n  let rec reverseHelper ln lo =\n    match ln with | [] -> lo | h::t -> reverseHelper t (h :: acc) in\n  reverseHelper l [];;\n"]}
{"fix": ["let listReverse l = \nlet rec reverseHelper l newList =\nmatch l with\n| [] -> newList\n| h::tl -> reverseHelper tl (h::newList) in\nreverseHelper l []"], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value lst\nHint: Did you mean fst, lsl or lsr?\n"], "bad": ["\nlet listReverse l =\n  let rec reverseHelper lst newList =\n    match lst with | [] -> newList | h::tl -> reverseHelper tl (h :: newList) in\n  reverseHelper lst [];;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a*a + x in\nlet base = 0 in\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet sqsum xs =\n  let f a x = (a * a) + xs in let base = 0 in List.fold_left f base xs;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a*a + x in\nlet base = 0 in\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: Unbound value a\n"], "bad": ["\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = [] in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = a in List.fold_left f base xs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun y -> y |> a |> x in\nlet base = fun y -> y in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value y\n"], "bad": ["\nlet pipe fs =\n  let f a x inner = (y |> a) |> x in\n  let base y = y in List.fold_left f base fs;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep^a in\nlet base = h in\nlet l = t in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type (string list -> string) -> 'a -> string\n       but an expression was expected of type\n         (string list -> string) -> 'a -> string list -> string\n       Type string is not compatible with type string list -> string \n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ (a t)) in\n      let base = h in let l = sl in List.fold_left f base l;;\n"]}
{"fix": ["let stringOfList f l = sepConcat \"[\" (List.map f l)"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"[\" List.map f l;;\n"]}
{"fix": [], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet stringOfList f l = let mid = List.map f l in \"[\" ^ (mid \"]\");;\n"]}
{"fix": ["let stringOfList f l = sepConcat \"; \" (List.map f l)"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" List.map f l;;\n"]}
{"fix": ["let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 then true\nelse false"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: Unbound value acc\n"], "bad": ["\nlet padZero l1 l2 =\n  let f a l = a + (1 l) in let base = a in List.fold_left f base;;\n", "\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) acc l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) acc l2 in\n  if length1 < length2 then true else false;;\n"]}
{"fix": ["let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 = length2 \nthen (l1,l2)\nelse \nif length1 < length2\nthen (List.append (clone 0 (length2 - length1)) l1, l2)\nelse (l1, (List.append (clone 0 (length1 - length2)) l2))"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 < length2\n  then clone (length2 - length1) 0\n  else if length2 < length1 then clone (length1 - length2) 0;;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 < length2\n  then clone (length2 - length1) 0\n  else if length2 < length1 then clone (length1 - length2) 0;;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 < length2\n  then clone (length2 - length1) 0\n  else if length2 < length1 then clone (length1 - length2) 0;;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 < length2\n  then clone 0 (length2 - length1)\n  else if length2 < length1 then clone 0 (length1 - length2);;\n"]}
{"fix": ["let rec removeZero l = match l with\n| [] -> l\n| x::l' -> \nif x=0 \nthen removeZero l'\nelse l"], "hw": "hw3", "problem": "removeZero", "message": ["Error: This expression has type int but an expression was expected of type\n         unit\n"], "bad": ["\nlet rec removeZero l =\n  match l with\n  | [] -> 0\n  | x::l' -> if x = 0 then List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l;;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carry2 = sumInit / 10 in\nlet dig = sumInit mod 10 in\nmatch a with\n| (x,y) -> (carry2, dig :: y) in\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int * 'b\n", "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int * 'b\n", "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int * 'b\n", "Error: Unbound value t\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in\n      match a with | [] -> [carry2; dig] | h::t -> carry2 :: dig :: t in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in\n      match a with | [] -> (carry2, [dig]) | h::t -> (carry2, (dig :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in match a with | h::t -> (carry2, (dig :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in\n      match a with | (x,y) -> (carry2, (dig :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (x1, x2)   = x in\nlet sumInit = x1 + x2 + carry in\nlet carry2 = sumInit / 10 in\nlet dig = sumInit mod 10 in\n(carry2, carry2::dig::[]) in\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in (carry2, (carry2 :: dig)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, acc) = a in\nlet (d1, d2)   = x in\nlet sumInit = d1 + d2 + carry in\nlet carryOut = sumInit / 10 in\nlet dig = sumInit mod 10 in\n(carryOut, dig::acc) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value x1\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (d1,d2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carryOut = sumInit / 10 in\n      let dig = sumInit mod 10 in (carryOut, (dig :: acc)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = \nlet (carry, acc) = a in\nlet (fact, dig)  = x in\nlet prod = mulByDigit dig l1 @ clone 0 carry in\nlet result = bigAdd prod acc in\n(carry+1, result) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: Unbound value i\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value i\n"], "bad": ["\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carryOut = sumInit / 10 in\n      let dig = sumInit mod 10 in let r = dig :: acc in (carryOut, r) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (carry,acc) = a in\n    let (fact,dig) = x in\n    let prod = (mulByDigit dig l1) @ (clone 0 carry) in\n    let result = bigAdd prod acc in ((i + 1), result) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = \nlet (carry, acc) = a in\nlet (fact, dig2)  = x in\nlet y = List.append (mulByDigit dig2 l1) (clone 0 carry) in\nlet result = bigAdd acc y in\n(carry+1, result) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carryOut = sumInit / 10 in\n      let dig = sumInit mod 10 in let r = dig :: acc in (carryOut, r) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (carry,acc) = a in\n    let (fact,dig2) = x in\n    let y = List.append mulByDigit dig2 l1 (clone 0 carry) in\n    let result = bigAdd acc y in ((carry + 1), result) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = \nlet (zeroNum, acc) = a in\nlet (fact, dig2)  = x in\nlet y = List.append (mulByDigit dig2 l1) (clone 0 zeroNum) in\n(zeroNum+1, bigAdd (y) (acc)) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: Unbound value carry\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value carry\n"], "bad": ["\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carryOut = sumInit / 10 in\n      let dig = sumInit mod 10 in let r = dig :: acc in (carryOut, r) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | _ -> bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (zeroNum,acc) = a in\n    let (fact,dig2) = x in\n    let y = List.append (mulByDigit dig2 l1) (clone 0 zeroNum) in\n    let result = bigAdd acc y in ((carry + 1), result) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs)"], "hw": "hw1", "problem": "sumList", "message": ["Error: Unbound value tl\n"], "bad": ["\nlet rec sumList xs = match xs with | [] -> 0 | f::b -> f + (sumList (tl xs));;\n"]}
{"fix": ["let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs)"], "hw": "hw1", "problem": "sumList", "message": ["Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList List.tl xs);;\n"]}
{"fix": ["let rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt n)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n = if n < 0 then [] else (match n with | f::b -> f);;\n", "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (n mod 10) :: ((digitsOfInt n) * 10);;\n", "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (n mod 10) :: ((digitsOfInt n) * 10);;\n"]}
{"fix": ["let rec adder a = if (sumList a)<10 then (sumList a) else adder (digits (sumList a))"], "hw": "hw1", "problem": "sumList", "message": ["Error: Unbound value digit\nHint: Did you mean digits?\nError: Unbound value digit\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value digit\nHint: Did you mean digits?\n"], "bad": ["\nlet rec sumList xs =\n  match xs with | [] -> 0 | f::b -> f + (sumList (List.tl xs));;\n\nlet rec adder a =\n  if (sumList a) < 10 then sumList a else adder (digit (sumList a));;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: Unbound value seen'\nHint: Did you mean seen?\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen' then seen' else h :: seen' in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((if (f x) = x then (x, false) else ((f x), true)), b);;\n", "\nlet fixpoint (f,b) =\n  wwhile\n    ((let func x = if (f x) = x then (x, false) else ((f x), true) in func x),\n      b);;\n", "\nlet fixpoint (f,b) =\n  wwhile\n    ((let func x = if (f x) = x then (x, false) else ((f x), true) in func),\n      b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "expr", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n"]}
{"fix": [], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type expr but an expression was expected of type\n         string\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> ex1 ^ (\"*\" ^ ex2)\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\""], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type string but an expression was expected of type\n         float\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "Error: This expression has type expr but an expression was expected of type\n         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)\n", "Error: This expression has type expr but an expression was expected of type\n         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)\n", "Error: This expression has type expr but an expression was expected of type\n         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)\n", "Error: This expression has type expr but an expression was expected of type\n         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)\n", "Error: This expression has type expr but an expression was expected of type\n         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)\n", "Error: This expression has type expr\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi * (exprToString ex))\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (exprToString ex))\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval ex))\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval ex x y))\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval ex x y))\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval ex x y));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval ex x y));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval ex x y));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex x y)));;\n"]}
{"fix": ["let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type string but an expression was expected of type\n         float\n", "Error: This expression has type string but an expression was expected of type\n         float\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type string but an expression was expected of type\n         float\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type string but an expression was expected of type\n         float\n", "Error: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\nError: Unbound value sampleExpr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) ->\n      ((exprToString (ex1, x, y)) +. (exprToString (ex2, x, y))) /. 2\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) / 2\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) * (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y);;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type unit -> expr\n       but an expression was expected of type bool\n", "Error: This expression has type expr but an expression was expected of type\n         bool\n", "Error: This expression has type unit -> expr\n       but an expression was expected of type unit\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = 0 in\n  if depth = 0\n  then case = (rand (0, 1))\n  else\n    (let case = rand (0, 6) in\n     match case with\n     | 0 -> buildX\n     | 1 -> buildY\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = 0 in\n  if depth = 0\n  then case = (rand (0, 1))\n  else\n    (let case = rand (0, 6) in\n     match case with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = rand (0, 6) in\n  if depth = 0\n  then\n    let case = rand (0, 1) in\n    match case with\n    | 0 -> buildX\n    | 1 -> buildY\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: This expression has type unit -> expr\n       but an expression was expected of type unit\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = rand (0, 6) in\n  if depth = 0\n  then\n    let case = rand (0, 1) in\n    match case with\n    | 0 -> buildX\n    | 1 -> buildY\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"]}
{"fix": ["let rec build (rand, depth) = let case = rand(0,6)"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type unit -> expr\n       but an expression was expected of type unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This variant expression is expected to have type unit\n       The constructor VarX does not belong to type unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = rand (0, 6) in\n  if depth = 0\n  then\n    let case = rand (0, 1) in\n    match case with\n    | 0 -> buildX\n    | 1 -> buildY\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = rand (0, 6) in\n  if depth = 0\n  then\n    let case = rand (0, 1) in\n    match case with\n    | 0 -> buildX ()\n    | 1 -> buildY\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = rand (0, 6) in\n  if depth = 0\n  then\n    let case = rand (0, 1) in\n    match case with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = rand (0, 6) in\n  if depth = 0\n  then\n    let case = rand (0, 1) in\n    match case with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = rand (0, 6) in\n  if depth = 0\n  then\n    let case = rand (0, 1) in\n    match case with\n    | 0 -> VarX\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let case = rand (0, 6) in\n  if depth = 0\n  then\n    let case = rand (0, 1) in\n    match case with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value ffor\n", "Error: Unbound value ffor\n", "Error: Unbound value ffor\n", "Error: Unbound value ffor\n", "Error: Unbound value ffor\n", "Error: Unbound value ffor\n", "Error: Unbound value ffor\n", "Error: Unbound value ffor\n", "Error: Unbound value ffor\n"], "bad": ["\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n", "\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n", "\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n", "\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n", "\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n", "\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n", "\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n", "\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n", "\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n"]}
{"fix": ["let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value ffor\n", "Error: Unbound value ffor\n", "Error: Unbound value ffor\n", "Error: Unbound value ffor\n", "Error: Unbound value ffor\n", "Error: Unbound value ffor\n", "Error: Unbound value ffor\n", "Error: Unbound value ffor\n"], "bad": ["\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n", "\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n", "\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n", "\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n", "\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n", "\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n", "\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n", "\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n"]}
{"fix": [], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type expr/1401\n       but an expression was expected of type expr/1214\nError: This expression has type string but an expression was expected of type\n         int\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type expr/1401\n       but an expression was expected of type expr/1214\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      ((((exprToString ex1) * ((exprToString ex1) + (exprToString ex2))) *\n          (((exprToString ex1) + (exprToString ex2)) + (exprToString ex3)))\n         *\n         ((((exprToString ex1) + (exprToString ex2)) + (exprToString ex3)) +\n            (exprToString ex4)))\n        *\n        (((((exprToString ex1) + (exprToString ex2)) + (exprToString ex3)) +\n            (exprToString ex4))\n           + (exprToString ex5));;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type string but an expression was expected of type\n         int\n", "Error: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "Error: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "Error: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))))\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      \"((\" ^\n        ((exprToString ex1) ^\n           (\")*(\" ^\n              ((exprToString ex1) ^\n                 (\"+\" ^\n                    ((exprToString ex2) ^\n                       (\")*(\" ^\n                          ((exprToString ex1) ^\n                             (\"+\" ^\n                                ((exprToString ex2) ^\n                                   (\"+\" ^\n                                      ((exprToString ex3) ^\n                                         (\")*(\" ^\n                                            ((exprToString ex1) ^\n                                               (\"+\" ^\n                                                  ((exprToString ex2) ^\n                                                     (\"+\" ^\n                                                        ((exprToString ex3) ^\n                                                           (\"+\" ^\n                                                              ((exprToString\n                                                                  ex4)\n                                                                 ^\n                                                                 (\")*(\" ^\n                                                                    (\n                                                                    (exprToString\n                                                                    ex1) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex2) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex3) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex4) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex5) ^\n                                                                    \"))\")))))))))))))))))))))))))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      ((((exprToString ex1) * ((exprToString ex1) + (exprToString ex2))) *\n          (((exprToString ex1) + (exprToString ex2)) + (exprToString ex3)))\n         *\n         ((((exprToString ex1) + (exprToString ex2)) + (exprToString ex3)) +\n            (exprToString ex4)))\n        *\n        (((((exprToString ex1) + (exprToString ex2)) + (exprToString ex3)) +\n            (exprToString ex4))\n           + (exprToString ex5));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      ((((eval ex1) * ((eval ex1) + (eval ex2))) *\n          (((eval ex1) + (eval ex2)) + (eval ex3)))\n         * ((((eval ex1) + (eval ex2)) + (eval ex3)) + (eval ex4)))\n        *\n        (((((eval ex1) + (eval ex2)) + (eval ex3)) + (eval ex4)) + (eval ex5));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      ((((eval ex1) *. ((eval ex1) + (eval ex2))) *\n          (((eval ex1) + (eval ex2)) + (eval ex3)))\n         * ((((eval ex1) + (eval ex2)) + (eval ex3)) + (eval ex4)))\n        *\n        (((((eval ex1) + (eval ex2)) + (eval ex3)) + (eval ex4)) + (eval ex5));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      ((((eval ex1) *. ((eval ex1) + (eval ex2))) *\n          (((eval ex1) + (eval ex2)) + (eval ex3)))\n         * ((((eval ex1) + (eval ex2)) + (eval ex3)) + (eval ex4)))\n        *\n        (((((eval ex1) + (eval ex2)) + (eval ex3)) + (eval ex4)) + (eval ex5));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      ((((eval (ex1, x, y)) *. ((eval (ex1, x, y)) + (eval (ex2, x, y)))) *\n          (((eval (ex1, x, y)) + (eval (ex2, x, y))) + (eval (ex3, x, y))))\n         *\n         ((((eval (ex1, x, y)) + (eval (ex2, x, y))) + (eval (ex3, x, y))) +\n            (eval (ex4, x, y))))\n        *\n        (((((eval (ex1, x, y)) + (eval (ex2, x, y))) + (eval (ex3, x, y))) +\n            (eval (ex4, x, y)))\n           + (eval (ex5, x, y)));;\n"]}
{"fix": ["let rec exprToString e = match e with VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ex -> \"sin(pi*\"^ exprToString ex ^\")\"\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"\n| FiboPlus (ex1,ex2,ex3,ex4,ex5) -> \"((\"^exprToString ex1^\")*(\"^exprToString ex1^\"+\"^exprToString ex2^\")*(\"^exprToString ex1^\"+\"^exprToString ex2^\"+\"^exprToString ex3^\")*(\"^exprToString ex1^\"+\"^exprToString ex2^\"+\"^exprToString ex3^\"+\"^exprToString ex4^\")*(\"^exprToString ex1^\"+\"^exprToString ex2^\"+\"^exprToString ex3^\"+\"^exprToString ex4^\"+\"^exprToString ex5^\"))\"\n| TheThing (ex1,ex2,ex3) -> \"((\"^exprToString ex1^\"*sin(pi*\"^exprToString ex2^\")*cos(pi*\"^exprToString ex3^\"))/2)\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))))\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      \"((\" ^\n        ((exprToString ex1) ^\n           (\")*(\" ^\n              ((exprToString ex1) ^\n                 (\"+\" ^\n                    ((exprToString ex2) ^\n                       (\")*(\" ^\n                          ((exprToString ex1) ^\n                             (\"+\" ^\n                                ((exprToString ex2) ^\n                                   (\"+\" ^\n                                      ((exprToString ex3) ^\n                                         (\")*(\" ^\n                                            ((exprToString ex1) ^\n                                               (\"+\" ^\n                                                  ((exprToString ex2) ^\n                                                     (\"+\" ^\n                                                        ((exprToString ex3) ^\n                                                           (\"+\" ^\n                                                              ((exprToString\n                                                                  ex4)\n                                                                 ^\n                                                                 (\")*(\" ^\n                                                                    (\n                                                                    (exprToString\n                                                                    ex1) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex2) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex3) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex4) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex5) ^\n                                                                    \"))\")))))))))))))))))))))))))))))\n  | TheThing (ex1,ex2,ex3) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"*sin(\" ^\n              ((exprToString ex2) ^ ((\")*cos(\" exprToString ex3) ^ (\")\" \")\")))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))))\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      \"((\" ^\n        ((exprToString ex1) ^\n           (\")*(\" ^\n              ((exprToString ex1) ^\n                 (\"+\" ^\n                    ((exprToString ex2) ^\n                       (\")*(\" ^\n                          ((exprToString ex1) ^\n                             (\"+\" ^\n                                ((exprToString ex2) ^\n                                   (\"+\" ^\n                                      ((exprToString ex3) ^\n                                         (\")*(\" ^\n                                            ((exprToString ex1) ^\n                                               (\"+\" ^\n                                                  ((exprToString ex2) ^\n                                                     (\"+\" ^\n                                                        ((exprToString ex3) ^\n                                                           (\"+\" ^\n                                                              ((exprToString\n                                                                  ex4)\n                                                                 ^\n                                                                 (\")*(\" ^\n                                                                    (\n                                                                    (exprToString\n                                                                    ex1) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex2) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex3) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex4) ^\n                                                                    (\"+\" ^\n                                                                    ((exprToString\n                                                                    ex5) ^\n                                                                    \"))\")))))))))))))))))))))))))))))\n  | TheThing (ex1,ex2,ex3) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"*sin(\" ^\n              ((exprToString ex2) ^\n                 (\")*cos(\" ^ ((exprToString ex3) ^ (\")\" \")\"))))));;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)\n| FiboPlus (ex1,ex2,ex3,ex4,ex5) -> ((eval (ex1,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y)+.eval (ex4,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y)+.eval (ex4,x,y)+.eval (ex5,x,y)))\n| TheThing (ex1,ex2,ex3) -> ((eval (ex1,x,y)*.sin(pi*. eval (ex2,x,y))*.cos(pi*. eval (ex3,x,y)))/.2.)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine ex -> sin (pi *. (eval (ex, x, y)))\n  | Cosine ex -> cos (pi *. (eval (ex, x, y)))\n  | Average (ex1,ex2) -> ((eval (ex1, x, y)) +. (eval (ex2, x, y))) /. 2.\n  | Times (ex1,ex2) -> (eval (ex1, x, y)) *. (eval (ex2, x, y))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      if (eval (ex1, x, y)) < (eval (ex2, x, y))\n      then eval (ex3, x, y)\n      else eval (ex4, x, y)\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      ((((eval (ex1, x, y)) *. ((eval (ex1, x, y)) +. (eval (ex2, x, y)))) *.\n          (((eval (ex1, x, y)) +. (eval (ex2, x, y))) +. (eval (ex3, x, y))))\n         *.\n         ((((eval (ex1, x, y)) +. (eval (ex2, x, y))) +. (eval (ex3, x, y)))\n            +. (eval (ex4, x, y))))\n        *.\n        (((((eval (ex1, x, y)) +. (eval (ex2, x, y))) +. (eval (ex3, x, y)))\n            +. (eval (ex4, x, y)))\n           +. (eval (ex5, x, y)))\n  | TheThing (ex1,ex2,ex3) ->\n      (((eval (ex1, x, y)) * (sin (pi * (eval (ex2, x, y))))) *\n         (cos (pi * (eval (ex3, x, y)))))\n        / 2;;\n"]}
{"fix": [], "hw": "hw2", "problem": "exprToString", "message": ["Error: The constructor FiboPlus expects 3 argument(s),\n       but is applied here to 5 argument(s)\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine ex -> \"sin(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Cosine ex -> \"cos(pi*\" ^ ((exprToString ex) ^ \")\")\n  | Average (ex1,ex2) ->\n      \"((\" ^ ((exprToString ex1) ^ (\"+\" ^ ((exprToString ex2) ^ \")/2)\")))\n  | Times (ex1,ex2) -> (exprToString ex1) ^ (\"*\" ^ (exprToString ex2))\n  | Thresh (ex1,ex2,ex3,ex4) ->\n      \"(\" ^\n        ((exprToString ex1) ^\n           (\"<\" ^\n              ((exprToString ex2) ^\n                 (\"?\" ^\n                    ((exprToString ex3) ^ (\":\" ^ ((exprToString ex4) ^ \")\")))))))\n  | FiboPlus (ex1,ex2,ex3,ex4,ex5) ->\n      \"((\" ^\n        ((exprToString ex1) ^\n           (\")*(\" ^\n              ((exprToString ex1) ^\n                 (\"+\" ^\n                    ((exprToString ex2) ^\n                       (\")*(\" ^\n                          ((exprToString ex1) ^\n                             (\"+\" ^\n                                ((exprToString ex2) ^\n                                   (\"+\" ^ ((exprToString ex3) ^ \"))\")))))))))))\n  | TheThing (ex1,ex2,ex3) ->\n      \"((\" ^\n        ((exprToString ex1) ^\n           (\"*sin(pi*\" ^\n              ((exprToString ex2) ^\n                 (\")*cos(pi*\" ^ ((exprToString ex3) ^ \"))/2)\")))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "expr", "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr\n  | TheThing of expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SixtyNine of expr* expr\n  | TheThing of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildFiboPlus (e1,e2) = FiboPlus (e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildTheThing (e1,e2,e3) = TheThing (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (0, 8) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 7 -> buildFiboPlus (build (rand, (depth - 1)))\n    | 8 ->\n        buildTheThing\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n"]}
{"fix": ["let rec build (rand, depth) = if depth>0 then(\nmatch rand(0,8) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))\n| 7 -> buildSixtyNine(build (rand,depth-1))\n| 8 -> buildTheThing(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))\nelse\nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | FiboPlus of expr* expr\n  | TheThing of expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SixtyNine of expr\n  | TheThing of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildFiboPlus (e1,e2) = FiboPlus (e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildTheThing (e1,e2,e3) = TheThing (e1, e2, e3);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (0, 8) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 7 -> buildFiboPlus (build (rand, (depth - 1)))\n    | 8 ->\n        buildTheThing\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n"]}
{"fix": [], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value a\n", "Error: This expression has type 'a but an expression was expected of type\n         ('a -> int) list\n       The type variable 'a occurs inside ('a -> int) list\n", "Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n", "Error: Unbound value a\n", "Error: Unbound value a\n", "Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = x fs in let base = a in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x fs in let base = 0 in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x fs in let base = fs in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x fs in let base = a in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = a + (x fs) in let base = a in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = fs fs in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x =  x(a) in\nlet base = (fun q->q) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base q = q in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x =  x(a) in\nlet base = (fun q->q) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base q = q in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x(a) in\nlet base = (fun q->q) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value f\n"], "bad": ["\nlet pipe fs = let f a x = f x a in let base q = q in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun w -> x(a) in\nlet base = (fun q->q) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"], "bad": ["\nlet pipe fs = let f a x x = a in let base q = q in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun w -> x(a) in\nlet base = (fun a->a) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value q\n"], "bad": ["\nlet pipe fs = let f a x w = x a in let base a = q in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a  in\nlet base = fun a -> a in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: Unbound value a\n", "Error: Unbound value a\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base a = a in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x a = a x in let base a = a in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base s = a s in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun w -> x(a(w))   in\nlet base = fun a -> a in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: Unbound value a\n", "Error: Unbound value x\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base a = a in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base a = a in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base = a in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base = x in List.fold_left f base fs;;\n"]}
{"fix": ["let stringOfList f l = \"[\"^(sepConcat \"; \" (List.map f l))^\"]\""], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f \"\" l)) ^ \"]\");;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f \"\" l)) ^ \"]\");;\n"]}
{"fix": ["let rec clone x n = if n<1 then [] \nelse \nlet rec helper acc f x = match x with \n| 0 -> acc\n| _ -> helper (f::acc) f (x-1)\nin helper [] x n"], "hw": "hw3", "problem": "clone", "message": ["Error: Unbound value return\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n =\n  if n < 1\n  then return []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> (helper (f :: acc) f x) - 1 in\n     helper [] x n);;\n", "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> (helper (f :: acc) f x) - 1 in\n     helper [] x n);;\n"]}
{"fix": ["let padZero l1 l2 = let x = (List.length l1 - List.length l2) in \nif x!=0 then\nif x<0 then\n(((clone 0 (abs x))@l1),l2)\nelse \n(l1,((clone 0 (abs x))@l2))\nelse \n(l1,l2)"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type int but an expression was expected of type\n         bool\n"], "bad": ["\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n"]}
{"fix": [], "hw": "hw3", "problem": "clone", "message": ["Error: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet args =\n  List.combine (clone List.length l1 List.length l1)\n    (List.combine (List.rev l1) (List.rev l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value =-\n", "Error: Unbound value =-\n", "Error: This expression has type (int * ('a * 'b)) list\n       but an expression was expected of type (int * int) list\n       Type 'a * 'b is not compatible with type int \n", "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"], "bad": ["\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | [] -> sum :: a\n             | x'::xs' ->\n                 if x' =- 1\n                 then\n                   (if sum = 9 then (-1) :: 0 :: xs' else (sum + 1) :: xs')\n                 else sum :: a)\n          else\n            (match a with\n             | [] -> (-1) :: (sum mod 10) :: a\n             | x'::xs' ->\n                 if x' =- 1\n                 then (-1) :: (sum mod 10) :: a\n                 else (-1) :: (sum mod 10) :: a) in\n    let base = [] in\n    let args =\n      List.combine (clone (List.length l1) (List.length l1))\n        (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | [] -> sum :: a\n             | x'::xs' ->\n                 if x' = (-1)\n                 then\n                   (if sum = 9 then (-1) :: 0 :: xs' else (sum + 1) :: xs')\n                 else sum :: a)\n          else\n            (match a with\n             | [] -> (-1) :: (sum mod 10) :: a\n             | x'::xs' ->\n                 if x' =- 1\n                 then (-1) :: (sum mod 10) :: a\n                 else (-1) :: (sum mod 10) :: a) in\n    let base = [] in\n    let args =\n      List.combine (clone (List.length l1) (List.length l1))\n        (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | [] -> sum :: a\n             | x'::xs' ->\n                 if x' = (-1)\n                 then\n                   (if sum = 9 then (-1) :: 0 :: xs' else (sum + 1) :: xs')\n                 else sum :: a)\n          else\n            (match a with\n             | [] -> (-1) :: (sum mod 10) :: a\n             | x'::xs' ->\n                 if x' = (-1)\n                 then (-1) :: (sum mod 10) :: a\n                 else (-1) :: (sum mod 10) :: a) in\n    let base = [] in\n    let args =\n      List.combine (clone (List.length l1) (List.length l1))\n        (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d,(b,c)) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | [] -> sum :: a\n             | x'::xs' ->\n                 if x' = (-1)\n                 then\n                   (if sum = 9 then (-1) :: 0 :: xs' else (sum + 1) :: xs')\n                 else sum :: a)\n          else\n            (match a with\n             | [] -> (-1) :: (sum mod 10) :: a\n             | x'::xs' ->\n                 if x' = (-1)\n                 then (-1) :: (sum mod 10) :: a\n                 else (-1) :: (sum mod 10) :: a) in\n    let base = [] in\n    let args =\n      List.combine (clone (List.length l1) (List.length l1))\n        (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d,(b,c)) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | [] -> sum :: a\n             | x'::xs' ->\n                 if x' = (-1)\n                 then\n                   (if sum = 9 then (-1) :: 0 :: xs' else (sum + 1) :: xs')\n                 else sum :: a)\n          else\n            (match a with\n             | [] -> (-1) :: (sum mod 10) :: a\n             | x'::xs' ->\n                 if x' = (-1)\n                 then (-1) :: (sum mod 10) :: a\n                 else (-1) :: (sum mod 10) :: a) in\n    let base = [] in\n    let args =\n      List.combine (clone (List.length l1) (List.length l1))\n        (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (b,c) -> let sum= b+c in \nif sum<10 then \nmatch a with \n| (len,[]) -> (len,[sum])\n| (len,x'::xs') -> \nif (x'=(-1)) then\nif (sum=9) then\n(len,-1::0::xs')\nelse\n(len,(sum+1)::xs')\nelse \n(len,sum::x'::xs')\nelse\nmatch a with \n| (len,[]) -> (len,-1::[(sum mod 10)])\n| (len,x'::xs') -> \nif (x'=(-1)) then\n(len,-1::((sum mod 10)+1)::xs')\nelse \n(len,-1::(sum mod 10)::x'::xs')\n\nin\nlet base = (List.length l1,[]) in\nlet args = (List.combine (List.rev l1) (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int * 'a list\n       but an expression was expected of type int list\n", "Error: This expression has type 'a * int list\n       but an expression was expected of type int list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * int list\n"], "bad": ["\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d,(b,c)) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | [] -> sum :: a\n             | x'::xs' ->\n                 if x' = (-1)\n                 then\n                   (if sum = 9 then (-1) :: 0 :: xs' else (sum + 1) :: xs')\n                 else sum :: a)\n          else\n            (match a with\n             | [] -> (-1) :: (sum mod 10) :: a\n             | x'::xs' ->\n                 if x' = (-1)\n                 then (-1) :: (sum mod 10) :: a\n                 else (-1) :: (sum mod 10) :: a) in\n    let base = ((List.length l1), []) in\n    let args =\n      List.combine (clone (List.length l1) (List.length l1))\n        (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | (len,[]) -> (len, [sum])\n             | (len,x'::xs') ->\n                 if x' = (-1)\n                 then\n                   (if sum = 9\n                    then (len, ((-1) :: 0 :: xs'))\n                    else (len, ((sum + 1) :: xs')))\n                 else (len, (sum :: a)))\n          else\n            (match a with\n             | (len,[]) -> (len, [(-1); sum mod 10])\n             | (len,x'::xs') ->\n                 if x' = (-1)\n                 then (-1) :: ((sum mod 10) + 1) :: a\n                 else (len, ((-1) :: (sum mod 10) :: x' :: xs'))) in\n    let base = ((List.length l1), []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | (len,[]) -> (len, [sum])\n             | (len,x'::xs') ->\n                 if x' = (-1)\n                 then\n                   (if sum = 9\n                    then (len, ((-1) :: 0 :: xs'))\n                    else (len, ((sum + 1) :: xs')))\n                 else (len, (sum :: x' :: xs')))\n          else\n            (match a with\n             | (len,[]) -> (len, [(-1); sum mod 10])\n             | (len,x'::xs') ->\n                 if x' = (-1)\n                 then (-1) :: ((sum mod 10) + 1) :: a\n                 else (len, ((-1) :: (sum mod 10) :: x' :: xs'))) in\n    let base = ((List.length l1), []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let rec mulByDigit i l = let lre = List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 (num::xs') xs\nelse\nhelper 1 (((num/10) mod 10)::(num mod 10)::xs') xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 (num::accum) xs\nelse\nhelper 1 (((num/10) mod 10)::(num mod 10)::accum) xs\nin helper 0 [] lre"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet rec mulByDigit i l =\n  let lre = List.rev l in\n  let rec helper carry accum lrev =\n    match lrev with\n    | [] -> removeZero accum\n    | x::xs ->\n        if carry = 1\n        then\n          (match accum with\n           | x1'::xs' ->\n               let num = (x * i) + x1' in\n               if num < 10\n               then (helper 0 num) :: (xs' xs)\n               else (helper 1 ((num / 10) mod 10)) :: (num mod 10) ::\n                 (xs' xs))\n        else\n          (let num = x * i in\n           if num < 10\n           then (helper 0 num) :: (accum xs)\n           else (helper 1 ((num / 10) mod 10)) :: (num mod 10) :: (accum xs)) in\n  helper 0 [] lre;;\n", "\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet rec mulByDigit i l =\n  let lre = List.rev l in\n  let rec helper carry accum lrev =\n    match lrev with\n    | [] -> removeZero accum\n    | x::xs ->\n        if carry = 1\n        then\n          (match accum with\n           | x1'::xs' ->\n               let num = (x * i) + x1' in\n               if num < 10\n               then (helper 0 num) :: (xs' xs)\n               else (helper 1 ((num / 10) mod 10)) :: (num mod 10) ::\n                 (xs' xs))\n        else\n          (let num = x * i in\n           if num < 10\n           then (helper 0 num) :: (accum xs)\n           else (helper 1 ((num / 10) mod 10)) :: (num mod 10) :: (accum xs)) in\n  helper 0 [] lre;;\n", "\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet rec mulByDigit i l =\n  let lre = List.rev l in\n  let rec helper carry accum lrev =\n    match lrev with\n    | [] -> removeZero accum\n    | x::xs ->\n        if carry = 1\n        then\n          (match accum with\n           | x1'::xs' ->\n               let num = (x * i) + x1' in\n               if num < 10\n               then helper 0 (num :: xs') xs\n               else (helper 1 ((num / 10) mod 10)) :: (num mod 10) ::\n                 (xs' xs))\n        else\n          (let num = x * i in\n           if num < 10\n           then (helper 0 num) :: (accum xs)\n           else (helper 1 ((num / 10) mod 10)) :: (num mod 10) :: (accum xs)) in\n  helper 0 [] lre;;\n"]}
{"fix": ["let digits n = digitsOfInt (abs n)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n"], "bad": ["\nlet rec digitsOfInt n = if n < 0 then [];;\n"]}
{"fix": ["let digits n = digitsOfInt (abs n)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value helperDigits\n", "Error: Unbound value helperDigits\n"], "bad": ["\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n", "\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value let_\n"], "bad": ["\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = let_ = (digitsOfInt 0);;\n"]}
{"fix": ["let palindrome w = \nlet converted = explode w in \nif(converted = (listReverse converted)) then true\nelse false"], "hw": "hw1", "problem": "palindrome", "message": ["Error: Unbound value reverse\n", "Error: This expression has type string but an expression was expected of type\n         'a list\n"], "bad": ["\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (reverse w) then true else false;;\n", "\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse w) then true else false;;\n"]}
{"fix": ["let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then begin Printf.printf \"hi\"; 0 end\nelse begin Printf.printf \"bye\"; 1 + additivePersistence2 sum end"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type\n         ('a -> 'b, out_channel, unit, unit, unit, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, out_channel, unit, unit, unit, unit)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type unit \n"], "bad": ["\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10\n  then (Printf.printf \"hi\"; 0)\n  else (Printf.printf \"bye\" 1) + (additivePersistence2 sum);;\n"]}
{"fix": [], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type ('a -> 'a * bool) * 'a\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f b') else c';;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value neg\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f (neg b)), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ( (f b),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type bool -> bool -> bool * bool\n       Type int is not compatible with type bool \n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f (not b)), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((f b) <> b), b);;\n", "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let ans = f b in ((ans, (ans <> b)), b));;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (let ans = f b in ((ans, (ans <> b)), b));;\n"]}
{"fix": [], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type expr but an expression was expected of type\n         string\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> VarX\n  | VarY  -> VarY\n  | Sine e1 -> exprToString e1\n  | Cosine e1 -> exprToString e1\n  | Average (e1,e2) -> (exprToString e1) ^ (exprToString e2)\n  | Times (e1,e2) -> (exprToString e1) ^ (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        ((exprToString e2) ^ ((exprToString e3) ^ (exprToString e4)));;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type int but an expression was expected of type\n         expr\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         expr\n"], "bad": ["\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | _ -> eval ((buildX ()), (buildY ()), y);;\n\nlet _ = eval ((Sine VarX), 1, 1);;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x *. 1.0\n  | VarY  -> y *. 1.0\n  | Sine e1 -> sin (pi * (eval (e1, x, y)));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> 1.0\n  | VarY  -> 1.0\n  | Sine e1 -> sin (pi * (eval (e1, x, y)));;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> 1.0\n  | VarY  -> 1.0\n  | Sine e1 -> sin (2 * (eval (e1, x, y)));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)));;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(eval(e1,x,y))"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)));;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)));;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: Unbound value Printf.snprintf\nHint: Did you mean sprintf?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if a < b\n      then (Printf.snprintf \"hi\"; eval (a_less, x, y))\n      else eval (b_less, x, y);;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: Unbound module Print\nHint: Did you mean Printf?\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type string but an expression was expected of type\n         float\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type string but an expression was expected of type\n         float\n", "Error: This expression has type unit but an expression was expected of type\n         float\n", "Error: This expression has type string but an expression was expected of type\n         out_channel\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let x = sin (pi *. (eval (e1, x, y))) in Print.sprintf \"sine is %d \" x\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let x = sin (pi *. (eval (e1, x, y))) in Printf.sprintf \"sine is %d \" x\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in\n      Printf.sprintf \"sine is %d \" ans\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in\n      Printf.sprintf \"sine is %f \" ans\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in\n      Printf.sprintf \"sine is %lf \" ans\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in\n      Printf.sprintf \"sine is %f \" 2.0\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in\n      Printf.printf \"sine is %f \" 2.0\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in\n      Printf.fprintf \"sine is %f \" 2.0\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type string but an expression was expected of type\n         out_channel\n", "Error: This expression has type string but an expression was expected of type\n         float\n", "Error: This expression has type unit but an expression was expected of type\n         float\n", "Error: This expression has type string but an expression was expected of type\n         float\n", "Error: This expression has type unit but an expression was expected of type\n         float\n", "Error: This expression has type int but an expression was expected of type\n         bool\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in\n      Printf.fprintf \"sine is %f \" ans\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in\n      Printf.sprintf \"sine is %f \" ans\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in Printf.printf \"sine is \"\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in Printf.sprintf \"sine is \"\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      let ans = sin (pi *. (eval (e1, x, y))) in Printf.printf \"sine is \"\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 ->\n      if 1 then (sin (pi *. (eval (e1, x, y))); Printf.printf \"sine is \")\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n"]}
{"fix": ["let rec build (rand, depth) = match (rand,depth)  with\n|(_,0) -> if((rand mod 2) == 0) then buildY()\nelse buildX()\n|(_,_) -> buildX()"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value r\n", "Error: Unbound value r\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (r, d) with\n  | (_,0) -> if (r mod 2) == 0 then buildY () else buildX ()\n  | (_,_) -> buildX ();;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (r mod 2) == 0 then buildY () else buildX ()\n  | (_,_) -> buildX ();;\n"]}
{"fix": ["let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "Error: This expression has type expr but an expression was expected of type\n         expr * expr\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        (((build (rand * 3)), (depth - 1)),\n          (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          (buildAverage\n             ((build ((rand + 3), (depth - 1))),\n               (build ((rand - 1), (depth - 1)))))\n      else\n        if (rand mod 5) == 0\n        then build ((rand + 3), (depth - 1))\n        else build ((rand + 1), (depth - 1));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        (((build rand), (depth - 1)), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          (buildAverage\n             ((build ((rand + 3), (depth - 1))),\n               (build ((rand - 1), (depth - 1)))))\n      else\n        if (rand mod 5) == 0\n        then build ((rand + 3), (depth - 1))\n        else build ((rand + 1), (depth - 1));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          (buildAverage\n             ((build ((rand + 3), (depth - 1))),\n               (build ((rand - 1), (depth - 1)))))\n      else\n        if (rand mod 5) == 0\n        then build ((rand + 3), (depth - 1))\n        else build ((rand + 1), (depth - 1));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        (((build rand), (depth - 1)), (build ((rand + 1), (depth - 1))));;\n"]}
{"fix": ["let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )\n\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), build(rand, depth - 1))\nelse \nbuild(rand + 1, depth - 1)"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if (depth > 10) && ((rand mod 7) == 0)\n      then\n        buildTimes\n          (buildAverage\n             ((build ((rand + 3), (depth - 1))),\n               (build ((rand - 1), (depth - 1)))))\n      else\n        if (rand mod 5) == 0\n        then build ((rand + 3), (depth - 1))\n        else build ((rand + 1), (depth - 1));;\n"]}
{"fix": ["let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )\n\n| (_, _) ->\nif(depth > 10) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), \nbuild(rand, depth - 1))\nelse if (depth = 9) then\nbuildSine(build(rand + 1, depth - 1))\nelse if (depth = 8) then\nbuildCosine(build(rand + 2, depth - 1))\nelse \nbuild(rand + 1, depth - 1)"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n", "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n", "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n", "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n"], "bad": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"]}
{"fix": ["let rec build (rand, depth) = failwith \"to be implemented\""], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n", "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n", "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n", "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n"], "bad": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n", "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n"], "bad": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match (rand, depth) with\n  | (_,0) -> if (rand mod 2) == 0 then buildY () else buildX ()\n  | (_,1) ->\n      if (rand mod 3) == 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | (_,2) ->\n      buildTimes\n        ((build (rand, (depth - 1))), (build ((rand + 1), (depth - 1))))\n  | (_,_) ->\n      if depth > 10\n      then\n        buildTimes\n          ((buildAverage\n              ((build ((rand + 3), (depth - 1))),\n                (build ((rand - 1), (depth - 1))))),\n            (build (rand, (depth - 1))))\n      else\n        if depth = 9\n        then buildSine (build ((rand + 1), (depth - 1)))\n        else\n          if depth = 8\n          then buildCosine (build ((rand + 2), (depth - 1)))\n          else build ((rand + 1), (depth - 1));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"]}
{"fix": ["let rec build (rand, depth) = match depth with \n| 0 -> buildX() \n| 1 ->  buildSine( build(rand, depth - 1) )\n| _ -> buildCosine( build(rand, depth - 1) )"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 ->\n      if rand > 1\n      then\n        (Printf.printf \"HIIIIIIIII!!!!!!!\";\n         buildSine (build (rand, (depth - 1))))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 ->\n      if rand > 1\n      then\n        (Printf.printf \"HIIIIIIIII!!!!!!!\";\n         buildSine (build (rand, (depth - 1))))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 ->\n      if rand > 1\n      then\n        (Printf.sprintf \"HIIIIIIIII!!!!!!!\";\n         buildSine (build (rand, (depth - 1))))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> buildX ()\n  | 1 -> if rand > 1 then buildSine (build (rand, (depth - 1)))\n  | _ -> buildCosine (build (rand, (depth - 1)));;\n"]}
{"fix": ["let rec build (rand, depth) = match depth with\n| 0 -> let z = rand in\nif( z > 1) then buildX()\nelse buildY()"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value z\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) = match depth with | 0 -> let z = rand in rand in\n  if z > 1 then buildX () else buildY ();;\n"]}
{"fix": ["let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n| 2 -> let num = rand(1, 3) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| 3 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuild(rand, depth - 1))"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 5) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 3) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      buildTimes\n        (buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"]}
{"fix": ["let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n\n| _ -> buildTimes(build(rand, depth - 1 ), build(rand, depth - 1))"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value buildTime\nHint: Did you mean buildTimes?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | _ -> buildTime ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"]}
{"fix": ["let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n\n| _ -> build(rand, depth - 1 )"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * expr\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        (buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (rand, (depth - 1))))\n  | _ -> build (rand, (depth - 1));;\n"]}
{"fix": ["let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 7 || num = 2) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then \nbuildSine( buildTimes(build(rand, depth - 1), buildCosine(build(rand, depth - 1) )) )\nelse \nbuildSine( buildTimes(build(rand, depth - 1), buildSine(build(rand, depth - 1) )))\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build(rand, depth - 1)), \nbuildTimes(build(rand, depth - 1) , buildSine(build(rand, depth - 1))))\nelse \nbuildTimes( buildSine(build(rand, depth - 1)), \nbuildTimes(build(rand, depth - 1) , buildSine(build(rand, depth - 1))))\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n\n| _ -> build(rand, depth - 1 )"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let num = rand (1, 10) in\n      if (num > 7) || (num = 2) then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then\n        buildSine\n          (buildTimes\n             ((build (rand, (depth - 1))), (buildCosine (rand, (depth - 1)))))\n      else\n        buildSine\n          (buildTimes\n             ((build (rand, (depth - 1))), (buildSine (rand, (depth - 1)))))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (buildTimes\n               ((build (rand, (depth - 1))),\n                 (buildSine (build (rand, (depth - 1)))))))\n      else\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (buildTimes\n               ((build (rand, (depth - 1))),\n                 (buildSine (build (rand, (depth - 1)))))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let num = rand (1, 10) in\n      if (num > 7) || (num = 2) then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (buildCosine (rand, (depth - 1)))\n      else\n        buildSine\n          (buildTimes\n             ((build (rand, (depth - 1))), (buildSine (rand, (depth - 1)))))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (buildTimes\n               ((build (rand, (depth - 1))),\n                 (buildSine (build (rand, (depth - 1)))))))\n      else\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (buildTimes\n               ((build (rand, (depth - 1))),\n                 (buildSine (build (rand, (depth - 1)))))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let num = rand (1, 10) in\n      if (num > 7) || (num = 2) then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then\n        buildSine\n          (buildTimes\n             ((build (rand, (depth - 1))),\n               (buildCosine (build (rand, (depth - 1))))))\n      else\n        buildSine\n          (buildTimes\n             ((build (rand, (depth - 1))), (buildSine (rand, (depth - 1)))))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (buildTimes\n               ((build (rand, (depth - 1))),\n                 (buildSine (build (rand, (depth - 1)))))))\n      else\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (buildTimes\n               ((build (rand, (depth - 1))),\n                 (buildSine (build (rand, (depth - 1)))))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | _ -> build (rand, (depth - 1));;\n"]}
{"fix": ["let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n\n| _ -> let num = rand(1, 3) in build(rand, depth - num )"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | _ -> let num = rand (1, 3) in build (rand, (depth num));;\n"]}
{"fix": ["let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n| 9 -> let num = rand(1,7) in\nif(num mod 2 = 0) then \nbuildAverage( buildSine(build(rand, depth - 1)), build(rand, depth - 1))\nelse\nbuildAverage( buildCosine(build(rand, depth - 1)), build(rand, depth - 1))\n\n| _ -> build(rand, depth - 1 )"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value num\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let num = rand (1, 10) in if num > 3 then buildX () else buildY ()\n  | 1 ->\n      let num = rand (1, 10) in\n      if (num mod 2) = 0\n      then buildSine (build (rand, (depth - 1)))\n      else buildCosine (build (rand, (depth - 1)))\n  | 2 ->\n      let num = rand (1, 30) in\n      if (num mod 2) == 0\n      then\n        buildTimes\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildTimes\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | 3 ->\n      let num = rand (1, 50) in\n      if (num mod 2) = 0\n      then\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildCosine (build (rand, (depth - 1)))))\n      else\n        buildTimes\n          ((buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n            (buildSine (build (rand, (depth - 1)))))\n  | 4 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      let num = rand (1, 10) in\n      if num = 1\n      then buildSine (buildSine (buildSine (build (rand, (depth - 1)))))\n      else\n        if num = 2\n        then\n          buildCosine (buildCosine (buildCosine (build (rand, (depth - 1)))))\n        else\n          if num = 3\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else buildCosine (buildSine (build (rand, (depth - 1))))\n  | 6 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 8 ->\n      buildTimes\n        ((buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))),\n          (buildSine (build (rand, (depth - 1)))))\n  | 9 ->\n      let num = rand (1, 7) in\n      if (num mod 2) = 0\n      then\n        buildAverage\n          ((buildSine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n      else\n        buildAverage\n          ((buildCosine (build (rand, (depth - 1)))),\n            (build (rand, (depth - 1))))\n  | _ -> build (rand, (depth - num));;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value doRandomGray\n", "Error: Unbound value doRandomGray\n", "Error: Unbound value doRandomGray\n"], "bad": ["\nlet _ = doRandomGray (10, 8, 270);;\n", "\nlet _ = doRandomGray (10, 8, 270);;\n", "\nlet _ = doRandomGray (10, 8, 270);;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value doRandomGray\n"], "bad": ["\nlet _ = doRandomGray (10, 270, 2);;\n"]}
{"fix": ["let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value ffor\n"], "bad": ["\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value doRandomColor\n"], "bad": ["\nlet _ = doRandomColor (11, 23, 1993);;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Percent of expr\n  | Negate of expr\n  | SumSquared of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Percent e1 -> (eval (e1, x, y)) *. 0.01\n  | Negate e1 -> (eval (e1, x, y)) * (-1)\n  | SumSquared (e1,e2,e3) ->\n      (((eval (e1, x, y)) * (eval (e1, x, y))) +\n         ((eval (e2, x, y)) * (eval (e2, x, y))))\n        + ((eval (e3, x, y)) * (eval (e3, x, y)));;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  wwhile (let g x = let xx = f x in (xx, (xx != (f xx))) in (g, b));;\n"]}
{"fix": [], "hw": "hw2", "problem": "expr", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n"]}
{"fix": ["let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)"], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value doRandomGray\n"], "bad": ["\nlet _ = doRandomGray (12, 617, 321);;\n"]}
{"fix": ["let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)"], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value doRandomGray\n"], "bad": ["\nlet _ = doRandomGray (12, 126, 3023);;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = x * x in\nlet base = 0 in\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type int list\n       but an expression was expected of type 'a list list\n       Type int is not compatible with type 'a list \n", "Error: Unbound value f\n", "Error: Unbound value f\n", "Error: This expression has type int but an expression was expected of type\n         int -> int\n", "Error: This expression has type int but an expression was expected of type\n         'a -> int -> int\n", "Error: This expression has type int but an expression was expected of type\n         'a -> int -> int\n"], "bad": ["\nlet sqsum xs =\n  let f a x = match x with | [] -> 0 | h::t -> 1 in\n  let base = 0 in List.fold_left f base xs;;\n\nlet sqsum xs =\n  let f a x = match x with | [] -> a | h::t -> (h * h) + (sqsum t) in\n  let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = match x with | [] -> a | h::t -> (h * h) + (f base t) in\n  let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x =\n    match x with | [] -> a | h::t -> (h * h) + (List.fold_left f base t) in\n  let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x x = x * x in let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x _ x = x * x in let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x a x = x * x in let base = 0 in List.fold_left f base xs;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type int but an expression was expected of type\n         int -> int -> int\n", "Error: Unbound value g\n", "Error: Unbound value g\n"], "bad": ["\nlet sqsum xs =\n  let f a x a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = (g a x) = ((x * x) + a) in\n  let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = (g a x) = ((x * x) + a) in\n  let base = 0 in List.fold_left g base xs;;\n"]}
{"fix": ["let rec sqsumL xs = match xs with \n| [] -> 0\n| h :: t -> h*h + sqsumL t"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type int list -> int\n       but an expression was expected of type int\n"], "bad": ["\nlet rec sqsumL xs = match xs with | [] -> 0 | h::t -> (h * h) + sqsumL;;\n"]}
{"fix": ["let rec sqsumL xs = match xs with \n| [] -> 0\n| h :: t -> sqsumL t + h*h"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec sqsumL xs = match xs with | [] -> 0 | h::t -> (sqsumL t) @ (h * h);;\n"]}
{"fix": [], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n"]}
{"fix": [], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: Unbound value f\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: Unbound value a\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = f a x in let base = 0 in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = failwith \"TBD\" in let base = a in List.fold_left f base fs;;\n"]}
{"fix": [], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value a\n"], "bad": ["\nlet pipe fs =\n  let f a x = failwith \"TBD\" in let base = a in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x =  failwith \"TBD\" in\nlet base = fun x -> x in \nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n"], "bad": ["\nlet pipe fs =\n  let f a x = failwith \"TBD\" in let base = x in List.fold_left f base fs;;\n"]}
{"fix": [], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> 'c -> 'd -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'd -> 'a\n", "Error: This expression has type 'a -> 'b -> 'c -> 'd -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'd -> 'a\n"], "bad": ["\nlet pipe fs = let f a x y x = a in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x y x = a in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x =  fun x' -> a x in\nlet base = fun x -> x in \nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value f\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs =\n  let f a x = a (f x) in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = let existing = a in let next = x in existing next in\n  let base x = x in List.fold_left f base fs;;\n"]}
{"fix": [], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value f\n", "Error: Unbound value f\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs =\n  let f a x = a (f x) in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = a (f x) in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x =  failwith \"hi\" in\nlet base = fun x -> x in \nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> 'c -> 'd -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'd -> 'a\n"], "bad": ["\nlet pipe fs = let f a x y x = a in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base = sep in\nlet l = t in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This expression has type string list\n       but an expression was expected of type string\n", "Error: This expression has type string but an expression was expected of type\n         unit\n"], "bad": ["\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if x = \"a\" then x :: a in\n      let base = sep in let l = t in List.fold_left f base l;;\n", "\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if x = \"a\" then x :: a else a in\n      let base = sep in let l = t in List.fold_left f base l;;\n", "\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if x = \"a\" then a ^ x in\n      let base = sep in let l = t in List.fold_left f base l;;\n"]}
{"fix": [], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type string but an expression was expected of type\n         unit\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if a = \"a\" then a ^ (x ^ sep) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n"]}
{"fix": ["let stringOfList f l = List.map (sepConcat f) l"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet t x = x + 1;;\n\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat f l;;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nlet carry = \nmatch a with\n| (x,y) -> x in\nmatch x with \n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int list * int list\n       but an expression was expected of type 'a list\n"], "bad": ["\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = padZero l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "bad": ["\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (addend_a,addend_b) ->\n          let new_carry = ((carry + addend_a) + addend_b) / 10 in\n          let digit = ((carry + addend_a) + addend_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = failwith \"to be implemented\";;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (index,result) = a in\n    let (list1,list2) = x in\n    match list2 with\n    | [] -> []\n    | h::t ->\n        let resList = mulByDigit h list1 in\n        let newIndex = index + 1 in\n        let newRes =\n          bigAdd result\n            (mulByDigit (int_of_float (10.0 ** (float (newIndex - 1))))\n               resList) in\n        (newIndex, newRes) in\n  let base = (0, []) in\n  let args = ((List.rev l1), (List.rev l2)) in\n  let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"hi\" in\nlet base = failwith \"to be implemented\" in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let carry = x in carry in\n    let base = failwith \"to be implemented\" in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let carry = x in carry in\n    let base = failwith \"to be implemented\" in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = failwith \"to be implemented\" in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nlet carry = \nmatch a with\n| (x,y) -> x in\nmatch x with \n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b -> 'c -> 'a\n       but an expression was expected of type 'a * 'b -> 'c -> 'a * 'b\n       The type variable 'a occurs inside 'a * 'b\n", "Error: This expression has type 'a * 'b -> 'c -> 'a\n       but an expression was expected of type 'a * 'b -> 'c -> 'a * 'b\n       The type variable 'a occurs inside 'a * 'b\n", "Error: This expression has type int * 'a list\n       but an expression was expected of type 'b list\n"], "bad": ["\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (x,y) -> x in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let carry = match a with | (x,y) -> x in carry in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = [] in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (x,y) -> x in\nmatch x with\n|(add1, add2) -> let newCarry = (carry + add1 + add2) mod 10 in\nlet num = (carry + add1 + add2) / 10 in\nmatch a with \n|(x,y) -> (newCarry, num :: y) in\nlet base = (0, []) in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value carry\n"], "bad": ["\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet f y z x = y z;;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet _ =\n  let bigAdd l1 l2 =\n    let add (l1,l2) =\n      let f a x =\n        let carry = match a with | (x,y) -> x in\n        match x with\n        | (addend_a,addend_b) ->\n            let new_carry = ((carry + addend_a) + addend_b) / 10 in\n            let digit = ((carry + addend_a) + addend_b) mod 10 in\n            (match a with | (x,y) -> (new_carry, (digit :: y))) in\n      carry in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (c,_) -> c in\nmatch x with\n|(add1, add2) -> let newCarry = (carry + add1 + add2) / 10 in\nlet num = (carry + add1 + add2) mod 10 in\nmatch a with \n|(x,y) -> (newCarry, num :: y) in\nlet base = (0, []) in\nlet args =  List.rev (List.combine (0::l1) (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value newCarry\n"], "bad": ["\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (c,_) -> c in\n      match x with\n      | (add1,add2) ->\n          let newCarry = ((carry + add1) + add2) / 10 in\n          let num = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (newCarry, (num :: y))) in\n    let base = (newCarry, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"tbd\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int list list\n       but an expression was expected of type 'a * 'b\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "bad": ["\nlet t x = x + 1;;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (c,_) -> c in\n      match x with\n      | (add1,add2) ->\n          let newCarry = ((carry + add1) + add2) / 10 in\n          let num = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (newCarry, (num :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let rec helper (num,carry,rest,l) =\n    match rest with\n    | [] -> removeZero (carry :: l)\n    | h::t ->\n        let prod = num * h in\n        helper (num, (prod / 10), t, (((carry + prod) mod 10) :: l)) in\n  helper (i, 0, l, []);;\n\nlet bigMul l1 l2 =\n  let g =\n    let f b x = ((mulByDigit x l1) @ (clone 0 (List.length b))) :: b in\n    let base = [] in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  List.fold_left bigAdd [] g;;\n", "\nlet t x = x + 1;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (c,_) -> c in\n      match x with\n      | (add1,add2) ->\n          let newCarry = ((carry + add1) + add2) / 10 in\n          let num = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (newCarry, (num :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper (num,carry,rest,l) =\n    match rest with\n    | [] -> removeZero (carry :: l)\n    | h::t ->\n        let prod = num * h in\n        helper (num, (prod / 10), t, (((carry + prod) mod 10) :: l)) in\n  helper (i, 0, l, []);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (index,result) = a in\n    let (list1,list2) = x in\n    match list2 with\n    | [] -> []\n    | h::t ->\n        let resList = mulByDigit h list1 in\n        let newIndex = index + 1 in\n        let newRes =\n          bigAdd result\n            (mulByDigit (int_of_float (10.0 ** (float (newIndex - 1))))\n               resList) in\n        (newIndex, newRes) in\n  let base = (0, []) in\n  let args = ((List.rev l1), (List.rev l2)) in\n  let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = match a with\n|(num, prod) -> (num + 1, bigAdd ((mulByDigit x (List.rev l1)) @ clone 0 num) prod) in\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This function has type int -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This function has type int -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet t x = x + 1;;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (c,_) -> c in\n      match x with\n      | (add1,add2) ->\n          let newCarry = ((carry + add1) + add2) / 10 in\n          let num = ((carry + add1) + add2) mod 10 in\n          (match a with | (x,y) -> (newCarry, (num :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let rec helper (num,carry,rest,l) =\n    match rest with\n    | [] -> removeZero (carry :: l)\n    | h::t ->\n        let prod = num * h in\n        helper (num, (prod / 10), t, (((carry + prod) mod 10) :: l)) in\n  helper (i, 0, l, []);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (num,prod) ->\n        ((num + 1),\n          (bigAdd ((mulByDigit x List.rev l1) @ (clone 0 num)) prod)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\""], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" List.map f l) ^ \"]\");;\n"]}
{"fix": ["let rec clone x n = \nlet rec helper a x n =\nif x <= 0 then []\nelse \nlet a' = x::a in\nhelper a' x (n-1)\nin helper [] x n"], "hw": "hw3", "problem": "clone", "message": ["Error: Unbound value helper\n"], "bad": ["\nlet rec clone x n =\n  let helper a x n =\n    if x <= 0 then [] else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n"]}
{"fix": ["let padZero l1 l2 = \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif length1 > length2 then \n(l1, List.append (clone 0 (length1 - length2)) l2)\nelse if length2 > length1 then \n(List.append (clone 0 (length2 - length1)) l1, l2)\nelse (l1,l2)"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 length1\n    then ((List.append (clone 0 (length1 - length2)) l1), l2)\n    else (l1, l2);;\n"]}
{"fix": [], "hw": "hw3", "problem": "removeZero", "message": ["Error: Unbound value removeZero\n"], "bad": ["\nlet _ = removeZero [0; 0; 0; 0];;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair list1 list2 = \nmatch (List.rev list1, List.rev list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> []\nin pair l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nargs\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n"], "bad": ["\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = 0 in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair (t1, t2))\n        | ([],[]) -> [] in\n      pair l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = 0 in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | ([],[]) -> [] in\n      pair l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = 0 in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair list1 list2 = \nmatch (list1, list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> []\nin pair List.rev l1 List.rev l2\nin\nlet (_, res) = List.fold_left f base args in\nargs\nin \nadd (padZero l1 l2)"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n"], "bad": ["\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match ((List.rev list1), (List.rev list2)) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair l1 l2 in\n    let (_,res) = List.fold_left f base args in args in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let rec mulByDigit i l =\nlet rec helper a c i l = match l with\n| [] -> a\n| h::t -> let x = (h*i + c) in \nlet n = if x > 9 then x mod 10 else x in\nlet c' = if x > 9 then x - 10 else 0 in\nlet a' = n::a in\nhelper a' c' i t\nin helper [] 0 i l"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: Unbound value helper\n"], "bad": ["\nlet rec mulByDigit i l =\n  let helper a i l =\n    match l with | [] -> a | h::t -> let a' = (h * i) :: a in helper a' i t in\n  helper [] i l;;\n"]}
{"fix": ["let rec mulByDigit i l =\nlet rec helper acc carry i l = match l with\n| [] -> acc\n| h::t -> let x = (h*i + carry) in \nlet n = if x > 9 then x mod 10 else x in\nlet carry' = if x > 9 then x/10 else 0 in\nlet acc' = n::acc in\nhelper acc' carry' i t\nin helper [] 0 i (List.rev l)"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: Unbound value a\n"], "bad": ["\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> acc\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let c' = if x > 9 then x - 10 else 0 in\n        let a' = n :: a in helper a' c' i t in\n  helper [] 0 i (List.rev l);;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair acc list1 list2 = \nmatch (list1, list2) with\n| (h1::t1, h2::t2) -> pair (List.append acc (h1,h2)) t1 t2\n| (_ , _) -> acc\nin pair [(0,0)] (List.rev l1) (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list -> 'b list -> 'c list\n       but an expression was expected of type 'c\n       The type variable 'c occurs inside 'a list -> 'b list -> 'c list\n"], "bad": ["\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (pair (h1, h2)) :: (acc t1 t2)\n        | (_,_) -> acc in\n      pair [(0, 0)] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \nlet rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in\nbuildZeros [] place in \nlet acc' = List.append (mulByDigit h l2) placeHolders in\ndigitProducts acc' (place+1) t l2)in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: Unbound value f\n"], "bad": ["\nlet _ = let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x =  bigAdd a x in\nlet base = [] in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int -> int list -> int list -> int list\n       but an expression was expected of type int\n", "Error: Unbound value digitsProducts\nHint: Did you mean digitProducts?\n"], "bad": ["\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          (digitProducts a) :: (acc (place + 1) t l2) in\n    digitsProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = a in\n  let base = failwith \"to be implemented\" in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitsProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x =  match a with \n| (_, z) -> (0, bigAdd z x) in\nlet base = (0, []) in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int * int list\n"], "bad": ["\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd a x in\n  let base = [] in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) | _ -> (0, 0) in\n  let base = [] in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) | _ -> (0, []) in\n  let base = [] in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = let ass y -> y in\nass y in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value y\n"], "bad": ["\nlet pipe fs =\n  let f a x = x a in let base = function | f -> y in List.fold_left f base fs;;\n"]}
{"fix": [], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"]}
{"fix": [], "hw": "hw3", "problem": "sqsum", "message": ["Error: Unbound value foo\n"], "bad": ["\nlet ans = foo 10;;\n"]}
{"fix": [], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b\n       but an expression was expected of type int\n"], "bad": ["\nlet pipe fs =\n  let f a x = x a in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"]}
{"fix": ["let digitsOfInt n = \nlet explodeNum n =\nif (n > 0)\nthen (n mod 10) :: (digitsOfInt (n/10))\nelse []\nin listReverse (explodeNum n)"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum = if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse explodeNum n;;\n", "\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum = if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n"]}
{"fix": ["let listReverse l = \nlet rec r e a =\nmatch a with\n| [] -> []\n| (x::l') -> x :: e :: r e l'\nin r [] l"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> [listReverse l'; x];;\n"]}
{"fix": [], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet listReverse l =\n  let rec r e a = match a with | [] -> [] | x::l' -> (r e l') :: x :: e in\n  r [] l;;\n", "\nlet listReverse l =\n  let rec r e a = match a with | [] -> e | x::l' -> (r e l') :: x :: e in\n  r [] l;;\n"]}
{"fix": [], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value explodeNum\nHint: Did you mean explode?\nError: Unbound value explodeNum\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value explodeNum\nHint: Did you mean explode?\n", "Error: Unbound value explodeNum\nHint: Did you mean explode?\nError: Unbound value explodeNum\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value explodeNum\nHint: Did you mean explode?\n"], "bad": ["\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (explodeNum (n / 10)) else [] in\n  listReverse (explodeNum n);;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (explodeNum (n / 10)) else [] in\n  listReverse (explodeNum n);;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec digitsOfInt n = if n > 0 then [digitsOfInt (n / 10); n mod 10] else 0;;\n"]}
{"fix": ["let listReverse l = \nlet rec rev [] o =\nmatch o with\n| [] -> []\n| (hd::tl) -> rev tl (hd::o)\nin rev l []"], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value rev\nHint: Did you mean ref?\n"], "bad": ["\nlet listReverse l =\n  let rev [] o = match o with | [] -> [] | hd::tl -> rev tl (hd :: o) in\n  rev l [];;\n"]}
{"fix": ["let digitsOfInt n =\nlet rec digits o a = \nif (a > 0)\nthen digits ((a mod 10)::o) (a/10)\nelse []\nin digits [] n"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digitsOfInt n =\n  let rec digits o a =\n    if a > 0 then digitsOfInt ((a mod 10) :: o) (a / 10) else [] in\n  digits [] n;;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile (f,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"], "bad": ["\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, b)), b);;\n"]}
{"fix": ["let fixpoint (f,b) = let helper x = \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type ('a -> 'a * bool) * 'a\n       but an expression was expected of type 'a -> 'a * bool\n", "Error: This expression has type ('a -> 'a * bool) * 'a\n       but an expression was expected of type 'a -> 'a * bool\n", "Error: This expression has type ('a -> 'a * bool) * 'a\n       but an expression was expected of type 'a -> 'a * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type bool -> bool * bool\n", "Error: Unbound value x\n", "Error: Unbound value x\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type bool -> bool * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) = wwhile (if b = (f b) then b else ((f b), b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) = wwhile (if b = (f b) then b else ((f b), b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) = wwhile (if b = (f b) then b else ((f b), b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  wwhile (if b = (f b) then (b, false) else (((f b), true), b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  wwhile (if x = (f x) then (b, false) else ((b, true), b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  wwhile (if x = (f x) then (x, false) else ((x, true), b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  wwhile (if b = (f b) then (b, false) else ((b, true), b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  wwhile ((if b = (f b) then (b, false) else (b, true)), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  let helper x = if b = (f b) then (b, false) else (b, true) in\n  wwhile ((helper b), b);;\n"]}
{"fix": ["let fixpoint (f,b) = let helper x = \nif b = (f b) then (b, false) else (f b, true) in\nwwhile (helper,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value l\n"], "bad": ["\nlet _ = l;;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((if b = (f b) then (b, false) else (f b, true)),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value l\n"], "bad": ["\nlet _ = l;;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value l\n", "Error: Unbound value l\n", "Error: Unbound value l\n", "Error: Unbound value l\n", "Error: Unbound value l\n", "Error: Unbound value fixpoint\n", "Error: Unbound value l\n", "Error: Unbound value l\n", "Error: Unbound value l\n"], "bad": ["\nlet _ = l;;\n", "\nlet _ = l;;\n", "\nlet _ = l;;\n", "\nlet _ = l;;\n", "\nlet _ = l;;\n", "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "\nlet _ = l;;\n", "\nlet _ = l;;\n", "\nlet _ = l;;\n"]}
{"fix": [], "hw": "hw2", "problem": "expr", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n"]}
{"fix": ["let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e    -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e  -> \"cos (pi*\" ^ exprToString e ^ \")\"\n| Average e1 e2 -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: Unbound constructor Varx\nHint: Did you mean VarX or VarY?\n", "Error: This expression has type string but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Varx  -> \"x\"\n  | Vary  -> \"y\"\n  | Sine e -> \"sin (pi*\" + (exprToString e);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" + (exprToString e);;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)\n| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)>=eval (e2,x,y)->  eval (e4,x,y)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: Unbound value <.\n", "Error: This expression has type float but an expression was expected of type\n         unit\n", "Error: Unbound value <.\n", "Error: This expression has type float but an expression was expected of type\n         unit\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi * (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y)) then eval (e3, x, y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi * (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) <. (eval (e2, x, y)) then eval (e3, x, y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) <. (eval (e2, x, y)) then eval (e3, x, y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) <. (eval (e2, x, y)) then eval (e3, x, y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y)) then eval (e3, x, y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) <. (eval (e2, x, y)) then eval (e3, x, y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e1, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y)) then eval (e3, x, y);;\n"]}
{"fix": ["let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand 0 4 with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand 0 1 with\n| 0 -> buildX()\n| 1 -> buildY()"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value depth'\nHint: Did you mean depth?\n", "Error: This expression has type 'a * 'b * 'c * 'd\n       but an expression was expected of type expr * expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, depth') in\n  if depth > 0\n  then\n    match rand 0 4 with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildTimes (e, e, e, e)\n  else (match rand 0 1 with | 0 -> buildX () | 1 -> buildY ());;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 0\n  then\n    match rand 0 4 with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildTimes (e, e, e, e)\n  else (match rand 0 1 with | 0 -> buildX () | 1 -> buildY ());;\n"]}
{"fix": ["let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 1\n  then\n    match rand (0 4) with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand (0 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 1\n  then\n    match rand (0 4) with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand (0 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 1\n  then\n    match rand (0 4) with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand (0 1) with | 0 -> buildX () | 1 -> buildY ());;\n"]}
{"fix": ["let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value rand\nHint: Did you mean land?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let e = build (rand, (depth - 1)) in\n  if depth > 1\n  then\n    match rand (0, 4) with\n    | 0 -> buildSine e\n    | 1 -> buildCosine e\n    | 2 -> buildAverage (e, e)\n    | 3 -> buildTimes (e, e)\n    | 4 -> buildThresh (e, e, e, e)\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n\nlet _ = build (rand, 2);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (i,true ) -> wwhile (f, i) | (i,false ) -> i;;\n\nlet fixpoint (f,b) =\n  wwhile (fun x  -> if x = (f x) then (x, false) else (((f x), true), b));;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value recu\n"], "bad": ["\nlet _ = recu 5;;\n"]}
{"fix": [], "hw": "hw2", "problem": "expr", "message": ["Error: Unbound value doRandomColor\n"], "bad": ["\nlet c3 () = (8, 98, 42);;\n\nlet _ = doRandomColor (c3 ());;\n"]}
{"fix": ["let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"], "hw": "hw2", "problem": "eval", "message": ["Error: Unbound value doRandomColor\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\nlet c3 () = (8, 98, 42);;\n\nlet _ = doRandomColor (c3 ());;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Divide of expr* expr\n  | MultDiv of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y)\n  | Divide (e1,e2) -> (eval (e1, x, y)) /. (eval (e2, x, y))\n  | MultDiv (e1,e2,e3) ->\n      ((eval (e1, x, y)) *. (eval (e2, x, y))) / (eval (e3, x, y));;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value doRandomGrey\n", "Error: Unbound value doRandomGrey\n"], "bad": ["\nlet g3 () = (11, 21, 76);;\n\nlet _ = doRandomGrey (g3 ());;\n", "\nlet g2 () = (12, 40, 312);;\n\nlet _ = doRandomGrey (g2 ());;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value doRandomColor\n"], "bad": ["\nlet c3 () = (8, 98, 42);;\n\nlet _ = doRandomColor (c3 ());;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         ('a, unit, string) format =\n           ('a, unit, string, string, string, string)\n           CamlinternalFormatBasics.format6\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type float but an expression was expected of type\n         'a ref\n", "Error: This expression has type float but an expression was expected of type\n         'a ref\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | NegPos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y)\n  | Square e1 -> (eval (e1, x, y)) ** 2.\n  | NegPos (e1,e2,e3) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      0. -. (eval (e3, x, y))\n  | NegPos (e1,e2,e3) -> eval (e3, x, y);;\n\nlet eval_fn e (x,y) = let rv = eval (e, x, y) in Format.sprintf rv;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | NegPos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y)\n  | Square e1 -> (eval (e1, x, y)) ** 2.\n  | NegPos (e1,e2,e3) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      0. -. (eval (e3, x, y))\n  | NegPos (e1,e2,e3) -> eval (e3, x, y);;\n\nlet eval_fn e (x,y) = let rv = eval (e, x, y) in Format.sprintf (\"%d\" (!rv));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | NegPos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y)\n  | Square e1 -> (eval (e1, x, y)) ** 2.\n  | NegPos (e1,e2,e3) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      0. -. (eval (e3, x, y))\n  | NegPos (e1,e2,e3) -> eval (e3, x, y);;\n\nlet eval_fn e (x,y) = let rv = eval (e, x, y) in Format.sprintf \"%d\" (!rv);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr\n  | NegPos of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      eval (e3, x, y)\n  | Thresh (e1,e2,e3,e4) -> eval (e4, x, y)\n  | Square e1 -> (eval (e1, x, y)) ** 2.\n  | NegPos (e1,e2,e3) when (eval (e1, x, y)) < (eval (e2, x, y)) ->\n      0. -. (eval (e3, x, y))\n  | NegPos (e1,e2,e3) -> eval (e3, x, y);;\n\nlet eval_fn e (x,y) = let rv = eval (e, x, y) in Format.sprintf \"%f\" (!rv);;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a**2. +. x in\nlet base = 0. in\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\nlet sqsum xs =\n  let f a x = (a ** 2) + x in let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = (a ** 2.) + x in let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = (a ** 2.) +. x in let base = 0 in List.fold_left f base xs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x'\n", "Error: Unbound value s\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base = x' in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = a x in let base = (f s) = s in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x in\nlet base = () in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n"], "bad": ["\nlet pipe fs = let f a x = x in let base = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value base\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = x in let base = base in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x in\nlet base = fun x y -> x y in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs =\n  let f a x = a x in let base x y = x y in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun y -> a (x y) in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs =\n  let f a x = a x in let base x y = x y in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun y -> a (x y) in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value y\n"], "bad": ["\nlet pipe fs =\n  let f a x y = a (x y) in let base x = y in List.fold_left f base fs;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: Unbound value l\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = \"\" in let l = l in List.fold_left f base l;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type string -> string\n       but an expression was expected of type string\n", "Error: This expression has type string -> string\n       but an expression was expected of type string\n", "Error: This expression has type string -> string\n       but an expression was expected of type string\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = (^) h in let l = t in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = sep ^ x in\n      let base = (^) h in let l = t in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = sep ^ x in\n      let base x = h ^ x in let l = t in List.fold_left f base l;;\n"]}
{"fix": ["let rec clone x n =\nif n > 0 then\nx :: clone x (n-1)\nelse\n[]"], "hw": "hw3", "problem": "clone", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: ((clone x n) - 1) else [];;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((h::i,j::k),(d::e,f::g)) -> ((f + d) / 10) :: ((h + j) mod 10) in\n    let base = (0, 0) in\n    let args =\n      List.rev\n        (List.combine (List.map (fun x  -> [x]) l1)\n           (List.map (fun x  -> [x]) l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((h::i,j::k),(d::e,f::g)) -> ((f + d) / 10) :: ((h + j) mod 10) in\n    let base = ([], []) in\n    let args =\n      List.rev\n        (List.combine (List.map (fun x  -> [x]) l1)\n           (List.map (fun x  -> [x]) l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e)/10,(d+e+b) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value h\n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) -> (((d + e) / 10), ((((d + e) + h) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine [0; 0; 9; 9] [1; 0; 0; 2]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine (0::l1) (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev ((List.combine 0) :: (l1 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev ((List.combine 0) :: (l1 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev ((List.combine (0 :: l1) 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let rec mulByDigit i l = if i > 0\nthen\nmulByDigit (i-1) (bigAdd l l)\nelse\n0"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type 'a -> 'b\n       but an expression was expected of type int\n", "Error: This expression has type 'a but an expression was expected of type\n         (int list -> int list -> int list) ->\n         (int list -> int list -> int list) -> 'a\n       The type variable 'a occurs inside\n       (int list -> int list -> int list) ->\n       (int list -> int list -> int list) -> 'a\n", "Error: This expression has type 'a but an expression was expected of type\n         (int list -> int list -> int list) ->\n         (int list -> int list -> int list) -> 'a\n       The type variable 'a occurs inside\n       (int list -> int list -> int list) ->\n       (int list -> int list -> int list) -> 'a\n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = (mulByDigit i) - (1 bigAdd l l);;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = mulByDigit (i - 1) bigAdd l l;;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l = match l with | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((b,c),(d,e)) ->\n          ((((d + e) + b) / 10), ((((d + e) + b) mod 10) :: c)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i > 0 then mulByDigit (i - 1) bigAdd l l else 0;;\n"]}
{"fix": [], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: Unbound value mulByDigit\n"], "bad": ["\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = match (a,x) with\n| ((b,c),d) -> (b+1,(mulByDigit d l1)::(clone 0 b))\nin\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: Unbound value mulByDigit\n"], "bad": ["\nlet _ = mulByDigit 9 [9; 7; 8; 9; 6; 7; 6; 4; 2];;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigMul", "message": ["Error: Unbound value mulByDigit\n", "Error: This expression has type int but an expression was expected of type\n         int * 'a list\n"], "bad": ["\nlet bigMul l1 l2 =\n  let f a x =\n    match (a, x) with\n    | ((b,c),d) -> ((b + 1), ((mulByDigit d l1) :: (clone 0 b))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet bigMul l1 l2 =\n  let f a x = match (a, x) with | ((b,c),d) -> d in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [4; 0] [1; 1];;\n"]}
{"fix": [], "hw": "hw3", "problem": "sqsum", "message": ["Error: Unbound value stringOfList\n"], "bad": ["\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n"]}
{"fix": ["let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs"], "hw": "hw1", "problem": "sumList", "message": ["Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type int list\n", "Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type int list\n", "Error: This expression has type int list -> 'a list\n       but an expression was expected of type 'b list\n"], "bad": ["\nlet rec sumList xs =\n  match xs with | [] -> [] | _ -> (List.hd xs) + (sumList List.tl);;\n", "\nlet rec sumList xs =\n  match xs with | _ -> (List.hd xs) + (sumList List.tl) | [] -> [];;\n", "\nlet rec sumList xs =\n  match xs with | [] -> [] | _ -> (List.hd xs) + (List.tl sumList);;\n"]}
{"fix": ["let rec sumList xs = \nmatch xs with\n| [] -> []\n| (x::xs') -> x"], "hw": "hw1", "problem": "sumList", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This function has type int list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec sumList xs = match xs with | [] -> [] | _ -> (List.hd xs) + 2;;\n", "\nlet rec sumList xs = match xs with | _ -> (List.hd xs) + 2 | [] -> [];;\n", "\nlet rec sumList xs =\n  match xs with | [] -> [] | _ -> (List.hd xs) + (sumList List.tl xs);;\n", "\nlet rec sumList xs =\n  match xs with | [] -> [] | _ -> (List.hd xs) + (sumList List.tl xs);;\n"]}
{"fix": ["let rec sumList xs = \nmatch xs with\n| [] -> []\n| (x::xs) -> x"], "hw": "hw1", "problem": "sumList", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec sumList xs = match xs with | [] -> [] | x::xs -> x + x;;\n"]}
{"fix": ["let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))"], "hw": "hw1", "problem": "sumList", "message": ["Error: This function has type int list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec sumList xs =\n  match xs with | [] -> [] | xs -> (List.hd xs) + (sumList List.tl xs);;\n", "\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList List.tl xs);;\n"]}
{"fix": ["let rec digitsOfInt n = \nmatch n with\n| n -> n :: []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n = match n with | n -> 5 | 0 -> [];;\n"]}
{"fix": ["let rec digitsOfInt n = \nmatch n with\n| (n::ns) -> n :: ns"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value ns\n", "Error: Unbound value ns\n"], "bad": ["\nlet rec digitsOfInt n = match n with | 0 -> [] :: ns | n -> n :: ns;;\n", "\nlet rec digitsOfInt n = match n with | n -> n :: ns;;\n"]}
{"fix": ["let rec digitsOfInt n = \nmatch n with\n| n::ns -> (n::ns)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value ns\n"], "bad": ["\nlet rec digitsOfInt n = match n with | n -> n :: ns;;\n"]}
{"fix": ["let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> List.hd ((n mod 10)::ns)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  let ns = [] in match n with | n -> (List.hd (n mod 10)) :: ns;;\n"]}
{"fix": ["let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((digitsOfInt (n / 10))::(n mod 10)::ns)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  let ns = [] in match n with | n -> (((n mod 10) :: ns) digitsOfInt n) / 10;;\n", "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 | n -> (n mod 10) :: (digitsOfInt (n / 10));;\n", "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 | n -> ((n mod 10) :: (digitsOfInt (n / 10))) :: ns;;\n"]}
{"fix": ["let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((digitsOfInt (n / 10))::(n mod 10))"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> 0 :: ns\n  | n -> (digitsOfInt (n / 10)) :: (n mod 10) :: ns;;\n", "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> 0 :: ns\n  | n -> (digitsOfInt (n / 10)) :: (n mod 10) :: ns;;\n", "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> 0 :: ns\n  | n -> (digitsOfInt (n / 10)) :: (n mod 10) :: ns;;\n"]}
{"fix": ["let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 :: ns | n -> (digitsOfInt (n / 10)) :: (n mod 10);;\n", "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 :: ns | n -> (digitsOfInt (n / 10)) :: (n mod 10);;\n", "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with | 0 -> 0 :: ns | n -> (digitsOfInt (n / 10)) :: (n mod 10);;\n"]}
{"fix": ["digitsOfInt (-1)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n", "Error: This expression has type int -> int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet _ = digitsOfInt - 5;;\n", "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet _ = digitsOfInt - 5;;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet _ = digitsOfInt - 2;;\n"]}
{"fix": ["let rec additivePersistence n ="], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n = sumList digitsOfInt n;;\n", "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n = sumList digitsOfInt n;;\n"]}
{"fix": [], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec digitalRoot n = if n < 10 then n else digitsOfInt n;;\n"]}
{"fix": [], "hw": "hw1", "problem": "sumList", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec digitalRoot n = if n < 10 then n else digitsOfInt n;;\n"]}
{"fix": ["digitalRoot 9876"], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n = sumList digitsOfInt n;;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: Unbound value count\n"], "bad": ["\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec additivePersistence n =\n  let count = count + 1 in\n  let count = 0 in\n  if n < 10 then count else additivePersistence (digitalRoot n);;\n"]}
{"fix": ["let rec additivePersistence n =\nlet count = 0 and n' = n in\nif (sumList (digitsOfInt n)) = digitalRoot n'\nthen count\nelse \nlet count = count + 1 in\nadditivePersistence (sumList (digitsOfInt n))"], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: Unbound value n'\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value n'\n"], "bad": ["\nlet count = 3;;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet n = (-234);;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet _ =\n  let rec additivePersistence n =\n    let count = 0\n    and n' = n in count = (count + 1) in\n  if (sumList (digitsOfInt n)) = (digitalRoot n')\n  then count\n  else additivePersistence (sumList (digitsOfInt n));;\n"]}
{"fix": ["let rec listReverse l = \nlet rec lr l' =\nmatch l with\n| [] -> l'\n| h::t -> lr (List.hd l)::l' (List.tl l) in\nlr [] listReverse"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec listReverse l =\n  let l' = [] in\n  match l with | [] -> l' | l -> (listReverse (List.tl l)) :: (List.hd l);;\n"]}
{"fix": [], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b -> 'c\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type 'b list\n"], "bad": ["\nlet rec listReverse l =\n  let rec lr l' =\n    match l with | [] -> l' | h::t -> (lr (List.hd l)) :: (l' (List.tl l)) in\n  lr [] listReverse;;\n", "\nlet rec listReverse l =\n  let rec lr l' = match l with | [] -> l' | h::t -> lr (h :: l') t in\n  lr [] listReverse;;\n", "\nlet rec listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in\n  lr [] listReverse;;\n", "\nlet rec listReverse l =\n  let l' = [] in\n  match l with | [] -> l' | h::t -> (List.hd l) :: (listReverse (List.tl l));;\n\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in\n  lr [] listReverse;;\n"]}
{"fix": ["let palindrome w = \nexplode w = listReverse (explode w )"], "hw": "hw1", "problem": "palindrome", "message": ["Error: Unbound value hello\n"], "bad": ["\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w = explode w;;\n\nlet _ = palindrome hello;;\n"]}
{"fix": ["let additivePersistence n =\nlet rec helper n n' i =\nif n' = digitalRoot (n)\nthen i\nelse helper n (sumList (digitsOfInt n')) (i + 1)\nin\nhelper n n 0"], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: Unbound value digitalRoot\n", "Error: Unbound value digitalRoot\n"], "bad": ["\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n", "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | xs -> (List.hd xs) + (sumList (List.tl xs));;\n\nlet additivePersistence n =\n  let rec helper n n' i =\n    if n' = (digitalRoot n)\n    then i\n    else helper n (sumList (digitsOfInt n')) (i + 1) in\n  helper n n 0;;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list list\n       but an expression was expected of type int list\n       Type int list is not compatible with type int \n"], "bad": ["\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else [n mod 10; digitsOfInt (n / 10)];;\n", "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else [n mod 10; digitsOfInt (n / 10)];;\n", "\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n -> if n < 0 then [] else [(n mod 10) :: (digitsOfInt (n / 10))];;\n"]}
{"fix": ["let rec digitsOfInt n =\nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse let rev = listReverse ns' in\n((n mod 10) ::  ( digitsOfInt (n / 10)) )"], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value ns'\nHint: Did you mean ns?\n"], "bad": ["\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n ->\n      if n < 0\n      then []\n      else\n        (let rev = listReverse ns' in (n mod 10) :: (digitsOfInt (n / 10)));;\n"]}
{"fix": ["let rec digitsOfInt n =\nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse let listReverse ns in\n((n mod 10) ::  ( digitsOfInt (n / 10)) )"], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value ns'\nHint: Did you mean ns?\n"], "bad": ["\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | 0 -> ns\n  | n ->\n      if n < 0\n      then []\n      else\n        (let rev = listReverse ns' in (n mod 10) :: (digitsOfInt (n / 10)));;\n"]}
{"fix": ["let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))\n| _ -> listReverse ns"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This pattern matches values of type int\n       but a pattern was expected which matches values of type 'a list\n"], "bad": ["\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | h::t -> listReverse ns\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"]}
{"fix": [], "hw": "hw1", "problem": "sumList", "message": ["Error: Unbound value h\n", "Error: Unbound value h\n"], "bad": ["\nlet sumList = [1; 2; 3];;\n\nlet _ = h :: (t sumList);;\n", "\nlet sumList = [1; 2; 3];;\n\nlet _ = (h :: t) sumList;;\n"]}
{"fix": [], "hw": "hw1", "problem": "listReverse", "message": ["Error: This pattern matches values of type int\n       but a pattern was expected which matches values of type 'a list\n"], "bad": ["\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let this = listReverse n in\n  match n with\n  | 0 -> []\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"]}
{"fix": [], "hw": "hw1", "problem": "sumList", "message": ["Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let this =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  this listReverse n;;\n"]}
{"fix": ["let rec digitsOfInt n = \nlet xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( digitsOfInt (n / 10)))\nin listReverse (xxx n)"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: Unbound value xxx\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec digitsOfInt n =\n  match n with\n  | 0 -> []\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet digitsOfInt n =\n  let xxx =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse (xxx n);;\n", "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet digitsOfInt n =\n  let xxx =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (xxx (n / 10)) in\n  listReverse (xxx n);;\n", "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet digitsOfInt n =\n  let rec xxx =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (xxx (n / 10)) in\n  listReverse (xxx n);;\n", "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let xxx =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse (xxx n);;\n"]}
{"fix": ["let digitsOfInt n = \nlet rec xxx n =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( xxx (n / 10)))\nin listReverse (xxx n)"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let xxx =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse (xxx n);;\n", "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let xxx =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse (xxx n);;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l)) removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n"]}
{"fix": ["let rec wwhile (f,b) =\nlet f' = f b in \nmatch f' with\n| (b', false) -> b'\n| (b', true) -> wwhile (f, b')"], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value x'\n", "Error: Unbound value b'\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let b' = match x' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b') in\n  f b;;\n", "\nlet rec wwhile (f,b) =\n  let b' = match b' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b') in\n  f b;;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"], "bad": ["\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (b', (b' = fOfB)) in\n      whilesFun (f, b)), b);;\n", "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (b', (b' = fOfB)) in\n      whilesFun (f, b)), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b' , b' = fOfB) in whilesFun f), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value b'\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' = let fOfB = f' b' in (b', (b' = fOfB)) in whilesFun f),\n      b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun (f)), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (b', (fOfB = b')) in\n      ((whilesFun f), b)), b);;\n"]}
{"fix": ["fixpoint (g,0)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value b'\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' = let fOfB b' = f' b' in (b', (fOfB = b')) in\n      whilesFun f), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((let whilesFun f' b' = (b', f' (b') = b') in whilesFun (f)), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int but an expression was expected of type\n         int -> int\n", "Error: Unbound value b'\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB b' = f' b' in (b', (fOfB = b')) in\n      whilesFun f), b);;\n\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' = let fOfB = f' b' in (b', (fOfB = b')) in whilesFun f),\n      b);;\n"]}
{"fix": ["fixpoint (g,0)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  wwhile ((let whilesFun f' b' = (b', ((f' b') = b')) in whilesFun f), b);;\n"]}
{"fix": ["fixpoint (g,0)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value b\n"], "bad": ["\nlet g x = x + 1;;\n\nlet _ = let f = g in b = (let g' = g b in (b, (b = g')));;\n"]}
{"fix": ["fixpoint (g,0)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n"]}
{"fix": ["fixpoint (g,0)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b = let fOfB = f' b in (fOfB, (fOfB = b')) in\n      whilesFun f), b);;\n"]}
{"fix": ["fixpoint (g,0)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' = let fOfB = f' b in (fOfB, (fOfB = b)) in whilesFun f),\n      b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "\nlet fixpoint (f,b) = wwhile ((let g = f in ((g b), (b = gb))), b);;\n", "\nlet fixpoint (f,b) = wwhile ((let g = f in ((g b), (b = gb))), b);;\n", "\nlet fixpoint (f,b) = wwhile ((let g = f in ((g b), (b = (g b)))), b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) = wwhile ((let g = f in ((g b), (b = (g b)))), b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "expr", "message": ["Error: This expression has type int but an expression was expected of type\n         expr\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         expr\n"], "bad": ["\nlet VarX  = 2;;\n"]}
{"fix": ["let rec exprToString e = match e with\n| VarX -> e"], "hw": "hw2", "problem": "exprToString", "message": ["Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: Unbound value x\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX x -> x;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> x;;\n"]}
{"fix": ["let rec exprToString e = match e with\n| VarX -> \"x\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type int but an expression was expected of type\n         expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> e;;\n\nlet _ = exprToString 2;;\n"]}
{"fix": ["exprToString VarX"], "hw": "hw2", "problem": "exprToString", "message": ["Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Sine ^ (exprToString e1);;\n"]}
{"fix": ["exprToString (VarX, VarY)"], "hw": "hw2", "problem": "exprToString", "message": ["Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"Sin(\" ^ ((exprToString e1) ^ \")\");;\n\nlet _ = exprToString Sine VarX;;\n"]}
{"fix": ["exprToString (Sine VarX)"], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"Sin(\" ^ ((exprToString e1) ^ \")\");;\n\nlet _ = exprToString (VarX, VarY);;\n"]}
{"fix": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\" ^ (exprToString e1) ^ \")\"\n| Cosine e1 -> \"cos(pi*\" ^ (exprToString e1) ^ \")\"\n| Average (e1, e2) -> \"((\" ^ (exprToString e1) ^ \"+\" ^ (exprToString e2) ^ \")\" ^ \"/2)\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2))\")));;\n\nlet _ = exprToString Average (VarX, VarY);;\n"]}
{"fix": ["exprToString (Sine (Cosine VarX))"], "hw": "hw2", "problem": "exprToString", "message": ["Error: This variant pattern is expected to have type expr\n       The constructor Time does not belong to type expr\nHint: Did you mean Times?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ (\")\" ^ \"/2)\"))))\n  | Time (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2));;\n"]}
{"fix": ["eval ((VarX * VarY), 1, 2)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type expr but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n\nlet _ = eval ((VarX * VarY), 1, 2);;\n"]}
{"fix": ["eval (Times (VarX,VarY), 1, 2)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type expr but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n\nlet _ = eval ((VarX * VarY), 1, 2);;\n"]}
{"fix": ["eval ((Sine (VarY)), 0.2, 0.3)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"], "bad": ["\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)));;\n\nlet _ = eval ((Sine (VarX, VarY)), 1, 2);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)));;\n\nlet _ = eval ((Sine (VarX, VarY)), 0.2, 0.3);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)));;\n\nlet _ = eval ((Sine (VarX, VarY)), 0.2, 0.3);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)));;\n\nlet _ = eval ((Sine (VarX, VarY)), 0.2, 0.3);;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = x * x in\nlet base = 0 in\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: Unbound value a\n"], "bad": ["\nlet sqsum xs = let f a x = x * x in let base = a in List.fold_left f base xs;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: Unbound value base\n", "Error: Unbound value f\n"], "bad": ["\nlet sqsum xs =\n  let f a x = base + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = f base (x * x) in let base = 0 in List.fold_left f base xs;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: Unbound value a\n"], "bad": ["\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = a in List.fold_left f base xs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\n(* Should this be able to hand strings or other types? *)\nlet base = 0 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value f\n"], "bad": ["\nlet pipe fs = let f a x = x f in let base = 0 in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = pipe in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n", "Error: Unbound value x\n", "Error: Unbound value x\n", "Error: Unbound value base\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = base in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n\nlet hi = pipe [] 3;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type string\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = [] in let l = sl in List.fold_left f base l;;\n"]}
{"fix": ["let stringOfList f l = \nList.map (sepConcat \"; \") l"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type string but an expression was expected of type\n         string list\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat \"; \";;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat (\"; \" l);;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat \"; \" l;;\n"]}
{"fix": ["let stringOfList f l = \nsepConcat \"; \" (List.map f l)"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n", "Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"; \") l l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"; \" l) l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat (\"; \" l)) l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat (\"; \" l));;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"; \" l);;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" List.map f l;;\n"]}
{"fix": ["let stringOfList f l = \n\"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\""], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l) \"]\");;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = [] in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n", "Error: Unbound value a\n", "Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type\n         (((((int -> int) -> int -> int) list -> int -> int) ->\n           ((int -> int) -> int -> int) list -> int -> int) ->\n          (((int -> int) -> int -> int) list -> int -> int) ->\n          ((int -> int) -> int -> int) list -> int -> int)\n         list -> int\n       but an expression was expected of type\n         (((((int -> int) -> int -> int) list -> int -> int) ->\n           ((int -> int) -> int -> int) list -> int -> int) ->\n          (((int -> int) -> int -> int) list -> int -> int) ->\n          ((int -> int) -> int -> int) list -> int -> int)\n         list -> 'a -> 'b\n       Type int is not compatible with type 'a -> 'b \n", "Error: This expression has type\n         (((((int -> int) -> int -> int) list -> int -> int) ->\n           ((int -> int) -> int -> int) list -> int -> int) ->\n          (((int -> int) -> int -> int) list -> int -> int) ->\n          ((int -> int) -> int -> int) list -> int -> int)\n         list -> int\n       but an expression was expected of type\n         (((((int -> int) -> int -> int) list -> int -> int) ->\n           ((int -> int) -> int -> int) list -> int -> int) ->\n          (((int -> int) -> int -> int) list -> int -> int) ->\n          ((int -> int) -> int -> int) list -> int -> int)\n         list -> 'a -> 'b\n       Type int is not compatible with type 'a -> 'b \n"], "bad": ["\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = x a in let base x = x in List.fold_left f base fs pipe [] 3;;\n\nlet pipe fs =\n  let f a x = x a in let base x = x in List.fold_left f base fs pipe [] 3;;\n", "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = x a in let base x = x in List.fold_left f base fs pipe [] 3;;\n\nlet pipe fs =\n  let f a x = x a in let base x = x in List.fold_left f base fs pipe [] 3;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x (a) in\nlet base = [] in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base = [] in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = 3 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n", "Error: Unbound value base\n", "Error: Unbound value base'\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = base in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = base' in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound constructor Nil\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = Nil in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun a -> a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n", "Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x x = a in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x x = a in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun a -> a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value a\n"], "bad": ["\nlet pipe fs = let f a x a = a in let base x = a in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n"], "bad": ["\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun x -> fun a -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x x = x x in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x a = x x in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun x -> fun a -> x (a) in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'b -> 'a\n"], "bad": ["\nlet pipe fs = let f a x x a = x in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun x a -> a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n"], "bad": ["\nlet pipe fs =\n  let f a x a x = x a in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun a -> a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"], "bad": ["\nlet pipe fs = let f a x x = a in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x(a) in\nlet base = 0 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'b -> 'a\n", "Error: This expression has type int but an expression was expected of type\n         'a -> 'b -> 'a\n", "Error: This expression has type int but an expression was expected of type\n         'a -> 'b -> 'b\n"], "bad": ["\nlet pipe fs = let f a x a x = a in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x a x = a in let base = 0 in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x x a = a in let base = 0 in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value b\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base x = b in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs =\n  let f a x = let a = x in x a in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = let a = x in a a in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = let a = x in a x in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = let a = x in x x in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun x -> fun a -> x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n", "Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n", "Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n"], "bad": ["\nlet pipe fs = let f a x x = a in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun a -> fun a -> x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs =\n  let f a x a a = a a in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x a a = x x in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value f\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n", "Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n", "Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n", "Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n"], "bad": ["\nlet pipe fs =\n  let f a x a x = f x a in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x a x = x a in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x a x = x a in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value a\n", "Error: Unbound value x\n"], "bad": ["\nlet pipe fs = let f a x = x in let base = a in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x in let base = f x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = x x in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) * 'a -> ('a -> 'b) * 'a\n       but an expression was expected of type ('a -> 'b) * 'a -> 'b\n       The type variable 'b occurs inside ('a -> 'b) * 'a\n", "Error: Variable a is bound several times in this matching\n", "Error: This expression has type 'a * ('a -> 'b) -> 'a * ('a -> 'b)\n       but an expression was expected of type 'a * ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a * ('a -> 'b)\n", "Error: Variable x is bound several times in this matching\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n", "Error: This expression has type 'a * 'b -> 'a * 'b\n       but an expression was expected of type 'a * 'b -> 'b\n       The type variable 'b occurs inside 'a * 'b\n", "Error: This expression has type ('a -> 'b) * 'a -> ('a -> 'b) * 'a\n       but an expression was expected of type ('a -> 'b) * 'a -> 'b\n       The type variable 'b occurs inside ('a -> 'b) * 'a\n", "Error: This expression has type ('a -> 'b) * 'a -> ('a -> 'b) * 'a\n       but an expression was expected of type ('a -> 'b) * 'a -> 'b\n       The type variable 'b occurs inside ('a -> 'b) * 'a\n"], "bad": ["\nlet pipe fs =\n  let f a x (x,a) = x a in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x (a,a) = x a in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x (a,x) = x a in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x (x,x) = x a in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x (x,a) = x x in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x (x,a) = a in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x (x,a) = x a in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x (x,a) = x a in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let rec padZero l1 l2 = \n(clone 0 (List.length l1 - List.length l2)) @ l2"], "hw": "hw3", "problem": "padZero", "message": ["Error: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound value List.len\n", "Error: Unbound value smaller\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 = (clone 0 List.len l1) - l2;;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 = (clone 0 ((List.len l1) - l2)) @ smaller;;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 = (clone 0 ((List.length l1) - l2)) @ smaller;;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 = (clone 0 ((List.length l1) - l2)) @ l2;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun x' -> a x in \nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x'\n"], "bad": ["\nlet pipe fs =\n  let f a x = let x' = x' (x a) in x' x a in\n  let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun x' -> x (a x') in \nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'a) -> 'a -> 'a\n       but an expression was expected of type ('a -> 'a) -> 'a\n       The type variable 'a occurs inside 'a -> 'a\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs =\n  let f a x x' = x' (a x) in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x x' = x' (x a) in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let rec padZero l1 l2 = \nif List.length l1 > List.length l2\nthen (l1, (clone 0 (List.length l1 - List.length l2)) @ l2)\nelse (clone 0 (List.length l2 - List.length l1) @ l1, l2)"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type int list * int list\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) padZero\n      [9; 9] [8; 8; 8];;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int list * int list\n       but an expression was expected of type ('a -> 'b list) * 'a\n       Type int list is not compatible with type 'a -> 'b list \n", "Error: This expression has type int list * int list\n       but an expression was expected of type ('a -> 'b list) * 'a\n       Type int list is not compatible with type 'a -> 'b list \n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "bad": ["\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base =  [0], [0]in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: Unbound value a\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: This expression has type (int * int) list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type (unit * unit) list\n       but an expression was expected of type 'a * 'b\n", "Error: Unbound value res\nHint: Did you mean ref?\n"], "bad": ["\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = (0, 0) in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [0] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [a] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [(0, 0)] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [((), ())] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = res in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type int list * int list\n       but an expression was expected of type 'a list list * 'b\n       Type int is not compatible with type 'a list \n", "Error: This expression has type int list * int list\n       but an expression was expected of type 'a list list * 'b\n       Type int is not compatible with type 'a list \n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type 'c list\n", "Error: This expression has type int list * int list\n       but an expression was expected of type 'a list list * 'b list list\n       Type int is not compatible with type 'a list \n", "Error: This expression has type 'a list list * 'b list list\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a list list * 'b list list\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a list list * 'b list list\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type 'c list\n"], "bad": ["\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([0], [0]) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([0], [0]) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([0], [0]) in\n    let args = List.rev (List.hd l1) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([0], [0]) in\n    let args = List.rev (List.hd l1) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([0], [0]) in\n    let args = ((List.rev (List.hd l1)), (List.rev (List.hd l2))) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([0], [0]) in\n    let args = [((List.rev (List.hd l1)), (List.rev (List.hd l2)))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([0], [0]) in\n    let args = ([List.rev (List.hd l1)], [List.rev (List.hd l2)]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([0], [0]) in\n    let args = ([List.rev (List.hd l1)], [List.rev (List.hd l2)]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([0], [0]) in\n    let args = ([List.rev (List.hd l1)], [List.rev (List.hd l2)]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([0], [0]) in\n    let args = ((List.rev (List.hd l1)), (List.rev (List.hd l2))) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun x'-> x (a x') in \nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type\n         'a -> ('b -> 'c) -> ('a -> 'b) -> 'c\n       The type variable 'a occurs inside ('b -> 'c) -> ('a -> 'b) -> 'c\n"], "bad": ["\nlet pipe fs =\n  let f a x x' x a = x (a x') in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun x'-> x (a x') in \nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'c\n       The type variable 'a occurs inside ('a -> 'b) -> 'c\n"], "bad": ["\nlet pipe fs =\n  let f a x x' a = x (a x') in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value %\n", "Error: This expression has type\n         int list -> int * int -> int -> int * int list\n       but an expression was expected of type\n         int list -> int * int -> int list\n       Type int -> int * int list is not compatible with type int list \n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type\n         int list -> int * int -> int -> int * int list\n       but an expression was expected of type\n         int list -> int * int -> int list\n       Type int -> int * int list is not compatible with type int list \n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type\n         int list -> int * int -> int -> int * int list\n       but an expression was expected of type\n         int list -> int * int -> int list\n       Type int -> int * int list is not compatible with type int list \n", "Error: This expression has type\n         int list -> int * int -> int -> int * int list\n       but an expression was expected of type\n         int list -> int * int -> int list\n       Type int -> int * int list is not compatible with type int list \n", "Error: This expression has type\n         int list -> int * int -> int -> int * int list\n       but an expression was expected of type\n         int list -> int * int -> int list\n       Type int -> int * int list is not compatible with type int list \n", "Error: This expression has type\n         int list -> int * int -> int -> int * int list\n       but an expression was expected of type\n         int list -> int * int -> int list\n       Type int -> int * int list is not compatible with type int list \n", "Error: This expression has type\n         int list -> int * int -> int -> int * int list\n       but an expression was expected of type\n         int list -> int * int -> int list\n       Type int -> int * int list is not compatible with type int list \n"], "bad": ["\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), ((sum % 10) :: a)) in\n    let base = (0, [0]) in\n    let args = ((List.rev (List.hd l1)), (List.rev (List.hd l2))) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), ((sum mod 10) :: a)) in\n    let base = (0, [0]) in\n    let args = ((List.rev (List.hd l1)), (List.rev (List.hd l2))) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), ((sum mod 10) :: a)) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine (l1, l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), ((sum mod 10) :: a)) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), ((sum mod 10) :: a)) in\n    let base = 0 [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), ((sum mod 10) :: a)) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), ((sum mod 10) :: a)) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), ((sum mod 10) :: a)) in\n    let base = ([0], [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), ((sum mod 10) :: a)) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), ((sum mod 10) :: a)) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int * int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int * int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list -> int * int -> int -> int list\n       but an expression was expected of type\n         int list -> int * int -> int list\n       Type int -> int list is not compatible with type int list \n", "Error: This expression has type int but an expression was expected of type\n         int * int\n", "Error: This expression has type\n         int list -> int * int -> int -> int * int list\n       but an expression was expected of type\n         int list -> int * int -> int list\n       Type int -> int * int list is not compatible with type int list \n", "Error: This expression has type\n         (int * int) list -> int * int -> int -> (int * int) list\n       but an expression was expected of type\n         (int * int) list -> int * int -> (int * int) list\n       Type int -> (int * int) list is not compatible with type\n         (int * int) list \n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int list -> int * int -> int -> int list\n       but an expression was expected of type\n         int list -> int * int -> int list\n       Type int -> int list is not compatible with type int list \n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n", "Error: This expression has type\n         (int * int) list -> int * int -> int -> int list * int list\n       but an expression was expected of type\n         (int * int) list -> int * int -> (int * int) list\n       Type int -> int list * int list is not compatible with type\n         (int * int) list \n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n"], "bad": ["\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in (x (sum / 10)) :: (sum mod 10) :: a in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in (x (sum / 10)) :: (sum mod 10) :: a in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in (sum / 10) :: (sum mod 10) :: a in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), (x :: (sum mod 10) :: a)) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), ((sum mod 10) :: a)) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), (sum mod 10)) :: a in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10) (sum mod 10)) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10) :: (sum mod 10)) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in (sum / 10) :: (sum mod 10) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in List.split ((sum / 10) :: (sum mod 10) :: a) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in List.split ((sum / 10), ((sum mod 10) :: a)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in List.split (((sum / 10), (sum mod 10)) :: a) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in List.split ((sum / 10), ((sum mod 10) :: a)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s)\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type\n         (int * int) list -> int * int -> int -> (int * int) list\n       but an expression was expected of type\n         (int * int) list -> int * int -> (int * int) list\n       Type int -> (int * int) list is not compatible with type\n         (int * int) list \n", "Error: This expression has type int * 'a list\n       but an expression was expected of type (int * int) list\n", "Error: This expression has type int * 'a list\n       but an expression was expected of type (int * int) list\n", "Error: This expression has type int * int list\n       but an expression was expected of type (int * int) list\n", "Error: This expression has type (int * int) list\n       but an expression was expected of type 'a * 'b\n", "Error: Unbound value t\n", "Error: This expression has type int * 'a\n       but an expression was expected of type (int * int) list\n", "Error: This expression has type int * 'a\n       but an expression was expected of type (int * int) list\n", "Error: This expression has type int * 'a\n       but an expression was expected of type (int * int) list\n"], "bad": ["\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in ((((c + s) + t) / 10), (((c + s) + t) mod 10)) :: a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet c = 3;;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (s,t) = x in ((((c + s) + t) / 10), (((c + s) + t) mod 10)) :: a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet c = 3;;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (s,t) = x in ((((c + s) + t) / 10), (((c + s) + t) mod 10)) :: a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet c = 3;;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (s,t) = x in ((((c + s) + t) / 10), (((c + s) + t) mod 10)) :: a in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet c = 3;;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (s,t) = x in ((((c + s) + t) / 10), (((c + s) + t) mod 10)) :: a in\n    let base = [(0, 0)] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in ((((c + s) + t) / 10), (((c + s) + t) mod 10)) :: a in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in ((((c + x') + x'') / 10), (((c + x') + x'') mod 10))\n        :: a in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in ((((c + x') + x'') / 10), (((c + x') + x'') mod 10))\n        :: a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in ((((c + x') + x'') / 10), (((c + x') + x'') mod 10))\n        :: a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value List.len\n", "Error: Unbound value List.lenth\nHint: Did you mean length?\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: Unbound value h\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type bool but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "bad": ["\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.len s) == (List.len x)\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.lenth s) == (List.length x)\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) == (List.length x)\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = (List.length x)\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = (List.length x)\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = (List.length x)\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length a) = (List.length x)\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = (List.length x)\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length x) = (List.length s)\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if ((h :: t) x) = []\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if x = []\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if x = [((), ())]\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length x) = 5\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length a) = 5\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = 5\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if s = []\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if s != []\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if s != []\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if s = []\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if s\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match s with\n      | [] -> c :: s\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match s with\n      | [] -> c :: s\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match s with\n      | [] -> ((c + x') + x'') :: s\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match s with\n      | [] -> (((c + x') + x'') + 0) :: s\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match s with\n      | [] -> (c + 0) :: s\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match (c, s) with\n      | (c,[]) -> (c + 0) :: s\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match (c, s) with\n      | (c,[]) -> c :: s\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match (c, s) with\n      | (c,[]) -> c :: s\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = (List.length s) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b list\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "bad": ["\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = (List.length a)\n      then (c, (c :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = (List.length x)\n      then (c, (c :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length x) = (List.length x)\n      then (c, (c :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = (List.length l1) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b list\n       but an expression was expected of type 'c list\n"], "bad": ["\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = (List.length a)\n      then (c, (c :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let rec mulByDigit i l = \nif i > 0\nthen bigAdd l (mulByDigit (i - 1) l)\nelse [0]"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int list -> int list\n       but an expression was expected of type int list\n"], "bad": ["\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else bigAdd [0];;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type 'a list * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list * 'a\n       but an expression was expected of type int list\n"], "bad": ["\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = (1, []) in\n  let args = ((List.rev l2), l1) in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,l) = x in\n    let (i',l') = a in\n    match i with | [] -> l' | h::t -> bigAdd ((mulByDigit h l') l') in\n  let base = (1, l1) in\n  let args = ((List.rev l2), l1) in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,l) = x in\n    let (i',l') = a in\n    match i with | [] -> l' | h::t -> bigAdd ((mulByDigit h l'), l') in\n  let base = (1, l1) in\n  let args = ((List.rev l2), l1) in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,l) = x in\n    let (i',l') = a in\n    match i with | [] -> l' | h::t -> bigAdd ((mulByDigit h l') l') in\n  let base = (1, l1) in\n  let args = ((List.rev l2), l1) in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,l) = x in\n    let (i',l') = a in\n    match i' with | [] -> l' | h::t -> bigAdd ((mulByDigit h l') l') in\n  let base = (1, l1) in\n  let args = ((List.rev l2), l1) in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,l) = x in\n    let (i',l') = a in\n    match i' with | [] -> l' | h::t -> (t, (bigAdd ((mulByDigit h l') l'))) in\n  let base = (1, l1) in\n  let args = ((List.rev l2), l1) in\n  let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type int list\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type int list\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type int list\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type int list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type int list\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type int list\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type int list\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type int list\n"], "bad": ["\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x = match x with | [] -> a | h::t -> bigAdd ((mulByDigit h a) a) in\n  let base = l1 in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x = match x with | [] -> a | h::t -> bigAdd ((mulByDigit (h a)) a) in\n  let base = l1 in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x = match x with | [] -> a | h::t -> bigAdd ((mulByDigit (h a)) a) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> a' | h::t -> bigAdd ((mulByDigit (h a')) a') in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> a' | h::t -> bigAdd ((mulByDigit (h l1')) a') in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> a' | h::t -> bigAdd ((mulByDigit (h, l1')) a') in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> a' | h::t -> bigAdd ((mulByDigit (h l1')) a') in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> a' | h::t -> bigAdd ((mulByDigit (h l1')) a') in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> a' | h::t -> bigAdd (mulByDigit (h l1') a') in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> a' | h::t -> bigAdd (mulByDigit (h l1')) a' in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int list -> int list\n       but an expression was expected of type int list\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type 'a * int list\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type 'a * int list\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type 'a * int list\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type 'a * int list\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type 'a * int list\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type 'a * int list\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type 'a * int list\n", "Error: This function has type int -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound value li'\nHint: Did you mean l1'?\n"], "bad": ["\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> (l1, a') | h::t -> bigAdd (mulByDigit (h l1')) a' in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> (l1, a') | h::t -> bigAdd ((mulByDigit (h l1')) a') in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> (l1, a') | h::t -> bigAdd (mulByDigit (h l1') a') in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = x in\n    match a with | [] -> (l1, a') | h::t -> bigAdd (mulByDigit (h l1') a') in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = x in\n    match a with | [] -> (l1, a') | h::t -> bigAdd (mulByDigit (h l1') a') in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = x in\n    match a with | [] -> (l1', a') | h::t -> bigAdd (mulByDigit (h l1') a') in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> (l1', a') | h::t -> bigAdd (mulByDigit (h l1') a') in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> (l1', a') | h::t -> bigAdd (mulByDigit (h l1') a') in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> (l1', a') | h::t -> bigAdd (mulByDigit h l1' a') in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with\n    | [] -> (l1', a')\n    | h::t -> (li', (bigAdd (mulByDigit h l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int list * int\n       but an expression was expected of type int list * int list\n       Type int is not compatible with type int list \n"], "bad": ["\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with\n    | [] -> (l1', a')\n    | h::t -> (l1', (bigAdd (mulByDigit h l1') a')) in\n  let base = (l1, 0) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, [0]) in\nlet args = (List.hd (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with\n    | [] -> (l1', a')\n    | h::t -> (l1', (bigAdd (mulByDigit h l1') a')) in\n  let base = (l1, [0]) in\n  let args = List.hd (List.rev List.hd l2) in\n  let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n| _ -> 0\nin\nhelper d k l"], "hw": "hw2", "problem": "assoc", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a list list\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet assoc (d,k,l) =\n  let rec helper di ki li =\n    match li with\n    | h::t ->\n        (match h with\n         | hh::tt -> if hh = ki then di else helper di ki tt\n         | _ -> 0) in\n  helper d k l;;\n"]}
{"fix": ["let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then d\nelse assoc(d,k,t)\n| _-> d"], "hw": "hw2", "problem": "assoc", "message": ["Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b * 'c\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n"], "bad": ["\nlet assoc (d,k,l) =\n  match l with\n  | h::t ->\n      let rec helper di ki li =\n        let (name,age) = li in\n        if name = ki\n        then di\n        else (match li with | h::t -> helper di ki t | _ -> di) in\n      helper d k h;;\n", "\nlet assoc (d,k,l) =\n  match l with\n  | h::t ->\n      let rec helper di ki li = match li with | h::t -> h in helper d k h;;\n\nlet _ =\n  let assoc (d,k,l) =\n    match l with\n    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n    | _ -> d in\n  helper d k h;;\n", "\nlet assoc (d,k,l) =\n  match l with\n  | h::t ->\n      let rec helper di ki li = match li with | h::t -> h in helper d k h;;\n\nlet _ =\n  let assoc (d,k,l) =\n    match l with\n    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n    | _ -> d in\n  helper d k h;;\n"]}
{"fix": ["let wwhile (f,b) = \nlet (func, boo) = f in\nfunc"], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type int -> int * bool\n       but an expression was expected of type 'a * 'b\n"], "bad": ["\nlet wwhile (f,b) = let (func,boo) = f in func;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n"]}
{"fix": ["let rec wwhile (f,b) = let func = f b in\nlet (value,boo) = func in\nif boo then wwhile (f,value)\nelse value"], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'a * bool\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type ('b -> 'a * bool) * 'b\n", "Error: This expression has type 'a -> 'b * bool\n       but an expression was expected of type ('a -> 'b * bool) * 'a\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (func, boo) else value;;\n", "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile func else value;;\n", "\nlet rec wwhile (f,b) =\n  let func = f b in let (value,boo) = func in if boo then wwhile f else value;;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value x\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: Unbound value x\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: Unbound value x\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile (let xx = (x * x) * x in ((xx, (xx < 100)), b));;\n", "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile (let xx = f b in ((xx, (xx = b)), b));;\n", "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile (((f b), (xx = b)), b);;\n", "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile (((f b), (xx = b)), b);;\n", "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile (let xx = (x * x) * x in ((xx, (xx < 100)), b));;\n", "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile (let xx = (b * b) * b in ((xx, (xx < 100)), b));;\n", "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile (let xx = (x * x) * x in ((xx, (xx < 100)), b));;\n", "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile ((((b * b) * b), (((b * b) * b) < 100)), b);;\n", "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile ((((b * b) * b), (b < 100)), b);;\n", "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile (((f b), false), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((let d x = let xx = f x in (xx, xx = b) in d),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) =\n  wwhile ((let d x = let xx = f x in (xx, (xx = b)) in d b), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((let g x = (f x, x = fx) in g,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  wwhile ((let d x = let xx = f x in (xx, (xx = b)) in d), b);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx = b)) in g), b);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx = b)) in g), b);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx = b)) in g), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((let g x = let d = (f x) in (d, x = d) in g),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) = wwhile ((let g x = ((f x), (x = fx)) in g), b);;\n", "\nlet fixpoint (f,b) = wwhile ((let g x = ((f x), (x = (f x))) in g), b);;\n", "\nlet fixpoint (f,b) = wwhile ((let g x = let d = f x in (d, (x = d)) in g), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((let g x = let d = (g b) in (d, x = d) in g),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) = wwhile ((let g x = let d = f x in (d, (x = d)) in g), b);;\n", "\nlet fixpoint (f,b) = wwhile ((let g x = let d = f b in (d, (x = d)) in g), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((let g x = let d = (f b) in (d, b = d) in g),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n"], "bad": ["\nlet fixpoint (f,b) = wwhile ((let g x = let d = g b in (d, (x = d)) in g), b);;\n", "\nlet fixpoint (f,b) =\n  wwhile ((let g x = let d = f b in (d, (x != d)) in g), b);;\n", "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((let g x = let d = (f x) in (d, x = d) in g b),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) = wwhile ((let g x = let d = f b in (d, (b = d)) in g), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((let g x = (f x, x = f x) in g),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  wwhile ((let g x = let d = f x in (d, (x = d)) in g b), b);;\n", "\nlet fixpoint (f,b) = wwhile ((let g x = let d = f x in (d, (x = d)) in g), b);;\n", "\nlet fixpoint (f,b) = wwhile ((let g x = let d = f x in (d, (x = d)) in g), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((let g x = (f x, x != f x) in g),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) = wwhile ((let g x = ((f x), (x = (f x))) in g), b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) = wwhile ((let g x = ((f x), (x != (f x))) in g), b);;\n"]}
{"fix": ["let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d"], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\nError: Unbound value sampleExpr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n"]}
{"fix": ["let rec exprToString ex = \nmatch ex with \n|VarX -> \"x\"\n|VarY -> \"y\"\n|Sine(e) -> \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) -> \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) -> \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) -> exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type expr but an expression was expected of type\n         string\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString ex =\n  match ex with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | _ -> \"\" ^ (ex ^ \"\");;\n"]}
{"fix": ["let rec build (rand, depth) = \nif depth=0 then buildX() else\nlet randNum = rand 0 5 in\nlet depth = depth - 1 in\nmatch randNum with \n|0 -> buildSine(build(makeRand(5,16), depth))\n|1 -> buildCosine(build(rand, depth))\n|2 -> buildTimes(build(rand, depth),build(rand, depth))\n|3 -> buildAverage(build(rand, depth),build(rand, depth))\n|_ -> buildY()"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n", "Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n", "Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand 0 5 in\n     match randNum with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildY ());;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = build ((makeRand (5, 16)), 5);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand 0 5 in\n     match randNum with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildY ());;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = let random = makeRand (5, 16) in build (random, 5);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand 0 5 in\n     match randNum with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildY ());;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = let random = makeRand (5, 16) in build (random, 5);;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand 0 5 in\n     let depth = depth - 1 in\n     match randNum with\n     | 0 -> buildSine (build ((makeRand (5, 16)), depth))\n     | 1 -> buildCosine (build (rand, depth))\n     | 2 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n     | 3 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n     | _ -> buildY ());;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand 0 5 in\n     let depth = depth - 1 in\n     match randNum with\n     | 0 -> buildSine (build ((makeRand (5, 16)), depth))\n     | 1 -> buildCosine (build ((makeRand (5, 16)), depth))\n     | 2 ->\n         buildTimes\n           ((build ((makeRand (5, 16)), depth)),\n             (build ((makeRand (5, 16)), depth)))\n     | 3 ->\n         buildAverage\n           ((build ((makeRand (5, 16)), depth)),\n             (build ((makeRand (5, 16)), depth)))\n     | _ -> buildY ());;\n"]}
{"fix": ["let rec exprToString ex = \nmatch ex with \n|VarX -> \"x\"\n|VarY -> \"y\"\n|Sine(e) -> \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) -> \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) -> \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) -> exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"\n|MyExpr1 (e1,e2,e3) -> \"(sqrt(\"^exprToString e1^\")*sqrt(\"^exprToString e2^\")*\"^exprToString e3^\")\"\n|MyExpr2 (e) -> \"halve(\"^exprToString^\")\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet rec exprToString ex =\n  match ex with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | MyExpr1 (e1,e2,e3) ->\n      \"(sqrt(\" ^\n        ((exprToString e1) ^\n           (\")*sqrt(\" ^ ((exprToString e2) ^ ((\")*\" exprToString e3) ^ \")\"))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type expr -> string\n       but an expression was expected of type string\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet rec exprToString ex =\n  match ex with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | MyExpr1 (e1,e2,e3) ->\n      \"(sqrt(\" ^\n        ((exprToString e1) ^\n           (\")*sqrt(\" ^\n              ((exprToString e2) ^ (\")*\" ^ ((exprToString e3) ^ \")\")))))\n  | MyExpr2 e -> \"halve(\" ^ (exprToString ^ \")\");;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | MyExpr1 (e1,e2,e3) -> ((sqrt e1) *. (sqrt e2)) *. e3\n  | MyExpr2 e -> e *. 0.5;;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type expr but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | MyExpr1 (e1,e2,e3) -> ((sqrt e1) *. (sqrt e2)) *. e3\n  | MyExpr2 e -> e *. 0.5;;\n"]}
{"fix": ["let rec eval (e,x,y) = \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)\n|MyExpr1(e1,e2,e3) -> cos(pi*.eval (e1,x,y))*.sin(pi*.eval (e2,x,y))*.eval(e3,x,y)\n|MyExpr2(e) -> sin(pi*.eval (e,x,y)*.0.5)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type expr but an expression was expected of type\n         float\n", "Error: This expression has type expr but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | MyExpr1 (e1,e2,e3) ->\n      ((Cosine (eval (e1, x, y))) *. (Sine (eval (e2, x, y)))) *.\n        (eval (e3, x, y))\n  | MyExpr2 e -> Sine ((eval (e, x, y)) *. 0.5);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | MyExpr1 (e1,e2,e3) ->\n      ((cos (pi *. (eval (e1, x, y)))) *. (sin (pi *. (eval (e2, x, y))))) *.\n        (eval (e3, x, y))\n  | MyExpr2 e -> Sine ((eval (e, x, y)) *. 0.5);;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a + x in\nlet base = 0 in\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type int but an expression was expected of type\n         float -> float -> float\n", "Error: This expression has type float but an expression was expected of type\n         float -> float -> float\n", "Error: This expression has type float but an expression was expected of type\n         float -> float -> float\n", "Error: This expression has type int but an expression was expected of type\n         int -> int -> int\n"], "bad": ["\nlet sqsum xs = let f a x = (+.) in let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs = let f a x = (+.) in let base = 0. in List.fold_left f base xs;;\n", "\nlet sqsum xs = let f a x = (+.) in let base = 0. in List.fold_left f base xs;;\n", "\nlet sqsum xs = let f a x = (+) in let base = 0 in List.fold_left f base xs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value f\n", "Error: This expression has type int but an expression was expected of type\n         'a list -> 'b list\n", "Error: This expression has type int but an expression was expected of type\n         'a list -> 'b list\n", "Error: This expression has type int but an expression was expected of type\n         'a list -> 'b list\n"], "bad": ["\nlet pipe fs =\n  let f a x = List.map f x in let base = 0 in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = List.map x in let base = 0 in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = List.map x in let base = 0 in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = List.map x in let base = 3 in List.fold_left f base fs;;\n"]}
{"fix": [], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list list\n       but an expression was expected of type 'a list\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type string\n", "Error: This expression has type 'a list\n       but an expression was expected of type string\n", "Error: This expression has type 'a list\n       but an expression was expected of type string\n", "Error: This expression has type 'a list\n       but an expression was expected of type string\n", "Error: This expression has type 'a list\n       but an expression was expected of type string\n", "Error: This expression has type 'a list list\n       but an expression was expected of type string\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = List.append (List.append a sep) h in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = List.append (List.append a sep) h in\n      let base = t in let l = sl in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = List.append h sep in\n      let base = h in let l = sl in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a @ x in\n      let base = h in let l = sl in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a @ x in\n      let base = h in let l = sl in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a @ sep in\n      let base = h in let l = t in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a @ sep in\n      let base = h in let l = sl in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a @ sep in\n      let base = t in let l = h in List.fold_left f base l;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x in\nlet base = 0 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n", "Error: Unbound value x\n", "Error: Unbound value x\n"], "bad": ["\nlet a = 20;;\n\nlet pipe fs = let f a x = x a in let base = x a in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x in let base = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x in let base = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fs in\nlet base = fs in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value base\n", "Error: Unbound value base\n", "Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound value x\n", "Error: Unbound value a'\n"], "bad": ["\nlet pipe fs = let f a x = base in let base = base in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = base in List.fold_left f base fs;;\n", "\nlet a = 20;;\n\nlet f x = let y = 1 in let g z = y + z in a + (g x);;\n\nlet pipe fs =\n  let f a x = f x a in let base = f x a in List.fold_left f base fs;;\n", "\nlet a = 20;;\n\nlet pipe fs = let f a x = x a in let base = f x a in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a' in let base = a' in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun x -> x  in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: Unbound value base\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet a = 20;;\n\nlet f x = let y = 1 in let g z = y + z in a + (g x);;\n\nlet pipe fs = let f a x = f a x in let base = 3 in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = fs in let base = fs in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = pipe a x in let base = 3 in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = fs in let base = fs in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = pipe a x in let base = 3 in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = fs in let base = fs in List.fold_left f base fs;;\n\nlet pipe fs = let f a x = pipe fs in let base = 3 in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = fs in let base = fs in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = pipe base in let base = 3 in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = fs in let base = fs in List.fold_left f base fs;;\n\nlet pipe fs = let f a x = pipe fs in let base = 3 in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun a -> x  in\nlet base = fun a -> a in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n"], "bad": ["\nlet pipe fs = let f a x a = x in let base a = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun a -> x  in\nlet base = fun a -> a in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n"], "bad": ["\nlet pipe fs = let f a x a = x in let base a = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun a -> x in\nlet base = pipe [] in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"], "bad": ["\nlet pipe fs = let f a x a = x in let base a = a in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a x = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = pipe [] in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x x = a in let base = pipe [] in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = pipe [] in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x a = x in let base a = a in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a x = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = pipe [] in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = a x in let base = pipe [] in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun p -> p in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n", "Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n"], "bad": ["\nlet a = 20;;\n\nlet pipe fs = let f a x = x a in let base = x a in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun x a-> a in\nlet base = fun p -> p in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'b -> 'a\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base p = p in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x x = x a in let base p = p in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x x a = x in let base p = p in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun x a -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value g\n", "Error: This expression has type 'a -> 'b -> 'c -> 'd -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'd -> 'a\n", "Error: Unbound value d\n"], "bad": ["\nlet pipe fs = let f a x d x = g in let base p = p in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x d x = a in let base p = p in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x x a = d in let base p = p in List.fold_left f base fs;;\n"]}
{"fix": [], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n"], "bad": ["\nlet a = 20;;\n\nlet f x = let y = 1 in let g z = y + z in a + (g x);;\n\nlet pipe fs =\n  let f a x x a d = d in let base p = p in List.fold_left f base fs;;\n\nlet _ = let base = pipe [] in List.fold_left f base fs;;\n", "\nlet a = 20;;\n\nlet f x = let y = 1 in let g z = y + z in a + (g x);;\n\nlet pipe fs =\n  let f a x x a d = d in let base p = p in List.fold_left f base fs;;\n\nlet _ = let base = pipe [] in List.fold_left f base fs;;\n", "\nlet a = 20;;\n\nlet f x = let y = 1 in let g z = y + z in a + (g x);;\n\nlet pipe fs =\n  let f a x x a d = d in let base p = p in List.fold_left f base fs;;\n\nlet _ = let base = pipe [] in List.fold_left f base fs;;\n", "\nlet a = 20;;\n\nlet f x = let y = 1 in let g z = y + z in a + (g x);;\n\nlet pipe fs =\n  let f a x x a d = d in let base p = p in List.fold_left f base fs;;\n\nlet _ = let base = pipe [] in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun d -> d in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet f x = 1;;\n\nlet f x = if x < 2 then 1 else x * (f (x - 1));;\n\nlet pipe fs =\n  let f a x x a d = d in let base p = p in List.fold_left f base fs;;\n\nlet _ = let base = pipe [] in List.fold_left f base fs;;\n", "\nlet f x = 1;;\n\nlet f x = if x < 2 then 1 else x * (f (x - 1));;\n\nlet pipe fs =\n  let f a x x a d = d in let base p = p in List.fold_left f base fs;;\n\nlet _ = let base = pipe [] in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base d = d in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun a x -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n"], "bad": ["\nlet pipe fs =\n  let f a x a x = x a in let base d = d in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n"], "bad": ["\nlet pipe fs = let f a x x = x a in let base d = d in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n"], "bad": ["\nlet pipe fs = let f a x x = x a in let base d = d in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x a = a x in let base d = d in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x a = a x in let base d = d in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun a ->  x a in\nlet base = fun d -> d in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n"], "bad": ["\nlet pipe fs =\n  let f a x a x = x a in let base d = d in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x a x = x a in let base d = d in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun a -> a in\nlet base = fun d-> d in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'b -> 'a\n"], "bad": ["\nlet pipe fs = let f a x a x = a in let base d = d in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun d ->  x a in\nlet base = fun d-> d in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"], "bad": ["\nlet pipe fs = let f a x d = a in let base d = d in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun p -> fun s a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'c -> 'a -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'c -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base d = d in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x d x = a x in let base d = d in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x a = a x in let base d = d in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun a d -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n"], "bad": ["\nlet pipe fs =\n  let f a x a x = x a in let base d = d in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n"], "bad": ["\nlet pipe fs =\n  let f a x a x = x a in let base d = d in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x  in\nlet base = fun p -> p in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base p = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base p = p in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base p = p in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun x -> x in\nlet base = fun p -> p in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"], "bad": ["\nlet pipe fs = let f a x x = a in let base p = p in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x in\nlet base = fun p -> p in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value list\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'b list\n"], "bad": ["\nlet pipe fs =\n  let f a x = list.rev x in let base p = p in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = List.rev x in let base p = p in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type ('b -> 'b) list\n", "Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type ('b -> 'b) list\n"], "bad": ["\nlet pipe fs =\n  let f a x = x in let base p = p in List.fold_left f base List.rev fs;;\n", "\nlet pipe fs =\n  let f a x = x in let base p = p in List.fold_left f base List.rev fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> 'a -> int\n       Type int is not compatible with type 'a -> int \n"], "bad": ["\nlet f x = 1;;\n\nlet f x = if x < 2 then 1 else x * (f (x - 1));;\n\nlet _ =\n  let pipe fs = let f a x = x in fun x  -> x in\n  let base p = p in List.fold_left f base (List.rev fs);;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a  in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type ('a list -> 'b -> 'b) list\n       The type variable 'a occurs inside 'a list -> 'b -> 'b\n"], "bad": ["\nlet pipe fs =\n  let f a x = x fs in let base p = p in List.fold_left f base (List.rev fs);;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun d-> x a d in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'a -> 'b) -> 'a -> 'a -> 'b\n       but an expression was expected of type\n         ('a -> 'a -> 'b) -> 'a -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs =\n  let f a x d = a x d in\n  let base p = p in List.fold_left f base (List.rev fs);;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet pipe fs =\n  let f a x = x in let base p = x p in List.fold_left f base (List.rev fs);;\n", "\nlet a = 20;;\n\nlet pipe fs =\n  let f a x = x in let base p = a p in List.fold_left f base (List.rev fs);;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun a' -> a' in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base a' = a' in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base a' = a' in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun p' -> a x  in\nlet base = fun a' -> a' in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"], "bad": ["\nlet pipe fs =\n  let f a x p' = a in let base a' = a' in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x =  fun p -> a x in\nlet base = pipe [] in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs =\n  let f a x p' = x a in let base a' = a' in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = a x in let base = pipe [] in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun l -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n", "Error: This expression has type 'a -> 'b -> 'c -> 'd -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'd -> 'a\n", "Error: This expression has type 'a -> 'b -> 'c -> 'd -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'd -> 'a\n", "Error: This expression has type 'a -> 'b -> 'c -> 'd -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'd -> 'a\n"], "bad": ["\nlet pipe fs = let f a x x = x a in let base p = p in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x l x = a in let base p = p in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x l x = a in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x l x = a in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun l -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> 'c -> ('a -> 'd) -> 'd\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> ('a -> 'd) -> 'd\n"], "bad": ["\nlet pipe fs =\n  let f a x l x = x a in let base p = p in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun l -> x (a l) in\nlet base = fun p -> p in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs =\n  let f a x l = l (x a) in let base p = p in List.fold_left f base fs;;\n"]}
{"fix": ["let stringOfList f l = \"[\"^ sepConcat \"; \" (List.map f l) ^\"]\""], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type string list -> string\n       but an expression was expected of type 'a list\n", "Error: This expression has type string but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((List.map f (sepConcat l)) ^ \"]\");;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((List.map f (sepConcat \"; \" l)) ^ \"]\");;\n"]}
{"fix": ["let rec clone x n = \nif n < 1 then \n[]\nelse \nx::(clone x (n-1))"], "hw": "hw3", "problem": "clone", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n = if n > 0 then x @ ((clone x n) - 1) else [];;\n", "\nlet rec clone x n = if n > 0 then x @ ((clone x n) - 1) else [];;\n", "\nlet rec clone x n = if n < 1 then [] else x :: ((clone x n) - 1);;\n"]}
{"fix": ["let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet x = List.length l1 - List.length l2 in \nlet list_p = clone 0 x in \n(l1,list_p@l2)\nelse if List.length l1 < List.length l2 then\nlet x = List.length l2 - List.length l1 in \nlet list_p = clone 0 x in \n(list_p@l1,l2)\nelse\n(l1,l2)"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type unit\n", "Error: This expression has type 'a list\n       but an expression was expected of type unit\n", "Error: This expression has type 'a list\n       but an expression was expected of type unit\n", "Error: This expression has type 'a list\n       but an expression was expected of type unit\n", "Error: Unbound value List.l1\n"], "bad": ["\nlet padZero l1 l2 = if (List.length l1) == (List.length l2) then l1 @ l2;;\n", "\nlet padZero l1 l2 = if (List.length l1) = (List.length l2) then l1 @ l2;;\n", "\nlet padZero l1 l2 = if (List.length l1) == (List.length l2) then l1 @ l2;;\n", "\nlet padZero l1 l2 = if (List.length l1) == (List.length l2) then l1 @ l2;;\n", "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if List.l1 > List.l2\n  then\n    let x = List.l1 - List.l2 in\n    let list_p = clone 0 x in (l1, (list_p @ l2))\n  else\n    if List.l1 < List.l2\n    then\n      (let x = List.l2 - List.l1 in\n       let list_p = clone 0 x in ((list_p @ l1), l2))\n    else (l1, l2);;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then \n(1, listy @ [initsum mod 10])\nelse \n(0,listy @ [initsum]) in\nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let x = (List.length l1) - (List.length l2) in\n    let list_p = clone 0 x in (l1, (list_p @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let x = (List.length l2) - (List.length l1) in\n       let list_p = clone 0 x in ((list_p @ l1), l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,listy) = a in\n      let (num1,num2) = x in\n      let initsum = (num1 + num2) + carry in\n      if initsum > 9\n      then (1, (listy @ [initsum mod 10]))\n      else (0, (listy @ initsum)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then \n(1, listy @ [initsum mod 10])\nelse \n(0,listy @ [initsum]) in\nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nList.rev (removeZero (add (padZero l1 l2)))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let x = (List.length l1) - (List.length l2) in\n    let list_p = clone 0 x in (l1, (list_p @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let x = (List.length l2) - (List.length l1) in\n       let list_p = clone 0 x in ((list_p @ l1), l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,listy) = a in\n      let (num1,num2) = x in\n      let initsum = (num1 + num2) + carry in\n      if initsum > 9\n      then (1, (listy @ [initsum mod 10]))\n      else (0, (listy @ [initsum])) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  List.rev removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> \nlet initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-intKeep) mod 100 in\nlet v = List.rev(t) in \nhelpy p v carrying accList@[intKeep] in\nremoveZero(List.rev(helpy i l 0 [0;0]))"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: Unbound value numList\nHint: Did you mean numsList?\n", "Error: Unbound value initKeep\nHint: Did you mean intKeep?\n", "Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type int list\n", "Error: Unbound value initKeep\nHint: Did you mean intKeep?\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: Unbound value list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n"], "bad": ["\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet mulByDigit i l =\n  let rec helpy p q carry accList =\n    let numsList = List.rev q in\n    match numList with\n    | [] -> accList\n    | h::t ->\n        let initMul = (h * p) + carry in\n        let intKeep = initMul mod 10 in\n        let carrying = (initMul - initKeep) mod 100 in\n        (helpy p List.rev t carrying accList) @ initKeep in\n  removeZero (list.rev (helpy i l 0 [(0, 0)]));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet mulByDigit i l =\n  let rec helpy p q carry accList =\n    let numsList = List.rev q in\n    match numsList with\n    | [] -> accList\n    | h::t ->\n        let initMul = (h * p) + carry in\n        let intKeep = initMul mod 10 in\n        let carrying = (initMul - initKeep) mod 100 in\n        (helpy p List.rev t carrying accList) @ initKeep in\n  removeZero (list.rev (helpy i l 0 [(0, 0)]));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet mulByDigit i l =\n  let rec helpy p q carry accList =\n    let numsList = List.rev q in\n    match numsList with\n    | [] -> accList\n    | h::t ->\n        let initMul = (h * p) + carry in\n        let intKeep = initMul mod 10 in\n        let carrying = (initMul - intKeep) mod 100 in\n        (helpy p List.rev t carrying accList) @ initKeep in\n  removeZero (list.rev (helpy i l 0 [(0, 0)]));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet mulByDigit i l =\n  let rec helpy p q carry accList =\n    let numsList = List.rev q in\n    match numsList with\n    | [] -> accList\n    | h::t ->\n        let initMul = (h * p) + carry in\n        let intKeep = initMul mod 10 in\n        let carrying = (initMul - intKeep) mod 100 in\n        let v = List.rev t in (helpy p v carrying accList) @ initKeep in\n  removeZero (list.rev (helpy i l 0 [(0, 0)]));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet mulByDigit i l =\n  let rec helpy p q carry accList =\n    let numsList = List.rev q in\n    match numsList with\n    | [] -> accList\n    | h::t ->\n        let initMul = (h * p) + carry in\n        let intKeep = initMul mod 10 in\n        let carrying = (initMul - intKeep) mod 100 in\n        let v = List.rev t in (helpy p v carrying accList) @ intKeep in\n  removeZero (list.rev (helpy i l 0 [(0, 0)]));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet mulByDigit i l =\n  let rec helpy p q carry accList =\n    let numsList = List.rev q in\n    match numsList with\n    | [] -> accList\n    | h::t ->\n        let initMul = (h * p) + carry in\n        let intKeep = initMul mod 10 in\n        let carrying = (initMul - intKeep) mod 100 in\n        let v = List.rev t in (helpy p v carrying accList) @ [intKeep] in\n  removeZero (list.rev (helpy i l 0 [(0, 0)]));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet mulByDigit i l =\n  let rec helpy p q carry accList =\n    let numsList = List.rev q in\n    match numsList with\n    | [] -> accList\n    | h::t ->\n        let initMul = (h * p) + carry in\n        let intKeep = initMul mod 10 in\n        let carrying = (initMul - intKeep) mod 100 in\n        let v = List.rev t in (helpy p v carrying accList) @ [intKeep] in\n  removeZero (List.rev (helpy i l 0 [(0, 0)]));;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = \nlet (upper_mult, total) = a in\nlet newTotal = mulByDigit x upper_mult in\nlet updateTotal = bigAdd newTotal total in\n(upper_mult@[0],updateTotal) in\nlet base = (l1,[]) in\nlet args =  l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"], "bad": ["\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let x = (List.length l1) - (List.length l2) in\n    let list_p = clone 0 x in (l1, (list_p @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let x = (List.length l2) - (List.length l1) in\n       let list_p = clone 0 x in ((list_p @ l1), l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,listy) = a in\n      let (num1,num2) = x in\n      let initsum = (num1 + num2) + carry in\n      if initsum > 9\n      then (1, (listy @ [initsum mod 10]))\n      else (0, (listy @ [initsum])) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (List.rev (add (padZero l1 l2)));;\n\nlet mulByDigit i l =\n  let rec helpy p q carry accList =\n    let numsList = List.rev q in\n    match numsList with\n    | [] -> [carry] @ accList\n    | h::t ->\n        let initMul = (h * p) + carry in\n        let intKeep = initMul mod 10 in\n        let carrying = (initMul - intKeep) / 10 in\n        let v = List.rev t in (helpy p v carrying [intKeep]) @ accList in\n  removeZero (helpy i l 0 []);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (bottom_mult,total) = a in\n    match bottom_mult with\n    | [] -> total\n    | h::t ->\n        let newTotal = mulByDigit h x in\n        let updateTotal = bigAdd newTotal total in (t, updateTotal) in\n  let base = (l1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": [], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n"], "bad": ["\nlet pipe fs =\n  let f a x x = x a in let base x1 = x1 in List.fold_left f base fs;;\n"]}
{"fix": ["let stringOfList f l = List.map (f (sepConcat \" \" l))"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: Unbound value sepconcat\nHint: Did you mean sepConcat?\nError: Unbound value sepconcat\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sepconcat\nHint: Did you mean sepConcat?\n"], "bad": ["\nlet stringOfList f l = List.map (f (sepconcat \" \" l));;\n"]}
{"fix": [], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (\" \" List.map (f l));;\n"]}
{"fix": ["let stringOfList f l = sepConcat \" \" l"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (\" \" List.map (f l));;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (\" \" (List.map (f l)));;\n"]}
{"fix": ["let rec clone x n = \nif (n <= 0) then []\nelse x::(clone x (n-1))"], "hw": "hw3", "problem": "clone", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: ((clone x n) - 1);;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list -> 'b list -> ('a * 'b) list\n       but an expression was expected of type string\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (x,y) -> [a; (x + y) mod 10] in\n    let base = [] in\n    let args = failwith List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list -> 'b list -> ('a * 'b) list\n       but an expression was expected of type string\n", "Error: This expression has type 'a list -> ('b * 'a) list\n       but an expression was expected of type (int * int) list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (y,z) ->\n          let sum = y + z in\n          (match a with\n           | h::t -> ((sum + h) / 10) :: ((sum + h) mod 10) :: t\n           | [] -> [sum / 10; sum mod 10]) in\n    let base = [] in\n    let args = failwith List.combine (l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (y,z) ->\n          let sum = y + z in\n          (match a with\n           | h::t -> ((sum + h) / 10) :: ((sum + h) mod 10) :: t\n           | [] -> [sum / 10; sum mod 10]) in\n    let base = [] in\n    let args = List.combine (l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (y,z) -> let sum = y+z in\nmatch a with \n| h::t -> ((sum+h)/10)::((sum+h)mod 10)::t\n| _ -> (sum/10)::[(sum mod 10)] in\nlet base = [] in\nlet args = List.rev(List.combine l1 l2) in\n(*let (_, res) =*) List.fold_left f base args (*in\nres*)\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (y,z) ->\n          let sum = y + z in\n          (match a with\n           | h::t -> ((sum + h) / 10) :: ((sum + h) mod 10) :: t\n           | _ -> [sum / 10; sum mod 10]) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet g =\nlet f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in\nlet base = [] in\nlet args = List.rev l2 in List.fold_left f base args in\nList.fold_left bigAdd [] g"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: Unbound value b\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value b\n"], "bad": ["\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let mult = i * x in\n    match a with\n    | h::t -> ((h + mult) / 10) :: ((h + mult) mod 10) :: t\n    | _ -> [mult / 10; mult mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x = (List.append ((mulByDigit x l1) (clone 0 (List.length b)))) ::\n    b in\n  let base = [] in let args = List.rev l2 in List.fold_left f base args;;\n", "\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (y,z) ->\n          let sum = y + z in\n          (match a with\n           | h::t -> ((sum + h) / 10) :: ((sum + h) mod 10) :: t\n           | _ -> [sum / 10; sum mod 10]) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let mult = i * x in\n    match a with\n    | h::t -> ((h + mult) / 10) :: ((h + mult) mod 10) :: t\n    | _ -> [mult / 10; mult mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let g =\n    let f a x = (List.append ((mulByDigit x l1) (clone 0 (List.length b))))\n      :: b in\n    let base = [] in let args = List.rev l2 in List.fold_left f base args in\n  List.fold_left bigAdd [] g;;\n", "\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (y,z) ->\n          let sum = y + z in\n          (match a with\n           | h::t -> ((sum + h) / 10) :: ((sum + h) mod 10) :: t\n           | _ -> [sum / 10; sum mod 10]) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let mult = i * x in\n    match a with\n    | h::t -> ((h + mult) / 10) :: ((h + mult) mod 10) :: t\n    | _ -> [mult / 10; mult mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let g =\n    let f a x = ((mulByDigit x l1) @ (clone 0 (List.length b))) :: b in\n    let base = [] in let args = List.rev l2 in List.fold_left f base args in\n  List.fold_left bigAdd [] g;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = match a with\n|(move,result) -> match x with\n|(fac,dig) -> let prod = mulByDigit dig (fac @ (clone 0 move)) in\n(move +1, bigAdd result prod) in \nlet base = (0,[]) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in \nlet (_,res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (input,result) ->\n          (match x with\n           | (y,z) ->\n               let sum = (y + z) + input in\n               ((sum / 10), ((sum mod 10) :: result))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i = 1\n  then l\n  else\n    if i = 0\n    then [0]\n    else if i < 0 then [] else bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (move,result) ->\n        (match x with\n         | (fac,dig) ->\n             let prod = mulByDigit dig (fac @ (clone 0 move)) in\n             ((move + 1), (bigAdd result prod))) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) (List.rev 12) in\n  let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let rec sumList xs = \nmatch xs with\n| []-> 0\n| h::t -> h+sumList t"], "hw": "hw1", "problem": "sumList", "message": ["Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n", "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n", "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n"], "bad": ["\nlet rec sumList xs = match 1 with | [] -> 0 | h::t -> h + (sumList t);;\n", "\nlet rec sumList xs = match 1 with | [] -> 0 | h::t -> h + (sumList t);;\n", "\nlet rec sumList xs = match 1 with | [] -> 0 | h::t -> h + (sumList t);;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value %\n", "Error: Unbound value h\n", "Error: Unbound value head\n", "Error: Unbound value hd\n", "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n"], "bad": ["\nlet rec digitsOfInt n = if (h % 2) = 0 then [] else tail;;\n", "\nlet rec digitsOfInt n = if (h mod 2) = 0 then [] else tail;;\n", "\nlet rec digitsOfInt n = if (head mod 2) = 0 then [] else tail;;\n", "\nlet rec digitsOfInt n = if (hd mod 2) = 0 then [] else tl;;\n", "\nlet rec digitsOfInt n = if n < 0 then [];;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec digitsOfInt n = match n with | [] -> [] | h::t -> if n < 0 then [];;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n"], "bad": ["\nlet rec digitsOfInt n = match n with | [] -> [] | _ -> if n < 0 then [];;\n", "\nlet rec digitsOfInt n = match n with | _ -> if n < 0 then [];;\n"]}
{"fix": ["let digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt(n/10)::[]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type (int * int) list list\n       but an expression was expected of type int list\n       Type (int * int) list is not compatible with type int \n", "Error: This expression has type (int * int) list list\n       but an expression was expected of type int list\n       Type (int * int) list is not compatible with type int \n"], "bad": ["\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n =\n  if n < 0 then [] else if n < 10 then [n] else digitsOfInt (n mod 10);;\n", "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n =\n  if n < 0 then [] else if n < 10 then [n] else digitsOfInt (n / 10);;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt (n/10) @ (n mod 10)::[]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int but an expression was expected of type\n         (int * int) list list list list list\n"], "bad": ["\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt (n/10) @ (n mod 10)::[]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n", "\nlet rec digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n", "\nlet rec digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10); []];;\n", "\nlet rec digitsOfInt n =\n  let myList = [] in if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n", "\nlet rec digitsOfInt n =\n  let myList = [] in if n <= 0 then [] else [(digitsOfInt n) mod 10];;\n", "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else [digitsOfInt (n mod 10); digitsOfInt (n / 10)];;\n"]}
{"fix": ["let rec digitsOfInt n = \nlet myList = [] in\nif n <= 0 \nthen []\nelse\nif n < 10\nthen [n]\nelse\ndigitsOfInt (n/10) @ n mod 10 :: []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value num\n"], "bad": ["\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0\n  then []\n  else if n < 10 then [num] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nn mod 10 :: []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a * 'b) list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: [] :: (digitsOfInt (n / 10));;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10; digitsOfInt (n / 10)];;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10; [digitsOfInt (n / 10)]];;\n", "\nlet rec digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [((digitsOfInt (n / 10)), (n mod 10))];;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nn mod 10 :: []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: [] :: (digitsOfInt (n / 10));;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\nn mod 10 :: digitsOfInt(n/10);"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | _ -> ([n mod 10], (digitsOfInt (n / 10)));;\n", "\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | _ -> [n mod 10; digitsOfInt (n / 10)];;\n", "\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | _ -> [digitsOfInt (n / 10); n mod 10];;\n"]}
{"fix": ["let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse(t) :: l"], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value listReverse\n", "Error: Unbound value listReverse\n"], "bad": ["\nlet _ = listReverse [1; 2; 3; 4];;\n", "\nlet _ = listReverse [1; 2; 3; 4];;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value digitsOfInt\n"], "bad": ["\nlet _ = digitsOfInt 3124;;\n"]}
{"fix": [], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec listReverse l = match l with | [] -> [] | h::t -> (listReverse t) @ h;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n"]}
{"fix": ["let digits n = digitsOfInt (abs n)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value listReverse\n"], "bad": ["\nlet _ = listReverse [1; 2; 3; 4];;\n"]}
{"fix": ["let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse t @ [h]"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type string but an expression was expected of type\n         int\n"], "bad": ["\nlet rec listReverse l = match l with | [] -> [] | h::t -> [h; 2; 2];;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n"]}
{"fix": ["let rec listReverse l = match l with\n|[] -> []\n|h::t -> listReverse t @ [h]"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec listReverse l = match l with | [] -> [] | h::t -> h @ (listReverse t);;\n\nlet _ = listReverse [1; 2; 3; 4];;\n", "\nlet rec listReverse l = match l with | [] -> [] | h::t -> (listReverse t) @ h;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n"]}
{"fix": ["let rec wwhile (f,b) = match f with\n|(x, y) -> \nif y = true\nthen wwhile (f, x)"], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type int -> int * bool\n       but an expression was expected of type bool\n"], "bad": ["\nlet rec wwhile (f,b) = match f with | false  -> b | true  -> wwhile (f, b);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n"]}
{"fix": ["let rec wwhile (f,b) = \nlet (x, y) = f b in\n\nif y = true\nthen wwhile (f, x)\nelse x"], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type int -> int * bool\n       but an expression was expected of type 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n"]}
{"fix": ["let rec wwhile (f,b) = match f with\n|(x,y)->\nif y = true\nthen wwhile (f, x)\nelse x"], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value c\n", "Error: This expression has type 'a * 'b\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (x,y) = f c in if y = true then wwhile (f, x) else x;;\n", "\nlet rec wwhile (f,b) =\n  match f with\n  | (x,y) -> let (x,y) = f b in if y = true then wwhile (f, x) else x;;\n"]}
{"fix": [], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type int -> int * bool\n       but an expression was expected of type 'a * bool\n", "Error: This expression has type int -> int * bool\n       but an expression was expected of type 'a * bool\n", "Error: Unbound value y\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "\nlet rec wwhile (f,b) =\n  match f with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "\nlet _ =\n  let rec wwhile (f,b) = (fun (x,y)  -> b) f in\n  if y = true then wwhile (f, x) else x;;\n"]}
{"fix": ["let rec wwhile (f,b) = \nlet (x, y) = f b in\nif y = true\nthen wwhile (f, x)\nelse x"], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value f1\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (x,y) = f1 b in if y = true then wwhile (f1, x) else x;;\n"]}
{"fix": ["let rec wwhile (f,b) = \nlet (x, y) = f b in\nif y = true\nthen wwhile (f, x)\nelse x"], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value a\n", "Error: This expression has type 'a but an expression was expected of type\n         'b -> 'a * bool\n       The type variable 'a occurs inside 'b -> 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (x,y) = f a in if y = true then wwhile (f, x) else x;;\n", "\nlet rec wwhile (f,b) =\n  let (x,y) = b f in if y = true then wwhile (f, x) else x;;\n"]}
{"fix": [], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type 'a * bool\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet rec wwwhile (f,b) =\n  match f with\n  | (x,y) -> if y = true then let (f',b') = f b in wwhile (f, x) else x;;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((fixpoint(f, f(b)),b))"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"], "bad": ["\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, b)), b);;\n"]}
{"fix": ["let fixpoint(f,b) = wwhile ((let g b = (f b, not ((f b = b))) in g), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "Error: This expression has type\n         (('a -> 'a * bool) -> ('a -> 'a * bool) -> ('a -> 'a * bool) * bool) *\n         ('a -> 'a * bool)\n       This is not a function; it cannot be applied.\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type\n         (('a -> 'a * bool) -> ('a -> 'a * bool) -> ('a -> 'a * bool) * bool) *\n         ('a -> 'a * bool)\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"], "bad": ["\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n", "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((fixpoint ((f b), b)), b);;\n", "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, b)), b);;\n", "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((fixpoint f), (f b));;\n", "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ( (let f' b = \n((f b, not(f b != b ))) in f'), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value x\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) =\n  wwhile ((let f' b = ((f x), (not ((f b) != b))) in f'), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ( (let f' b = \n((f b, (f b != b ))) in f'), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((let h x = (h b, f b != b) in h), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n"], "bad": ["\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet fixpoint (f,b) = wwhile ((let h x = ((f b), ((f b) != b)) in f), b);;\n", "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((let f x = (h b, f b != b) in f), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ( (fun x -> f b, f b != b in f"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) = wwhile ((let f x = ((h b), ((f b) != b)) in f), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((let f x = (f x, f x != x) in f), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) = wwhile ((let f x = ((f b), ((f b) != b)) in f), b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value x\n", "Error: Unbound value x\n", "Error: This expression has type float but an expression was expected of type\n         expr\nError: Unbound constructor Average\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type float but an expression was expected of type\n         expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n\nlet _ = eval ((Sine x), 0.5, 0.7);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n\nlet _ = eval ((Sine x), 0.5, 0.7);;\n", "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> buildSine x\n  | Cosine x -> buildCosine x\n  | Average (x,y) -> buildAverage (x, y);;\n\nlet _ = eval ((Sine VarX), 0.5, 0.7);;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi*.VarX)\n| Cosine(a) -> cos(pi*.VarY)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         expr\nError: Unbound constructor Average\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type float but an expression was expected of type\n         expr\n", "Error: This expression has type float but an expression was expected of type\n         expr\nError: Unbound constructor Average\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type float but an expression was expected of type\n         expr\n", "Error: This expression has type float but an expression was expected of type\n         expr\nError: Unbound constructor Average\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type float but an expression was expected of type\n         expr\n", "Error: This expression has type float but an expression was expected of type\n         expr\nError: Unbound constructor Average\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type float but an expression was expected of type\n         expr\n", "Error: This expression has type float but an expression was expected of type\n         expr\nError: Unbound constructor Average\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type float but an expression was expected of type\n         expr\n"], "bad": ["\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> buildSine x\n  | Cosine x -> buildCosine x\n  | Average (x,y) -> buildAverage (x, y);;\n\nlet _ = eval (VarX, 0.5, 0.7);;\n", "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> buildSine x\n  | Cosine x -> buildCosine x\n  | Average (x,y) -> buildAverage (x, y);;\n\nlet _ = eval (VarX, 0.5, 0.7);;\n", "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> buildSine x\n  | Cosine x -> buildCosine x\n  | Average (x,y) -> buildAverage (x, y);;\n\nlet _ = eval (VarX, 0.5, 0.7);;\n", "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> buildSine x\n  | Cosine x -> buildCosine x\n  | Average (x,y) -> buildAverage (x, y);;\n\nlet _ = eval (VarX, 0.5, 0.7);;\n", "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> buildSine x\n  | Cosine x -> buildCosine x\n  | Average (x,y) -> buildAverage (x, y);;\n\nlet _ = eval (VarX, 0.5, 0.7);;\n"]}
{"fix": ["let rec build (rand, depth) = match depth with\n|0 -> let r = rand(0,2) in\nif r = 0 \nthen buildX()\nelse buildY()"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value buildVarX\nHint: Did you mean buildX?\nError: Unbound value buildVarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value buildVarX\nHint: Did you mean buildX?\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type unit -> expr\n       but an expression was expected of type unit\n", "Error: This expression has type unit -> expr\n       but an expression was expected of type unit\n"], "bad": ["\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let r = rand (0, 1) in\n      if r = 0 then buildVarX () else if r = 1 then buildVarY ();;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let r = rand (0, 1) in\n      if r = 0 then buildX () else if r = 1 then buildY ();;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let r = rand (0, 1) in\n      if r = 0 then buildX () else if r = 1 then buildY ();;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let r = rand (0, 1) in if r = 0 then buildX else if r = 1 then buildY;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let r = rand (0, 2) in if r = 0 then buildX else if r = 1 then buildY;;\n"]}
{"fix": ["let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: Unbound value buildThersh\nHint: Did you mean buildThresh?\nError: Unbound value buildThersh\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value buildThersh\nHint: Did you mean buildThresh?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let r = rand (0, 2) in if r = 0 then buildX () else buildY ()\n  | _ ->\n      let r = rand (0, 5) in\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if r = 1\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if r = 2\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if r = 3\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let r = rand (0, 2) in if r = 0 then buildX () else buildY ()\n  | _ ->\n      let r = rand (0, 5) in\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if r = 1\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if r = 2\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if r = 3\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              buildThersh\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                  (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "expr", "message": ["Error: Unbound value buildThird\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | Timestwo of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildHalf e = Half e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let r = rand (0, 2) in if r = 0 then buildX () else buildY ()\n  | _ ->\n      let r = rand (0, 9) in\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if r = 1\n        then buildCosine (buildSine (build (rand, (depth - 1))))\n        else\n          if r = 2\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else\n            if r = 3\n            then buildCosine (build (rand, (depth - 1)))\n            else\n              if r = 4\n              then\n                buildAverage\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r = 5\n                then\n                  buildAverage\n                    ((buildCosine (build (rand, (depth - 1)))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r = 6\n                  then\n                    buildTimes\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    if r = 7\n                    then\n                      buildThresh\n                        ((build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))))\n                    else\n                      if r = 8\n                      then buildHalf (build (rand, (depth - 1)))\n                      else buildThird (build (rand, (depth - 1)));;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: Unbound value x\n", "Error: Unbound value f\n", "Error: Unbound value f\n"], "bad": ["\nlet sqsum xs =\n  let f a x = failwith \"to be implemented\" in\n  let base = x * x in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = List.fold_left f a x in\n  let base = x * x in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = List.fold_left f a b in\n  let base = x * x in List.fold_left f base xs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = function g -> a x in\nlet base = function x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: Unbound value a\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: Unbound value base\n", "Error: Unbound value x\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: Unbound value f\n"], "bad": ["\nlet pipe fs =\n  let f a x = a x in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base = a 0 in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base = fs in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = a x in\n  let base = match base with | 0 -> 0 | _ -> fs in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = a x in\n  let base = match x with | 0 -> 0 | _ -> fs in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = a x in\n  let base = match fs with | 0 -> 0 | _ -> fs in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = f a x in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = function g -> g in\nlet base = function x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> ('a -> 'b -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'b -> 'c) -> 'c\n", "Error: This expression has type 'a -> 'b -> ('b -> 'a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('b -> 'a -> 'c) -> 'c\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs =\n  let f a x = function | g -> g a x in\n  let base = function | x -> x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = function | g -> g x a in\n  let base = function | x -> x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = function | g -> g (x a) in\n  let base = function | x -> x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = function | g -> g x in\n  let base = function | x -> x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = function g -> x in\nlet base = function x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'a) -> 'a -> 'a\n       but an expression was expected of type ('a -> 'a) -> 'a\n       The type variable 'a occurs inside 'a -> 'a\n"], "bad": ["\nlet pipe fs =\n  let f a x = function | g -> g (a x) in\n  let base = function | x -> x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = function g -> a( x g)  in\nlet base = function x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'a) -> 'a -> 'a\n       but an expression was expected of type ('a -> 'a) -> 'a\n       The type variable 'a occurs inside 'a -> 'a\n"], "bad": ["\nlet pipe fs =\n  let f a x = function | g -> g (a x) in\n  let base = function | x -> x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = function g -> a(x g)  in\nlet base = function x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'c -> ('c -> 'a) -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'c -> 'a -> 'b\n       The type variable 'a occurs inside 'c -> 'a\n"], "bad": ["\nlet pipe fs =\n  let f a x = function | g -> a (g x) in\n  let base = function | x -> x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = function g -> x (a g)  in\nlet base = function b -> b in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> ('b -> 'c) -> ('a -> 'b) -> 'c\n       but an expression was expected of type 'a -> ('b -> 'c) -> 'a\n       The type variable 'a occurs inside ('a -> 'b) -> 'c\n"], "bad": ["\nlet pipe fs =\n  let f a x = function | g -> x (g a) in\n  let base = function | b -> b in List.fold_left f base fs;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type string but an expression was expected of type\n         string list\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = sep in List.fold_left f base l;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) < 2\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: Unbound record field length\n", "Error: Unbound record field length\n", "Error: This expression has type int but an expression was expected of type\n         'a list -> int\n", "Error: This expression has type int but an expression was expected of type\n         'a list -> int\n", "Error: Unbound record field length\n", "Error: This expression has type string but an expression was expected of type\n         unit\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if x.length < 2 then a ^ x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if sl.length < 2 then a ^ x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if List.length < 2 then a ^ x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if List.length = 2 then a ^ x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if t.length = 2 then a ^ x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length t) = 2 then a ^ x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) = 0\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: Unbound value l\n", "Error: This variant expression is expected to have type 'a list\n       The constructor () does not belong to type list\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length l) = 0 then a ^ x else a ^ (x ^ sep) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length ()) = 0 then a ^ x else a ^ (x ^ sep) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(sl) > 2\nthen a ^ x ^ sep\nelse if List.length(sl) > 1\nthen a ^ x \nelse x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: Unbound value s1\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x =\n        if (List.length sl) > 2\n        then a ^ (x ^ sep)\n        else if (List.length s1) > 1 then a ^ x else x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) > 2\nthen a ^ x ^ sep\nelse x ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type string but an expression was expected of type\n         string list\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length t) > 2 then a ^ (x ^ sep) else x ^ x in\n      let base = \"\" in let l = sepConcat sep t in List.fold_left f base l;;\n"]}
{"fix": ["let stringOfList f l = List.map (fun a -> a l)"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type string -> string list -> string\n       but an expression was expected of type ('a -> 'b) list\n", "Error: This expression has type string -> string list -> string\n       but an expression was expected of type ('a -> 'b) list\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = if (List.length sl) > 1 then h else h in\n      let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (fun a  -> a l) sepConcat;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = if (List.length sl) > 1 then h else h in\n      let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (fun a  -> a l) sepConcat;;\n"]}
{"fix": [], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type string\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type string\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type string\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type string\n", "Error: This expression has type ('a -> 'b) list -> 'b list\n       but an expression was expected of type string list\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = if (List.length sl) > 1 then h else h in\n      let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat (\";\", l));;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = if (List.length sl) > 1 then h else h in\n      let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (\";\", (List.map (fun c  -> l)));;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = if (List.length sl) > 1 then h else h in\n      let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (\";\", (List.map (fun c  -> c l)));;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = if (List.length sl) > 1 then h else h in\n      let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (\";\", (List.map (fun c  -> c l)));;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = if (List.length sl) > 1 then h else h in\n      let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map (fun c  -> c l));;\n"]}
{"fix": [], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type 'a list -> 'b list\n       but an expression was expected of type string list\n", "Error: This expression has type ('a -> 'b) list -> 'b list\n       but an expression was expected of type string list\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map (fun c  -> f l));;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map (fun f  -> f l));;\n"]}
{"fix": ["let stringOfList f l = sepConcat \";\" (List.map f l)"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" List.map f l;;\n"]}
{"fix": [], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type 'a list -> 'b list\n       but an expression was expected of type string list\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map (f l));;\n"]}
{"fix": ["let stringOfList f l = sepConcat \"; \" (List.map (f) l )"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: Unbound value str\n", "Error: Unbound value str\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let string str = sepConcat \";\" (List.map f l) in \"[\" ^ (str ^ \"]\");;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let string str = sepConcat \"; \" (List.map f l) in \"[\" ^ (str ^ \"]\");;\n"]}
{"fix": [], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type string\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat (\"; \" (List.map f l))) ^ \"]\");;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if (List.length sl) > 1 then a ^ (sep ^ x) else a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat (\"; \", (List.map f l))) ^ \"]\");;\n"]}
{"fix": ["let rec clone x n = \nif n < 1\nthen []\nelse x:: (clone x (n-1))"], "hw": "hw3", "problem": "clone", "message": ["Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n", "Error: Unbound value =<\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n = match n with | 0 -> [] | h::t -> x :: ((clone x n) - 1);;\n", "\nlet rec clone x n = if n =< 0 then [] else x :: ((clone x n) - 1);;\n", "\nlet rec clone x n = if n < 1 then [] else x :: ((clone x n) - 1);;\n", "\nlet rec clone x n = if n < 1 then [] else x :: ((clone x n) - 1);;\n"]}
{"fix": ["let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen \"hi\"\nelse \"bye\""], "hw": "hw3", "problem": "padZero", "message": ["Error: Unbound value a\n"], "bad": ["\nlet padZero l1 l2 =\n  let int a = (List.length l1) - (List.length l2) in\n  if a > 0 then \"hi\" else \"bye\";;\n"]}
{"fix": ["let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1,(clone 0 a))\nelse (l1,l2)"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = (List.length l1) - (List.length l2) in\n  if a > 0 then l1 * (clone 0 a) else \"bye\";;\n", "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = (List.length l1) - (List.length l2) in\n  if a > 0 then l1 * (clone 0 a) else l1 * l2;;\n", "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = (List.length l1) - (List.length l2) in\n  if a > 0 then l1 * (clone 0 a) else l1 * l2;;\n", "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = (List.length l1) - (List.length l2) in\n  if a > 0 then l1 * (clone 0 a) else l1 * l2;;\n"]}
{"fix": ["let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1,(List.append (clone 0 a) l2))\nelse (l1,l2)"], "hw": "hw3", "problem": "padZero", "message": ["Error: Unbound value List.apend\nHint: Did you mean append?\n"], "bad": ["\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = (List.length l1) - (List.length l2) in\n  if a > 0 then (l1, (List.apend (clone 0 a) l2)) else (l1, l2);;\n"]}
{"fix": ["let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1,(List.append (clone 0 a) l2))\nelse ((List.append (clone 0 (0-a)) l1), l2)"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type int list\n       but an expression was expected of type 'a list * int list\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type 'a list\n"], "bad": ["\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = (List.length l1) - (List.length l2) in\n  if a > 0\n  then (l1, (List.append (clone 0 a) l2))\n  else List.append (clone 0 (0 - a)) l2;;\n", "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = (List.length l1) - (List.length l2) in\n  if a > 0\n  then (l1, (List.append (clone 0 a) l2))\n  else ((List.append (clone 0 (0 - a))), l2);;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "removeZero", "message": ["Error: Unbound value padZero\n"], "bad": ["\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"], "bad": ["\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [] in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = l1 in\n    let base = [] in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = l1 in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = l1 in\n    let base = [0] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = l1 in\n    let base = [0] in\n    let args = 0 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = l1 in\n    let base = [0] in\n    let args = [0] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = l1 in\n    let base = [0] in\n    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "removeZero", "message": ["Error: Unbound value padZero\n"], "bad": ["\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a -> 'b -> 'a * 'b\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'a * 'b\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type int list list\n       Type 'a * 'b is not compatible with type int list \n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type int list\n       Type 'a * 'b is not compatible with type int \n", "Error: Unbound value a\n", "Error: This expression has type 'a list * int\n       but an expression was expected of type int\n", "Error: This expression has type int * 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int * int\n       but an expression was expected of type int\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type int list\n       Type 'a * 'b is not compatible with type int \n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type (int * 'a list) list\n       but an expression was expected of type int\n", "Error: This expression has type int * 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a, x) in\n    let base = [0] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = [0] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = (a, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = (l1, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [(0, [])] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value sqsum\n"], "bad": ["\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n"]}
{"fix": ["let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec digitsOfInt n = match n <= 0 with | true  -> [] | false  -> 1;;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: Unbound value %\n", "Error: This function has type int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> ((digitsOfInt n) / 10) @ [n % 10];;\n", "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> ((digitsOfInt n) / 10) @ [n % 10];;\n", "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | false  -> ((digitsOfInt n) / 10) @ [n % 10]\n  | true  -> [];;\n", "\nlet rec digitsOfInt n =\n  match n <= 0 with | true  -> [] | false  -> [(digitsOfInt n) / 10; n % 10];;\n", "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> ((digitsOfInt n) / 10) @ [n % 10];;\n", "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> [(digitsOfInt n) / 10] @ [n % 10];;\n", "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> ((digitsOfInt n) / 10) @ [n % 10];;\n", "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> [n % 10] @ ((digitsOfInt n) / 10);;\n", "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> [digitsOfInt n div 10; n mod 10];;\n", "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> [(digitsOfInt n) / 10; n mod 10];;\n", "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> (n mod 10) :: ((digitsOfInt n) / 10);;\n", "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> (n mod 10) :: ((digitsOfInt n) / 10);;\n", "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> (n mod 10) :: ((digitsOfInt n) / 10);;\n"]}
{"fix": ["let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> (n mod 10) :: (digitsOfInt (n/10))"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> (n mod 10) :: ((digitsOfInt n) - 10);;\n"]}
{"fix": ["let rec listReverse l =\nmatch l with\n| []\t    -> []\n| (h :: t)  -> h :: listReverse t"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec listReverse l =\n  match l with | h::[] -> h | h::t -> [listReverse t; h];;\n"]}
{"fix": ["let rec listReverse l =\nmatch l with\n| []\t    -> []\n| (_ :: h :: [])  -> h :: listReverse []"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec listReverse l =\n  match l with | [] -> [] | t::h::[] -> [h; listReverse t];;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | t::h::[] -> h :: (listReverse t);;\n"]}
{"fix": ["let palindrome w = \nif explode(w) = listReverse (explode(w))\nthen true\nelse false"], "hw": "hw1", "problem": "palindrome", "message": ["Error: Unbound value palindrome\n"], "bad": ["\nlet _ = palindrome \"myxomatosis\";;\n"]}
{"fix": ["ate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (bb,false ) -> bb | (bb,true ) -> wwhile (f, bb);;\n\nlet fixpoint (f,b) =\n  wwhile (fun ff  -> fun b  -> (((f b), ((f b) = (f (b - 1)))), b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (bb,false ) -> bb | (bb,true ) -> wwhile (f, bb);;\n\nlet fixpoint (f,b) =\n  wwhile (fun ff  -> fun b  -> (((f b), ((f b) != (f (b - 1)))), b));;\n"]}
{"fix": ["let fixpoint (f, b"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value trunc\n"], "bad": ["\nlet g x = trunc;;\n"]}
{"fix": ["let fixpoint (f, b"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  let ff b = ((f b), (((f b) != b) || (b != (f (b - 1))))) in wwhile (ff, b);;\n"]}
{"fix": ["let fixpoint(f, b) = wwhile((fun b -> (f b, f b != b || b != f b-1)), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value trunca\nHint: Did you mean truncate?\n", "Error: Unbound value trunca\nHint: Did you mean truncate?\n"], "bad": ["\nlet fixpoint (f,b) =\n  let ff b = ((f b), (((f b) != b) || (b != (f (b - 1))))) in wwhile (ff, b);;\n", "\nlet g x = trunca;;\n", "\nlet g x = trunca;;\n"]}
{"fix": ["let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || b != f b-1)), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value trunca\nHint: Did you mean truncate?\n"], "bad": ["\nlet g x = trunca;;\n"]}
{"fix": ["te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value trunca\nHint: Did you mean truncate?\n"], "bad": ["\nlet g x = trunca;;\n"]}
{"fix": ["let fixpoint(f, b) = wwhile((fun b -> (f(b), not (f(b) = b) || not (f(b) = f(f(b))))) , b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value trunca\nHint: Did you mean truncate?\n", "Error: Unbound value trunca\nHint: Did you mean truncate?\n", "Error: Unbound value trunca\nHint: Did you mean truncate?\n", "Error: Unbound value wwhile\n", "Error: Unbound value trunca\nHint: Did you mean truncate?\n"], "bad": ["\nlet g x = trunca;;\n", "\nlet g x = trunca;;\n", "\nlet g x = trunca;;\n", "\nlet fixpoint (f,b) =\n  wwhile ((fun b  -> ((f b), (((f b) != b) || ((f b) != (f (f b)))))), b);;\n", "\nlet g x = trunca;;\n"]}
{"fix": ["let rec exprToString e = \nmatch e with\n| VarX _\t    -> \"x\"\n| VarY _\t    -> \"y\"\n| Sine x\t    -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine x\t    -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Average (x,y)     -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^\")/2)\"\n| Times (x,y)       -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (a,b,c,d)  -> \n\"(\" ^ exprToString(a) ^ \"<\" exprToString(y) ^ \"?\" ^ \nexprToString(c) ^ \":\" ^ exprToString(d)"], "hw": "hw2", "problem": "exprToString", "message": ["Error: Unbound value exprToStringx\nHint: Did you mean exprToString?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX _ -> \"x\"\n  | VarY _ -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ (exprToStringx ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ (exprToStringx ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")));;\n"]}
{"fix": ["let rec exprToString e = \nmatch e with\n| VarX\t\t    -> \"x\"\n| VarY\t\t    -> \"y\"\n| Sine x\t    -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine x\t    -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Average (x,y)     -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^\")/2)\"\n| Times (x,y)       -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (a,b,c,d)  -> \n\"(\" ^ exprToString(a) ^ \"<\" ^ exprToString(b) ^ \"?\" ^ \nexprToString(c) ^ \":\" ^ exprToString(d)"], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: Unbound value y\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX _ -> \"x\"\n  | VarY _ -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           ((\"<\" exprToString y) ^\n              (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX _ -> \"x\"\n  | VarY _ -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d)))))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "exprToString", "message": ["Error: Unbound value sampleExpr1\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d)))))));;\n\nlet _ = exprToString sampleExpr1;;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value ring\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = ring sampleExpr1;;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | Cosine a -> cos (pi * (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) + (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = 3 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value a\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value base\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = base in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x(a) in\nlet base = 0 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x(a) in\nlet base = 0 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x(a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value a\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = function | a -> a in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value int\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = int in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = fun x' ->\nlet f a x = x a in\nlet base = x' in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value int\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = int a in List.fold_left f base fs;;\n"]}
{"fix": ["let rec clone x n = \nmatch n > 0 with\n| false -> []\n| true  -> x :: clone x (n-1)"], "hw": "hw3", "problem": "clone", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         int -> int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> [x] @ ((clone x n) - 1);;\n", "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone ((x n) - 1));;\n", "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: ((clone x n) - 1);;\n"]}
{"fix": ["let padZero l1 l2 = \nmatch List.length l1 = List.length l2 with\n| true -> (l1, l2)\n| false ->\nlet lendiff = List.length l1 - List.length l2 in\nmatch lendiff > 0 with\n| true  -> (l1, (clone 0 lendiff) @ l2)\n| false -> ((clone 0 (-lendiff)) @ l1, l2)"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> ((((clone 0) - lendiff) @ l1), l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = (x + y) / 10 :: a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"], "bad": ["\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) + a) / 10 in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) + a) / 10 in\n    let base = 0 in\n    let args = List.combine l1 l2 in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) + a) / 10 in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) / 10) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = ((x + y) mod 10) :: a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value %\n"], "bad": ["\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) % 10) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = ((x + y) / 10) :: a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value %\n"], "bad": ["\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) % 10) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = ((x + y) / 10) :: a in\nlet base = [] in\nlet args = List.rev(List.combine l1 l2) in\nlet (res) = List.fold_left f base args in\nList.rev res\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) / 10) :: a in\n    let base = [] in\n    let args = List.rev List.combine l1 l2 in\n    let res = List.fold_left f base args in List.rev res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) / 10) :: a in\n    let base = [] in\n    let args = List.rev List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  List.rev removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = \nmatch a with\n| [] -> (x + y) :: a \n| h :: t -> [x + y + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev(List.combine l1 l2) in\nlet (res) = List.fold_left f base args in\nres\nin \n(add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value %\n"], "bad": ["\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h % 10] @ t in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = \nmatch a with\n| [] -> (x + y) :: a \n| h :: t -> [x + y + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev((0,0) :: List.combine l1 l2) in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value removeZeros\nHint: Did you mean removeZero?\nError: Unbound value removeZeros\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value removeZeros\nHint: Did you mean removeZero?\n"], "bad": ["\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZeros (add (padZero l1 l2));;\n"]}
{"fix": ["let rec mulByDigit i l = \nlet f a x = \nmatch a with\n| [] -> (i * x) :: a \n| h :: t -> [i * x + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev(0 :: l) in\nList.fold_left f base args"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b\n       but an expression was expected of type int\n"], "bad": ["\nlet y f g x = f (g x);;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(x * y) + (h / 10); h mod 10] @ t in\n  let base = [] in let args = List.rev (0 :: l) in List.fold_left f base args;;\n"]}
{"fix": ["let rec mulByDigit i l = \nlet f a x = \nmatch a with\n| [] -> (i * x) :: a \n| h :: t -> [i * x + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev(0 :: l) in\nremoveZero (List.fold_left f base args)"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This function has type int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero List.fold_left f base args;;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = \nmatch a with\n| [] -> (x + y) :: a \n| h :: t -> [x + y + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev((0,0) :: List.combine l1 l2) in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"], "bad": ["\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []  -> (mulByDigit x l2)\n| _   -> bigAdd a (mulByDigit x l2)\nin\nlet base = [] in\nlet args = List.rev l1 in\nlet (res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"], "bad": ["\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | [] -> (mulByDigit x l2) :: a\n    | h::t -> [(bigAdd (mulByDigit x l2) h) / 10; h mod 10] @ t in\n  let base = [] in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | [] -> (mulByDigit x l2) :: a\n    | h::t -> [bigAdd (mulByDigit x l2) [h / 10]; h mod 10] @ t in\n  let base = [] in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | [] -> mulByDigit x l2 | _ -> bigAdd a (mulByDigit x l2) in\n  let base = [] in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []  -> (mulByDigit x l2)\n| _   -> bigAdd (List.rev(0 :: (List.rev a))) (mulByDigit x l2)\nin\nlet base = [] in\nlet args = List.rev l1 in\nlet (res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This function has type int list -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | [] -> mulByDigit x l2\n    | _ -> bigAdd List.rev (0 :: (List.rev a)) (mulByDigit x l2) in\n  let base = [] in\n  let args = List.rev l1 in let res = List.fold_left f base args in res;;\n"]}
{"fix": ["let test = mulByDigit 1 [1;0]"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This function has type int -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet test = mulByDigit 1 [1; 0];;\n\nlet test = mulByDigit 1 [1; 0] List.rev test;;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet test = mulByDigit 1 [1; 0];;\n\nlet test = mulByDigit 1 [1; 0] List.rev test;;\n"]}
{"fix": ["let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x::y -> x + sumList y"], "hw": "hw1", "problem": "sumList", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n"], "bad": ["\nlet rec sumList xs =\n  match xs with | [] -> 0 | x::[] -> x | (x::y)::[] -> x + (sumList y);;\n", "\nlet rec sumList xs = match xs with | [] -> 0 | (x::y)::[] -> x + (sumList y);;\n"]}
{"fix": ["let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n / 10) @ [n mod 10]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value a\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: Unbound value %\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | a -> [a] | ab -> a :: (digitsOfInt b));;\n", "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n == 0 then 0 else (digitsOfInt (n / 10)) :: (n % 10);;\n", "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n == 0 then [] else (digitsOfInt (n / 10)) :: (n % 10);;\n", "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n == 0 then 0 else (digitsOfInt (n / 10)) @ [n % 10];;\n", "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n % 10];;\n"]}
{"fix": ["let rec additivePersistence n =\nlet sum = sumList (digitsOfInt n) in\nif (sum < 10) then 1\nelse\n1 + additivePersistence sum"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound value additivePersistance\nHint: Did you mean additivePersistence?\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if (n / 10) == 0 then [n mod 10] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | a::b -> a + (sumList b);;\n\nlet rec additivePersistence n =\n  let sum = sumList digitsOfInt n in\n  if sum < 10 then 1 else 1 + (additivePersistance sum);;\n", "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if (n / 10) == 0 then [n mod 10] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | a::b -> a + (sumList b);;\n\nlet rec additivePersistence n =\n  let sum = sumList (digitsOfInt n) in\n  if sum < 10 then 1 else 1 + (additivePersistance sum);;\n"]}
{"fix": ["let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: [b] -> listReverse b @ a"], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value digitalRoot\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet _ = digitalRoot 9876;;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> b :: (listReverse a);;\n"]}
{"fix": [], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type string but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type string but an expression was expected of type\n         'a list\n", "Error: This expression has type string but an expression was expected of type\n         'a list\n", "Error: This expression has type string but an expression was expected of type\n         'a list\n", "Error: This expression has type string but an expression was expected of type\n         'a list\n", "Error: This expression has type string but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec listReverse l =\n  match l with | [] -> [] | a::b::[] -> (listReverse b) @ a;;\n", "\nlet rec listReverse l = match l with | [] -> [] | a::b -> (listReverse b) @ a;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) :: a;;\n", "\nlet rec listReverse l = match l with | [] -> [] | a::b -> (listReverse b) @ a;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b::[] -> (listReverse [b]) @ a;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n", "\nlet rec listReverse l = match l with | [] -> [] | a::b -> (listReverse b) @ a;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n", "\nlet rec listReverse l = match l with | [] -> [] | a::b -> (listReverse b) @ a;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n", "\nlet rec listReverse l = match l with | [] -> [] | a::b -> (listReverse b) @ a;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n"]}
{"fix": ["let rec digitsOfInt n =\nif (n < 0) then []\nelse\nif (n / 10 = 0) then [n mod 10]\nelse digitsOfInt (n / 10) @ [n mod 10]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value digitsOfInt\n"], "bad": ["\nlet _ = digitsOfInt 0;;\n"]}
{"fix": ["let rec digitsOfInt n =\nif n < 0 then []\nelse if n < 10 then [n]\nelse digitsOfInt (n / 10) @ [n mod 10]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int list\n       but an expression was expected of type unit\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if (n / 10) > 0 then (digitsOfInt (n / 10)) @ [n mod 10];;\n"]}
{"fix": ["let rec digitsOfInt n =\nif n < 0 then []\nelse if n < 10 then n\nelse digitsOfInt (n/10) :: [n mod 10]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n < 10 then n else [digitsOfInt (n / 10); n mod 10];;\n"]}
{"fix": ["let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse if n > 10 then digitsOfInt(n mod 10)\nelse\nlet a = n mod 10 in\nlet b = n / 10 in\nif b = 0 then [n]\nelse a :: digitsOfInt b"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n < 10 then n else [digitsOfInt (n / 10); n mod 10];;\n", "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n < 10 then [n] else [digitsOfInt (n / 10); n mod 10];;\n", "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n > 10 then [digitsOfInt (n / 10); n mod 10] else n;;\n"]}
{"fix": ["let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet a = n / 10 in\nlet b = n mod 10 in\ndigitsOfInt a :: b"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int but an expression was expected of type\n         string\n"], "bad": ["\nlet _ = 1 ^ 2;;\n"]}
{"fix": ["let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet a = n / 10 in\nlet b = n mod 10 in\nlet c = [a; b] in\nif a > 9 then\ndigitsOfInt a :: c"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (let a = n / 10 in let b = n mod 10 in (digitsOfInt a) :: b);;\n"]}
{"fix": ["let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet a = n / 10 in\nlet b = n mod 10 in\nlet c = [a; b] in\nif a > 9 then\nmatch c with\n| x::xs -> digitsOfInt (x) ::[xs]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let a = n / 10 in\n     let b = n mod 10 in let c = [a; b] in if a > 9 then (digitsOfInt a) :: c);;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let a = n / 10 in\n     let b = n mod 10 in\n     let c = [a; b] in\n     if a > 9 then match c with | x::xs -> [digitsOfInt x; xs]);;\n"]}
{"fix": ["let c = listReverse b"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec listReverse l =\n  match l with | [] -> [] | a::[] -> [a] | a::b::[] -> b :: (listReverse a);;\n"]}
{"fix": ["let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b ->\nlet c = listReverse b in\nmatch c with\n| [] -> []\n| d :: e -> d :: listReverse c"], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value b\n"], "bad": ["\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n\nlet c = listReverse b;;\n"]}
{"fix": ["let rec listReverse l =\nmatch l with\n| [] -> []\n| b :: [] -> [b]"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec listReverse l = match l with | [] -> [] | a::b -> [listReverse b; a];;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> [listReverse b; [a]];;\n"]}
{"fix": [], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value s\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec digitsOfInt n = if n < 0 then [] else (s.[i]) :: (go (i + 1));;\n", "\nlet rec listReverse l = match l with | [] -> [] | a::b::[] -> 0;;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int but an expression was expected of type\n         string\n"], "bad": ["\nlet rec digitsOfInt n = if n < 0 then [] else [n.[0]];;\n"]}
{"fix": ["let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse [a] b"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: Unbound value last\n", "Error: Unbound value last\n", "Error: Unbound value last\n"], "bad": ["\nlet rec digitsOfInt n = if n < 0 then [] else [n [0]];;\n", "\nlet rec listReverse l =\n  let last t = match t with | [] -> [] | a::[] -> a | a::b -> last b in\n  (last t) :: (listReverse l);;\n", "\nlet rec listReverse l =\n  let last t = match t with | [] -> [] | a::[] -> a | a::b -> last b in\n  (last t) :: (listReverse l);;\n", "\nlet rec listReverse l =\n  let last t = match t with | [] -> [] | a::[] -> a | a::b -> last b in\n  (last t) :: (listReverse l);;\n"]}
{"fix": ["let rec listReverse l =\nlet last t =\nmatch t with\n| [] -> []\n| [a] -> [a]\n| b :: c -> last c\nin last l"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec listReverse l = match l with | [] -> [] | a::b -> listReverse [a] b;;\n"]}
{"fix": ["let rec listReverse l =\nlet a = [] in\nlet getHead b =\nmatch b with\n| [] -> []\n| x :: xs -> x :: a\nin match l with\n| [] -> a\n| c :: d -> listReverse d"], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value last\n", "Error: Unbound value last\n"], "bad": ["\nlet rec listReverse l =\n  let last t = match t with | [] -> [] | a::[] -> [a] | b::c -> last c in\n  last l;;\n", "\nlet rec listReverse l =\n  let last t = function | [] -> [] | a::[] -> [a] | b::c -> last c in last l;;\n"]}
{"fix": ["let rec listReverse l =\nlet a = [] in\nlet get b = function\n| [] -> []\n| x :: xs -> x :: a\nin get l"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet getHead b = match b with | [] -> [] | x::xs -> x;;\n\nlet rec listReverse l =\n  let a = [] in\n  let getHead b = match b with | [] -> [] | x::xs -> x :: (a getHead xs) in\n  getHead l;;\n", "\nlet getHead b = match b with | [] -> [] | x::xs -> x;;\n\nlet rec listReverse l =\n  let a = [] in\n  let getHead b = function | [] -> [] | x::xs -> x :: (a getHead xs) in\n  getHead l;;\n", "\nlet rec listReverse l =\n  let a = [] in\n  let rec get a = match a with | [] -> [] | x::xs -> [get xs; x] in get l;;\n"]}
{"fix": ["let rec digitsOfInt n =\nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  let rec integers a b =\n    match a with | [] -> b | x::xs -> integers xs (x :: b) in\n  integers n [];;\n\nlet _ = digitsOfInt 3124;;\n", "\nlet rec digitsOfInt n =\n  let rec integers a b =\n    match a with | [] -> b | x::xs -> integers xs ((a mod 10) :: b) in\n  integers n [];;\n"]}
{"fix": ["let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse \nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec digitsOfInt n =\n  let rec integers a b =\n    if a = 0 then b else integers (a / 10) ((a mod 10) :: b) in\n  integers n 0;;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with\n| []    ->\nseen\n| h::t  ->\nlet seen' =\nif (List.mem h seen) then seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: This expression has type bool but an expression was expected of type\n         'a ref\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if !(List.mem h seen) then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a -> 'b -> 'c\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b -> 'c\n", "Error: Unbound value f\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f f b), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet _ =\n  let fixpoint (f,b) = match f with | true  -> false | false  -> true in\n  wwhile (f, b);;\n"]}
{"fix": ["let fixpoint (f,b) =\nwwhile ((f b) b,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((f b) = b), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (fun x  -> (((f x) = b), b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (fun x  -> ((((f x) = b), b), b));;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "Error: Unbound value notequal\nHint: Did you mean notequals?\nError: Unbound value notequal\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value notequal\nHint: Did you mean notequals?\n", "Error: This expression has type 'a -> bool\n       but an expression was expected of type 'a -> 'a * bool\n       Type bool is not compatible with type 'a * bool \n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((notequal b), b);;\n", "\nlet notequals x y = x <> y;;\n\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((notequals b), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (fun x  -> (((f b) = b), b));;\n", "\nlet equ f b = (f b) = b;;\n\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((equ f b), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (if b = (f b) then true else (false, b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((b, ((f b) = b)), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (fun b  -> ((b, ((f b) = b)), b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (fun b  -> ((b, ((f b) = b)), b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (((f b) <> b), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (fun b  -> (((f b) <> b), b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (match (f, b) with | (b',c') -> (((f b') <> b'), b));;\n"]}
{"fix": ["let fixpoint (f,b) =\nwwhile (f,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type ('d -> 'd * bool) * 'd\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((not ((f b) = b)), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((not f), ((f b) = b), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = ((wwhile (fun x  -> ((not x), ((f b) = b)))), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) = b)), b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (fun f  -> ((f, ((f b) = b)), b));;\n"]}
{"fix": ["let fixpoint (f,b) =\nwwhile (f b,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (fun f  -> ((f, ((f b) = b)), b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) = b)), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let x = not f in ((x, ((f b) = b)), b));;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type bool\n       This is not a function; it cannot be applied.\n", "Error: This function has type bool -> bool\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "Error: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type\n         'c -> 'c * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type\n         'c -> 'c * bool\n", "Error: Unbound value a\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value a\n", "Error: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type\n         'c -> 'c * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type\n         'c -> 'c * bool\n", "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression has type ('a -> 'a) * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "Error: This expression has type ('a -> 'a) * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "Error: This expression has type ('a -> 'a) * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "Error: This expression has type (('a -> 'a) * bool) * 'a\n       but an expression was expected of type ('b -> 'b * bool) * 'b\n       Type ('a -> 'a) * bool is not compatible with type 'b -> 'b * bool \n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (((not f) b), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (((not f b) b), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile ((not (f b)), b);;\n", "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n", "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) =\n  wwhile ((fixpoint (f, (match f b with | (b',c') -> c'))), b);;\n", "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) =\n  wwhile ((fixpoint (f, (a = (match f b with | (b',c') -> c')))), b);;\n", "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) =\n  wwhile ((fixpoint (f, (let a = match f b with | (b',c') -> c' in a))), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (((f b) <> b), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) <> b)), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (fun f  -> fun b  -> ((f, ((f b) <> b)), b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) =\n  wwhile (fun func  -> fun f  -> fun b  -> ((f, ((f b) <> b)), b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) =\n  wwhile (let func x y = (x, ((x y) <> y)) in ((func f b), b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let func x y =\n       match (x y) = y with | true  -> (x, true) | false  -> (x, false) in\n     ((func f b), b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let func x y =\n       match (x y) = y with | true  -> (x, true) | false  -> (x, false) in\n     ((func f b), b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let func x y =\n       match (x y) = y with\n       | true  -> ((x, true), b)\n       | false  -> ((x, false), b) in\n     func f b);;\n"]}
{"fix": ["let fixpoint (f,b) =\nwwhile (let func x = fun x -> (0,true) in func b,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int * bool\n       but an expression was expected of type 'a -> 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with\n  | (b',c') -> (match c' with | true  -> wwhile (f, b') | false  -> b');;\n\nlet fixpoint (f,b) = wwhile (let func x x = (0, true) in ((func f b), b));;\n"]}
{"fix": ["let fixpoint (f,b) =\nwwhile (let func x = fun x -> (f b,(f b) = b) in func b,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  wwhile (let func x x = ((f b), ((f b) <> b)) in ((func b), b));;\n"]}
{"fix": ["let fixpoint (f,b) =\nwwhile (let rec func x = fun x -> (f b,not ((f b) = b)) in func b,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  wwhile (let func x x = ((f b), ((f b) = b)) in ((func b), b));;\n", "\nlet fixpoint (f,b) =\n  wwhile (let func x x = ((f b), ((f b) = b)) in ((func b), b));;\n", "\nlet fixpoint (f,b) =\n  wwhile (let func x x = ((f b), (not ((f b) = b))) in ((func b), b));;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n"], "bad": ["\nlet fixpoint (f,b) =\n  wwhile (let rec func x x = ((f b), (not ((f b) = b))) in ((func b), b));;\n", "\nlet fixpoint (f,b) =\n  wwhile (let func x x = ((f b), (not ((f b) = b))) in ((func b), b));;\n", "\nlet fixpoint (f,b) =\n  wwhile (let _ = fun x  -> ((f b), (not ((f b) = b))) in ((func b), b));;\n", "\nlet fixpoint (f,b) = wwhile (fun x  -> (((f b), (not ((f b) = b))), b));;\n", "\nlet fixpoint (f,b) =\n  wwhile (let func x x = ((f b), (not ((f b) = b))) in ((func b), b));;\n", "\nlet fixpoint (f,b) =\n  wwhile (let func x x = ((f b), (not ((f b) = b))) in ((func b), b));;\n", "\nlet fixpoint (f,b) =\n  wwhile (let func x x = ((f b), ((f b) = b)) in (func, b));;\n", "\nlet fixpoint (f,b) =\n  wwhile (let func x x = ((f x), ((f x) = x)) in (func, b));;\n", "\nlet fixpoint (f,b) = wwhile (let func x = ((f x), ((f x) = x)) in (func, b));;\n", "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n"]}
{"fix": ["let rec exprToString e =\nmatch e with\nVarX\t\t\t\t  ->\n\"x\"\n| VarY\t\t\t\t    ->\n\"y\"\n| Sine    expr0\t\t\t    ->\n\"sin(pi*\" ^ exprToString expr0 ^ \")\"\n| Cosine  expr0\t\t\t    ->\n\"cos(pi*\" ^ exprToString expr0 ^ \")\"\n| Average (expr0,expr1)\t\t    ->\n\"(\" ^ exprToString expr0 ^ \"+\" ^ exprToString expr1 ^ \")/2)\"\n| Times   (expr0,expr1)\t\t    ->\n\"(\" ^ exprToString expr0 ^ \"*\" ^ exprToString expr1 ^ \")\"\n| Thresh  (expr0,expr1,expr2,expr3)     ->\n\"(\" ^ exprToString expr0 ^ \"<\" ^ exprToString expr1 ^ \"?\" ^ exprToString expr2 ^ \":\" ^ exprToString expr3 ^ \")\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: Variable expr is bound several times in this matching\n", "Error: This expression has type expr but an expression was expected of type\n         string\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr) ->\n      \"(\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr) ^ \")/2)\")))\n  | Times (expr,expr) ->\n      \"(\" ^ ((exprToString expr) ^ (\"*\" ^ ((exprToString expr) ^ \")\")))\n  | Thresh (expr,expr,expr,expr) ->\n      \"(\" ^ (expr ^ (\"<\" ^ (expr ^ (\"?\" ^ (expr ^ (\":\" ^ (expr ^ \")\")))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"*\" ^ ((exprToString expr1) ^ \")\")))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        (expr0 ^ (\"<\" ^ (expr1 ^ (\"?\" ^ (expr2 ^ (\":\" ^ (expr3 ^ \")\")))))));;\n"]}
{"fix": ["let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type int but an expression was expected of type\n         float\n", "Error: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\nError: Unbound value sampleExpr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (eval (expr0, x, y))\n  | Cosine expr0 -> cos (eval (expr0, x, y))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (eval (expr0, x, y))\n  | Cosine expr0 -> cos (eval (expr0, x, y))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n"]}
{"fix": ["let rec assoc (d,k,l) =\nmatch l with\n[]    ->\nd\n| (s,i)::t  ->\n(match k = s with\ntrue  ->\ni\n| false ->\nassoc (d,k,t)\n)"], "hw": "hw2", "problem": "assoc", "message": ["Error: This expression has type int but an expression was expected of type\n         ('a * 'b) list\n", "Error: This expression has type string but an expression was expected of type\n         int\n"], "bad": ["\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (s,i)::t -> (match k = i with | true  -> l | false  -> assoc (d, k, t));;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (s,i)::t -> (match k = i with | true  -> i | false  -> assoc (d, k, t));;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n"]}
{"fix": ["let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 -> buildX()\n| 1 -> buildY()\n)\n| _ ->\n(match rand (0,3) with\n0 ->\nbuildSine(build(rand,depth-1))\n| 1 ->\nbuildCosine(build(rand,depth-1))\n| 2 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n)"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ())\n  | _ ->\n      (match rand (0, 4) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 -> buildAverage (build (rand, (depth - 1)))\n       | 3 -> buildTimes (build (rand, (depth - 1)))\n       | 4 -> buildThresh (build (rand, (depth - 1))));;\n"]}
{"fix": ["let rec eval (e,x,y) =\nmatch e with\nVarX\t\t\t\t  ->\nx\n| VarY\t\t\t\t    ->\ny\n| Sine    expr0\t\t\t    ->\nsin (pi *. eval (expr0,x,y))\n| Cosine  expr0\t\t\t    ->\ncos (pi *. eval (expr0,x,y))\n| Average (expr0,expr1)\t\t    ->\n(eval (expr0,x,y) +. eval (expr1,x,y)) /. 2.\n| Times (expr0,expr1)\t\t    ->\neval (expr0,x,y) *. eval (expr1,x,y)\n| Thresh  (expr0,expr1,expr2,expr3) ->\n(match (eval (expr0,x,y) < eval (expr1,x,y)) with\ntrue  ->\neval (expr2,x,y)\n| false ->\neval (expr3,x,y)\n)\n| Maximum (expr0,expr1,expr2)       ->\n(match (eval (expr0,x,y) < eval (expr1,x,y)) with\ntrue  ->\n(match (eval (expr1,x,y) < eval (expr2,x,y)) with\ntrue  ->\neval (expr2,x,y)\n| false ->\neval (expr1,x,y)\n)\n| false ->\n(match (eval (expr0,x,y) < eval (expr2,x,y)) with\ntrue  ->\neval (expr2,x,y)\n| false ->\neval (expr0,x,y)\n)\n)\n| Absolute (expr0)\t\t    ->\n(match (eval (expr0,x,y) < 0.0) with\ntrue  ->\n0.0 -. eval (expr0,x,y)\n| false ->\neval (expr0,x,y)\n)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type expr/2139\n       but an expression was expected of type expr/3472\nError: Unbound constructor Average\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type expr/2139\n       but an expression was expected of type expr/3472\n"], "bad": ["\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)));;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 4) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x))\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1))\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f))\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")))\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name)\nlet _ = emitGrayscale ((eval_fn sampleExpr), 150, \"sample\");;\n"]}
{"fix": ["let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 ->\nbuildX()\n| _ ->\nbuildY()\n)\n| _ ->\n(match rand (0,6) with\n0 ->\nbuildSine(build(rand,depth-1))\n| 1 ->\nbuildCosine(build(rand,depth-1))\n| 2 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 5 ->\nbuildMaximum(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ ->\nbuildAbsolute(build(rand,depth-1))\n)"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr/2139\n       but an expression was expected of type expr/3472\nError: Unbound constructor Average\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type expr/2139\n       but an expression was expected of type expr/3472\n"], "bad": ["\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Maximum of expr* expr* expr\n  | Absolute of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr0 -> sin (pi *. (eval (expr0, x, y)))\n  | Cosine expr0 -> cos (pi *. (eval (expr0, x, y)))\n  | Average (expr0,expr1) ->\n      ((eval (expr0, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr0,expr1) -> (eval (expr0, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  -> eval (expr2, x, y)\n       | false  -> eval (expr3, x, y))\n  | Maximum (expr0,expr1,expr2) ->\n      (match (eval (expr0, x, y)) < (eval (expr1, x, y)) with\n       | true  ->\n           (match (eval (expr1, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr1, x, y))\n       | false  ->\n           (match (eval (expr0, x, y)) < (eval (expr2, x, y)) with\n            | true  -> eval (expr2, x, y)\n            | false  -> eval (expr0, x, y)))\n  | Absolute expr0 ->\n      (match (eval (expr0, x, y)) < 0.0 with\n       | true  -> 0.0 -. (eval (expr0, x, y))\n       | false  -> eval (expr0, x, y));;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (0, 1) with | 0 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (0, 4) with\n       | 0 -> buildSine (build (rand, (depth - 1)))\n       | 1 -> buildCosine (build (rand, (depth - 1)))\n       | 2 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr0 -> \"sin(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Cosine expr0 -> \"cos(pi*\" ^ ((exprToString expr0) ^ \")\")\n  | Average (expr0,expr1) ->\n      \"(\" ^ ((exprToString expr0) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr0,expr1) ->\n      (exprToString expr0) ^ (\"*\" ^ (exprToString expr1))\n  | Thresh (expr0,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr0) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) ^ \")\")))))))\n  | Maximum (expr0,expr1,expr2) ->\n      \"maximum(\" ^\n        ((exprToString expr0) ^\n           (\",\" ^\n              ((exprToString expr1) ^ (\",\" ^ ((exprToString expr2) ^ \")\")))))\n  | Absolute expr0 -> \"absolute(\" ^ ((exprToString expr0) ^ \")\");;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x))\nlet rec rseq g r n = if n <= 0 then [] else (g r) :: (rseq g r (n - 1))\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n)\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z))\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f))\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")))\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name)\nlet _ = emitGrayscale ((eval_fn sampleExpr), 150, \"sample\");;\n"]}
{"fix": ["let pipe fs n = \nlet f a x = x a in\nlet base n = 0 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value f\n", "Error: Unbound value x\n"], "bad": ["\nlet pipe fs = let f a x = f a x in let base = 0 in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base = x in List.fold_left f base fs;;\n"]}
{"fix": ["let stringOfList f l = \"[ \" ^ sepConcat \"; \" l ^ \" ]\""], "hw": "hw3", "problem": "stringOfList", "message": ["Error: Unbound value sepConCat\nHint: Did you mean sepConcat?\nError: Unbound value sepConCat\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sepConCat\nHint: Did you mean sepConcat?\n"], "bad": ["\nlet stringOfList f l = \"[ \" ^ ((sepConCat \"; \" l) ^ \" ]\");;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int * int\n       but an expression was expected of type int\n", "Error: This expression has type int -> int -> int * int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n", "Error: This expression has type int * int\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int * 'a\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int -> int -> int * int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n", "Error: This expression has type int -> int -> int * int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list -> int list -> int\n       but an expression was expected of type\n         int list -> int list -> int list\n       Type int is not compatible with type int list \n", "Error: This expression has type\n         int list -> int list * int list -> int * int list\n       but an expression was expected of type\n         int list -> int list * int list -> int list\n       Type int * int list is not compatible with type int list \n", "Error: This expression has type\n         int list -> int list * int list -> int * int list\n       but an expression was expected of type\n         int list -> int list * int list -> int list\n       Type int * int list is not compatible with type int list \n"], "bad": ["\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = [l1; l2] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = [l1; l2] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = (0, 0) in\n    let args = [l1; l2] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, (a + x)) in\n    let base = (0, 0) in\n    let args = [l1; l2] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = (0, 0) in\n    let args = [l1; l2] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = l1 in\n    let args = [l1; l2] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = (0, l1) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a, (a + x)) in\n    let base = 0 in\n    let args = 1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a, (a + x)) in\n    let base = 0 in\n    let args = [1] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | ah::at -> (match x with | xh::xt -> ah + at) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | ah::at -> (match x with | xh::xt -> ah + xh) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (ah::at,bh::bt) -> (1, ((ah + bh) :: a)) in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (ah::at,bh::bt) -> (1, ((ah + bh) :: a)) in\n    let base = (0, []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type (int list * int list) list\n", "Error: This expression has type int list * int list\n       but an expression was expected of type\n         int list * (int list * int list) list\n       Type int is not compatible with type int list * int list \n", "Error: This expression has type int list * int list\n       but an expression was expected of type int list * int list list\n       Type int is not compatible with type int list \n"], "bad": ["\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,result) ->\n          (match x with\n           | (h1::t1,h2::t2) ->\n               ((((h1 + h2) + carry) / 10), (((h1 + h2) mod 10) :: result))) in\n    let base = (0, []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,result) ->\n          (match x with\n           | (h1::t1,h2::t2) ->\n               ((((h1 + h2) + carry) / 10), (((h1 + h2) mod 10) :: result))) in\n    let base = (0, l1) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,h1::t1) ->\n          (match x with\n           | h2::t2 ->\n               ((((h1 + h2) + carry) / 10), (((h1 + h2) mod 10) :: t1))) in\n    let base = (0, l1) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let padZero l1 l2 =\nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nmatch length1 >= length2 with\ntrue  ->\nlet n = length1 - length2 in\nlet zeroes = clone 0 n in\n(l1, List.append zeroes l2)\n\n| false ->\nlet n = length2 - length1 in\nlet zeroes = clone 0 n in\n(List.append zeroes l1, l2)"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append (zeroes l2)))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in List.append ((zeroes l1), l2);;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append (zeroes l2)))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append (zeroes l1)), l2);;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int list * int list\n       but an expression was expected of type int list * int list list\n       Type int is not compatible with type int list \n", "Error: This expression has type int list * int list\n       but an expression was expected of type\n         (int * int list) * int list list\n       Type int list is not compatible with type int * int list \n", "Error: This expression has type 'a list\n       but an expression was expected of type int * int list\n", "Error: This expression has type int list * int list\n       but an expression was expected of type int list * int list list\n       Type int is not compatible with type int list \n", "Error: This expression has type int list * int list\n       but an expression was expected of type int list * int list list\n       Type int is not compatible with type int list \n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c list * 'd list) list\n", "Error: This expression has type int list * int list\n       but an expression was expected of type int * ('a list * 'b list) list\n       Type int list is not compatible with type int \n", "Error: This expression has type int list * int list\n       but an expression was expected of type int list * int list list\n       Type int is not compatible with type int list \n", "Error: Unbound value h3\n", "Error: This expression has type int list * int list\n       but an expression was expected of type int list * int list list\n       Type int is not compatible with type int list \n"], "bad": ["\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,h1::t1) ->\n          (match x with\n           | h2::t2 ->\n               ((((h1 + h2) + carry) / 10), (((h1 + h2) mod 10) :: t1))) in\n    let base = (0, l1) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,h1::t1) ->\n          (match x with\n           | h2::t2 ->\n               ((((h1 + h2) + carry) / 10), (((h1 + h2) mod 10) :: t1))) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,h1::t1) ->\n          (match x with\n           | h2::t2 ->\n               ((((h1 + h2) + carry) / 10), (((h1 + h2) mod 10) :: t1))) in\n    let base = [] in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,h1::t1) ->\n          (match x with\n           | h2::t2 ->\n               ((((h1 + h2) + carry) / 10), (((h1 + h2) mod 10) :: t1))) in\n    let base = (0, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (0,[]) -> (0, [])\n      | (carry,h1::t1) ->\n          (match x with\n           | h2::t2 ->\n               ((((h1 + h2) + carry) / 10), (((h1 + h2) mod 10) :: t1))) in\n    let base = (0, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (carry,result) -> (0, (carry :: result)) in\n    let base = (0, []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,result) -> (match x with | (h1::t1,h2::t2) -> (0, [])) in\n    let base = (0, []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list1,result) -> (match x with | (h1::t1,h2::t2) -> (0, [])) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,h2::t2) -> (match x with | h3::t3 -> (t1, (h1 :: h3 :: t3))) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,h2::t2) ->\n          (match x with | [] -> (t2, [h3]) | h3::t3 -> (t2, (h2 :: h3 :: t3))) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,h2::t2) ->\n          (match x with | [] -> (t2, [h2]) | h3::t3 -> (t2, (h2 :: h3 :: t3))) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value h2\n", "Error: This expression has type int list * int list\n       but an expression was expected of type int list * int list list\n       Type int is not compatible with type int list \n", "Error: This expression has type int list * int list\n       but an expression was expected of type int * 'a list\n       Type int list is not compatible with type int \n", "Error: This expression has type int list * int list\n       but an expression was expected of type int * 'a list\n       Type int list is not compatible with type int \n"], "bad": ["\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,_) ->\n          (match x with | [] -> (t1, [h2]) | h3::t3 -> (t1, (h2 :: h3 :: t3))) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,_) ->\n          (match x with | [] -> (t1, [h1]) | h3::t3 -> (t1, (h1 :: h3 :: t3))) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, []) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, []) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\n(*\nlet f a x = (0,[]) in\nlet base = (l1, []) in\nlet args = l2 in*)\nlet (_, res) = (0,[0;0;0;0])(*List.fold_left f base args*) in\nres\nin\nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"], "bad": ["\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = let (_,res) = 0; [0; 0; 0; 0] in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = (0,[0;0;0;0]) in\nlet base = (0,[0;0;0;0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int list * int list\n       but an expression was expected of type int * 'a list\n       Type int list is not compatible with type int \n", "Error: This expression has type int list * int list\n       but an expression was expected of type (int * int list) * 'a list\n       Type int list is not compatible with type int * int list \n", "Error: This expression has type int list * int list\n       but an expression was expected of type (int * int list) * 'a list\n       Type int list is not compatible with type int * int list \n"], "bad": ["\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, [0; 0; 0; 0]) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, [0; 0; 0; 0]) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, [0; 0; 0; 0]) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = (0,[0;0;0;0]) in\nlet base = (0,l1) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "bad": ["\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, [0; 0; 0; 0]) in\n    let base = (0, []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =(*\nmatch a with\n[]  ->\n([],[])\n| h1::t1  ->*)\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list -> 'b -> 'c list * int list\n       but an expression was expected of type 'a list -> 'b -> 'a list\n       Type 'c list * int list is not compatible with type 'a list \n"], "bad": ["\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | [] -> ([], []) | h1::t1 -> (l1, [0; 0; 0; 0]) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1,_)  ->\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list -> 'b -> 'c * int list\n       but an expression was expected of type 'a list -> 'b -> 'a list\n       Type 'c * int list is not compatible with type 'a list \n", "Error: This expression has type 'a list -> 'b -> 'c * int list\n       but an expression was expected of type 'a list -> 'b -> 'a list\n       Type 'c * int list is not compatible with type 'a list \n"], "bad": ["\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with | [] -> (l1, [0; 0; 0; 0]) | h1::t1 -> (l1, [0; 0; 0; 0]) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | h1::t1 -> (l1, [0; 0; 0; 0]) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, rh::rt)  ->\n(t1,((h1+x+rh) mod 10)::rt)\nin\nlet base = (l1,[0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int list * int list\n       but an expression was expected of type int list * 'a list list\n       Type int is not compatible with type 'a list \n"], "bad": ["\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (match x with | h2::t2 -> (t1, (((h1 + rh) mod 10) :: rt))) in\n    let base = (l1, [0]) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\n(t1, (h1+x)/10::((h1+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\n(t1, (h1+x+rh)/10::((h1+x+rh) mod 10)::rt)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value h1\n"], "bad": ["\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (j1::t1,[]) -> (t1, [(h1 + x) / 10; (h1 + x) mod 10])\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\nif (h1+x > 9) then\n(t1, (h1+x)/10::((h1+x) mod 10)::[])\nelse\n(t1, ((h1+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\nif (h1+x+rh > 9) then\n(t1, (h1+x+rh)/10::((h1+x+rh) mod 10)::rt)\nelse\n(t1, ((h1+x+rh) mod 10)::rt)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int list * int list\n"], "bad": ["\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) ->\n          if (h1 + x) > 9\n          then (t1, [(h1 + x) / 10; (h1 + x) mod 10])\n          else [(h1 + x) mod 10]\n      | (h1::t1,rh::rt) ->\n          if ((h1 + x) + rh) > 9\n          then\n            (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n          else (((h1 + x) + rh) mod 10) :: rt in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\n(List.tl (List.rev (h1::t1)), (h1+x)/10::((h1+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\n(List.tl (List.rev (h1::t1)), (h1+x+rh)/10::((h1+x+rh) mod 10)::rt)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) ->\n          (((List.tl List.rev h1) :: t1), [(h1 + x) / 10; (h1 + x) mod 10])\n      | (h1::t1,rh::rt) ->\n          (((List.tl List.rev h1) :: t1), ((((h1 + x) + rh) / 10) ::\n            (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\n(List.rev (List.tl (List.rev (h1::t1))), (h1+x)/10::((h1+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\n(List.rev (List.tl (List.rev (h1::t1))), (h1+x+rh)/10::((h1+x+rh) mod 10)::rt)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) ->\n          ((List.rev List.tl (List.rev (h1 :: t1))),\n            [(h1 + x) / 10; (h1 + x) mod 10])\n      | (h1::t1,rh::rt) ->\n          ((List.rev List.tl (List.rev (h1 :: t1))), ((((h1 + x) + rh) / 10)\n            :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\nlet h2::t2 = List.rev (h1::t1) in\n(List.rev t2, (h2+x)/10::((h2+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\nlet h2::t2 = List.rev (h1::t1) in\n(List.rev t2, (h2+x+rh)/10::((h2+x+rh) mod 10)::rt)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) ->\n          let h2::t2 = (List.rev h1) :: t1 in\n          ((List.rev t2), [(h2 + x) / 10; (h2 + x) mod 10])\n      | (h1::t1,rh::rt) ->\n          let h2::t2 = (List.rev h1) :: t1 in\n          ((List.rev t2), ((((h2 + x) + rh) / 10) :: (((h2 + x) + rh) mod 10)\n            :: rt)) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) ->\n          let h2::t2 = (List.rev h1) :: t1 in\n          ((List.rev t2), [(h2 + x) / 10; (h2 + x) mod 10])\n      | (h1::t1,rh::rt) ->\n          let h2::t2 = (List.rev h1) :: t1 in\n          ((List.rev t2), ((((h2 + x) + rh) / 10) :: (((h2 + x) + rh) mod 10)\n            :: rt)) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\n(t1, ((h1+x) / 10)::((h1+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\n(t1, ((h1+x+rh) / 10)::((h1+x+rh) mod 10)::rt)\n\nin\nlet base = (List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value rh\n"], "bad": ["\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) -> (t1, [((h1 + x) + rh) / 10; ((h1 + x) + rh) mod 10])\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = match a with\n(h1::t1, rh::rt)  ->\n(t1, bigAdd (mulByDigit h1 (rh::rt)) rt)\nin\nlet base = (List.rev l1, [0]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,rh::rt) -> (t1, (bigAdd ((mulByDigit h1 rh) :: rt) rt)) in\n  let base = ((List.rev l1), [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = match a with\n(h1::t1, r)  ->\n(t1, bigAdd (mulByDigit h1 (List.append r [0])) r)\nin\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type 'a list * int list\n       but an expression was expected of type 'a list * int list list\n       Type int is not compatible with type int list \n", "Error: This expression has type int list list\n       but an expression was expected of type int list\n       Type int list is not compatible with type int \n"], "bad": ["\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,rh::rt) -> (t1, ((bigAdd (mulByDigit x rh) rh) :: rt)) in\n  let base = ((List.rev l1), [1]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,rh::rt) -> (t1, ((bigAdd (mulByDigit x rh) rt) :: rt)) in\n  let base = ((List.rev l1), [1]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = match a with\n(h1::t1, r) ->\n(h1::t1, bigAdd (mulByDigit x (h1::t1)) r)\n| _\t      ->\n(* Should not get here *) ([], [])\nin\nlet base = (List.rev l1, [1]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,r) -> ((h1 :: t1), (bigAdd ((mulByDigit x h1) :: t1) r))\n    | _ -> ([], []) in\n  let base = ((List.rev l1), [1]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let pipe fs n =\nlet f a x = x a in\nlet base = n in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value n\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = n in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x =\nfun g b y n ->\nmatch n with\n[]  ->\nn\n| _   ->\ny b\nin\nlet base = f 0 [] in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: Unbound value n\n", "Error: This expression has type int but an expression was expected of type\n         'a -> ('a -> 'b) -> 'c -> 'b\n", "Error: Unbound value a\n", "Error: Unbound value a\n", "Error: Unbound value a\n"], "bad": ["\nlet pipe fs =\n  let f a x = match x with | [] -> 0 | _ -> x a in\n  let base = n in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x a x n = x a in let base = n in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x a x n = x a in let base = 0 in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x a x n = x a in let base = a in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x a x n = match n with | [] -> n | _ -> x a in\n  let base = f a x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x g b y n = match n with | [] -> n | _ -> y b in\n  let base = f a x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x =\nmatch x with\n[]  ->\n1\n| _   ->\n0\n\nin\nlet base = f 0 [] in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int -> 'b list\n"], "bad": ["\nlet pipe fs =\n  let f a x = let g b y n = match n with | [] -> n | _ -> y b in g a x in\n  let base = f 0 [] in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x =\nmatch a with\n[]  ->\n[]\n| _   ->\nx a\nin\nlet base = f [] (fun x -> x) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet pipe fs =\n  let f a x = match x with | [] -> 1 | _ -> x a in\n  let base = f 0 [] in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = match x with | [] -> [] | _ -> x a in\n  let base = f 0 [] in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x =\nfun a x ->\nmatch x with\nx',y  ->\nx' a\nin\nlet base = f 0 [] in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type\n         'a -> 'b -> 'c -> ('a -> 'd) -> 'e list -> 'd -> 'd\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside\n       'c -> ('a -> 'd) -> 'e list -> 'd -> 'd\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet pipe fs =\n  let f a x = match x with | [] -> [] | _ -> x a in\n  let base = f 0 [] in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = match x with | [] -> a | _ -> x a in\n  let base = f 0 [] in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x g b y z = match y with | [] -> z | _ -> b a in\n  let base = f 0 [] in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x a x =\n    match x with | (x',y) -> (match x' with | [] -> y | _ -> x' a) in\n  let base = f 0 [] in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x =\nmatch x with\n[]  ->\n0\n| _   ->\n1\nin\nlet base = 0 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet pipe fs =\n  let f a x = match x with | [] -> 0 | _ -> 1 in\n  let base = [] in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x =\nx a\nin\nlet base = 0 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet pipe fs =\n  let f a x = match x with | [] -> a | _ -> x a in\n  let base = 0 in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs n = \nlet f a x = x a in\nlet base = n in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value a\n", "Error: Unbound value x\n"], "bad": ["\nlet pipe fs = let f a x = x in let base = a in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x in let base = f x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x y -> y in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type ('b -> 'b) list\n"], "bad": ["\nlet pipe fs =\n  let f a x = x a in\n  let base = match fs with | (fn,n) -> n in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs =\nlet f a x = fun y -> x a in\nlet base = fun b -> b in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n"], "bad": ["\nlet pipe fs =\n  let f a x y z = z y in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x y z = z y in let base b = b in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs =\nlet f a x = x a in\nlet base = fun b -> fun c -> c in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> 'c -> 'd -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'd -> 'a\n"], "bad": ["\nlet pipe fs =\n  let f a x fn fn2 = a in let base b = b in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs =\nlet f a x = fun fn -> x (fun a -> a) in\nlet base = fun b -> b in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n", "Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n", "Error: This expression has type 'a -> 'b -> 'c -> ('a -> 'd) -> 'd\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> ('a -> 'd) -> 'd\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'b -> 'c -> 'a\n       The type variable 'a occurs inside 'b -> 'c -> 'a\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'b -> 'c -> 'a\n       The type variable 'a occurs inside 'b -> 'c -> 'a\n"], "bad": ["\nlet pipe fs =\n  let f a x c d = d c in let base b = b in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x y = y a in let base b = b in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x y z = z a in let base b = b in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x fn x a = fn in let base b = b in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x fn x a = fn in let base b = b in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs =\nlet f a x = fun y -> x a in\nlet base = fun b -> b in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n", "Error: Unbound value base\n"], "bad": ["\nlet pipe fs =\n  let f a x y z = z y in let base b = b in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x y = x base in let base b = b in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs =\nlet f a x = fun y -> x a in\nlet base = fun b -> b in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value b\n"], "bad": ["\nlet pipe fs = let f a x y = x a in let base = b in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs =\nlet f a x = let an = a in x an in\nlet base = fun b -> b in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> (('b -> 'a) -> 'c) -> 'c\n       The type variable 'a occurs inside (('b -> 'a) -> 'c) -> 'c\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> (('b -> 'a) -> 'c) -> 'c\n       The type variable 'a occurs inside (('b -> 'a) -> 'c) -> 'c\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n"], "bad": ["\nlet pipe fs =\n  let f a x y z = z (fun r  -> y) in\n  let base b = b in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x y z = z (fun r  -> y) in\n  let base b = b in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x y z = z y in let base b = b in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs =\nlet f a x = let y = a in x y in\nlet base = fun b -> b in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> 'c -> ('a -> 'd) -> 'd\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> ('a -> 'd) -> 'd\n", "Error: This expression has type 'a -> 'b -> 'c -> ('a -> 'd) -> 'd\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> ('a -> 'd) -> 'd\n"], "bad": ["\nlet pipe fs =\n  let f a x = let y z xn = xn a in y in\n  let base b = b in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = let y z xn = xn a in y in\n  let base b = b in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs =\nlet f a x = let y = pipe x a in y in\nlet base = fun b -> b in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type (('a -> 'a) -> 'a -> 'a) list\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet pipe fs =\n  let f a x = let y = a in x y in let base b = b in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = let y = pipe x a in x y in\n  let base b = b in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs =\nlet f a x = x(a) in\nlet base = fun b -> b in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value f\n"], "bad": ["\nlet pipe fs = let f a x = f x a in let base b = b in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs =\nlet f a x = fun y z -> z (x (a)) in\nlet base = fun b -> b in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type\n         ('a -> 'b) -> 'c -> 'a -> 'd -> ('b -> 'e) -> 'e\n       but an expression was expected of type ('a -> 'b) -> 'c -> 'a -> 'b\n       The type variable 'b occurs inside 'd -> ('b -> 'e) -> 'e\n", "Error: Unbound value c\n"], "bad": ["\nlet pipe fs =\n  let f a x c y z = z (a c) in let base b = b in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x y z = z (a c) in let base b = b in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs =\nlet f a x = fun c -> x (a) in\nlet base = fun b -> b in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs =\n  let f a x c = c (x a) in let base b = b in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs =\nlet f a x = fun c -> x a c in\nlet base = fun b -> b in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> ('b -> 'c) -> ('a -> 'b) -> 'c\n       but an expression was expected of type 'a -> ('b -> 'c) -> 'a\n       The type variable 'a occurs inside ('a -> 'b) -> 'c\n"], "bad": ["\nlet pipe fs =\n  let f a x c = x (c a) in let base b = b in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs =\nlet f a x = fun c -> fun d -> x d in\nlet base = fun b -> b in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x c = c x in let base b = b in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs =\nlet f a x = fun c -> x (fun d -> a) in\nlet base = fun b -> b in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n", "Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"], "bad": ["\nlet pipe fs =\n  let f a x c d = d c in let base b = b in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x c = a in let base b = b in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs =\nlet f a x = x a in\nfun base ->\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value base\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = base in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs =\nlet f a x = x a in\nlet base = List.fold_left f (fun b -> b) fs in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value base\n"], "bad": ["\nlet pipe fs =\n  let f a x = x a in\n  let base = List.fold_left f base fs in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs =\nlet f a x = x a in\nlet base = List.fold_left f (fun b -> b) fs in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value base\n"], "bad": ["\nlet pipe fs =\n  let f a x = x a in\n  let base = List.fold_left f (fun b  -> base) fs in List.fold_left f base fs;;\n"]}
{"fix": [], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'a) list\n       but an expression was expected of type (('a -> 'a) -> 'a -> 'a) list\n       The type variable 'a occurs inside 'a -> 'a\n"], "bad": ["\nlet pipe fs =\n  let f a x = x a in\n  let base = List.fold_left f (fun b  -> List.fold_left f b fs) fs in\n  List.fold_left f base fs;;\n"]}
{"fix": ["let rec digitsOfInt n =\nlet l = [] in\nif n<0 then l else l"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "Error: This expression has type 'a list\n       but an expression was expected of type unit\n"], "bad": ["\nlet rec digitsOfInt n = if n < 0 then [];;\n", "\nlet rec digitsOfInt n = let l = [] in if n < 0 then l;;\n"]}
{"fix": ["let digitsOfInt n =\nlet l = [] in\nif n<0 then l else digitsHelper n l"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value digitsHelper\n"], "bad": ["\nlet digitsOfInt n = let l = [] in if n < 0 then l else digitsHelper n l;;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: Unbound value sumList\n"], "bad": ["\nlet rec digitsHelper n l =\n  if n < 10 then n :: l else digitsHelper (n / 10) ((n mod 10) :: l);;\n\nlet digitsOfInt n = let l = [] in if n < 0 then l else digitsHelper n l;;\n\nlet rec digitalRoot n =\n  let l = digitsOfInt n in\n  let x = sumList l in if x = n then x else digitalRoot x;;\n"]}
{"fix": ["let rec assoc (d,k,l) = \nmatch l with\n| [] -> k\n| (s,i)::xs -> if k = s then i else assoc (d,k,xs)"], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value s\n"], "bad": ["\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> k\n  | x::xs -> let x = (s, i) in if k = s then i else assoc (d, k, xs);;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (not (List.mem h seen)) then h::seen else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: This function has type bool -> bool\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not List.mem h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"]}
{"fix": ["let rec wwhile (f,b) = \nlet calc = f b in\nlet (b',c') = calc in\nif c' then wwhile (f,b') else b'"], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let calc = f b in let (b',c') = calc in if c' then f b' else b';;\n", "\nlet rec wwhile (f,b) =\n  let calc = f b in let (b',c') = calc in if c' then f b' else b';;\n", "\nlet rec wwhile (f,b) =\n  let calc = f b in let (b',c') = calc in if c' then f b' else b';;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((f),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value f\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value f\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"], "bad": ["\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  let calc = f b in let (b',c') = calc in if c' then wwhile (f, b') else b';;\n\nlet _ = (fixpoint (f, b)) = (wwhile ((f b), b));;\n", "\nlet rec wwhile (f,b) =\n  let calc = f b in let (b',c') = calc in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((let f x = f x in f b),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"], "bad": ["\nlet rec wwhile (f,b) =\n  let calc = f b in let (b',c') = calc in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((fun x -> f b),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n", "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let calc = f b in let (b',c') = calc in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((let f x = f x in f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet rec wwhile (f,b) =\n  let calc = f b in let (b',c') = calc in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((let f x = wwhile (f, x) in f b), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((let f x = f b in f),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"], "bad": ["\nlet rec wwhile (f,b) =\n  let calc = f b in let (b',c') = calc in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((fun x -> (f x,f x!=x)),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) = wwhile ((fun x  -> (x, (x != b))), b);;\n", "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f x), ((f x) != b))), b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "expr", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n"]}
{"fix": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine x -> \"sin(pi*%s)\" x\n| Cosine x -> \"cos(pi*%s)\" x\n| Average x y -> \"((%s+%s)/2)\" x y\n| Times x y -> \"%s*%s\" x y\n| Thresh x y z a -> \"%s<%s?%s:%s\" x y z a"], "hw": "hw2", "problem": "exprToString", "message": ["Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX x -> \"x\" | VarY y -> \"y\";;\n"]}
{"fix": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\" ^ exprToString x ^ \"+\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (x,y,z,a) -> \"(\" ^ exprToString x ^ \"<\" ^ exprToString y ^ \"?\" ^ exprToString z ^ \":\" ^ exprToString a ^ \")\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: Unbound value sprintf\n", "Error: This expression has type expr but an expression was expected of type\n         string\n", "Error: Unbound value expToString\nHint: Did you mean exprToString?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*%s)\" x\n  | Cosine x -> \"cos(pi*%s)\" x\n  | Average (x,y) -> \"((%s+%s)/2)\" x y\n  | Times (x,y) -> \"%s*%s\" x y\n  | Thresh (x,y,z,a) -> \"%s<%s?%s:%s\" x y z a;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> sprintf \"sin(pi*%s)\" x\n  | Cosine x -> sprintf \"cos(pi*%s)\" x\n  | Average (x,y) -> sprintf \"((%s+%s)/2)\" x y\n  | Times (x,y) -> sprintf \"%s*%s\" x y\n  | Thresh (x,y,z,a) -> sprintf \"%s<%s?%s:%s\" x y z a;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"sin(pi*%s)\" x\n  | Cosine x -> Printf.sprintf \"cos(pi*%s)\" x\n  | Average (x,y) -> Printf.sprintf \"((%s+%s)/2)\" x y\n  | Times (x,y) -> Printf.sprintf \"%s*%s\" x y\n  | Thresh (x,y,z,a) -> Printf.sprintf \"%s<%s?%s:%s\" x y z a;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (x,y,z,a) ->\n      (exprToString x) ^\n        (\"<\" ^\n           ((expToString y) ^\n              (\"?\" ^ ((exprToString z) ^ (\":\" ^ (exprToString a))))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | Cosine a -> cos (pi * (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) + (eval (b, x, y))) / 2\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi * (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) + (eval (b, x, y))) / 2\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\nError: Unbound value sampleExpr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value sampleExpr\nHint: Did you mean sampleExpr1 or sampleExpr2?\nError: Unbound value sampleExpr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sampleExpr\nHint: Did you mean sampleExpr1 or sampleExpr2?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet _ = emitGrayscale ((eval_fn sampleExpr), 150, \"sample\");;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: Unbound value f\n"], "bad": ["\nlet sqsum xs =\n  let f a x =\n    match x with | [] -> a | h::t -> List.fold_left f (a + (h * h)) t in\n  let base = 0 in List.fold_left f base xs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value a\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun x -> x in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n"], "bad": ["\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let padZero l1 l2 =\nlet diff = (List.length l1 - List.length l2) in\nif diff >= 0 then (l1, (clone 0 diff) @ l2)\nelse ((clone 0 (abs diff)) @ l1, l2)"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type int -> int list\n       but an expression was expected of type int\n", "Error: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else ((((clone 0) - diff) @ l1), l2);;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 abs diff) @ l1), l2);;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| []   -> \nif ((arg1 + arg2) > 9)\nthen [1] @ [(arg1 + arg2) mod 10] @ a\nelse ((arg1 + arg2)::a)\n| h::t -> \nif ((arg1 + arg2 + h) > 9)\nthen [1] @ [(arg1 + arg2 + h) mod 10] @ a\nelse ((arg1 + arg2 + h)::a)\nin\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      match a with\n      | [] ->\n          if (arg1 + arg2) > 9\n          then [1] @ ([(arg1 + arg2) mod 10] @ a)\n          else (arg1 + arg2) :: a\n      | h::t ->\n          if ((arg1 + arg2) + h) > 9\n          then [1] @ ([((arg1 + arg2) + h) mod 10] @ a)\n          else ((arg1 + arg2) + h) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| (0,[])   -> \nif ((arg1 + arg2) > 9)\nthen (1, [(arg1 + arg2) mod 10])\nelse (0,[arg1 + arg2])\n| (1,_::t) -> \nif ((arg1 + arg2 + 1) > 9)\nthen (1, [(arg1 + arg2 + 1) mod 10] @ t)\nelse (0, ((arg1 + arg2 + 1)::t))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_,res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value h\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      match a with\n      | (0,[]) ->\n          if (arg1 + arg2) > 9\n          then (1, [(arg1 + arg2) mod 10])\n          else (0, [arg1 + arg2])\n      | (1,_::t) ->\n          if ((arg1 + arg2) + h) > 9\n          then (1, ([((arg1 + arg2) + 1) mod 10] @ t))\n          else (0, (((arg1 + arg2) + 1) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| (0,[])   -> \nif ((arg1 + arg2) > 9)\nthen (1, [(arg1 + arg2) mod 10])\nelse (0,[arg1 + arg2])\n| (1, h::t) -> \nif ((arg1 + arg2 + 1) > 9)\nthen (1, [(arg1 + arg2 + 1) mod 10] @ t)\nelse (0, ((arg1 + arg2 + 1)::t))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_,res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value t\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      match a with\n      | (0,[]) ->\n          if (arg1 + arg2) > 9\n          then (1, [(arg1 + arg2) mod 10])\n          else (0, [arg1 + arg2])\n      | (1,_) ->\n          if ((arg1 + arg2) + 1) > 9\n          then (1, ([((arg1 + arg2) + 1) mod 10] @ t))\n          else (0, (((arg1 + arg2) + 1) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| (0, acc) -> \nif ((arg1 + arg2) > 9)\nthen (1, ((arg1 + arg2) mod 10)::acc)\nelse (0,(arg1 + arg2)::acc)\n| (0, [])  ->\nif ((arg1 + arg2) > 9)\nthen (1, [(arg1 + arg2) mod 10])\nelse (0, [arg1 + arg2])\n| (_, acc) -> \nif ((arg1 + arg2 + 1) > 9)\nthen (1, ((arg1 + arg2 + 1) mod 10)::acc)\nelse (0, ((arg1 + arg2 + 1)::acc))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_,res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int * 'a\n       but an expression was expected of type int list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      match a with\n      | (0,_) ->\n          if (arg1 + arg2) > 9\n          then (1, [(arg1 + arg2) mod 10])\n          else (0, [arg1 + arg2])\n      | (_,_) ->\n          if ((arg1 + arg2) + 1) > 9\n          then (1, ([((arg1 + arg2) + 1) mod 10] @ a))\n          else (0, (((arg1 + arg2) + 1) :: a)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet rec pow10 exp =\nmatch exp with\n| 0 -> 1\n| n -> 10 * (pow10 n-1) in\nlet padded_x = x * pow10 ((List.length padding) - 1) in\nmatch l with\n| []   -> \n([], [], acc)\n| h::t -> \nlet (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\n(0::padding, t, bigAdd acc (mulByDigit padded_x f_rev)) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int but an expression was expected of type\n         string\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         string\n", "Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      let (carry,acc) = a in\n      if ((arg1 + arg2) + carry) > 9\n      then (1, ((((arg1 + arg2) + carry) mod 10) :: acc))\n      else (0, (((arg1 + arg2) + carry) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (fin,res) = List.fold_left f base args in fin :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet mulByDigit i l =\n  let saved = l in\n  let rec helper i' l' =\n    match i' with\n    | 0 -> []\n    | 1 -> l'\n    | _ -> helper (i' - 1) (bigAdd saved l') in\n  helper i l;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (padding,l,acc) = a in\n    let padded_x = (x * 10) ^ ((List.length padding) - 1) in\n    match l with\n    | [] -> ([], [], acc)\n    | h::t ->\n        let (first,second) = padZero [h] padding in\n        let f_rev = List.rev first in\n        ((0 :: padding), t, (bigAdd acc (mulByDigit padded_x f_rev))) in\n  let base = ([0], (List.rev l1), []) in\n  let args = List.rev l2 in let (_,_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      let (carry,acc) = a in\n      if ((arg1 + arg2) + carry) > 9\n      then (1, ((((arg1 + arg2) + carry) mod 10) :: acc))\n      else (0, (((arg1 + arg2) + carry) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (fin,res) = List.fold_left f base args in fin :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet mulByDigit i l =\n  let saved = l in\n  let rec helper i' l' =\n    match i' with\n    | 0 -> []\n    | 1 -> l'\n    | _ -> helper (i' - 1) (bigAdd saved l') in\n  helper i l;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (padding,l,acc) = a in\n    let padded_x = x * (10 ** ((List.length padding) - 1)) in\n    match l with\n    | [] -> ([], [], acc)\n    | h::t ->\n        let (first,second) = padZero [h] padding in\n        let f_rev = List.rev first in\n        ((0 :: padding), t, (bigAdd acc (mulByDigit padded_x f_rev))) in\n  let base = ([0], (List.rev l1), []) in\n  let args = List.rev l2 in let (_,_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      let (carry,acc) = a in\n      if ((arg1 + arg2) + carry) > 9\n      then (1, ((((arg1 + arg2) + carry) mod 10) :: acc))\n      else (0, (((arg1 + arg2) + carry) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (fin,res) = List.fold_left f base args in fin :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet mulByDigit i l =\n  let saved = l in\n  let rec helper i' l' =\n    match i' with\n    | 0 -> []\n    | 1 -> l'\n    | _ -> helper (i' - 1) (bigAdd saved l') in\n  helper i l;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (padding,l,acc) = a in\n    let padded_x = x * (10. ** ((List.length padding) - 1)) in\n    match l with\n    | [] -> ([], [], acc)\n    | h::t ->\n        let (first,second) = padZero [h] padding in\n        let f_rev = List.rev first in\n        ((0 :: padding), t, (bigAdd acc (mulByDigit padded_x f_rev))) in\n  let base = ([0], (List.rev l1), []) in\n  let args = List.rev l2 in let (_,_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet rec pow10 exp =\nmatch exp with\n| 0 -> 1\n| n -> 10 * (pow10 (n-1)) in\nlet padded_x = x * pow10 ((List.length padding) - 1) in\nlet rec helper padding l acc padded_x = \nmatch l with\n| []   ->\n[]\n| h::t ->\nlet (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\nbigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x) in\nlet result = helper padding l acc padded_x in\n([0], l, result) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: Unbound value List.reverse\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value List.reverse\n", "Error: Unbound value t\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value t\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      let (carry,acc) = a in\n      if ((arg1 + arg2) + carry) > 9\n      then (1, ((((arg1 + arg2) + carry) mod 10) :: acc))\n      else (0, (((arg1 + arg2) + carry) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (fin,res) = List.fold_left f base args in fin :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet mulByDigit i l =\n  let saved = l in\n  let rec helper i' l' =\n    match i' with\n    | 0 -> []\n    | 1 -> l'\n    | _ -> helper (i' - 1) (bigAdd saved l') in\n  helper i l;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (padding,l,acc) = a in\n    let rec pow10 exp = match exp with | 0 -> 1 | n -> 10 * (pow10 (n - 1)) in\n    let padded_x = x * (pow10 ((List.length padding) - 1)) in\n    let rec helper padding l acc padded_x =\n      match l with\n      | [] -> []\n      | h::t ->\n          let (first,second) = padZero [h] padding in\n          let f_rev = List.reverse first in\n          bigAdd (mulByDigit padded_x f_rev)\n            (helper (0 :: padding) t (mulByDigit padded_x f_rev) padded_x) in\n    let result = helper padding l acc padded_x in ([0], t, result) in\n  let base = ([0], (List.rev l1), []) in\n  let args = List.rev l2 in let (_,_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      let (carry,acc) = a in\n      if ((arg1 + arg2) + carry) > 9\n      then (1, ((((arg1 + arg2) + carry) mod 10) :: acc))\n      else (0, (((arg1 + arg2) + carry) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (fin,res) = List.fold_left f base args in fin :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet mulByDigit i l =\n  let saved = l in\n  let rec helper i' l' =\n    match i' with\n    | 0 -> []\n    | 1 -> l'\n    | _ -> helper (i' - 1) (bigAdd saved l') in\n  helper i l;;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (padding,l,acc) = a in\n    let rec pow10 exp = match exp with | 0 -> 1 | n -> 10 * (pow10 (n - 1)) in\n    let padded_x = x * (pow10 ((List.length padding) - 1)) in\n    let rec helper padding l acc padded_x =\n      match l with\n      | [] -> []\n      | h::t ->\n          let (first,second) = padZero [h] padding in\n          let f_rev = List.rev first in\n          bigAdd (mulByDigit padded_x f_rev)\n            (helper (0 :: padding) t (mulByDigit padded_x f_rev) padded_x) in\n    let result = helper padding l acc padded_x in ([0], t, result) in\n  let base = ([0], (List.rev l1), []) in\n  let args = List.rev l2 in let (_,_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x =\nlet (padding, acc) = a in\n(padding+1, bigAdd acc ((mulByDigit x l1) @ (clone 0 padding))) in\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type\n         int * int list -> int -> int * int list * int list\n       but an expression was expected of type\n         int * int list -> int -> int * int list\n       Type int * int list * int list is not compatible with type\n         int * int list \nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type\n         int * int list -> int -> int * int list * int list\n       but an expression was expected of type\n         int * int list -> int -> int * int list\n       Type int * int list * int list is not compatible with type\n         int * int list \n"], "bad": ["\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      let (carry,acc) = a in\n      if ((arg1 + arg2) + carry) > 9\n      then (1, ((((arg1 + arg2) + carry) mod 10) :: acc))\n      else (0, (((arg1 + arg2) + carry) :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (fin,res) = List.fold_left f base args in fin :: res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet mulByDigit i l =\n  let saved = l in\n  let rec helper i' l' =\n    match i' with\n    | 0 -> []\n    | 1 -> l'\n    | _ -> helper (i' - 1) (bigAdd saved l') in\n  helper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (padding,acc) = a in\n    ((padding + 1), l1, (bigAdd acc ((mulByDigit x l1) @ (clone 0 padding)))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let rec digitsOfInt n = if n > 0\nthen\n(n mod 10) :: (digitsOfInt (n/10))\nelse\n[]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) :: (n mod 10) else 0;;\n", "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) :: (n mod 10) else [];;\n"]}
{"fix": ["let rec listReverse l = function\n| [] -> l\n| (h::t) -> listReverse (h::l) t"], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value listReverse\n"], "bad": ["\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n"]}
{"fix": ["let rec listReverse l = match l with\n| [] -> l\n| [other::tail::[]] -> tail :: other"], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value l\n", "Error: Unbound value l\n"], "bad": ["\nlet _ =\n  let rec listReverse l = function | [] -> l | h::t -> listReverse (h :: l) t in\n  l [] list;;\n", "\nlet _ =\n  let rec listReverse l = function | [] -> l | h::t -> listReverse (h :: l) t in\n  listReverse [] l;;\n"]}
{"fix": [], "hw": "hw1", "problem": "sumList", "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec listReverse l =\n  match l with | [] -> l | (other::tail::[])::[] -> tail :: other;;\n"]}
{"fix": ["let rec listReverse l =\nlet rec listReverseHelper l ans = match ans with\n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "Error: Unbound value listReverseHelper\n"], "bad": ["\nlet rec listReverse l =\n  match l with | [] -> l | (other::tail::[])::[] -> tail :: other;;\n", "\nlet rec listReverse l = listReverseHelper l [];;\n"]}
{"fix": ["let rec digitsOfInt n =\nlet digitsOfIntHelper n1 = \nif n > 0\nthen\nlistReverse ((n mod 10) :: (digitsOfInt (n/10)))\nelse\n[]\nin\nlistReverse (digitsOfIntHelper n)"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec listReverse l =\n  let rec listReverseHelper dec acc =\n    match dec with | [] -> acc | h::t -> listReverseHelper t (h :: acc) in\n  listReverseHelper l [];;\n\nlet rec digitsOfInt n =\n  if n > 0 then (listReverse (n mod 10)) :: (digitsOfInt (n / 10)) else [];;\n"]}
{"fix": ["let rec additivePersistence n = \nlet rec sumDigits n1 = \nif n1 < 10 then \nn1 \nelse\nn1 mod 10 + sumDigits (n1 / 10) in \nif (n < 10) then\n0\nelse\n1 + additivePersistence (sumDigits n)"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: Unbound value %\n"], "bad": ["\nlet rec additivePersistence n =\n  let rec sumDigits n1 =\n    if n < 10 then n else (n1 % 10) + (sumDigits (n1 / 10)) in\n  if n < 10 then 0 else 1 + (additivePersistence (sumDigits n));;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int\n"], "bad": ["\nlet rec sumDigits n1 =\n  if n1 < 10 then n1 else (n1 mod 10) + (sumDigits (n1 / 10));;\n\nlet rec digitalRoot n = if n > 10 then digitalRoot sumDigits n else n;;\n"]}
{"fix": ["let palindrome w = (explode w) = (listReverse (explode w))"], "hw": "hw1", "problem": "palindrome", "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n"], "bad": ["\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec listReverseHelper dec acc =\n    match dec with | [] -> acc | h::t -> listReverseHelper t (h :: acc) in\n  listReverseHelper l [];;\n\nlet palindrome w = (explode w) = (explode (listReverse w));;\n"]}
{"fix": ["let rec fixpoint (f,x) = \nlet x' = f x in\nif x' = x then x else fixpoint (f, x')"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type\n         (('a -> 'b) -> 'a -> 'b) * ('a -> 'b)\n"], "bad": ["\nlet rec fixpoint (f,x) = let x' = f x in if x' = x then x else fixpoint f x';;\n"]}
{"fix": ["let rec fixpoint (f,x) = \nlet x' = f x in\nlet g x = (x', x' = x) in \nwwhile (g,x)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a -> ('b -> 'a) * bool\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'b -> 'a\n"], "bad": ["\nlet rec wwhile (f,x) = let (x',b') = f x in if b' then wwhile (f, x') else x';;\n\nlet rec fixpoint (f,x) =\n  let x' = f x in let g x = (f, (x' = x)) in wwhile (g, x);;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine     (e1) -> sin(pi *. (eval (e1, x, y)))\n| Cosine   (e1) -> cos(pi *. (eval (e1, x, y)))\n| Average  (e1, e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y)))/.2.\n| Times    (e1, e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n| Thresh   (e1, e2, e3, e4) \n-> if (eval (e1, x, y)) < (eval (e2, x, y)) then\n(eval (e3, x, y)) else\n(eval (e4, x, y))"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type string but an expression was expected of type\n         float\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (exprToString e1))\n  | Cosine e1 -> cos (pi *. (exprToString e1))\n  | Average (e1,e2) -> ((exprToString e1) +. (exprToString e2)) /. 2.\n  | Times (e1,e2) -> (exprToString e1) *. (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      if (exprToString e1) < (exprToString e2)\n      then exprToString e3\n      else exprToString e4;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval e1))\n  | Cosine e1 -> cos (pi *. (eval e1))\n  | Average (e1,e2) -> ((eeval e1) +. (eval e2)) /. 2.\n  | Times (e1,e2) -> (eval e1) *. (eval e2)\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval e1) < (eval e2) then eval e3 else eval e4;;\n"]}
{"fix": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine     (e1) -> \"sin(pi*\" ^ (exprToString e1) ^ \")\"\n| Cosine   (e1) -> \"cos(pi*\" ^ (exprToString e1) ^ \")\"\n| Average  (e1, e2) -> \"((\" ^ (exprToString e1) ^ \"+\"\n^ (exprToString e2) ^ \")/2)\"\n| Times    (e1, e2) -> (exprToString e1) ^ \"*\"\n^ (exprToString e2)\n| Thresh   (e1, e2, e3, e4) -> \"(\" ^ (exprToString e1) ^ \"<\"\n^ (exprToString e2) ^ \"?\"\n^ (exprToString e3) ^ \":\"\n^ (exprToString e4) ^ \")\"\n| AbsThresh (e1, e2, e3) -> let s = exprToString e3 in\n\"(abs(\" ^ (exprToString e1) ^ \")<abs(\"\n^ (exprToString e2) ^ \"?\"\n^ s ^ \":abs(\"\n^ s ^ \"))\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: Unbound value e4\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | AbsThresh (e1,e2,e3) ->\n      let s = exprToString e3 in\n      \"(abs(\" ^\n        ((exprToString e1) ^\n           (\")<abs(\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^ (s ^ (\":abs(\" ^ ((exprToString e4) ^ \"))\")))))));;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine     (e1) -> sin(pi *. (eval (e1, x, y)))\n| Cosine   (e1) -> cos(pi *. (eval (e1, x, y)))\n| Average  (e1, e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y)))/.2.\n| Times    (e1, e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n| Thresh   (e1, e2, e3, e4) \n-> if (eval (e1, x, y)) < (eval (e2, x, y)) then\n(eval (e3, x, y)) else\n(eval (e4, x, y))\n| AbsThresh (e1, e2, e3) -> let s = eval (e3, x, y) in\nif abs_float (eval (e1, x, y)) < abs_float (eval (e2, x, y)) then\ns else\nabs_float s\n| ModThresh (e1, e2, e3) -> \nif (truncate (100. *. (eval (e1, x, y)))) mod 5 = 0 then\n(eval (e2, x, y)) else\n(eval (e3, x, y))"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | AbsThresh (e1,e2,e3) ->\n      let s = eval (e3, x, y) in\n      if (abs_float (eval (e1, x, y))) < (abs_float (eval (e2, x, y)))\n      then s\n      else abs_float s\n  | ModThresh (e1,e2,e3) ->\n      if ((truncate (100 *. (eval (e1, x, y)))) mod 5) = 0\n      then eval (e2, x, y)\n      else eval (e3, x, y);;\n"]}
{"fix": ["let rec build (rand, depth) = \nlet r = rand (0,99) in\nif depth = 0 then\nif (r < 50) then\nbuildX()\nelse\nbuildY()\nelse\nbuildY()"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         unit -> expr\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: Unbound value expr\nHint: Did you mean exp?\nError: Unbound constructor AbsThresh\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value expr\nHint: Did you mean exp?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX else buildY)\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    if r < 90\n                    then\n                      buildModThresh\n                        ((build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then buildX () else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    if r < 90\n                    then\n                      buildModThresh\n                        ((build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))));;\n", "\nlet buildAbsThresh (e1,e2,e3) = AbsThresh (e1, e2, e3);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildModThresh (e1,e2,e3) = ModThresh (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (e1,e2,e3,e4) = Thresh (e1, e2, e3, e4);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | AbsThresh of expr* expr* expr\n  | ModThresh of expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  let r = rand (0, 99) in\n  if depth = 0\n  then (if r < 50 then (buildX ()) :: expr else buildY ())\n  else\n    if r < 5\n    then buildX ()\n    else\n      if r < 10\n      then buildY ()\n      else\n        if r < 30\n        then buildSine (build (rand, (depth - 1)))\n        else\n          if r < 50\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r < 60\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r < 70\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r < 80\n                then\n                  buildThresh\n                    ((build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r < 90\n                  then\n                    buildAbsThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    if r < 90\n                    then\n                      buildModThresh\n                        ((build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))));;\n"]}
{"fix": ["let padZero l1 l2 = \nlet dif = (List.length l1) - (List.length l2) in\nif (dif = 0) then\n(l1, l2)\nelse if (dif < 0) then (*l2 is bigger*)\n((clone 0 (0-dif)) @ l1, l2)\nelse\n(l1, ((clone 0 dif) @ l2))"], "hw": "hw3", "problem": "padZero", "message": ["Error: Unbound value diff\nHint: Did you mean dif?\n"], "bad": ["\nlet rec clone x n =\n  let rec cloneHelper x n ans =\n    if n > 0 then cloneHelper x (n - 1) (x :: ans) else ans in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let dif = (List.length l1) - (List.length l2) in\n  if dif = 0\n  then (l1, l2)\n  else\n    if dif < 0\n    then (((clone 0 (0 - diff)) @ l1), l2)\n    else (l1, ((clone 0 diff) @ l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type string but an expression was expected of type\n         'a * 'b\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet (_,_) = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, rest) = a in\nlet (d1, d2) = x in\nlet sum = d1 + d2 + carry in\nif (sum > 9) then\n(1, (sum - 10)::rest)\nelse\n(0, sum::rest) in\nlet base = (0, []) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value list\n"], "bad": ["\nlet rec clone x n =\n  let rec cloneHelper x n ans =\n    if n > 0 then cloneHelper x (n - 1) (x :: ans) else ans in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let dif = (List.length l1) - (List.length l2) in\n  if dif = 0\n  then (l1, l2)\n  else\n    if dif < 0\n    then (((clone 0 (0 - dif)) @ l1), l2)\n    else (l1, ((clone 0 dif) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,rest) = a in\n      let (d1,d2) = x in\n      let sum = (d1 + d2) + carry in\n      if sum > 9 then (1, ((sum - 10) :: rest)) else (0, (sum :: rest)) in\n    let base = (0, []) in\n    let args = List.combine (list.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let rec mulByDigit i l = \nlet rec mulHelper l' = match l' with\n| [] -> (0,[])\n| h :: t -> let (carry, rest) = mulHelper t in\nlet prod = i * h + carry in\n(prod/10, (prod mod 10) :: rest) in\nlet (_, ans) = mulHelper (0::(List.rev (l))) in\nans"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"], "bad": ["\nlet rec mulByDigit i l =\n  let rec mulHelper l' =\n    match l' with\n    | [] -> (0, [])\n    | h::t ->\n        let (carry,rest) = mulHelper t in\n        let prod = (i * h) + carry in ((prod / 10), ((prod mod 10) :: rest)) in\n  let (_,ans) = (mulHelper 0) :: (List.rev l) in ans;;\n"]}
{"fix": ["let rec digitsOfInt n = \nif (n <= 0) \nthen []\nelse \nn :: []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec digitsOfInt n = if n <= 0 then [] else n mod 10;;\n", "\nlet rec digitsOfInt n = if n <= 0 then [] else [n mod (10 n)];;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n = if n <= 0 then [] else [n mod 10; digitsOfInt n];;\n", "\nlet rec digitsOfInt n = if n <= 0 then [] else [n mod 10; digitsOfInt n];;\n"]}
{"fix": ["let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 :: myList"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  let myList = [] in if n <= 0 then [] else (n mod 10) @ myList;;\n"]}
{"fix": ["let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n"], "bad": ["\nlet rec digitsOfInt n = let myList = [] in if n <= 0 then [];;\n", "\nlet rec digitsOfInt n = let myList = [] in if n <= 0 then [];;\n", "\nlet rec digitsOfInt n =\n  let myList = [] in if n <= 0 then ([] mod 10) :: myList;;\n", "\nlet rec digitsOfInt n = let myList = [] in if n <= 0 then [];;\n", "\nlet rec digitsOfInt n = let myList = [] in if n <= 0 then [];;\n"]}
{"fix": ["let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nn mod 10 :: myList"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n"], "bad": ["\nlet rec digitsOfInt n = let myList = [] in if n <= 0 then [];;\n"]}
{"fix": ["let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nn mod 10 :: myList"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n"], "bad": ["\nlet rec digitsOfInt n =\n  let myList = [] in if n <= 0 then ([] mod 10) :: myList;;\n", "\nlet rec digitsOfInt n = let myList = [] in if n <= 0 then [];;\n"]}
{"fix": ["let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nn mod 10 :: myList"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else (n mod 10) :: ((myList n) mod 100) :: myList;;\n"]}
{"fix": ["let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt n"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type bool but an expression was expected of type\n         'a list\n", "Error: This expression has type int -> int list list\n       but an expression was expected of type int list list\n"], "bad": ["\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else n = (n - (n mod 10)); (n :: myList) :: digitsOfInt;;\n", "\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: digitsOfInt;;\n"]}
{"fix": ["let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt (n - n mod 10)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int -> int list list\n       but an expression was expected of type int list list\n"], "bad": ["\nlet rec digitsOfInt n =\n  let myList = [] in\n  if n <= 0 then [] else ((n mod 10) :: myList) :: digitsOfInt;;\n"]}
{"fix": ["let rec digitsOfInt n =\nif (n <= 0) then []\nelse \nList.rev (n mod 10 :: digitsOfInt (n / 10))"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value rev\nHint: Did you mean ref?\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else rev ((n mod 10) :: (digitsOfInt (n / 10)));;\n"]}
{"fix": ["let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10))"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (List.rev digitsOfInt (n / 10));;\n"]}
{"fix": ["let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10))"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else ((n mod 10) :: (digitsOfInt (n / 10))) List.rev;;\n"]}
{"fix": ["let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: List.rev (digitsOfInt (n / 10)))"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (List.rev digitsOfInt (n / 10));;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (List.rev digitsOfInt (n / 10));;\n"]}
{"fix": ["let rec additivePersistence n = \nmatch (digitsOfInt n) with\n| [] -> 0\n| _ -> sumList (digitsOfInt n)"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | h::t -> h + t;;\n", "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList digitsOfInt n;;\n", "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList digitsOfInt n;;\n", "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with | [] -> 0 | _ -> sumList digitsOfInt n;;\n"]}
{"fix": ["let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen  \nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type bool but an expression was expected of type\n         unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = 1 in if (sumList (digitsOfInt n)) > 9 then count = (count + 1);;\n", "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (count additivePersistence (sumList (digitsOfInt n)));;\n", "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (count additivePersistence (sumList (digitsOfInt n)));;\n", "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (count additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n"]}
{"fix": [], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (count additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (count additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9 then 1 :: count else sumList count;;\n"]}
{"fix": ["let rec additivePersistence n = \nlet x = 1 in x + 1;\nif (sumList (digitsOfInt n) > 9) \nthen \nadditivePersistence (sumList (digitsOfInt n))\nelse x"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This variant expression is expected to have type bool\n       The constructor :: does not belong to type bool\n", "Error: This variant expression is expected to have type bool\n       The constructor :: does not belong to type bool\n", "Error: Unbound value &&&\nHint: Did you mean &&?\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: Unbound value count\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then (1 :: count) & (additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then (1 :: count) && (additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let count = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then (1 :: count) &&& (additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = 1 in\n  if (sumList (digitsOfInt n)) > 9\n  then x + (1 additivePersistence (sumList (digitsOfInt n)))\n  else sumList count;;\n", "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = 1 in\n  x + 1;\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else sumList count;;\n"]}
{"fix": ["let rec additivePersistence n = \nlet x = [0] in\nif (sumList (digitsOfInt n) > 9) then begin\n1 :: x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse sumList x"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = [0] in\n  if (sumList (digitsOfInt n)) > 9\n  then 1 :: (x additivePersistence (sumList (digitsOfInt n)))\n  else sumList x;;\n"]}
{"fix": ["let rec additivePersistence n = \n1::[2];\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  1 @ x;\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n))\n  else sumList x;;\n"]}
{"fix": ["let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \n\nsumList x;"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [0];;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) < 9\n  then (1 :: x; additivePersistence (sumList (digitsOfInt n)))\n  else 1 :: x;\n  sumList x;;\n"]}
{"fix": ["let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList x;\nend"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [0];;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) < 9\n  then (1 :: x; additivePersistence (sumList (digitsOfInt n)))\n  else (1 :: x; sumList [x]);;\n"]}
{"fix": ["listReverse \"nikhil\""], "hw": "hw1", "problem": "listReverse", "message": ["Error: This function has type string -> char list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = explode l listReverse \"nikhil\";;\n"]}
{"fix": ["let rec listReverse l = match l with \n|[] -> []\n|[h1] -> h1::[]\n|(h::t) -> h::(listReverse t)"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec listReverse l =\n  match l with | [] -> [] | h1 -> [h1] | h::t -> h :: (listReverse t);;\n"]}
{"fix": ["let rec listReverse l = match l with \n|[] -> []\n|[h1] -> h1::[]\n|(h::t) -> h::(listReverse t)"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec listReverse l =\n  match l with | [] -> [] | h1::[] -> [h1] | h::t -> t :: (listReverse t);;\n"]}
{"fix": ["let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> h::(listReverse t)"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) :: h;;\n"]}
{"fix": ["let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> listReverse t"], "hw": "hw1", "problem": "listReverse", "message": ["Error: Variable t is bound several times in this matching\n", "Error: Variable h is bound several times in this matching\n"], "bad": ["\nlet rec listReverse l = match l with | [] -> [] | (h::t)::t -> [];;\n", "\nlet rec listReverse l = match l with | [] -> [] | h::h::t -> [];;\n"]}
{"fix": ["let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> begin\n(listReverse t);\nh::[]\nend"], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value h\n", "Error: Unbound value h\n", "Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec listReverse l = match l with | [] -> [h] | h::t -> listReverse t;;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse t | _ -> [h];;\n", "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [listReverse t h];;\n", "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [(listReverse t) h];;\n"]}
{"fix": ["let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then\";\n(1::x);\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n(1::x);\nsumList x\nend"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This function has type string -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type unit but an expression was expected of type\n         int\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9\n  then\n    (print_string \"going into then\" print_newline ();\n     1\n     ::\n     x;\n     additivePersistence (sumList (digitsOfInt n)))\n  else (1 :: x; sumList x);;\n", "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9\n  then\n    ((print_string \"going into then\") / (print_newline ());\n     1\n     ::\n     x;\n     additivePersistence (sumList (digitsOfInt n)))\n  else (1 :: x; sumList x);;\n"]}
{"fix": [], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: Unbound value print_String\nHint: Did you mean print_string?\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9\n  then\n    (print_string \"going into then\";\n     1\n     ::\n     x;\n     additivePersistence (sumList (digitsOfInt n)))\n  else (print_String \"going into else\"; 1 :: x; sumList x);;\n"]}
{"fix": ["let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n(1::x);\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n(1::x);\nsumList x\nend"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: Unbound record field print\n", "Error: Unbound value List.print\n", "Error: Unbound value print_list\nHint: Did you mean print_int?\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9\n  then\n    (print_string \"going into then | \";\n     x.print;\n     1\n     ::\n     x;\n     additivePersistence (sumList (digitsOfInt n)))\n  else (print_string \"going into else | \"; 1 :: x; sumList x);;\n", "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9\n  then\n    (print_string \"going into then | \";\n     List.print x;\n     1\n     ::\n     x;\n     additivePersistence (sumList (digitsOfInt n)))\n  else (print_string \"going into else | \"; 1 :: x; sumList x);;\n", "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 9\n  then\n    (print_string \"going into then | \";\n     print_list x (1 :: x);\n     additivePersistence (sumList (digitsOfInt n)))\n  else (print_string \"going into else | \"; 1 :: x; sumList x);;\n"]}
{"fix": [], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  let x = x + 1 in\n  if (sumList (digitsOfInt n)) > 9\n  then\n    (print_string \"going into then | \";\n     additivePersistence (sumList (digitsOfInt n)))\n  else (print_string \"going into else | \"; sumList x);;\n", "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet x = [];;\n\nlet rec additivePersistence n =\n  let x = x + 1 in\n  if (sumList (digitsOfInt n)) > 9\n  then\n    (print_string \"going into then | \";\n     additivePersistence (sumList (digitsOfInt n)))\n  else (print_string \"going into else | \"; x);;\n"]}
{"fix": [], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else List.rev ((n mod 10) :: (List.rev (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet rec additivePersistence n =\n  let x = 1 in\n  if (sumList (digitsOfInt n)) > 9\n  then\n    (print_string \"going into then | \";\n     additivePersistence (sumList (digitsOfInt n)))\n  else (print_string \"going into else | \"; sumList x);;\n"]}
{"fix": ["let palindrome w = \nlet explosion = explode w in\nif (explosion = listReverse explosion) then true\nelse false"], "hw": "hw1", "problem": "palindrome", "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n"], "bad": ["\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = List.rev l;;\n\nlet palindrome w = if (explode w) = (listReverse w) then true else false;;\n"]}
{"fix": ["let additivePersistence n = n + 1"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: Unbound value count\n"], "bad": ["\nlet additivePersistence n = count;;\n"]}
{"fix": ["let additivePersistence n a = n + a"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: Unbound value b\n"], "bad": ["\nlet additivePersistence n a = (n + a) + b;;\n"]}
{"fix": ["let additivePersistence n a = \nif (sumList (digitsOfInt n) > 9)\nthen additivePersistence (sumList (digitsOfInt n)) (a + 1)\nelse 9"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type int but an expression was expected of type\n         unit\n"], "bad": ["\nlet rec listReverse l = List.rev l;;\n\nlet additivePersistence n a = n + a;;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else listReverse ((n mod 10) :: (listReverse (digitsOfInt (n / 10))));;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | h::t -> h + (sumList t) | _ -> (-1);;\n\nlet additivePersistence n a =\n  if (sumList (digitsOfInt n)) > 9\n  then additivePersistence (sumList (digitsOfInt n)) (a + 1);;\n"]}
{"fix": ["let listReverse l = myListReverse l []"], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value myListReverse\nHint: Did you mean mylistReverse?\n"], "bad": ["\nlet rec mylistReverse origList newList =\n  match origList with | [] -> [] | h::t -> (myListReverse t h) :: newList;;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) else (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: Unbound value mem\n", "Error: This function has type bool -> bool\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound record field mem\n", "Error: Unbound record field mem\n", "Error: This expression has type bool but an expression was expected of type\n         'a ref\n", "Error: This expression has type 'a -> 'a list -> bool\n       but an expression was expected of type 'b ref\n", "Error: This expression has type bool but an expression was expected of type\n         'a ref\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This expression has type 'a list\n       but an expression was expected of type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if mem h l then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not l.mem h then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not (l.mem h) then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if !(l.mem h) then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if !(List.mem h seen) then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (!List.mem) h seen then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if !(List.mem h seen) then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [2] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) else seen in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: This expression has type bool but an expression was expected of type\n         'a ref\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if !(List.mem h seen) then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (not (List.mem h seen)) then (h::seen) else seen in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: This expression has type 'a -> 'a list -> bool\n       but an expression was expected of type 'b ref\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (!List.mem) h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"], "bad": ["\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, b)), b);;\n", "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (((fixpoint f), b), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile (f,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (b, b);;\n"]}
{"fix": ["let fixpoint (f,b) = b"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (b, b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((f),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (f, (f b));;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((f ),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value a\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f a), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((f b),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"], "bad": ["\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, b)), b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\n", "Error: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\n", "Error: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\n", "Error: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\n", "Error: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\n", "Error: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type bool but an expression was expected of type\n         ('a -> 'a * bool) * 'a\n", "Error: This expression has type\n         ('a -> 'a * bool) * 'a -> ('a -> 'a * bool) * 'a\n       but an expression was expected of type\n         ('a -> 'a * bool) * 'a ->\n         ('a -> 'a * bool) * 'a -> (('a -> 'a * bool) * 'a) * bool\n       Type ('a -> 'a * bool) * 'a is not compatible with type\n         ('a -> 'a * bool) * 'a -> (('a -> 'a * bool) * 'a) * bool \nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type\n         ('a -> 'a * bool) * 'a -> ('a -> 'a * bool) * 'a\n       but an expression was expected of type\n         ('a -> 'a * bool) * 'a ->\n         ('a -> 'a * bool) * 'a -> (('a -> 'a * bool) * 'a) * bool\n       Type ('a -> 'a * bool) * 'a is not compatible with type\n         ('a -> 'a * bool) * 'a -> (('a -> 'a * bool) * 'a) * bool \n", "Error: This expression has type\n         ('a -> 'a * bool) * 'a -> ('a -> 'a * bool) * 'a\n       but an expression was expected of type\n         ('a -> 'a * bool) * 'a -> (('a -> 'a * bool) * 'a) * bool\n       Type ('a -> 'a * bool) * 'a is not compatible with type\n         (('a -> 'a * bool) * 'a) * bool \n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "Error: This expression has type unit but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type unit but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "Error: Unbound value a\n", "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"], "bad": ["\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile (if (not (f b)) = b then b else ((fixpoint ((f b), b)), b));;\n", "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile (if (not (f b)) = b then b else ((fixpoint (f, (f b))), b));;\n", "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile (if (not (f b)) = b then b else ((fixpoint (f, (f b))), b));;\n", "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (if (not (f b)) = b then b else fixpoint (f, b));;\n", "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile (if (not (f b)) = b then b else ((fixpoint (f, b)), b));;\n", "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile (if (not (f b)) = b then b else ((fixpoint (f, b)), b));;\n", "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (if (f b) = b then b else ((fixpoint (f, b)), b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (if (f b) = b then b else wwhile (f, (f b)));;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (if (f b) = b then (b, b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((if (f b) = b then b), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f (if (f b) = b then b)), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f (if (f b) = b then b else b)), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f (if (f b) = b then b else b)), a);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f (if (f b) = b then b else b)), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f (if (f b) = b then b else b)), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((failwith \"to be written\"), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f (if (f b) = b then 1 else 0)), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let h x = f x in ((x, (x = b)), b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> x), b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "exprToString", "message": ["Error: Unbound value sprintf\n", "Error: Unbound value sprintf\n", "Error: Unbound value printf\n", "Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: Unbound value sprintf\n", "Error: Unbound value printf\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> sprintf \"%s\" VarX;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> sprintf \"%s\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> printf \"%s\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX a -> sprintf \"%s\" a;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX a -> sprintf \"%s\" a;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | Sine s -> sprintf \"%s\" s;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | Sine s -> printf \"%s\" s;;\n"]}
{"fix": [], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type expr but an expression was expected of type\n         string\n", "Error: This expression has type expr but an expression was expected of type\n         string\n", "Error: invalid format \"%VarX\": at character number 1, invalid conversion \"%V\"\n", "Error: This variant expression is expected to have type\n         ('a, Format.formatter, unit) format\n       The constructor VarX does not belong to type CamlinternalFormatBasics.format6\n", "Error: Unbound value Format.print\nHint: Did you mean printf?\n", "Error: This expression has type expr but an expression was expected of type\n         float\n", "Error: This expression has type expr but an expression was expected of type\n         float\n", "Error: This expression has type expr but an expression was expected of type\n         float\n", "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "Error: This expression has type expr but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | Sine s -> Format.printf \"%s\" s;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Format.printf \"%s\" VarX;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Format.printf \"%VarX\" VarX;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Format.printf VarX;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Format.print VarX;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Format.printf \"%expr\" VarX;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Format.printf \"%float\" VarX;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Format.sprintf \"%float\" VarX;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | Sine s -> Format.sprintf \"%expr\" Sine;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | Sine s -> Format.sprintf \"%expr\" s;;\n"]}
{"fix": [], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type expr but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | Sine s -> Format.sprintf \"%expr\" s;;\n"]}
{"fix": ["let rec exprToString e = match e with\n| VarX -> \"x\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type expr but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Sine s -> Format.sprintf \"%d\" (sin (3.142 * e));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Sine s -> Format.sprintf \"%d\" (sin (3 * e));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Sine s -> Format.sprintf \"%d\" (sin (3 * 2));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Sine s -> Format.sprintf \"%d\" (sin (3.0 * 2.0));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Sine s -> Format.sprintf \"%d\" (sin (3 * 2.0));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Sine s -> Format.sprintf \"%d\" (sin (3 * 2));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Sine s -> Format.sprintf \"%i\" (sin (3 * 2));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Sine s -> Format.sprintf \"%i\" (sin (3.0 * 2.0));;\n"]}
{"fix": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.sprintf \"%expr\" 1.0 ^ \")\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type expr but an expression was expected of type\n         string\n", "Error: This expression has type expr but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ (s ^ \")\");;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.sprintf \"%expr\" s) ^ \")\");;\n"]}
{"fix": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ (exprToString s)  ^ \")\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: invalid format \"%_\": at character number 2, unexpected end of format\n", "Error: invalid format \"%\": at character number 1, unexpected end of format\n", "Error: invalid format \"%\": at character number 1, unexpected end of format\n", "Error: This expression has type expr but an expression was expected of type\n         float\n", "Error: This expression has type expr but an expression was expected of type\n         int\n", "Error: This expression has type expr but an expression was expected of type\n         float\n", "Error: This expression has type expr but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.sprintf \"%_\" s) ^ \")\");;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.sprintf \"%\" s) ^ \")\");;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.printf \"%\" s) ^ \")\");;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.printf \"%f\" s) ^ \")\");;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.printf \"%i\" s) ^ \")\");;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.printf \"%expr\" s) ^ \")\");;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine s -> \"sin(pi*\" ^ ((Format.printf \"%e\" s) ^ \")\");;\n"]}
{"fix": ["let mine = buildAverage(VarX, VarY)"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type float but an expression was expected of type\n         expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet mine = buildAverage (2.0, 4.0);;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x \n| VarY -> y\n| Average (a1,a2) -> buildAverage(a1,a2)"], "hw": "hw2", "problem": "build", "message": ["Error: The constructor Average expects 2 argument(s),\n       but is applied here to 0 argument(s)\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> let vx = x in vx\n  | VarY  -> let vy = y in vy\n  | Average  -> buildAverage (vx, vy);;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> buildAverage (a1, a2);;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> buildAverage (a1, a2);;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type expr but an expression was expected of type\n         float\n", "Error: This expression has type expr but an expression was expected of type\n         int\n", "Error: This expression has type expr but an expression was expected of type\n         float\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type expr but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> eval (VarX, a1, a2);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> a1 + a2;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> (eval (VarX, a1, a2)) + (eval (VarY, a1, a2));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> (eval (VarX, x, y)) + (eval (VarY, a1, a2));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Average (a1,a2) -> (eval (VarX, x, y)) +. (eval (VarY, a1, a2));;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval (s1,x,y))\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type expr but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Sine s1 -> sin s1\n  | Average (a1,a2) -> (eval (VarX, x, y)) +. (eval (VarY, x, y));;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval (s1,x,y))\n| Cosine (c1) -> cos (eval (c1,x,y))\n| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.(2.0)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet c1 () = failwith \"to be implemented\";;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Sine s1 -> sin (eval (s1, x, y))\n  | Cosine c1 -> cos (eval (c1, x, y))\n  | Average (a1,a2) -> ((eval (a1, x, y)) +. (eval (a2, x, y))) / 2.0;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet c1 () = failwith \"to be implemented\";;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x +. 0.0\n  | VarY  -> y +. 0.0\n  | Sine s1 -> sin (eval (s1, x, y))\n  | Cosine c1 -> cos (eval (c1, x, y))\n  | Average (a1,a2) -> ((eval (a1, x, y)) +. (eval (a2, x, y))) /. 2;;\n"]}
{"fix": ["build (makeRand (10,39), 4)"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value rand\nHint: Did you mean land?\n"], "bad": ["\nlet rec build (rand,depth) = rand (1, 4);;\n\nlet _ = build (rand, 4);;\n"]}
{"fix": ["let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildX()\n| 4 -> buildY()\n| 5 -> buildX()\n| 6 -> buildY()\n| 7 -> buildX()"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type int but an expression was expected of type\n         expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | 1 -> VarX\n  | 2 -> 22\n  | 3 -> 33\n  | 4 -> 44\n  | 5 -> 55\n  | 6 -> 66\n  | 7 -> 77;;\n"]}
{"fix": ["let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildSine(buildX())\n| 2 -> buildY()\n| 3 -> buildX()\n| 4 -> buildY()\n| 5 -> buildX()\n| 6 -> buildY()\n| 7 -> buildX()"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         unit\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | 1 -> buildX (buildY ())\n  | 2 -> buildY ()\n  | 3 -> buildX ()\n  | 4 -> buildY ()\n  | 5 -> buildX ()\n  | 6 -> buildY ()\n  | 7 -> buildX ();;\n"]}
{"fix": ["let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildTimes(buildCosine(buildSine(buildX())), buildCosine(buildSine(buildX())))\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine(build(rand, depth))\n| 4 -> buildCosine(build(rand, depth))\n| 5 -> buildAverage(build(rand, depth), build(rand, depth))\n| 6 -> buildTimes(build(rand, depth), build(rand, depth))\n| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))"], "hw": "hw2", "problem": "build", "message": ["Error: This variant expression is expected to have type expr\n       The constructor () does not belong to type expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | _ ->\n      buildTimes\n        ((buildCosine (buildSine (buildX ()))),\n          (buildCosine (buildSine (buildX ()))))\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 -> buildSine ()\n  | 4 -> buildSine (buildX ())\n  | 5 -> buildSine (buildX ())\n  | 6 -> buildSine (buildX ())\n  | 7 -> buildSine (buildX ());;\n"]}
{"fix": ["let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ( (if (depth = 0) then buildX() else build(rand, depth - 1)), (if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes(build(rand, depth), build(rand, depth))\n| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 ->\n      buildSine (if depth = 0 then buildX () else build (rand, (depth - 1)))\n  | 4 ->\n      buildCosine\n        (if depth = 0 then buildY () else build (rand, (depth - 1)))\n  | 5 ->\n      buildAverage\n        (if depth = 0\n         then buildX ()\n         else\n           ((build (rand, (depth - 1))),\n             (if depth = 0 then buildY () else build (rand, (depth - 1)))))\n  | 6 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n  | 7 ->\n      buildThresh\n        ((build (rand, depth)), (build (rand, depth)), (build (rand, depth)),\n          (build (rand, depth)));;\n"]}
{"fix": ["let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type\n         ('a -> 'b, Format.formatter, unit, unit, unit, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, Format.formatter, unit, unit, unit, unit)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type unit \n", "Error: This expression has type expr but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | _ -> Format.printf \"%f\" rand (1, 7)\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 ->\n      buildSine (if depth = 0 then buildX () else build (rand, (depth - 1)))\n  | 4 ->\n      buildCosine\n        (if depth = 0 then buildY () else build (rand, (depth - 1)))\n  | 5 ->\n      buildAverage\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 6 ->\n      buildTimes\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 7 ->\n      buildThresh\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))),\n          (if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | _ -> rand (1, 7)\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 ->\n      buildSine (if depth = 0 then buildX () else build (rand, (depth - 1)))\n  | 4 ->\n      buildCosine\n        (if depth = 0 then buildY () else build (rand, (depth - 1)))\n  | 5 ->\n      buildAverage\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 6 ->\n      buildTimes\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 7 ->\n      buildThresh\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))),\n          (if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))));;\n"]}
{"fix": ["let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildThresh(VarX,VarX,VarX,VarX)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand (1, 7) with\n  | _ -> buildTimes VarX\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 ->\n      buildSine (if depth = 0 then buildX () else build (rand, (depth - 1)))\n  | 4 ->\n      buildCosine\n        (if depth = 0 then buildY () else build (rand, (depth - 1)))\n  | 5 ->\n      buildAverage\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 6 ->\n      buildTimes\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))))\n  | 7 ->\n      buildThresh\n        ((if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))),\n          (if depth = 0 then buildX () else build (rand, (depth - 1))),\n          (if depth = 0 then buildY () else build (rand, (depth - 1))));;\n"]}
{"fix": ["let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 2) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (1, 5) with\n     | 1 -> buildSine ((build (rand, (depth - 1))) * (buildY ()))\n     | 2 -> buildCosine ((build (rand, (depth - 1))) * (buildX ()))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type int * bool\n       but an expression was expected of type 'a -> 'a * bool\n", "Error: Unbound value f\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet _ =\n  let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile ((f 3), 2);;\n", "\nlet _ = f 2;;\n"]}
{"fix": ["let fixpoint (f,b) = if (wwhile (f, b) = b) then b else (wwhile (f, f b))"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value f\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"], "bad": ["\nlet _ = f 2;;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f, b), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((f, b), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ( (let f x =  in f), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = if (wwhile (f, b)) = b then b else wwhile (f, (f b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (a,b) -> if not b then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = if (wwhile (f, b)) = b then b else wwhile (f, (f b));;\n"]}
{"fix": ["let fixpoint (f,b) = \nlet h x = let x = b in (x, x != f x)  in\nwwhile (h, b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  let f x = let x = b in (x, (x != (f x))) in wwhile (f, b);;\n"]}
{"fix": ["let fixpoint (f,b) = \nlet h x = (b, b != f b)  in\nwwhile (h, b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  let h x = let x = b in (x, (x != (f x))) in wwhile (h, b);;\n"]}
{"fix": ["let fixpoint (f,b) = \nlet h b = (b, b != f b)  in\nwwhile (h, b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) = let h x = (b, (b != (f b))) in wwhile (h, b);;\n", "\nlet fixpoint (f,b) = let h x = (b, (b != (f b))) in wwhile (h, b);;\n"]}
{"fix": ["let fixpoint (f,b) = \nlet f x = (x, x != f x)  in\nwwhile (h, b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) = let h b = (b, (b != (f b))) in wwhile (h, b);;\n"]}
{"fix": ["let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx != b)  in\nwwhile (f, b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) = let f x = (x, (x != (f x))) in wwhile (h, b);;\n", "\nlet fixpoint (f,b) = let f x = (x, (x != (f x))) in wwhile (f, b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx != b)) in wwhile (f, b);;\n", "\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx != b)) in wwhile (f, x);;\n", "\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx != b)) in wwhile (f, b);;\n", "\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx != x)) in wwhile (f, b);;\n", "\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx != x)) in wwhile (g, b);;\n", "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet fixpoint (f,b) =\n  let f x = let xx = f x in (xx, (xx != x)) in wwhile (f, b);;\n", "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet fixpoint (f,b) =\n  let a x = let xx = f x in (xx, (xx != x)) in wwhile (a, b);;\n"]}
{"fix": ["let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)"], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = (x *. x) in\nlet base = 0.0 in\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> float -> float\n", "Error: This expression has type float but an expression was expected of type\n         'a -> float -> float\n"], "bad": ["\nlet sqsum xs =\n  let f a x a x = x *. x in let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x a x = x *. x in let base = 0.0 in List.fold_left f base xs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base =  \"\" in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type string but an expression was expected of type\n         int\n"], "bad": ["\nlet pipe fs = let f a x = x + a in let base = \"\" in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x + 1 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value a'\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = a' in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base =  fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> 0 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value a\n", "Error: Unbound value x\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value a\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base x = a in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = (+) 0 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = (+) x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = (+) 0 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = (+) x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = (+) 0   in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = 0 (+) in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = (x a) a in\nlet base = (+) 0 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base = (+) 0 in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = (x a) a in\nlet base = (+) 0 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> 'c\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside 'a -> 'b -> 'c\n", "Error: This expression has type ('a -> 'a -> 'b) -> 'a -> 'b\n       but an expression was expected of type\n         ('a -> 'a -> 'b) -> 'a -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'a -> 'b\n"], "bad": ["\nlet pipe fs =\n  let f a x = (a x) a in let base = (+) 0 in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = (a x) x in let base = (+) 0 in List.fold_left f base fs;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (x^sep) ^ a in\nlet base = \"\" in\nlet l = [] in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type string but an expression was expected of type\n         string list\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (x ^ sep) ^ a in\n      let base = \"\" in let l = \"\" in List.fold_left f base l;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (h^sep) ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type string list\n       but an expression was expected of type string\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (h ^ sep) ^ t in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (h^sep) ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type string but an expression was expected of type\n         string list\n", "Error: Unbound value a\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (h ^ sep) ^ x in\n      let base = \"\" in let l = h in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (h ^ sep) ^ x in\n      let base = \"\" in let l = a in List.fold_left f base l;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (x^sep) ^ a in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: Unbound value s1\n", "Error: This expression has type string list\n       but an expression was expected of type string\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (x ^ sep) ^ a in\n      let base = \"\" in let l = s1 in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (x ^ sep) ^ a in\n      let base = \"\" in let l = h ^ t in List.fold_left f base l;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = 3 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type ('a -> 'a) list\n       The type variable 'a occurs inside 'a -> 'a\n", "Error: Unbound value List.head\n", "Error: This expression has type 'a list\n       but an expression was expected of type ('a -> 'a) list\n       The type variable 'a occurs inside 'a -> 'a\n"], "bad": ["\nlet pipe fs =\n  let f a x = x a in let base = List.hd fs in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = x a in let base = List.head fs in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = x a in let base = List.hd fs in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun y -> (+) y  in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n"], "bad": ["\nlet pipe fs =\n  let f a x = x a in let base y = (+) x in List.fold_left f base fs;;\n"]}
{"fix": [], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = x + 1 in List.fold_left f base fs;;\n"]}
{"fix": ["let rec clone x n = \nif n > 0 then clone (x) (n - 1) else []"], "hw": "hw3", "problem": "clone", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec clone x n = if n > 0 then clone [x] (n - 1) else [];;\n"]}
{"fix": ["let rec clone x n = \nlet acc = [] in\nif n > 0 then clone (x@acc) (n - 1) else []"], "hw": "hw3", "problem": "clone", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec clone x n =\n  let acc = [] in if n > 0 then clone (x :: acc) (n - 1) else [];;\n"]}
{"fix": ["let rec clone x n = \nlet acc = [x] in\nif n > 0 then clone (x) (n - 1) else []"], "hw": "hw3", "problem": "clone", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec clone x n =\n  let acc = [] in if n > 0 then clone (x :: x) (n - 1) else [];;\n"]}
{"fix": ["let rec clone x n = \nlet acc = [0] in\nif n > 0 then clone (x) (n - 1) else []"], "hw": "hw3", "problem": "clone", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec clone x n =\n  let acc = [x] in if n > 0 then clone (x :: acc) (n - 1) else [];;\n", "\nlet rec clone x n =\n  let acc = [0] in if n > 0 then clone (x :: acc) (n - 1) else [];;\n"]}
{"fix": ["let padZero l1 l2 = \nlet l1_len = List.length l1 in\nlet l2_len = List.length l2 in\nlet l_diff = l1_len - l2_len in\nlet to_append = clone 0 l_diff in\nif (l_diff < 0) then ((to_append @ l1), l2) else (l1, (to_append @ l2))"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n"], "bad": ["\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  let to_append = clone 0 l_diff in if l_diff < 0 then ((to_append @ l1), l2);;\n", "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  let to_append = clone 0 l_diff in if l_diff < 0 then ((to_append @ l1), l2);;\n"]}
{"fix": ["let padZero l1 l2 = \nlet l1_len = List.length l1 in\nlet l2_len = List.length l2 in\nlet l_diff = l1_len - l2_len in\nif (l_diff < 0) then ((clone 0 (l_diff * (-1)) @ l1), l2) else (l1, (clone 0 l_diff @ l2))"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then ((clone 0 ((l_diff * (-1)) @ l1)), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type int list\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type int list\n       Type 'a * 'b is not compatible with type int \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type int list\n       Type 'a * 'b is not compatible with type int \n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type float\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type float but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type int\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"], "bad": ["\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x + x) :: a in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x + x) :: a in\n    let base = ([], []) in\n    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x + x) :: a in\n    let base = [] in\n    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x + x) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x * x) + a in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x * x) + a in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x *. x) +. a in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x * x) + a in\n    let base = [0] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x * x) + a in\n    let base = 0 in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x *. x) +. a in\n    let base = 0. in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x * x) + a in\n    let base = ([], []) in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x * x) + a in\n    let base = 0 in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x * x) + a in\n    let base = ([], []) in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x * x) + a in\n    let base = ([], []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x * x) + a in\n    let base = 0 in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let x = List.hd l1 in ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value List.head\n"], "bad": ["\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let x = List.head l1 in ([x + 1], [x + 2]) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = let a = List.hd l1 in let b = List.hd l2 in ([a+1],[a+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let a = l1 in let b = l2 in ([a + 1], [a + 2]) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"], "bad": ["\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + 1], [x + 2]) in\n    let base = ([], []) in\n    let args = (l1, l2) in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type ('a * 'b) list\n       but an expression was expected of type int list\n       Type 'a * 'b is not compatible with type int \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int list * int list) list list\n       Type 'a * 'b is not compatible with type (int list * int list) list \n", "Error: This expression has type int list * int list\n       but an expression was expected of type int list list * 'a\n       Type int is not compatible with type int list \n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type int * int\n       Type 'a list is not compatible with type int \n"], "bad": ["\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + 1], [x + 2]) in\n    let base = ([], []) in\n    let args = [(l1, l2)] in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (a,b) = List.hd x in ([a + 1], [b + 2]) in\n    let base = ([], []) in\n    let args = [(l1, l2)] in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a,b) = List.hd x in ([(List.hd a) + 1], [(List.hd b) + 2]) in\n    let base = ([], []) in\n    let args = [(l1, l2)] in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([(List.hd x) + 1], [(List.hd x) + 2]) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a,b) = List.hd x in (((List.hd a) + 1), ((List.hd b) + 2)) in\n    let base = ([], []) in\n    let args = [(l1, l2)] in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+1])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int -> int -> int list * int list\n       but an expression was expected of type int -> int -> int\n       Type int list * int list is not compatible with type int \n"], "bad": ["\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + a], [x + a]) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+1])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int -> int -> int list * int list\n       but an expression was expected of type int -> int -> int\n       Type int list * int list is not compatible with type int \n", "Error: This expression has type 'a list -> 'a -> 'a list list * 'a list list\n       but an expression was expected of type 'a list -> 'a -> 'a list\n       Type 'a list list * 'a list list is not compatible with type 'a list \n"], "bad": ["\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + a], [x + a]) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x :: a], [x :: a]) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet y = List.hd l2 in\nlet (one,two) = a in (x::one,y::two)\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int list list\n       but an expression was expected of type int list\n       Type int list is not compatible with type int \n"], "bad": ["\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let y = l2 in let (one,two) = a in ((x :: one), (y :: two)) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet y = List.hd l2 in\n(let (one,two) = a in (x::one,y::two))\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n"], "bad": ["\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let y = List.hd l2 in\n      List.combine (let (one,two) = a in ((x :: one), (y :: two))) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let y = List.hd l2 in\n      List.split\n        (List.combine (let (one,two) = a in ((x :: one), (y :: two)))) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let y = List.hd l2 in\n      List.split (let (one,two) = a in ((x :: one), (y :: two))) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let y = List.hd l2 in\n      List.combine\n        (List.split (let (one,two) = a in ((x :: one), (y :: two)))) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> if ((fir + sec) < 10) then ([], (fir + sec)::b2)  else ([], (fir + sec)::b2)\nin\nlet base = ([],[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value base\n"], "bad": ["\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = base in\n      match x with\n      | (a,b) ->\n          if (a + b) < 10\n          then ([], ((a + b) :: b2))\n          else ([], ((a + b) :: b2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if (fir + sec) < 10\n          then ([], ((fir + sec) :: b2))\n          else (((fir + sec) / 10), (((fir + sec) mod 10) :: b2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec) < 10) \nthen (b1, (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if (fir + sec) < 10\n          then ([], ((fir + sec) :: b2))\n          else ((((fir + sec) / 10) + b1), (((fir + sec) mod 10) :: b2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if (fir + sec) < 10\n          then ([], ((fir + sec) :: b2))\n          else ((((fir + sec) / 10) + b1), (((fir + sec) mod 10) :: b2)) in\n    let base = (\"\", []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if (fir + sec) < 10\n          then ([], ((fir + sec) :: b2))\n          else ((((fir + sec) / 10) + b1), (((fir + sec) mod 10) :: b2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if (fir + sec) < 10\n          then ([], ((fir + sec) :: b2))\n          else ((((fir + sec) / 10) + b1), (((fir + sec) mod 10) :: b2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let rec mulByDigit i l = \nlet rec helper a b acc = \nif (a > 0) \nthen helper (a - 1) b (bigAdd b b)\nelse acc\nin\nhelper i l []"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if ((fir + sec) + b1) < 10\n          then\n            (if (List.length b2) >= ((List.length l1) - 1)\n             then (0, (b1 :: (((fir + sec) + b1) mod 10) :: b2))\n             else (0, (((fir + sec) + b1) :: b2)))\n          else\n            if (List.length b2) >= ((List.length l1) - 1)\n            then (0, (b1 :: (((fir + sec) + b1) mod 10) :: b2))\n            else\n              ((((fir + sec) + b1) / 10), ((((fir + sec) + b1) mod 10) ::\n                b2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper a b acc =\n    if a > 0 then helper (a - 1) b (bigAdd b b) else acc in\n  helper i l 0;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = (0,((mulByDigit x l2) @ (clone 0 ((List.length l1) - 1))))\nin\nlet base = (0, [0]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: Unbound value sec\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sec\n", "Error: This expression has type int list list\n       but an expression was expected of type int list\n       Type int list is not compatible with type int \nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list list\n       but an expression was expected of type int list\n       Type int list is not compatible with type int \n"], "bad": ["\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if ((fir + sec) + b1) < 10\n          then\n            (if (List.length b2) >= ((List.length l1) - 1)\n             then (0, ((((fir + sec) + b1) mod 10) :: b2))\n             else (0, (((fir + sec) + b1) :: b2)))\n          else\n            if (List.length b2) >= ((List.length l1) - 1)\n            then (0, (b1 :: (((fir + sec) + b1) mod 10) :: b2))\n            else\n              ((((fir + sec) + b1) / 10), ((((fir + sec) + b1) mod 10) ::\n                b2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet rec mulByDigit i l =\n  let rec helper a b acc =\n    if a > 0 then helper (a - 1) b (bigAdd b acc) else acc in\n  helper i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | h::t -> (0, ((mulByDigit h sec) @ (clone 0 ((List.length fir) - 1)))) in\n  let base = (0, [0]) in\n  let args = [l1; l2] in let (_,res) = List.fold_left f base args in res;;\n", "\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if ((fir + sec) + b1) < 10\n          then\n            (if (List.length b2) >= ((List.length l1) - 1)\n             then (0, ((((fir + sec) + b1) mod 10) :: b2))\n             else (0, (((fir + sec) + b1) :: b2)))\n          else\n            if (List.length b2) >= ((List.length l1) - 1)\n            then (0, (b1 :: (((fir + sec) + b1) mod 10) :: b2))\n            else\n              ((((fir + sec) + b1) / 10), ((((fir + sec) + b1) mod 10) ::\n                b2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet rec mulByDigit i l =\n  let rec helper a b acc =\n    if a > 0 then helper (a - 1) b (bigAdd b acc) else acc in\n  helper i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x = (0, ((mulByDigit x l2) @ (clone 0 ((List.length l1) - 1)))) in\n  let base = (0, [0]) in\n  let args = [l1; l2] in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int but an expression was expected of type\n         int * int -> int\n", "Error: Unbound value r\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  match rand with\n  | 0 ->\n      let halff = makeRand (0, 2) in\n      if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  match rand with\n  | 0 ->\n      let halff = r = (makeRand (0, 2)) in\n      if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand with\n  | 0 -> let halff = rand in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"]}
{"fix": ["let rec build (rand, depth) =\nmatch depth with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int but an expression was expected of type\n         int * int -> int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"]}
{"fix": ["let rec build (rand, depth) =\nlet rdm = rand in\nmatch rdm with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> Cosine(build(rand, depth-1)) \n| 3 -> Sine(build(rand,depth-1))\n| 4 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 5 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 7 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rdm = rand in\n  match rdm with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 ->\n      Thresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rdm = rand in\n  match rdm with\n  | 0 ->\n      let halff = rand (0, 2) in if halff = 0 then buildY () else buildX ()\n  | 1 ->\n      let halff = rand (0, 2) in\n      if halff = 0\n      then Cosine (build (rand, (depth - 1)))\n      else Sine (build (rand, (depth - 1)))\n  | 2 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 3 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 ->\n      Thresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"]}
{"fix": ["let rec build (rand, depth) =\nlet rdm = rand(0,7) in\nmatch rdm with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> Cosine(build(rand, depth-1)) \n| 3 -> Sine(build(rand,depth-1))\n| 4 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 5 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 6 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type 'a * 'b\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a * 'b\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand with\n  | (a,b) ->\n      let rdm = rand (0, 7) in\n      (match rdm with\n       | 0 -> buildY ()\n       | 1 -> buildX ()\n       | 2 -> Cosine (build (rand, (depth - 1)))\n       | 3 -> Sine (build (rand, (depth - 1)))\n       | 4 ->\n           Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           Thresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand with\n  | (a,b) ->\n      let rdm = rand (a, b) in\n      (match rdm with\n       | 0 -> buildY ()\n       | 1 -> buildX ()\n       | 2 -> Cosine (build (rand, (depth - 1)))\n       | 3 -> Sine (build (rand, (depth - 1)))\n       | 4 ->\n           Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 ->\n           Thresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"]}
{"fix": ["let b = build(r,5)"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type int but an expression was expected of type\n         int * int -> int\n"], "bad": ["\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet r = makeRand (0, 7);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rdm = rand (0, 7) in\n  match rdm with\n  | 0 -> buildY ()\n  | 1 -> buildX ()\n  | 2 -> Cosine (build (rand, (depth - 1)))\n  | 3 -> Sine (build (rand, (depth - 1)))\n  | 4 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      Thresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | _ -> build (rand, (depth - 1));;\n\nlet rnd = r (0, 8);;\n\nlet b = build (rnd, 5);;\n"]}
{"fix": [], "hw": "hw3", "problem": "stringOfList", "message": ["Error: Unbound value sepConcat\n"], "bad": ["\nlet stringOfList f l =\n  let newStr = sepConcat \"; \" (List.map f l) in \"[\" ^ (newStr ^ \"]\");;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ ((digitsOfInt n) / 10);;\n"]}
{"fix": ["let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t"], "hw": "hw1", "problem": "sumList", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) @ [(digitsOfInt n) / 10];;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) @ [(digitsOfInt n) / 10];;\n"]}
{"fix": [], "hw": "hw1", "problem": "sumList", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n = (n mod 10) @ [(digitsOfInt n) / 10];;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10; (digitsOfInt n) / 10];;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ [(digitsOfInt n) / 10];;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ [digitsOfInt (n / 10)];;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) @ [digitsOfInt (n / 10)];;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ [digitsOfInt (n / 10)];;\n"]}
{"fix": [], "hw": "hw1", "problem": "sumList", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [n mod 10] @ [digitsOfInt (n / 10)];;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [(digitsOfInt n) / 10; n mod 10];;\n"]}
{"fix": [], "hw": "hw1", "problem": "sumList", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else [digitsOfInt (n / 10); n mod 10];;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (let n10 = n / 10 in [digitsOfInt n10; n mod 10]);;\n"]}
{"fix": ["let rec digitsOfInt n =\nif n <= 0 then []\nelse let n2 = [n mod 10] @ digitsOfInt (n/10) in\nlistReverse n2"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (let n2 = [n mod 10] @ ((digitsOfInt n) / 10) in listReverse n2);;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) @ [digitsOfInt (n / 10)];;\n"]}
{"fix": ["let rec digitsOfInt n =\nif n <= 0 then []\nelse digitsOfInt (n/10) :: (n mod 10)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: ((digitsOfInt n) / 10);;\n"]}
{"fix": [], "hw": "hw1", "problem": "sumList", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list list\n", "Error: This expression has type int but an expression was expected of type\n         'a list list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else (let l = (digitsOfInt (n / 10)) :: (n mod 10) in listReverse l);;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let leading = (digitsOfInt (n / 10)) :: (n mod 10) in\n     listReverse leading);;\n", "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [listReverse t; h];;\n"]}
{"fix": [], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) :: h;;\n"]}
{"fix": ["let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t"], "hw": "hw1", "problem": "sumList", "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> t :: (listReverse h);;\n"]}
{"fix": [], "hw": "hw1", "problem": "sumList", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec listReverse l = match l with | [] -> [] | h::t -> [listReverse t; h];;\n"]}
{"fix": [], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec listReverse l = match l with | [] -> [] | h::t -> [listReverse t; h];;\n"]}
{"fix": ["let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t"], "hw": "hw1", "problem": "sumList", "message": ["Error: Unbound value i\n"], "bad": ["\nlet rec myAppend l n = match l with | [] -> [i] | h::t -> h :: (myAppend t i);;\n"]}
{"fix": ["let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t"], "hw": "hw1", "problem": "sumList", "message": ["Error: Unbound value rev\nHint: Did you mean ref?\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet _ =\n  let rec listReverse l =\n    match l with | [] -> [] | h::t -> rev = (listReverse t) in\n  [rev; h];;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> let rev = listReverse t in [rev; h];;\n"]}
{"fix": [], "hw": "hw1", "problem": "palindrome", "message": ["Error: This expression has type string but an expression was expected of type\n         char list\n"], "bad": ["\nlet rec helperAppend l n =\n  match l with | [] -> n | h::t -> h :: (helperAppend t n);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> helperAppend (listReverse t) [h];;\n\nlet palindrome w = (listReverse (explode w)) = w;;\n"]}
{"fix": ["let rec wwhile (f,b) = match (f b) with\n| (f', x') -> if x' then wwhile (f, f')\nelse f'"], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match b with | (f',b') -> if b' then wwhile (f, f') else f';;\n"]}
{"fix": ["let rec wwhile (f,b) = match f,b with\n| (f', bool1) -> if bool1 then wwhile (f, f')\nelse f'"], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value me\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match me b with | (f',bool1) -> if bool1 then wwhile (f, f') else f';;\n"]}
{"fix": ["let rec wwhile (f,b) = match f b with\n| (f', bool1) -> if bool1 then wwhile (f, f')\nelse f'"], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type int -> int * bool\n       but an expression was expected of type bool\n", "Error: This expression has type int -> int * bool\n       but an expression was expected of type bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match (f, b) with | (f',bool1) -> if bool1 then wwhile (f, f') else f';;\n\nlet _ = let me x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (me, 2);;\n", "\nlet rec wwhile (f,b) =\n  match (f, b) with | (f',bool1) -> if bool1 then wwhile (f, f') else f';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value x\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value x\n", "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"], "bad": ["\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((if ((f b) = b) && (f (f x)) then f b else fixpoint (f, (f b))), b);;\n", "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((if ((f b) = b) && (f (f b)) then f b else fixpoint (f, (f b))), b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"], "bad": ["\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((if ((f b) = b) && (f (f b)) then f b else fixpoint (f, (f b))), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((fun x -> let b = (f x) in (b, b != x)),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let helper = if (f b) = b then ((f b), true) else ((f b), false) in\n     (helper, b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let helper = if (f b) = b then ((f b), true) else ((f b), false) in\n     (helper, b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let helper = if (f b) = b then ((f b), true) else ((f b), false) in\n     (helper, b));;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((let helper b =\nif b = f b then (f b, false)\nelse (f b, true)\nin helper),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value f\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper b = if b = (f b) then ((f b), false) else ((f b), true) in\n      helper), b);;\n\nlet _ = fixpoint (f, 1);;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: This expression has type expr/2315\n       but an expression was expected of type expr/2519\nError: This expression has type expr/2573\n       but an expression was expected of type expr/2593\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type expr/2315\n       but an expression was expected of type expr/2519\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n"]}
{"fix": ["let rec build (rand, depth) = if depth = 0 then\nif rand(0,1) = 0 then buildX()\nelse buildY()\nelse match rand(0,6) with\n|0 -> build(rand,(depth - 1))\n|1 -> buildSine(build(rand,(depth - 1))) \n|2 -> buildCosine(build(rand, (depth - 1)))\n|3 -> buildAverage(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|4 -> buildTimes(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|5 -> buildThresh(build(rand, (depth - 1)),build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),build(rand, (depth - 1)))"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value buildMax\nHint: Did you mean build, buildY or buildX?\nError: Unbound value buildMax\nHint: Did you mean build, buildX or buildY?\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value buildMax\nHint: Did you mean build, buildY or buildX?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand (0, 1)) = 0 then buildX () else buildY ())\n  else\n    (match rand (0, 7) with\n     | 0 -> build (rand, (depth - 1))\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildMax ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildCubic\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 7 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"]}
{"fix": ["let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)"], "hw": "hw2", "problem": "assoc", "message": ["Error: This expression has type expr/2731\n       but an expression was expected of type expr/2799\nError: This expression has type expr/2843\n       but an expression was expected of type expr/2853\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type expr/2731\n       but an expression was expected of type expr/2799\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Divide of expr* expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Hello of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Hello1 of expr* expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Hello2 of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Hello1 (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e1) ^ \")\")))))))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Hello2 (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e4) ^ (\":\" ^ ((exprToString e3) ^ \")\")))))));;\n\nlet sampleExpr4 = Hello (VarX, VarY, (Cosine VarY));;\n\nlet _ = exprToString sampleExpr4;;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: Unbound value e1\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Fourth of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | ThreeTimes of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Fourth e -> (eval (e1, x, y)) /. 4.0\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | ThreeTimes (e1,e2,e3) ->\n      ((eval (e1, x, y)) *. (eval (e2, x, y))) *. (eval (e3, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value c\n", "Error: This expression has type int * 'a list\n       but an expression was expected of type int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + carry) / 10) :: ((h + c) mod 10) :: t\n      | _ -> [carry / 10; carry mod 10] in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n      | _ -> [carry / 10; carry mod 10] in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n      | _ -> [carry / 10; carry mod 10] in\n    let base = 0 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n      | _ -> [carry / 10; carry mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((o,sum),[]) -> (0, sum)\n      | ((o,sum),(b,c)::l') ->\n          let d = (b + c) + o in\n          if d < 10 then (0, (d :: sum)) else (1, ((d - 10) :: sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((o,sum),[]) -> (0, sum)\n      | ((o,sum),(b,c)::l') ->\n          let d = (b + c) + o in\n          if d < 10 then (0, (d :: sum)) else (1, ((d - 10) :: sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let carry = match a with (x,y) -> x in\nmatch x with (d1,d2) -> let new_carry = (carry + d1 + d2)/10 in\nlet digit = (carry + d1 + d2) mod 10 in\nmatch a with (x,y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type int\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          let new_carry = ((a + d1) + d2) / 10 in\n          let digit = ((a + d1) + d2) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (d1,d2) ->\n          let new_carry = ((a + d1) + d2) / 10 in\n          let digit = ((a + d1) + d2) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let c = match a with (pair,sum) -> pair in\nmatch x with (d1,d2) -> let c' = (c + d1 + d2)/10 in\nlet digit = (c + d1 + d2) mod 10 in\nmatch a with (pair,sum) -> (c', digit::sum) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n", "Error: Unbound value pair\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let c = match a with | (pair,sum) -> pair in\n      match a with\n      | ((d1,d2),sum) ->\n          let c' = ((c + d1) + d2) / 10 in\n          let sum = ((c + d1) + d2) mod 10 in\n          (match a with | (pair,sum) -> (c', (digit :: sum))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let c = match a with | (pair,sum) -> pair in\n      match pair with\n      | (d1,d2) ->\n          let c' = ((c + d1) + d2) / 10 in\n          let digit = ((c + d1) + d2) mod 10 in\n          (match a with | (pair,sum) -> (c', (digit :: sum))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let rec mulByDigit i l = \nif i = 1 then l\nelse if i = 0 then []\nelse if i < 0 then match (bigAdd (bigAdd l l) (mulByDigit ( (i*(-1)) -2) l)) with\n| h::t -> (h*(-1))::t\n| _ -> []\nelse bigAdd (bigAdd l l) (mulByDigit (i-2) l)"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,sum) ->\n          (match x with\n           | (d1,d2) ->\n               let c' = ((c + d1) + d2) / 10 in\n               let d' = ((c + d1) + d2) mod 10 in (c', (d' :: sum))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 1\n  then l\n  else\n    if i = 0\n    then []\n    else\n      if i < 0\n      then\n        (match bigAdd (bigAdd l l) (mulByDigit ((i * (-1)) - 2) l) with\n         | h::t -> (h * (-1)) :: t\n         | _ -> 0)\n      else bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = match a with\n(c,sum) -> (c + 1, bigAdd ((mulByDigit x l1) @ clone 0 c) sum) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type string\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a * 'b\n       but an expression was expected of type string\n"], "bad": ["\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,sum) ->\n          (match x with\n           | (d1,d2) ->\n               let c' = ((c + d1) + d2) / 10 in\n               let d' = ((c + d1) + d2) mod 10 in (c', (d' :: sum))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i = 1\n  then l\n  else\n    if i = 0\n    then []\n    else\n      if i < 0\n      then\n        (match bigAdd (bigAdd l l) (mulByDigit ((i * (-1)) - 2) l) with\n         | h::t -> (h * (-1)) :: t\n         | _ -> [])\n      else bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (c,sum) -> ((c + 1), (bigAdd ((mulByDigit x l1) @ (clone 0 c)) sum)) in\n  let base = failwith (0, []) in\n  let args = failwith l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let rec sumList xs =\nmatch xs with\n| []  -> 0\n| x::xs' ->x + sumList xs'"], "hw": "hw1", "problem": "sumList", "message": ["Error: Unbound value sum\n"], "bad": ["\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sum xs');;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n < 0 then []\nelse [1;2;3]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec digitsOfInt n = if n < 0 then 4;;\n", "\nlet rec digitsOfInt n = if n < 0 then [];;\n", "\nlet rec digitsOfInt n = if n < 0 then 0;;\n", "\nlet rec digitsOfInt n = if n < 0 then n;;\n", "\nlet rec digitsOfInt n = if n < 0 then [] else n;;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| _ -> loop n []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let innerFunc elem = Printf.printf \"Element is %d\\n\" elem in\n     List.iter innerFunc n);;\n", "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (let f elem = Printf.printf \"Element is %d\\n\" elem in List.iter f n);;\n", "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (let f elem = Printf.printf \"Element is %d\\n\" elem in List.iter f n);;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| _ -> loop n []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value listElem1\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop listElem1 listElem2 =\n       if listElem1 = 0\n       then listElem2\n       else loop (listElem1 / 10) ((listElem1 mod 10) :: listElem2) in\n     match listElem1 with | _ -> loop listElem1 []);;\n"]}
{"fix": ["let rec additivePersistence n = \nlet rec loop retVal = \nif retVal < 10 then retVal\nelse loop (sumList(digitsOfInt retVal )) in match n with \n| 0 -> 0\n| _ -> loop n"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: Unbound value x\n", "Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec additivePersistence n = if (n mod 10) != 0 then x = (x + 1);;\n", "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  let rec loop retVal =\n    if retVal < 10 then retVal else loop sumList (digitsOfInt retVal) in\n  match n with | 0 -> 0 | _ -> loop n;;\n"]}
{"fix": ["let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This function has type int ref -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  let rec addP = 0 in\n  let rec recursive_loop retVal =\n    if retVal < 10\n    then addP\n    else addP = (addP + (1 recursive_loop (sumList (digitsOfInt retVal)))) in\n  match n with | 0 -> 0 | _ -> recursive_loop n;;\n", "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  let addP = 0 in\n  let rec recursive_loop retVal =\n    if retVal < 10\n    then addP\n    else addP = (addP + (1 recursive_loop (sumList (digitsOfInt retVal)))) in\n  match n with | 0 -> 0 | _ -> recursive_loop n;;\n", "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  let addP = 0 in\n  let rec recursive_loop retVal =\n    if retVal < 10\n    then addP\n    else incr addP recursive_loop (sumList (digitsOfInt retVal)) in\n  match n with | 0 -> 0 | _ -> recursive_loop n;;\n"]}
{"fix": ["let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type bool but an expression was expected of type\n         int\n", "Error: Unbound value retVal\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ =\n  let rec additivePersistence n =\n    let addP = 0 in\n    let rec recursive_loop retVal =\n      if retVal < 10 then addP else addP = (addP + 1) in\n    recursive_loop (sumList (digitsOfInt retVal)) in\n  match n with | 0 -> 0 | _ -> recursive_loop n;;\n", "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ =\n  let rec additivePersistence n =\n    let addP = 0 in\n    let rec recursive_loop retVal = if retVal < 10 then addP else addP + 1 in\n    recursive_loop (sumList (digitsOfInt retVal)) in\n  match n with | 0 -> 0 | _ -> recursive_loop n;;\n", "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  let addP = 0 in\n  let rec recursive_loop retVal =\n    if retVal < 10\n    then addP\n    else addP + (1 recursive_loop (sumList (digitsOfInt retVal))) in\n  match n with | 0 -> 0 | _ -> recursive_loop n;;\n"]}
{"fix": ["let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal addP = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) addP in match n with\n| 0 -> 0\n| _ -> recursive_loop n addP"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int\n", "Error: This expression has type int -> int\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  let addP = 0 in\n  let rec recursive_loop retVal addP =\n    if retVal < 10\n    then addP\n    else\n      (let addP = addP + 1 in recursive_loop (sumList (digitsOfInt retVal))) in\n  match n with | 0 -> 0 | _ -> recursive_loop n;;\n", "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  let addP = 0 in\n  let rec recursive_loop retVal addP =\n    if retVal < 10\n    then addP\n    else\n      (let addP = addP + 1 in\n       recursive_loop (sumList (digitsOfInt retVal)) addP) in\n  match n with | 0 -> 0 | _ -> recursive_loop n;;\n"]}
{"fix": ["let palindrome w =\nw = listReverse w"], "hw": "hw1", "problem": "palindrome", "message": ["Error: Unbound value List.listReverse\n"], "bad": ["\nlet palindrome w = w = (List.listReverse w);;\n"]}
{"fix": ["let palindrome w =\nlet pk = explode w in\nlet reverse = listReverse (explode w) in\nif reverse = pk then true\nelse false"], "hw": "hw1", "problem": "palindrome", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type string\n", "Error: This expression has type string but an expression was expected of type\n         char list\n", "Error: This expression has type string but an expression was expected of type\n         char list\n"], "bad": ["\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec rev element =\n    function | [] -> element | h::t -> rev (h :: element) t in\n  rev [] l;;\n\nlet palindrome w =\n  let reverse = explode (listReverse w) in\n  if reverse = w then true else false;;\n", "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec rev element =\n    function | [] -> element | h::t -> rev (h :: element) t in\n  rev [] l;;\n\nlet palindrome w =\n  let reverse = listReverse (explode w) in\n  if reverse = w then true else false;;\n", "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec rev element =\n    function | [] -> element | h::t -> rev (h :: element) t in\n  rev [] l;;\n\nlet palindrome w =\n  let pk = explode w in\n  let reverse = listReverse (explode w) in\n  if reverse = w then true else false;;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = seen in\nif List.mem h seen' then h::seen \nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        if List.mem h l\n        then h :: seen'\n        else (let rest' = t in helper (seen', rest')) in\n  List.rev (helper ([], l));;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = l in\nif List.mem h l then h::seen' \nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        if List.mem h seen\n        then h :: seen'\n        else (let rest' = t in helper (seen', rest')) in\n  List.rev (helper ([], l));;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t ->\n(* Seen' should hold only the unique ones *)\nlet seen' =  \nif List.mem h seen = false then h::seen\nelse seen\nin\n(* If the head is NOT in hte list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then h :: seen in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"]}
{"fix": ["let rec wwhile (f,b) = match (f,b) with\n| (func, param) ->\nif param = true then func param \nelse param\n| _ -> b"], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value num\n", "Error: Unbound value num\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match (f, b) with\n  | (func,param) -> if param = true then func param else num\n  | _ -> 0;;\n", "\nlet rec wwhile (f,b) =\n  match (f, b) with\n  | (func,param) -> if param = true then func param else num\n  | _ -> b;;\n"]}
{"fix": ["let rec wwhile (f,b) = match (f,b) with\n| (func, param) ->\nif param = true then f param \nelse 0"], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type bool but an expression was expected of type\n         int\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match (f, b) with\n  | (func,param) -> if param = true then f param else 0\n  | _ -> b;;\n"]}
{"fix": ["let rec wwhile (f,b) = match b with\n| (e, boo) ->\nif boo = true then e"], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a * (('b -> 'c) * bool)\n       The type variable 'a occurs inside 'a * (('b -> 'c) * bool)\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'c * (('a -> 'b) * bool)\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b * ('a * bool)\n", "Error: This expression has type 'a but an expression was expected of type\n         'a * (('b -> 'c) * bool)\n       The type variable 'a occurs inside 'a * (('b -> 'c) * bool)\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match b with | (e,boo) -> if boo = true then e else wwhile f e;;\n", "\nlet rec wwhile (f,b) =\n  match b with | (e,boo) -> if boo = true then e else wwhile e b;;\n", "\nlet rec wwhile (f,b) =\n  match b with | (e,boo) -> if boo = true then e else wwhile b;;\n", "\nlet rec wwhile (f,b) =\n  match b with | (e,boo) -> if boo = true then e else wwhile f b;;\n"]}
{"fix": [], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type ('a -> 'b) * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b) * bool\n"], "bad": ["\nlet rec wwhile (f,b) = match b with | (e,boo) -> if boo = true then e b;;\n"]}
{"fix": ["let rec wwhile (f,b) = match b with\n| (express, boo) ->\nif boo = true then wwhile(express, b)\nelse express"], "hw": "hw2", "problem": "expr", "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match b with\n  | (express,boo) -> if boo = true then wwhile (f, express) else express;;\n"]}
{"fix": ["let rec wwhile (f,b) = \nlet ans = f b in\nmatch ans with\n| (num, boo) ->\nif boo = true then wwhile(f, num)\nelse num"], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type int but an expression was expected of type\n         (int -> int * bool) * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match b with\n  | (express,boo) -> if boo = true then wwhile (express, b) else express;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n"]}
{"fix": ["let fixpoint (f,b) = \nwwhile \n((let func p = \nlet cal = f p in \nif p == cal then (cal, false)\nelse (cal, true) in func\n),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value xx\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let ans = f b in\n  match ans with | (num,tf) -> if tf = true then wwhile (f, num) else num;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let func p =\n        let cal = f p in if p == cal then (cal, false) else (cal, true) in\n      xx), b);;\n"]}
{"fix": ["let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine sin  -> \"(sin(pi*\" ^ (exprToString sin) ^ \")\"  \n| Cosine cos -> \"(cos(pi*\" ^ (exprToString cos) ^ \")\"\n| Average (n1, n2) ->  \"( \" ^ (exprToString n1) ^ \"+\" ^ (exprToString n2) ^ \")/2\"\n| Times (t1, t2) -> \"(\" ^ (exprToString t1) ^ \"*\" ^ (exprToString t2) ^ \")\"\n| Thresh (th1, th2, th3, th4) -> \"bullshit\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine sin -> \"(sin(pi*\" ^ ((exprToString sin) ^ \")\")\n  | Cosine cos -> \"(cos(pi*\" ^ ((exprToString cos) ^ \")\")\n  | Average (n1,n2) ->\n      \"( \" ^ ((exprToString n1) ^ (\"+\" ^ ((exprToString n2) ^ \")/2\")))\n  | Times (t1,t2) ->\n      \"(\" ^ ((exprToString t1) ^ ((\"*\" (exprToString t2)) ^ \")\"))\n  | Thresh (th1,th2,th3,th4) -> \"bullshit\";;\n"]}
{"fix": [], "hw": "hw2", "problem": "expr", "message": ["Error: Unbound value tf\n"], "bad": ["\nlet rec wwhile (f,b) = if tf = true then wwhile (f, num) else num;;\n"]}
{"fix": ["let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value f\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let ans = f b in\n  match ans with | (num,tf) -> if tf = true then wwhile (f, num) else num;;\n\nlet _ = let (p,k) = f b in if k then wwhile (f, p) else p;;\n"]}
{"fix": [], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | DivAdd of expr* expr* expr* expr\n  | TriMult of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine sin -> \"sin(pi*\" ^ ((exprToString sin) ^ \")\")\n  | Cosine cos -> \"cos(pi*\" ^ ((exprToString cos) ^ \")\")\n  | Average (n1,n2) ->\n      \"((\" ^ ((exprToString n1) ^ (\"+\" ^ ((exprToString n2) ^ \")/2)\")))\n  | Times (t1,t2) -> (exprToString t1) ^ (\"*\" ^ (exprToString t2))\n  | Thresh (th1,th2,th3,th4) ->\n      \"(\" ^\n        ((exprToString th1) ^\n           (\"<\" ^\n              ((exprToString th2) ^\n                 (\"?\" ^\n                    ((exprToString th3) ^ (\":\" ^ ((exprToString th4) ^ \")\")))))))\n  | DivAdd (ds1,ds2,ds3,ds4) ->\n      \"((\" ^\n        ((exprToString ds1) ^\n           (\"+\" ^\n              ((exprToString ds2) ^\n                 (\") / (\" ^\n                    ((exprToString ds3) ^ (\"+\" ^ ((exprToString ds4) \"))\")))))))\n  | TriMult (tm1,tm2,tm3) ->\n      \"(\" ^\n        ((exprToString tm1) ^\n           (\"*\" ^ ((exprToString tm2) ^ ((\"*\" (exprToString tm3)) ^ \")\"))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | DivAdd of expr* expr* expr* expr\n  | TriMult of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine sin -> \"sin(pi*\" ^ ((exprToString sin) ^ \")\")\n  | Cosine cos -> \"cos(pi*\" ^ ((exprToString cos) ^ \")\")\n  | Average (n1,n2) ->\n      \"((\" ^ ((exprToString n1) ^ (\"+\" ^ ((exprToString n2) ^ \")/2)\")))\n  | Times (t1,t2) -> (exprToString t1) ^ (\"*\" ^ (exprToString t2))\n  | Thresh (th1,th2,th3,th4) ->\n      \"(\" ^\n        ((exprToString th1) ^\n           (\"<\" ^\n              ((exprToString th2) ^\n                 (\"?\" ^\n                    ((exprToString th3) ^ (\":\" ^ ((exprToString th4) ^ \")\")))))))\n  | DivAdd (ds1,ds2,ds3,ds4) ->\n      \"((\" ^\n        ((exprToString ds1) ^\n           (\"+\" ^\n              ((exprToString ds2) ^\n                 (\") / (\" ^\n                    ((exprToString ds3) ^ (\"+\" ^ ((exprToString ds4) \"))\")))))))\n  | TriMult (tm1,tm2,tm3) ->\n      \"(\" ^\n        ((exprToString tm1) ^\n           (\"*\" ^ ((exprToString tm2) ^ ((\"*\" (exprToString tm3)) ^ \")\"))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "expr", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | DivAdd of expr* expr* expr* expr\n  | TriMult of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine sin -> \"sin(pi*\" ^ ((exprToString sin) ^ \")\")\n  | Cosine cos -> \"cos(pi*\" ^ ((exprToString cos) ^ \")\")\n  | Average (n1,n2) ->\n      \"((\" ^ ((exprToString n1) ^ (\"+\" ^ ((exprToString n2) ^ \")/2)\")))\n  | Times (t1,t2) -> (exprToString t1) ^ (\"*\" ^ (exprToString t2))\n  | Thresh (th1,th2,th3,th4) ->\n      \"(\" ^\n        ((exprToString th1) ^\n           (\"<\" ^\n              ((exprToString th2) ^\n                 (\"?\" ^\n                    ((exprToString th3) ^ (\":\" ^ ((exprToString th4) ^ \")\")))))))\n  | DivAdd (ds1,ds2,ds3,ds4) ->\n      \"((\" ^\n        ((exprToString ds1) ^\n           (\"+\" ^\n              ((exprToString ds2) ^\n                 (\") / (\" ^\n                    ((exprToString ds3) ^ (\"+\" ^ ((exprToString ds4) ^ \"))\")))))))\n  | TriMult (tm1,tm2,tm3) ->\n      \"(\" ^\n        ((exprToString tm1) ^\n           (\"*\" ^ ((exprToString tm2) ^ ((\"*\" (exprToString tm3)) ^ \")\"))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a  in\nlet base = f  in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n", "Error: Unbound value a\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = f x a in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = f a in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a  in\nlet base =  3 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value a\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a  in\nlet base =  f 3 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = x 3 in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = 3  in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type int -> 'a\n       but an expression was expected of type ('a -> 'a) list\n", "Error: Unbound value x\n", "Error: Unbound value a\n", "Error: Unbound value base\n", "Error: Unbound value f\n", "Error: This expression has type 'a -> int\n       but an expression was expected of type 'a list\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = fs 3 in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x in let base = f (x a) in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = x in let base = f ((f a x) a) in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x in let base = f base in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = f x in let base = 3 in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = fs x in let base = 3 in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = f  in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n", "Error: Unbound value a\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = a in\nlet base = f  in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base = f in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value base\n", "Error: Unbound value a\n"], "bad": ["\nlet pipe fs =\n  match fs with\n  | [] -> base\n  | f::fs' -> let f a x = x a in let base = a in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = a in List.fold_left f base fs;;\n"]}
{"fix": [], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type (int -> 'a) -> 'a\n       but an expression was expected of type int\n", "Error: Unbound value a\n", "Error: Unbound value x\n", "Error: This expression has type 'a -> ('a -> 'b) -> 'b\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type ('a list -> 'a list) list\n       The type variable 'a occurs inside 'a list -> 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type ('a list -> 'a list) list\n       The type variable 'a occurs inside 'a list -> 'a list\n"], "bad": ["\nlet pipe fs =\n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = f 0 in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = f a in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = f x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = f in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = fs' in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = fs' in List.fold_left f base fs;;\n"]}
{"fix": [], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n", "Error: Unbound value a\n"], "bad": ["\nlet pipe fs = let f a x = 0 in let base = x a in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = 0 in let base = a in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs =\nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n", "Error: Unbound value a\n"], "bad": ["\nlet pipe fs =\n  let f a x = x a in let base = f (x, a) in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = f a in List.fold_left f base fs;;\n"]}
{"fix": [], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n"], "bad": ["\nlet pipe fs =\n  let f a x = x a in let base = f (x a) in List.fold_left f base fs;;\n"]}
{"fix": ["let stringOfList f l = \nList.map sepConcat l"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat f l) l;;\n"]}
{"fix": ["let stringOfList f l = \nList.map ( sepConcat (f l) ) l"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n", "Error: This expression has type string but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map ((sepConcat \"\") l) l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f ((sepConcat \"\") l);;\n"]}
{"fix": ["let stringOfList f l = \nList.map (sepConcat f) l"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat f) (f l);;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat f) (f l);;\n"]}
{"fix": ["let stringOfList f l = \nList.map (sepConcat f) l"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n", "Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat (\"\" l)) l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"\" l) l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat f l) l;;\n"]}
{"fix": ["let stringOfList f l = \n\"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\""], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type 'a -> 'b\n       but an expression was expected of type string\n", "Error: This expression has type string list -> string\n       but an expression was expected of type 'a list\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a list -> 'b list\n       but an expression was expected of type string\n", "Error: This expression has type string list -> string\n       but an expression was expected of type string\n", "Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f (sepConcat f l);;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f (sepConcat l);;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = (sepConcat \"\" l) List.map (f l);;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat List.map (f l) l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (List.map (f l)) l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\") ^ ((List.map (f l)) ^ \"]\"));;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" List.map (f l)) ^ \"]\");;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" List.map (f l)) ^ \"]\");;\n"]}
{"fix": ["let rec clone x n = match n with \n| 0 -> []\n| n -> x@clone x (n-1)"], "hw": "hw3", "problem": "clone", "message": ["Error: This expression has type int -> 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside int -> 'a list\n"], "bad": ["\nlet rec clone x n = match n with | 0 -> [] | _ -> [clone x];;\n"]}
{"fix": [], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n"], "bad": ["\nlet padZero l1 l2 = if (List.length l1) = (List.length l2) then (l1, l2);;\n"]}
{"fix": [], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type unit\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n"], "bad": ["\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2) then List.combine (l1, l2);;\n", "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2) then List.combine l1 l2;;\n", "\nlet padZero l1 l2 = if (List.length l1) = (List.length l2) then l1 l2;;\n", "\nlet padZero l1 l2 = if (List.length l1) = (List.length l2) then (l1, l2);;\n"]}
{"fix": [], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n"], "bad": ["\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2) then (l1, l2) else (l1, l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then padZero (0 :: (l1 l2));;\n", "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2) then (l1, l2) else (l1, l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then padZero ((0 :: l1) l2);;\n", "\nlet rec padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then padZero ((0 :: l1) l2);;\n", "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then 0 :: l1;;\n", "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then ((0 :: l1), l2);;\n"]}
{"fix": ["let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then (l1, l2)\nelse (l1, l2)"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n"], "bad": ["\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then ((0 :: l1), l2);;\n", "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then ((List.append [0] l1), l2);;\n", "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then (l1, l2);;\n"]}
{"fix": ["let padZero l1 l2 = \nif List.length l1 > List.length l2 then (l1, 0::l2)\nelse if List.length l1 < List.length l2 then (0::l1, l2)\nelse (l1, l2)"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         'a list list\n"], "bad": ["\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then ((0 :: l1), (0 :: l2))\n    else ([l1], [l2]);;\n", "\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (l2 :: 0))\n  else\n    if (List.length l1) < (List.length l2) then ((0 :: l1), l2) else (l1, l2);;\n"]}
{"fix": ["let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \n(* L1 is greater, so append 0's to l2 *)\n(l1, List.append (clone 0 l1G) l2) \nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l1 in \n(List.append (clone 0 l2G) l1, l2)\nelse (l1, l2)"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type\n         int -> (int list * int list) list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then clone (l1, (0 :: l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then clone ((0 :: l1), l2)\n    else (l1, l2);;\n", "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    List.append (l1, (clone (l1, l2)))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l2) in\n       List.append ((clone (l1 l2G)), l2))\n    else (l1, l2);;\n", "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    List.append (l1, (clone (0, l1G)))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l2) in\n       List.append ((clone (0 l2G)), l2))\n    else (l1, l2);;\n", "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    List.append (l1, (clone (0 l1G)))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l2) in\n       List.append ((clone (0 l2G)), l2))\n    else (l1, l2);;\n", "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    List.append (l1 clone (0 l1G))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l2) in\n       List.append (clone (0 l2G) l2))\n    else (l1, l2);;\n", "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    List.append (l1, (clone (0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       List.append (clone (0 l2G) l1) l2)\n    else (l1, l2);;\n", "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    List.append (l1, ((clone 0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       List.append (((clone 0 l2G) l1), l2))\n    else (l1, l2);;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x in\nlet (carry, rest) = a in \nlet total = n1 + n2 + carry in\n(total/10, (total mod 10)::rest) in\nlet base = (0, []) in\nlet args = List.rev (List.combine(0::l1) ( 0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value sum\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    (l1, (List.append (clone 0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       ((List.append (clone 0 l2G) l1), l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (carry,rest) = a in\n      let total = (n1 + n2) + carry in ((total / 10), ((sum mod 10) :: rest)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine ((0 :: l1), (0 :: l2))) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    (l1, (List.append (clone 0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       ((List.append (clone 0 l2G) l1), l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (carry,rest) = a in\n      let total = (n1 + n2) + carry in\n      ((total / 10), ((total mod 10) :: rest)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine ((0 :: l1), (0 :: l2))) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10)::(mulByDigit i t))\nelse prod::t"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: ((prod / 10) + (mulByDigit i t))\n      else prod :: t;;\n", "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: ((prod / 10) + (mulByDigit i t)) :: t\n      else prod :: t;;\n", "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10 then (prod mod 10) :: (prod / 10) else prod :: t;;\n"]}
{"fix": ["let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)::(mulByDigit i t) )\nelse (prod mod 10)::t"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then [prod mod 10; (prod / 10) :: (mulByDigit i t)]\n      else prod :: t;;\n", "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: ((prod / 10) + (mulByDigit i t)) :: t\n      else prod :: t;;\n", "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: ((prod / 10) + (mulByDigit i t))\n      else prod :: t;;\n", "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then [prod mod 10; (prod / 10) + (mulByDigit i t)]\n      else prod :: t;;\n", "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: ((prod / 10) + (mulByDigit i t))\n      else prod :: t;;\n", "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: ((prod / 10) + (mulByDigit i t))\n      else prod :: t;;\n", "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: ((prod / 10) + (mulByDigit i t))\n      else (prod mod 10) :: t;;\n"]}
{"fix": [], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int list list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then ((prod mod 10) :: ((prod / 10) + (mulByDigit i t))) :: t\n      else (prod mod 10) :: t;;\n", "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: ((prod / 10) + [mulByDigit i t])\n      else (prod mod 10) :: t;;\n", "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: [prod / 10] :: (mulByDigit i t)\n      else (prod mod 10) :: t;;\n"]}
{"fix": ["let rec mulByDigit i l = \nlet mult i l = \nlet f a x = \nlet (carryOver, rest) = a in\nlet num = carryOver + (x * i) in\nlet secondDigit = num mod 10 in\nlet carryOver = num / 10 in\nlet result = secondDigit::rest in (carryOver, rest) in\nlet base = (0, []) in\nlet (carryOver, rest) = List.fold_left f base (List.rev l) in\ncarryOver::rest in\nremoveZero(mult i l)"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      let lastDigit = prod / 10 in\n      let firstDigit = prod mod 10 in\n      if prod > 10\n      then [lastDigit; firstDigit + (mulByDigit (i t))]\n      else firstDigit :: t;;\n", "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      let lastDigit = prod / 10 in\n      let firstDigit = prod mod 10 in\n      let ret = mulByDigit (i t) in\n      (match ret with\n       | [] -> 0\n       | h2::t2 ->\n           if h2 > 10\n           then\n             let temp = h2 in\n             (if prod > 10\n              then [lastDigit; firstDigit + temp]\n              else firstDigit :: t));;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in\nlet base = [] in\nlet args = List.rev l2 in\nList.fold_left f base args"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int list\n       This is not a function; it cannot be applied.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: Unbound value mulByDigitx\nHint: Did you mean mulByDigit?\nError: Unbound value mulByDigitx\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value mulByDigitx\nHint: Did you mean mulByDigit?\n", "Error: This expression has type int list list\n       but an expression was expected of type 'a * 'b\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list list\n       but an expression was expected of type 'a * 'b\n"], "bad": ["\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    (l1, (List.append (clone 0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       ((List.append (clone 0 l2G) l1), l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (carry,rest) = a in\n      let total = (n1 + n2) + carry in\n      ((total / 10), ((total mod 10) :: rest)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let rec helper acc mult =\n    match mult with | 0 -> acc | _ -> helper (bigAdd acc l) (mult - 1) in\n  helper [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    List.append (((mulByDigit x l1) (clone 0 (List.length a))) :: a) in\n  let base = [] in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet bigMul l1 l2 =\n  let f a x = ((mulByDigitx l1) @ (clone 0 (List.length a))) :: a in\n  let base = [] in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    (l1, (List.append (clone 0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       ((List.append (clone 0 l2G) l1), l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (carry,rest) = a in\n      let total = (n1 + n2) + carry in\n      ((total / 10), ((total mod 10) :: rest)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let rec helper acc mult =\n    match mult with | 0 -> acc | _ -> helper (bigAdd acc l) (mult - 1) in\n  helper [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x = ((mulByDigit x l1) @ (clone 0 (List.length a))) :: a in\n  let base = [] in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let rec sumList xs = \nlet x :: t = xs in\nx + sumList (t)"], "hw": "hw1", "problem": "sumList", "message": ["Error: Unbound value hd\n", "Error: Unbound record field length\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b array\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b array\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type int but an expression was expected of type\n         unit\n"], "bad": ["\nlet rec sumList xs = (xs.(0)) + (hd xs);;\n", "\nlet rec sumList xs = if xs.length != 0 then (xs.(0)) + (sumList (hd xs));;\n", "\nlet rec sumList xs =\n  if (List.length xs) != 0 then (xs.(0)) + (sumList (hd xs));;\n", "\nlet rec sumList xs =\n  if (List.length xs) != 0 then (xs.(0)) + (sumList (List.hd xs));;\n", "\nlet rec sumList xs =\n  if (List.length xs) != 0 then (List.nth xs 0) + (sumList (List.hd xs));;\n", "\nlet rec sumList xs =\n  if (List.length xs) != 0 then (List.nth xs 0) + (sumList (List.tl xs));;\n", "\nlet rec sumList xs =\n  if (List.length xs) != 0 then (List.nth xs 0) + (sumList (List.tl xs));;\n"]}
{"fix": ["let rec sumList xs = \nlet x :: t = xs in\nx + if t = [] then 0 else sumList (t)"], "hw": "hw1", "problem": "sumList", "message": ["Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type unit but an expression was expected of type\n         int\n"], "bad": ["\nlet rec sumList xs = let x::t = xs in if t != [] then x + (sumList t);;\n", "\nlet rec sumList xs = let x::t = xs in if x != [] then x + (sumList t);;\n", "\nlet rec sumList xs = let x::t = xs in x + (if t != [] then sumList t);;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n = (n mod 10) :: (if n <> [] then digitsOfInt (n / 10));;\n"]}
{"fix": ["let rec digitsOfInt n = \nlet int list digInt = n mod 10 in\nif n > 0 then digitsOfInt (n / 10)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value digInt\n", "Error: Unbound value digInt\n"], "bad": ["\nlet rec digitsOfInt n =\n  let int list digInt = n mod 10 in\n  if n > 0 then digitsOfInt (n / 10) else digInt;;\n", "\nlet rec digitsOfInt n =\n  let int list digInt = n mod 10 in\n  if n > 0 then digitsOfInt (n / 10) else digInt;;\n"]}
{"fix": ["let rec digitsOfInt n = \nlet list digInt = n mod 10 :: digInt in\nif (n / 10) <> 0 then digitsOfInt ( n / 10)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value digInt\n", "Error: Unbound value int\n", "Error: Unbound value digInt\n"], "bad": ["\nlet rec digitsOfInt n = digInt = ((n mod 10) :: (digitsOfInt (n / 10)));;\n", "\nlet rec digitsOfInt n =\n  (int list digInt) = ((n mod 10) :: (digitsOfInt (n / 10)));;\n", "\nlet rec digitsOfInt n = digInt = ((n mod 10) :: (digitsOfInt (n / 10)));;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"], "bad": ["\nlet rec digitsOfInt n =\n  let int list digInt = (n mod 10) :: digInt in\n  if (n / 10) <> 0 then digInt :: (digitsOfInt (n / 10));;\n", "\nlet rec digitsOfInt n =\n  let int list digInt = [] in\n  if (n / 10) <> 0 then digInt :: (digitsOfInt (n / 10));;\n"]}
{"fix": ["let rec digitsOfInt n =\nmatch n / 10 with\n| 0  -> n mod 10 ::[]\n| _  -> n mod 10 :: digitsOfInt( n / 10)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list list\n       but an expression was expected of type int list\n       Type 'a list is not compatible with type int \n"], "bad": ["\nlet rec digitsOfInt n =\n  let digInt = [] in\n  if (n / 10) <> 0 then digInt :: (digitsOfInt (n / 10)) else [];;\n\nlet digitsOfInt n =\n  let l = [] in\n  match n / 10 with\n  | 0 -> []\n  | _ -> l :: (n mod 10) :: (digitsOfInt (n / 10));;\n", "\nlet rec digitsOfInt n =\n  let digInt = [] in\n  if (n / 10) <> 0 then digInt :: (digitsOfInt (n / 10)) else [];;\n\nlet l = [];;\n\nlet digitsOfInt n =\n  match n / 10 with\n  | 0 -> []\n  | _ -> l :: (n mod 10) :: (digitsOfInt (n / 10));;\n", "\nlet rec digitsOfInt n =\n  let digInt = [] in\n  if (n / 10) <> 0 then digInt :: (digitsOfInt (n / 10)) else [];;\n\nlet l = [];;\n\nlet digitsOfInt n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> l :: (n mod 10) :: (digitsOfInt (n / 10));;\n", "\nlet rec digitsOfInt n =\n  let digInt = [] in\n  if (n / 10) <> 0 then digInt :: (digitsOfInt (n / 10)) else [];;\n\nlet digitsOfInt n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsOfInt (n / 10));;\n"]}
{"fix": ["let rec listReverse l = \nmatch l with \n| []   -> []\n| x::l -> x :: listReverse(l)"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec listReverse l =\n  match l with | [] -> [] | x::l -> (listReverse l) :: x;;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | x::l -> x :: (listReverse l x);;\n"]}
{"fix": ["let rec listReverse l = \nlet h::t = l in\nmatch l with \n| []   -> []\n| h::t -> listReverse t"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) :: h;;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) :: h;;\n", "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [listReverse t; h];;\n"]}
{"fix": [], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value x\n", "Error: Unbound value x\n", "Error: Unbound value x\n", "Error: Unbound value h\n"], "bad": ["\nlet rec listReverse l =\n  match l with | [] -> x | h::t -> (h :: x; listReverse t);;\n", "\nlet rec listReverse l =\n  let h::t = l in\n  let x = h :: x in match l with | [] -> x | h::t -> listReverse t;;\n", "\nlet rec listReverse l =\n  let h::t = l in\n  let x = h :: x in match t with | [] -> x | h::t -> listReverse t;;\n", "\nlet rec listReverse l = if l <> [] then (h :: t) = l;;\n"]}
{"fix": ["let rec sumList xs =\nmatch xs with\n| [] -> 0\n| h::t -> h + sumList(t)"], "hw": "hw1", "problem": "sumList", "message": ["Error: Unbound value x\n"], "bad": ["\nlet rec sumList xs = match xs with | [] -> x + 0 | h::t -> x + (sumList t);;\n"]}
{"fix": ["let rec listReverse l = \nmatch l with\n| [] -> []\n| h::t -> (listReverse t)"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) :: h;;\n"]}
{"fix": ["let rec listReverse2 l dest = \nmatch l with\n| [] -> []\n| h::t -> listReverse2 t (h::dest)"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type unit\n"], "bad": ["\nlet rec listReverse l =\n  if l <> [] then match l with | [] -> l | h::t -> (listReverse t) :: h;;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: Unbound value t\n"], "bad": ["\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n = digitalRoot (sumList t);;\n"]}
{"fix": ["let rec digitalRoot n = digitalRoot(sumList(digits(n)))"], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n = digitalRoot (sumList n);;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: Unbound value digitalRoot\n", "Error: Unbound value n\n", "Error: Unbound value sumList\n", "Error: Unbound value sumList\n", "Error: Unbound value sumList\n", "Error: Unbound value digits\n", "Error: Unbound value digits\n", "Error: Unbound value digits\n", "Error: Unbound value digitalRoot\n", "Error: Unbound value digitalRoot\n"], "bad": ["\nlet _ = digitalRoot 9876;;\n", "\nlet rec digitalRoot2 num total =\n  total +\n    (if (n mod 10) <> 0 then digitalRoot2 (sumList (digits num)) else 0);;\n", "\nlet rec digitalRoot2 num total =\n  total +\n    (if (num mod 10) <> 0 then digitalRoot2 (sumList (digits num)) else 0);;\n", "\nlet rec digitalRoot2 num total =\n  total +\n    (if (num mod 10) <> 0\n     then digitalRoot2 (sumList (digits num) total)\n     else 0);;\n", "\nlet rec digitalRoot2 num total =\n  total +\n    (if (num mod 10) <> 0\n     then digitalRoot2 ((sumList (digits num)) total)\n     else 0);;\n", "\nlet rec digitalRoot2 num total =\n  let l = digits num in\n  let s = sumList l in\n  total + (if (s mod 10) <> 0 then digitalRoot2 s else 0);;\n", "\nlet rec digitalRoot2 num total =\n  let l = digits num in\n  let s = sumList l in\n  let total = total + s in\n  if (s mod 10) <> 0 then digitalRoot2 s total else 0;;\n", "\nlet rec digitalRoot2 num total =\n  let l = digits num in\n  let s = sumList l in\n  let total = total + s in\n  if (s mod 10) <> 0 then digitalRoot2 s total else total;;\n", "\nlet _ = digitalRoot 9876;;\n", "\nlet _ = digitalRoot 9876;;\n"]}
{"fix": [], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: Unbound value digitalRoot\n", "Error: Unbound value additivePersistence\n"], "bad": ["\nlet _ = digitalRoot 65536;;\n", "\nlet _ = additivePersistence 9876;;\n"]}
{"fix": [], "hw": "hw1", "problem": "sumList", "message": ["Error: Unbound value digits\n"], "bad": ["\nlet additivePersistence n =\n  let l = digits n in\n  let s = sumList l in\n  let p = p + 1 in if (s / 10) <> 0 then additivePersistence s else p;;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value digits\n", "Error: Unbound value listReverse\n"], "bad": ["\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n c =\n  let l = digits n in\n  let s = sumList l in\n  if (s / 10) <> 0 then (additivePersistence s c) + 1 else c;;\n", "\nlet digitsOfInt n = listReverse (digitsToList n);;\n"]}
{"fix": ["let digitsOfInt n = listReverse (digitsToList n)"], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value digitsOfInt\n"], "bad": ["\nlet rec digitsToList n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsOfInt (n / 10));;\n"]}
{"fix": ["let listReverse l = listReverse2 l []"], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value listReverse\n", "Error: Unbound value listReverse2\n"], "bad": ["\nlet rec digitsToList n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsToList (n / 10));;\n\nlet digitsOfInt n = listReverse (digitsToList n);;\n", "\nlet listReverse l = listReverse2 l [];;\n"]}
{"fix": ["let rec additivePersistence2 n c =\nlet l = digits(n) in\nlet s = sumList(l) in\nif s / 10 <> 0 then additivePersistence2 s c+1 else c+1"], "hw": "hw1", "problem": "additivePersistence", "message": ["NO ERROR FROM MINIMAL PROGRAM!!!\nError: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec listReverse2 l dest =\n  match l with | [] -> dest | h::t -> listReverse2 t (h :: dest);;\n\nlet rec digitsToList n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsToList (n / 10));;\n\nlet listReverse l = listReverse2 l [];;\n\nlet digitsOfInt n = listReverse (digitsToList n);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n c =\n  let l = digits n in\n  let s = sumList l in\n  if (s / 10) <> 0 then (additivePersistence s c) + 1 else c;;\n\nlet additivePersistence n = additivePersistence n 0;;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: Unbound value seen'\nHint: Did you mean seen?\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen' then seen' else h :: seen' in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile (f ,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (((f b) <> b), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile (f b ,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ( f, b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "Error: This expression has type ('a -> 'a * bool) * 'a\n       but an expression was expected of type 'a -> 'a * bool\n", "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "Error: This expression has type ('a -> 'a -> 'a * bool) * 'a -> 'a\n       but an expression was expected of type\n         ('a -> 'a -> 'a * bool) * 'a ->\n         (('a -> 'a -> 'a * bool) * 'a) * bool\n       The type variable 'a occurs inside\n       (('a -> 'a -> 'a * bool) * 'a) * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type ('a -> 'a -> 'a * bool) * 'a -> 'a\n       but an expression was expected of type\n         ('a -> 'a -> 'a * bool) * 'a ->\n         (('a -> 'a -> 'a * bool) * 'a) * bool\n       The type variable 'a occurs inside\n       (('a -> 'a -> 'a * bool) * 'a) * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((wwhile (f, b)), b);;\n", "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((wwhile (f, b)), b);;\n", "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (if (f b) = b then b else ((f b), b));;\n", "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, b)), b);;\n", "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (fixpoint, b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ( let b' = f b in if b' = b then f b else f b')"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "Error: This expression has type ('a -> 'a * bool) * 'a\n       but an expression was expected of type 'a -> 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile (let b' = f b in if b' = b then f b else ((f b'), b));;\n"]}
{"fix": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(expr) -> \"sin(pi*\"^exprToString(expr)^\")\"\n| Cosine(expr) -> \"cos(pi\"^ exprToString(expr)^\")\"\n| Average(expr, expr2) -> \"((\"^exprToString(expr)^\"+\"^exprToString(expr2)^\"/2)\"\n| Times(expr, expr2) -> exprToString(expr)^\"*\"^exprToString(expr2)\n| Thresh(expr, expr2, expr3, expr4) -> \"(\"^exprToString(expr)^\"<\"^exprToString(expr2)^\"?\"^exprToString(expr3)^\":\"^exprToString(expr4)^\")\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr2) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr,expr2) -> (exprToString expr) ^ (\"*\" exprToString expr2)\n  | Thresh (expr,expr2,expr3,expr4) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr2) ^\n                 (\"?\" ^\n                    ((exprToString expr3) ^ (\":\" ^ (exprToString expr4 \")\")))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr2) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr2) ^ \"/2)\")))\n  | Times (expr,expr2) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr2))\n  | Thresh (expr,expr2,expr3,expr4) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr2) ^\n                 (\"?\" ^\n                    ((exprToString expr3) ^ (\":\" ^ (exprToString expr4 \")\")))))));;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(eval(e, x, y ))\n| Cosine(e)  -> cos(eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) +. (eval(e2, x ,y) /. 2.0))\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (eval (e, x, y))\n  | Cosine e -> cos (eval (e, x, y))\n  | Average (e1,e2) -> ((eval (e1, x, y)) /. 2) + ((eval (e2, x, y)) /. 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (eval (e, x, y))\n  | Cosine e -> cos (eval (e, x, y))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) /. 2.0) + ((eval (e2, x, y)) /. 2.0)\n  | Times (e1,e2) -> (eval (e1, x, y)) * (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"]}
{"fix": ["let buildY()                       = VarY"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value buildCosine\n"], "bad": ["\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n"]}
{"fix": ["let rec build (rand, depth) = \nif depth = 0 then \nmatch rand(0, 2) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand(2, 7) with \n| 2 -> buildSine(build(rand, depth - 1))\n| 3 -> buildCosine(build(rand, depth - 1))\n| 4 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 6 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value makeRand\n", "Error: This pattern matches values of type int\n       but a pattern was expected which matches values of type\n         int * int -> int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  let f = makeRand rand in\n  if depth = 0\n  then buildX ()\n  else\n    (match f with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let f = makeRand rand in\n  if depth = 0\n  then buildX ()\n  else\n    (match f with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value f\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet _ = let fixpoint (f,b) = let xx = f b in (xx, (xx = b)) in wwhile (f, b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile (f, b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value f\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet _ = let fixpoint (f,b) = let xx = f b in (xx, (xx = b)) in wwhile (f, b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "Error: This expression has type ('a -> 'a * bool) * 'a\n       but an expression was expected of type 'a -> 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((wwhile (f, b)), b);;\n", "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (if (f b) = b then b else ((f b), b));;\n"]}
{"fix": ["let fixpoint (f,b) = \nlet (b', c') = f b in\nif b = b' then b else wwhile (f , b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = let b' = f b in if b = b' then b else wwhile (f, b);;\n"]}
{"fix": ["let fixpoint (f,b) = \nlet f x = let xx = f b in (xx, xx <> b) in wwhile (f, b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: Unbound value f\n", "Error: Unbound value f\n", "Error: Unbound value b'\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = let (b',c') = f b in if b = b' then b else wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = let b' = f b in if b = b' then b else wwhile (f, b);;\n", "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet _ =\n  let fixpoint (f,b) = let b' = f b in if b = b' then b else f b in\n  wwhile (f, b);;\n", "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet _ =\n  let fixpoint (f,b) = let b' = f b in if b = b' then b else f b in\n  wwhile ((f b), b);;\n", "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet _ =\n  let fixpoint (f,b) = let f b = b' in if b = b' then b else f b in\n  wwhile ((f b), b);;\n", "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = false then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  let f x = let xx = f b in (xx, (xx <> b)) in wwhile ((f b), b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet _ = let fixpoint (f,b) = let xx = f b in (xx, (xx <> b)) in wwhile (f, b);;\n", "\nlet fixpoint (f,b) =\n  let f b = let xx = f b in (xx, (xx <> b)) in wwhile (f, b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "expr", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n"]}
{"fix": [], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Chunky of expr* expr* expr\n  | Monkey of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) /. 2.0) +. ((eval (e2, x, y)) /. 2.0)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Chunky (e1,e2,e3) ->\n      ((eval (e1, x, y)) ** (eval (e2, x, y))) ** (eval (e3, x, y))\n  | Monkey (e1,e2) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y)) then (-1) else 1;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a + x in\nlet base =  0 in\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int -> int\n", "Error: This expression has type int but an expression was expected of type\n         int -> int\n"], "bad": ["\nlet sqsum xs = let f a x = (+) x in let base = [] in List.fold_left f base xs;;\n", "\nlet sqsum xs = let f a x = (+) x in let base = 0 in List.fold_left f base xs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base =  f in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value a'\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = a' in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base =  0 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n", "Error: Unbound value a\n", "Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = x a in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = (f) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value f\n", "Error: Unbound value a\n"], "bad": ["\nlet pipe fs = let f a x = x (f a) in let base = 0 in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = f a in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = (+) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value g\n", "Error: Unbound value base\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = f g in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = x a in let base = f base in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet rec base = base in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value base\n", "Error: Unbound value x\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = base in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = x a in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": [], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (\";\" List.map (f l));;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (\"\" List.map (f l));;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (\"\" List.map (f l));;\n"]}
{"fix": ["let stringOfList f l = \nlet x = List.map f l  in\nsepConcat \";\" x"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a list -> 'b list\n       but an expression was expected of type string list\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"\" List.map (f l);;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"\" List.map (f l);;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = let x = List.map (f l) in sepConcat \";\" x;;\n"]}
{"fix": ["let stringOfList f l = \nlet x = List.map f l  in\nsepConcat \";\" x"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" List.map f l;;\n"]}
{"fix": ["let rec clone x n = \nif n <= 0 then []\nelse n :: (clone x (n-1))"], "hw": "hw3", "problem": "clone", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else n :: ((clone x n) - 1);;\n", "\nlet rec clone x n = if n <= 0 then [] else n :: ((clone x n) - 1);;\n"]}
{"fix": ["let padZero l1 l2 = \nlet x1 = List.length(l1) in\nlet x2 = List.length(l2) in\nif x1 < x2 then l1 @ clone 0 (x2-x1)\nelse l2 @ clone 0 (x1-x2)"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2 then x1 @ (clone 0 (x2 - x1)) else x2 @ (clone 0 (x1 - x2));;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a +. x**2.0 in\nlet base =  0.0 in\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\nlet sqsum xs =\n  let f a x = a + (x ** 2) in let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = a + (x ** 2.0) in let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = a +. (x ** 2.0) in let base = 0 in List.fold_left f base xs;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a + int_of_float(float_of_int(x)**2.0) in\nlet base =  0 in\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type int but an expression was expected of type\n         float\n", "Error: Unbound value pow\n"], "bad": ["\nlet sqsum xs =\n  let f a x = a + (x ** 2) in let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = a + (pow x 2) in let base = 0 in List.fold_left f base xs;;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type int list\n       Type 'a * 'b is not compatible with type int \n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = List.combine (l1, l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: Unbound value bigAdd\n"], "bad": ["\nlet rec mulByDigit i l = if i <> 0 then mulByDigit (i - 1) bigAdd l l else l;;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value f\n", "Error: This expression has type int * 'a\n       but an expression was expected of type (int * int) list list\n", "Error: This expression has type int * 'a\n       but an expression was expected of type (int * int) list list\n", "Error: This expression has type int * 'a\n       but an expression was expected of type (int * int) list list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (hold,res) = f a x in\n      match x with\n      | (x1,x2)::(x3,x4)::t ->\n          let tens = x1 + (x2 / 10) in let ones = x1 + (x2 mod 10) in () in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      match x with\n      | (x1,x2)::t ->\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in [(tens, ones)] :: a\n      | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      match x with\n      | (x1,x2)::t ->\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in [(tens, ones)] :: a\n      | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      match x with\n      | (x1,x2)::t ->\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in [(tens, ones)] :: a\n      | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int * 'a\n       but an expression was expected of type 'b list\n", "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      match x with\n      | (x1,x2)::t ->\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in a @ [(tens, ones)]\n      | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2)::t ->\n          let ha::ht = a in\n          let (a1,a2) = ha in\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in a @ [(tens, ones)]\n      | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2)::t ->\n          let ha::_ = a in\n          let (a1,a2) = ha in\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in a @ [(tens, ones)]\n      | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2)::t ->\n          let ha::_ = a in\n          let (a1,a2) = ha in\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in a @ [(tens, ones)]\n      | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2)::t ->\n          let ha::_ = a in\n          let (a1,a2) = ha in\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in (tens, ones) :: a\n      | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | h::t ->\n          let (x1,x2) = h in\n          let ha::_ = a in\n          let (a1,a2) = ha in\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in (tens, ones) :: a\n      | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | h::t ->\n          let (x1,x2) = h in\n          let ha::_ = a in\n          let (a1,a2) = ha in\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in (tens, ones) :: a\n      | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (a1, a2) = a in\nlet h :: _ = a1 in\nlet tens = x1 + x2 + h / 10 in\nlet ones = x1 + x2 + h mod 10 in\n(tens :: a1, ones :: a2)\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: Unbound value x1\n", "Error: This expression has type int * int\n       but an expression was expected of type (int * int) list\n", "Error: This expression has type (int * int) list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type (int * 'a) list -> int * int -> int * int\n       but an expression was expected of type\n         (int * 'a) list -> int * int -> (int * 'a) list\n       Type int * int is not compatible with type (int * 'a) list \n", "Error: This expression has type (int * int) list\n       but an expression was expected of type 'a * 'b\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | h::t -> a | [] -> a in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let ha::_ = a in\n      let (a1,a2) = ha in\n      let tens = (x1 + x2) + (a1 / 10) in\n      let ones = (x1 + x2) + (a1 mod 10) in (tens, ones) :: a in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let ha::_ = a in\n      let (a1,a2) = ha in\n      let tens = (x1 + x2) + (a1 / 10) in\n      let ones = (x1 + x2) + (a1 mod 10) in (tens, ones) :: a in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let ha::_ = a in\n      let (a1,a2) = ha in\n      let tens = (x1 + x2) + (a1 / 10) in\n      let ones = (x1 + x2) + (a1 mod 10) in (tens, ones) :: a in\n    let base = [(0, 0)] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let ha::_ = a in\n      let (a1,a2) = ha in\n      let tens = (x1 + x2) + (a1 / 10) in\n      let ones = (x1 + x2) + (a1 mod 10) in (tens, ones) in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let ha::_ = a in\n      let (a1,a2) = ha in\n      let tens = (x1 + x2) + (a1 / 10) in\n      let ones = (x1 + x2) + (a1 mod 10) in (tens, ones) :: a in\n    let base = [(0, 0)] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nmatch carry with\n| h :: t -> \nlet tens = x1 + x2 + h / 10 in\nlet ones = x1 + x2 + h mod 10 in\n(tens :: carry, ones :: res)\n| [] ->\nlet tens = x1 + x2 / 10 in\nlet ones = x1 + x2 mod 10 in\n(tens :: carry, ones :: res)\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      match carry with\n      | h::t ->\n          let tens = (x1 + x2) + (h / 10) in\n          let ones = (x1 + x2) + (h mod 10) in\n          ((tens :: carry), (ones :: res))\n      | [] ->\n          let tens = x1 + (x2 / 10) in\n          let ones = x1 + (x2 mod 10) in ((carry :: a1), (ones :: res)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nif carry <> [] then\nlet ch :: _ = carry in\nlet tens = (x1 + x2 + ch) / 10 in\nlet ones = (x1 + x2 + ch) mod 10 in\n([tens] , tens :: ones :: res)\nelse\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: res)\n\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b * 'c\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: This expression has type int * int list -> int * int -> int list\n       but an expression was expected of type\n         int * int list -> int * int -> int * int list\n       Type int list is not compatible with type int * int list \n", "Error: This expression has type int list * 'a list\n       but an expression was expected of type int * int list\n       Type int list is not compatible with type int \n", "Error: This expression has type int list * 'a list\n       but an expression was expected of type int * int list\n       Type int list is not compatible with type int \n", "Error: This expression has type int list * int list\n       but an expression was expected of type int * int list\n       Type int list is not compatible with type int \n", "Error: This expression has type\n         int * int list -> int * int -> int list * int list\n       but an expression was expected of type\n         int * int list -> int * int -> int * int list\n       Type int list is not compatible with type int \n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      match x2 with\n      | h::t ->\n          let (carry,res) = a in\n          let tens = ((x1 + x2) + h) / 10 in\n          let ones = ((x1 + x2) + h) mod 10 in\n          ((tens :: carry), (ones :: res))\n      | [] ->\n          let (carry,res) = a in\n          let tens = ((x1 + x2) + h) / 10 in\n          let ones = ((x1 + x2) + h) mod 10 in tens :: ones :: res in\n    let base = ([0], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      match x with\n      | h::t ->\n          let (carry,res) = a in\n          let tens = ((x1 + x2) + h) / 10 in\n          let ones = ((x1 + x2) + h) mod 10 in\n          ((tens :: carry), (ones :: res))\n      | [] ->\n          let (carry,res) = a in\n          let tens = ((x1 + x2) + h) / 10 in\n          let ones = ((x1 + x2) + h) mod 10 in tens :: ones :: res in\n    let base = ([0], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | h::t ->\n          let (x1,x2) = x in\n          let (carry,res) = a in\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in\n          if t = []\n          then (0, (tens :: ones :: res))\n          else ((tens :: carry), (ones :: res))\n      | [] -> a in\n    let base = ([0], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      let tens = (x1 + x2) + (carry / 10) in\n      let ones = (x1 + x2) + (carry mod 10) in tens :: ones :: res in\n    let base = ([0], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      let tens = (x1 + x2) + (carry / 10) in\n      let ones = (x1 + x2) + (carry mod 10) in (tens, (tens :: ones :: res)) in\n    let base = ([0], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      let tens = (x1 + x2) + (carry / 10) in\n      let ones = (x1 + x2) + (carry mod 10) in (tens, (tens :: ones :: res)) in\n    let base = ([0], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      let tens = (x1 + x2) + (carry / 10) in\n      let ones = (x1 + x2) + (carry mod 10) in (tens, (tens :: ones :: res)) in\n    let base = ([0], [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      let tens = (x1 + x2) + (carry / 10) in\n      let ones = (x1 + x2) + (carry mod 10) in\n      ([tens], (tens :: ones :: res)) in\n    let base = ([0], [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      if carry <> []\n      then\n        let tens = ((x1 + x2) + carry) / 10 in\n        let ones = ((x1 + x2) + carry) mod 10 in\n        ([tens], (tens :: ones :: res))\n      else\n        (let tens = (x1 + x2) / 10 in\n         let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let rec mulByDigit i l = \nif i <> 0 then mulByDigit (i-1) (bigAdd l l)\nelse l"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type 'a but an expression was expected of type\n         (int list -> int list -> int list) ->\n         (int list -> int list -> int list) -> 'a\n       The type variable 'a occurs inside\n       (int list -> int list -> int list) ->\n       (int list -> int list -> int list) -> 'a\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      if res <> []\n      then\n        let lastTens::rest = res in\n        (if carry <> []\n         then\n           let ch::_ = carry in\n           let tens = ((x1 + x2) + ch) / 10 in\n           let ones = ((x1 + x2) + ch) mod 10 in\n           ([tens], (tens :: ones :: rest))\n         else\n           (let tens = (x1 + x2) / 10 in\n            let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: rest))))\n      else\n        if carry <> []\n        then\n          (let ch::_ = carry in\n           let tens = ((x1 + x2) + ch) / 10 in\n           let ones = ((x1 + x2) + ch) mod 10 in\n           ([tens], (tens :: ones :: res)))\n        else\n          (let tens = (x1 + x2) / 10 in\n           let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i <> 0 then mulByDigit (i - 1) bigAdd l l else l;;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nmatch res with\n| h :: t -> \n(match carry with\n| h1 :: t1 ->\nlet tens = (x1 + x2 + h1) / 10 in\nlet ones = (x1 + x2 + h1) mod 10 in\n([tens], tens :: ones :: t)\n| [] ->\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: t)\n)\n| [] -> \n(match carry with\n| h1 :: t1 ->\nlet tens = (x1 + x2 + h1) / 10 in\nlet ones = (x1 + x2 + h1) mod 10 in\n([tens], tens :: ones :: res)\n| [] ->\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: res)\n)\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value h1\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      match res with\n      | h::t ->\n          (match carry with\n           | h1::t1 ->\n               let tens = ((x1 + x2) + h1) / 10 in\n               let ones = ((x1 + x2) + h1) mod 10 in\n               ([tens], (tens :: ones :: t))\n           | [] ->\n               let tens = (x1 + x2) / 10 in\n               let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: t)))\n      | [] ->\n          (match carry with\n           | h1::t1 ->\n               let tens = ((x1 + x2) + h1) / 10 in\n               let ones = ((x1 + x2) + h1) mod 10 in\n               ([tens], (tens :: ones :: res))\n           | [] ->\n               let tens = ((x1 + x2) + h1) / 10 in\n               let ones = ((x1 + x2) + h1) mod 10 in\n               ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let rec mulByDigit i l = helper [0] i l"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      match res with\n      | h::t ->\n          (match carry with\n           | h1::t1 ->\n               let tens = ((x1 + x2) + h1) / 10 in\n               let ones = ((x1 + x2) + h1) mod 10 in\n               ([tens], (tens :: ones :: t))\n           | [] ->\n               let tens = (x1 + x2) / 10 in\n               let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: t)))\n      | [] ->\n          (match carry with\n           | h1::t1 ->\n               let tens = ((x1 + x2) + h1) / 10 in\n               let ones = ((x1 + x2) + h1) mod 10 in\n               ([tens], (tens :: ones :: res))\n           | [] ->\n               let tens = (x1 + x2) / 10 in\n               let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec helper ans i l =\n  if i = 0 then ans else helper (bigAdd ans l) (i - 1) l;;\n\nlet rec mulByDigit i l = helper 0 i l;;\n"]}
{"fix": ["let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin\" ^ exprToString a\n| Cosine a -> \"cos\" ^ exprToString a\n| Average (a,b) -> exprToString a ^ \"/\" ^ exprToString b\n| Times (a,b) -> exprToString a ^ \"*\" ^ exprToString b\n| Thresh (a,b,c,d) -> exprToString a ^ \"<\" ^ exprToString b ^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d"], "hw": "hw2", "problem": "exprToString", "message": ["Error: Unbound value string\nHint: Did you mean stdin?\n", "Error: Unbound constructor String\n", "Error: Unbound value x\n"], "bad": ["\nlet rec exprToString e = (string x) = e;;\n", "\nlet rec exprToString e = (String x) = e;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> \"sin\" ^ (exprToString a)\n  | Cosine a -> \"cos\" ^ (exprToString a)\n  | Average (a,b) -> (exprToString a) ^ (\"/\" ^ (exprToString b))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      (exprToString a) ^\n        (\"<\" ^\n           ((exprToString b) ^\n              (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d))))));;\n"]}
{"fix": ["let rec eval (e,x,y) = \nmatch e with\n|VarX -> x\n|VarY -> y\n|Sine a -> sin (pi *. eval(a,x,y))\n|Cosine a -> cos (pi *. eval(a,x,y))\n|Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.\n|Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n|Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n"]}
{"fix": ["let rec build (rand, depth) = \nif depth = 0 then \nlet result = rand 0 1 in\nif result = 0 then \nbuildX() else\nbuildY()\nelse\nlet result = rand 0 6 in\nmatch result with\n|0 -> buildX()\n|1 -> buildY()\n|2 -> buildSine(build(rand,depth-1))\n|3 -> buildCosine(build(rand,depth-1))\n|4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n|_ -> buildX()"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type unit but an expression was expected of type\n         (int -> int -> int) * int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let result = rand 0 1 in (if result = 0 then buildX () else buildY ())\n  else\n    (let result = rand 0 6 in\n     match result with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> build ());;\n"]}
{"fix": ["let rec eval (e,x,y) = \nmatch e with\n|VarX -> x\n|VarY -> y\n|Sine a -> sin (pi *. eval(a,x,y))\n|Cosine a -> cos (pi *. eval(a,x,y))\n|Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.\n|Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n|Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)\n|Inverse a -> let result  = eval(a,x,y) in\nif result = 0. then 0.\nelse\n1. /. result\n|Max (a,b) -> let aResult = eval(a,x,y) in\nlet bResult = eval(b,x,y) in\nif aResult > bResult then aResult\nelse bResult\n|Range (a,b,c) -> let aResult = eval(a,x,y) in\nlet bResult = eval(b,x,y) in\nlet cResult = eval(c,x,y) in\nif aResult < bResult then bResult else\nif aResult < cResult then cResult else\naResult"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Inverse of expr\n  | Max of expr* expr\n  | Range of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Inverse a ->\n      let result = eval (a, x, y) in if result = 0. then 0 else 1 /. result\n  | Max (a,b) ->\n      let aResult = eval (a, x, y) in\n      let bResult = eval (b, x, y) in\n      if aResult > bResult then aResult else bResult\n  | Range (a,b,c) ->\n      let aResult = eval (a, x, y) in\n      let bResult = eval (b, x, y) in\n      let cResult = eval (c, x, y) in\n      if aResult < bResult\n      then bResult\n      else if aResult < cResult then cResult else aResult;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Inverse of expr\n  | Max of expr* expr\n  | Range of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Inverse a ->\n      let result = eval (a, x, y) in if result = 0. then 0. else 1 /. result\n  | Max (a,b) ->\n      let aResult = eval (a, x, y) in\n      let bResult = eval (b, x, y) in\n      if aResult > bResult then aResult else bResult\n  | Range (a,b,c) ->\n      let aResult = eval (a, x, y) in\n      let bResult = eval (b, x, y) in\n      let cResult = eval (c, x, y) in\n      if aResult < bResult\n      then bResult\n      else if aResult < cResult then cResult else aResult;;\n"]}
{"fix": ["let padZero l1 l2 = \nlet num1 = List.length l2 - List.length l1 in\nlet num2 = List.length l1 - List.length l2 in\n(clone 0 num1 @l1,clone 0 num2 @ l2)"], "hw": "hw3", "problem": "padZero", "message": ["Error: Unbound value list\n"], "bad": ["\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (list.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n|(z,y) -> let sum = z + y in\nif sum > 10 then let result = ((sum mod 10)::a) in\n1::result else\nsum::a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"], "bad": ["\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (z,y) ->\n          let sum = z + y in\n          if sum > 10\n          then let result = a @ (sum mod 10) in result @ 1\n          else a @ result in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (z,y) ->\n          let sum = z + y in\n          if sum > 10\n          then let result = a @ (sum mod 10) in result @ 1\n          else a @ result in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (z,y) ->\n          let sum = z + y in\n          if sum > 10\n          then let result = a @ (sum mod 10) in result @ 1\n          else a @ result in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (z,y) ->\n          let sum = z + y in\n          if sum > 10\n          then let result = (sum mod 10) :: a in 1 :: result\n          else sum :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\nmatch x with\n|(z,y) -> (match a with\n|[] -> let sum = z + y in\nintlist sum\n|h::t -> let sum = h + z + y in\n(intlist sum) @ t) in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x = if x < 10 then x else [intlist (x / 10); x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | h -> let sum = (h + z) + y in intlist sum\n           | h::t -> let sum = (h + z) + y in (intlist sum) :: t) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else [intlist (x / 10); x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | h -> let sum = (h + z) + y in intlist sum\n           | h::t -> let sum = (h + z) + y in (intlist sum) :: t) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | h -> let sum = (h + z) + y in intlist sum\n           | h::t -> let sum = (h + z) + y in (intlist sum) @ t) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\nmatch x with\n|(z,y) -> (match a with\n|[] -> let sum = z + y in\nintlist sum\n|h::t -> let sum = h + z + y in\n(intlist sum) @ t) in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t -> let sum = (h + z) + y in (intlist sum) :: t) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\nmatch x with\n|(z,y) -> (match a with\n|[] -> let sum = z + y in\nintlist sum\n|h::t -> let sum = h + z + y in\nlet result = (intlist sum) @ t in\nif sum < 10 then 0::result else result) in \n\nlet base = [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value result\n"], "bad": ["\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet f a x =\n  let rec intlist l = if l < 10 then [l] else (intlist (l / 10)) @ [l mod 10] in\n  match x with\n  | (z,y) ->\n      (match a with\n       | [] -> let sum = z + y in intlist sum\n       | h::t -> let sum = (h + z) + y in (intlist sum) @ t);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet _ =\n  let bigAdd l1 l2 =\n    let add (l1,l2) =\n      let f a x =\n        let rec intlist x =\n          if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n        match x with\n        | (z,y) ->\n            (match a with\n             | [] -> let sum = z + y in intlist sum\n             | h::t -> let sum = (h + z) + y in result = ((intlist sum) @ t)) in\n      if sum < 10 then 0 :: result else result in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: Unbound value h\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         int list\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This function has type int list -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This function has type int list -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int but an expression was expected of type\n         int list\nError: Unbound value padZero\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> 0\n  | h::t ->\n      let (_,zeroList) = padZero (t, []) in\n      let mult = (intlist h) * i in\n      let res = mult @ zeroList in bigAdd res (mulByDigit t);;\n", "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10];;\n\nlet rec mulByDigit i l = failwith \"to be implemented\";;\n\nlet _ =\n  let mult = (intlist h) * i in\n  let res = mult @ zeroList in bigAdd res (mulByDigit t);;\n", "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> 0\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> let (_,zeroList') = padZero (t', []) in zeroList' in\n      let mult = (intlist h) * i in\n      let res = mult @ zeroList in bigAdd res (mulByDigit t);;\n", "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> 0\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero (t', []) with | (a,b) -> b) in\n      let mult = (intlist h) * i in\n      let res = mult @ zeroList in bigAdd res (mulByDigit t);;\n", "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> 0\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero (t', [0]) with | (a,b) -> b) in\n      let mult = (intlist h) * i in\n      let res = mult @ zeroList in bigAdd res (mulByDigit t);;\n", "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> 0\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero (t', [0]) with | (a,b) -> b) in\n      let mult = (intlist h) * i in\n      let res = mult @ zeroList in bigAdd res (mulByDigit t);;\n", "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> 0\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero (t' [0]) with | (a,b) -> b) in\n      let mult = (intlist h) * i in\n      let res = mult @ zeroList in bigAdd res (mulByDigit t);;\n", "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> 0\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero (t' [0]) with | (a,b) -> b) in\n      let mult = (intlist h) * i in\n      let res = mult @ zeroList in bigAdd res (mulByDigit t);;\n", "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> 0\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero t' [0] with | (a,b) -> b) in\n      let mult = (intlist h) * i in\n      let res = mult @ zeroList in bigAdd res (mulByDigit t);;\n", "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> 0\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero t' [0] with | (a,b) -> b) in\n      let mult = intlist (h * i) in\n      let res = mult @ zeroList in bigAdd res (mulByDigit t);;\n", "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> 0\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero t' [0] with | (a,b) -> b) in\n      let mult = intlist (h * i) in\n      let res = mult @ zeroList in bigAdd res (mulByDigit i t);;\n", "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> 0\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero t' [0] with | (a,b) -> b) in\n      let mult = intlist (h * i) in\n      let res = mult @ zeroList in bigAdd (res (mulByDigit (i t)));;\n", "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> 0\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero t' [0] with | (a,b) -> b) in\n      let mult = intlist (h * i) in\n      let res = mult @ zeroList in bigAdd (res mulByDigit (i t));;\n", "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> 0\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero t' [0] with | (a,b) -> b) in\n      let mult = intlist (h * i) in\n      let res = mult @ zeroList in bigAdd res mulByDigit (i t);;\n", "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> 0\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero t' [0] with | (a,b) -> b) in\n      let mult = intlist (h * i) in\n      let res = mult @ zeroList in bigAdd res (mulByDigit i t);;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = match a with \n|(b,c) -> b @ [0] , bigAdd ((mulByDigit x l2) @ b) c in \nlet base = ([],[0]) in\nlet args = l1 in\nlet (res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This function has type int list -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int list * 'a\n       but an expression was expected of type int list\n", "Error: This expression has type int list * int\n       but an expression was expected of type int list * int list\n       Type int is not compatible with type int list \n"], "bad": ["\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (b,c) -> ((b @ [0]), ((bigAdd bigMul x l2) @ (c a))) in\n  let base = ([], 0) in\n  let args = l1 in let res = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> [0]\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero t [0] with | (a,b) -> b) in\n      let mult = intlist (h * i) in\n      let res = mult @ zeroList in bigAdd res (mulByDigit i t);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (b,c) -> ((b @ [0]), (bigAdd ((mulByDigit x l2) @ b) a)) in\n  let base = ([], 0) in\n  let args = l1 in let res = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> [0]\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero t [0] with | (a,b) -> b) in\n      let mult = intlist (h * i) in\n      let res = mult @ zeroList in bigAdd res (mulByDigit i t);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (b,c) -> ((b @ [0]), (bigAdd ((mulByDigit x l2) @ b) c)) in\n  let base = ([], 0) in\n  let args = l1 in let res = List.fold_left f base args in res;;\n"]}
{"fix": ["let rec digitsOfInt n = \nmatch n > 0 with\n| true  -> digOfIntHelper n::[n mod 10] \n| false -> []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value digOfIntHelper\n", "Error: This expression has type int but an expression was expected of type\n         int -> int\n", "Error: Unbound value %\n"], "bad": ["\nlet rec digitsOfInt n =\n  match n > 0 with | true  -> [digOfIntHelper; n mod 10] | false  -> [];;\n", "\nlet rec digOfIntHelper h = match h > 0 with | true  -> 1 | false  -> 0;;\n\nlet rec digitsOfInt n =\n  match n > 0 with | true  -> [digOfIntHelper; n mod 10] | false  -> [];;\n", "\nlet rec digOfIntHelper h = match h > 0 with | true  -> 1 | false  -> 0;;\n\nlet rec digitsOfInt n =\n  match n > 0 with | true  -> [digOfIntHelper; n % 10] | false  -> [];;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digOfIntHelper h = match h > 0 with | true  -> 1 | false  -> 0;;\n\nlet rec digitsOfInt n =\n  match n with\n  | 0 -> []\n  | 0::[] -> []\n  | 1 -> []\n  | true  -> [digOfIntHelper n; []; n mod 10]\n  | false  -> [];;\n", "\nlet rec digOfIntHelper h = match h > 0 with | true  -> 1 | false  -> 0;;\n\nlet rec digitsOfInt n =\n  match n > 0 with | true  -> [digOfIntHelper n; []; n mod 10] | false  -> [];;\n", "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt n)\n       | true  -> (digitsOfInt n) mod 10);;\n"]}
{"fix": ["let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: []\n| true  -> (n / 10) :: digitsOfInt (n mod 10)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> [n]\n       | true  -> (digitsOfInt (n / 10)) :: (digitsOfInt (n mod 10)));;\n"]}
{"fix": ["let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: []\n| true  -> n / 10 :: digitsOfInt (n / 10)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> [n]\n       | true  -> (digitsOfInt (n / 10)) :: (n mod 10));;\n"]}
{"fix": ["let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> 1 :: []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with | false  -> n :: (digitsOfInt (n / 10)) | true  -> 1);;\n", "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt (n / 10))\n       | true  -> 1 :: 1);;\n"]}
{"fix": ["let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 )"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt (n / 10))\n       | true  -> 1 :: 2);;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt (n / 10))\n       | true  -> [digitsOfInt (n / 10); n mod 10]);;\n"]}
{"fix": [], "hw": "hw1", "problem": "listReverse", "message": ["Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n"], "bad": ["\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> (reverseHelper t h) :: revd in\n  reverseHelper [] l;;\n", "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> (reverseHelper t h) :: revd in\n  reverseHelper [] l;;\n", "\nlet listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> (reverseHelper t h) :: revd in\n  reverseHelper [] l;;\n", "\nlet listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> reverseHelper t (h :: revd) in\n  reverseHelper [] l;;\n", "\nlet rec listReverse l = failwith \"TBD\";;\n\nlet listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  reverseHelper [] l;;\n", "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  reverseHelper [] l;;\n", "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  listReverse [] l;;\n", "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  listReverse [] l;;\n", "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match l with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  listReverse l [];;\n", "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match l with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  listReverse [] l;;\n", "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match l with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  reverseHelper [];;\n", "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match l with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  reverseHelper l;;\n", "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match l with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  listReverse l [];;\n", "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match l with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  listReverse [] l;;\n"]}
{"fix": ["let rec listReverse l =\nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a list -> 'a list\n", "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a list -> 'a list\n", "Error: Unbound value r\n"], "bad": ["\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match l with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  reverseHelper [] l;;\n", "\nlet rec listReverse l =\n  let rec reverseHelper r =\n    match l with | [] -> [] | h::t -> listReverse t (h :: r) in\n  listReverse l [];;\n", "\nlet rec listReverse l =\n  let reverseHelper r =\n    match l with | [] -> [] | h::t -> listReverse t (h :: r) in\n  listReverse l [];;\n", "\nlet rec listReverse l =\n  let reverseHelper r =\n    match l with | [] -> [] | h::t -> listReverse t (h :: r) in\n  listReverse l [];;\n", "\nlet rec listReverse l =\n  let reverseHelper r =\n    match l with | [] -> [] | h::t -> listReverse t (h :: r) in\n  listReverse [] [];;\n", "\nlet rec listReverse l =\n  let reverseHelper r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  listReverse [] [];;\n", "\nlet rec listReverse l =\n  let reverseHelper r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper l [];;\n", "\nlet rec listReverse l =\n  let reverseHelper r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper [];;\n", "\nlet rec listReverse l =\n  let reverseHelper r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  r;;\n"]}
{"fix": ["let rec listReverse l =\nlet rec reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> reverseHelper t ( h::r ) \nin\nreverseHelper []"], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value reverseHelper\n"], "bad": ["\nlet rec listReverse l =\n  let reverseHelper l r =\n    match l with | [] -> l | h::t -> reverseHelper t (h :: r) in\n  reverseHelper [];;\n"]}
{"fix": ["let listReverse l =\nlet rec reverseHelper l rl = \nmatch l with\n| []    -> rl\n| h::t  -> reverseHelper t ( h::rl ) \nin\nreverseHelper l []"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type 'a list\n"], "bad": ["\nlet listReverse l =\n  let rec reverseHelper l rl =\n    function | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n"]}
{"fix": [], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  let digOfInt n =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: (digitsOfInt (n / 10))\n         | true  -> (n mod 10) :: (digitsOfInt (n / 10))) in\n  listReverse n;;\n", "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  let digOfInt n r =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: (digitsOfInt (n / 10))\n         | true  -> (n mod 10) :: (digitsOfInt (n / 10))) in\n  listReverse n r;;\n", "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  let digOfInt n r =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: (digitsOfInt (n / 10))\n         | true  -> (n mod 10) :: (digitsOfInt (n / 10))) in\n  listReverse n r;;\n", "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  let digOfInt n r =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: (digitsOfInt (n / 10))\n         | true  -> (n mod 10) :: (digitsOfInt (n / 10))) in\n  listReverse n;;\n", "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  let digOfInt n =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: (digitsOfInt (n / 10))\n         | true  -> (n mod 10) :: (digitsOfInt (n / 10))) in\n  listReverse n;;\n"]}
{"fix": ["let rec digOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 )"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value n\n"], "bad": ["\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  listReverse\n    (match n > 0 with\n     | false  -> []\n     | true  ->\n         (match n > 9 with\n          | false  -> n :: (digitsOfInt (n / 10))\n          | true  -> (n mod 10) :: (digitsOfInt (n / 10))));;\n\nlet rec digOfInt =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt (n / 10))\n       | true  -> (n mod 10) :: (digitsOfInt (n / 10)));;\n"]}
{"fix": ["let additivePersistence n = \nlet rec addPerHelper n l =\nmatch l with\n| []    -> 0\n| [a]   -> n\n| _     -> addPerHelper (n + 1) (digitsOfInt(sumList l))\nin\naddPerHelper 0 (digitsOfInt n)"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: Unbound value sumlist\nHint: Did you mean sumList?\nError: Unbound value sumlist\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sumlist\nHint: Did you mean sumList?\n"], "bad": ["\nlet digitsOfInt n =\n  let rec digOfIntHelper n l =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: l\n         | true  -> digOfIntHelper (n / 10) ((n mod 10) :: l)) in\n  digOfIntHelper n [];;\n\nlet additivePersistence n =\n  let rec addPerHelper n l =\n    match l with\n    | [] -> 0\n    | a::[] -> n\n    | _ -> addPerHelper (n + 1) (digitsOfInt (sumlist l)) in\n  addPerHelper 0 (digitsOfInt n);;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value additivePersistence\n"], "bad": ["\nlet _ = additivePersistence 1;;\n"]}
{"fix": [], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: Unbound value digitsOfInt\n"], "bad": ["\nlet digits n = digitsOfInt (abs n);;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: Unbound value digitalRoot\n", "Error: Unbound value digitalRoot\n", "Error: Unbound value digitalRoot\n", "Error: Unbound value additivePersistence\n"], "bad": ["\nlet _ = digitalRoot 98763;;\n", "\nlet _ = digitalRoot 98763;;\n", "\nlet _ = digitalRoot 98763;;\n", "\nlet _ = additivePersistence 9876;;\n"]}
{"fix": ["let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0"], "hw": "hw1", "problem": "sumList", "message": ["Error: Unbound value digitalRoot\n"], "bad": ["\nlet _ = digitalRoot 9876;;\n"]}
{"fix": ["let rec palindrome w = \nmatch w with\n| []    -> \n(match listReverse(w) with\n| []  -> true\n| _   -> false)\n| h::t  ->\n(match listReverse(w) with\n| []      -> true\n| h2::t2  -> if (h2 = h)\nthen (\npalindrome t )\nelse (\nfalse ) )"], "hw": "hw1", "problem": "palindrome", "message": ["Error: Unbound value h1\n", "Error: Unbound value palindrome\n"], "bad": ["\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet palindrome w =\n  match w with\n  | [] -> (match listReverse w with | [] -> true | _ -> false)\n  | h::t ->\n      (match listReverse w with\n       | [] -> true\n       | h2::t2 -> if h2 = h1 then palindrome t else false);;\n", "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet palindrome w =\n  match w with\n  | [] -> (match listReverse w with | [] -> true | _ -> false)\n  | h::t ->\n      (match listReverse w with\n       | [] -> true\n       | h2::t2 -> if h2 = h then palindrome t else false);;\n"]}
{"fix": [], "hw": "hw1", "problem": "palindrome", "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n"], "bad": ["\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec palindrome w =\n  match w with\n  | [] -> (match listReverse w with | [] -> true | _ -> false)\n  | h::t ->\n      (match listReverse w with\n       | [] -> true\n       | h2::t2 -> if h2 = h then palindrome t else false);;\n\nlet _ = palindrome \"myxomatosis\";;\n"]}
{"fix": ["let listReverse l = lReverse (l, [])"], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value reverseHelper\n"], "bad": ["\nlet _ = reverseHelper l [];;\n"]}
{"fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: Unbound value fixpoint\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (b',true ) -> wwhile (f, b') | (b',false ) -> b';;\n\nlet fixpoint (f,b) = wwhile (((f b), (b <> (f b))), b);;\n", "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (b',true ) -> wwhile (f, b') | (b',false ) -> b';;\n\nlet fixpoint (f,b) =\n  let (b',c) = ((f b), ((f b) <> b)) in wwhile ((b', c), b);;\n"]}
{"fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: Unbound value f\n", "Error: Unbound value f\n", "Error: Unbound value f\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (b',true ) -> wwhile (f, b') | (b',false ) -> b';;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ = fixpoint (collatz, 9001);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (b',true ) -> wwhile (f, b') | (b',false ) -> b';;\n\nlet fixpoint (f,b) = wwhile ((b, (b <> (f b))), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (b',true ) -> wwhile (f, b') | (b',false ) -> b';;\n\nlet _ =\n  let fixpoint (f,b) = let b' = f b in (b', ((f b) <> b)) in wwhile (f, b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (b',true ) -> wwhile (f, b') | (b',false ) -> b';;\n\nlet _ =\n  let fixpoint (f,b) = let b' = f b in (b', ((f b) <> b)) in wwhile (f, b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (b',true ) -> wwhile (f, b') | (b',false ) -> b';;\n\nlet _ =\n  let fixpoint (f,b) = let b' = f b in (b', ((f b) <> b)) in wwhile (f, b);;\n"]}
{"fix": ["let rec exprToString e = match e with\nVarX   \t\t      -> \"x\"\n| VarY  \t\t-> \"y\"\n| Sine(x)\t\t-> \"sin(pi*\" ^ (exprToString x) ^ \")\"\n| Cosine(x)\t\t-> \"cos(pi*\" ^ (exprToString x) ^ \")\"\n| Average(x1,x2)\t-> \"((\" ^ (exprToString x1) ^ \"+\" ^ (exprToString x2) ^ \")/2)\"\n| Times(x1,x2)\t\t-> (exprToString x1) ^ \"*\" ^ (exprToString x2)\n| Thresh(x1,x2,x3,x4)\t-> \"(\" ^ (exprToString x1) ^ \"<\" ^ (exprToString x2) \n^ \"?\" ^ (exprToString x3) ^ \":\" ^ (exprToString x4) ^ \")\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: Unbound value exprToString\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type string but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x1,x2) ->\n      \"((\" ^ ((exprToString x1) ^ (\"+\" ^ ((exprToString x2) ^ \")/2)\")))\n  | Times (x1,x2) -> (exprToString x1) ^ (\"*\" ^ (exprToString x2))\n  | Thresh (x1,x2,x3,x4) ->\n      \"(\" ^\n        ((exprToString x1) ^\n           (\"<\" ^\n              ((exprToString x2) ^\n                 (\"?\" ^\n                    ((exprToString x3) ^ (\":\" ^ ((exprToString x4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      \"(\" ^\n        ((exprToString x1) ^\n           (\"<\" ^\n              ((exprToString x2) ^\n                 (\"?\" ^\n                    ((exprToString x3) ^ (\":\" ^ ((exprToString x4) ^ \")\")))))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\nError: Unbound value sampleExpr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      if (eval (x1, x, y)) < (eval (x2, x, y))\n      then eval (x3, x, y)\n      else eval (x4, x, y);;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n"]}
{"fix": ["let rec build (rand, depth) = match depth with\n| 0   -> ( match (rand 1 3 ) with\n| 1 -> buildX()\n| 2 -> buildY() \n)\n| _   -> ( match (rand 1 5 ) with\n| 1 -> buildSine(build(rand,depth-1))\n| 2 -> buildCosine(build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),\nbuild(rand,depth-1),build(rand,depth-1))\n)"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value buildSin\nHint: Did you mean buildSine?\nError: Unbound value buildSin\nHint: Did you mean build, buildY or buildX?\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value buildSin\nHint: Did you mean buildSine?\n", "Error: Unbound value buildCos\nHint: Did you mean build, buildCosine, buildY or buildX?\nError: Unbound value buildCos\nHint: Did you mean build, buildX or buildY?\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value buildCos\nHint: Did you mean build, buildCosine, buildY or buildX?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand 1 3 with | 1 -> buildX () | 2 -> buildY ())\n  | _ ->\n      (match rand 1 4 with\n       | 1 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 2 -> buildSin (build (rand, (depth - 1)))\n       | 3 -> buildCos (build (rand, (depth - 1)))\n       | 4 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand 1 3 with | 1 -> buildX () | 2 -> buildY ())\n  | _ ->\n      (match rand 1 4 with\n       | 1 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCos (build (rand, (depth - 1)))\n       | 4 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"]}
{"fix": ["let rec exprToString e = match e with\nVarX   \t\t      -> \"x\"\n| VarY  \t\t-> \"y\"\n| Sine(x)\t\t-> \"sin(pi*\" ^ (exprToString x) ^ \")\"\n| Cosine(x)\t\t-> \"cos(pi*\" ^ (exprToString x) ^ \")\"\n| Average(x1,x2)\t-> \"((\" ^ (exprToString x1) ^ \"+\" ^ (exprToString x2) ^ \")/2)\"\n| Times(x1,x2)\t\t-> (exprToString x1) ^ \"*\" ^ (exprToString x2)\n| Thresh(x1,x2,x3,x4)\t-> \"(\" ^ (exprToString x1) ^ \"<\" ^ (exprToString x2) \n^ \"?\" ^ (exprToString x3) ^ \":\" ^ (exprToString x4) ^ \")\"\n| CosE(x1,x2,x3)\t-> \"cos(pi*\" ^ (exprToString x1) ^ \"*\" ^ (exprToString x2) ^ \")e^(-pi*\" \n^ (exprToString x3) ^ \"^2)\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type expr but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      if (eval (x1, x, y)) < (eval (x2, x, y))\n      then eval (x3, x, y)\n      else eval (x4, x, y)\n  | CosE (x1,x2,x3) ->\n      (cos ((pi *. (eval (x1, x, y))) *. (eval (x2, x, y)))) *.\n        (e ** ((- pi) *. ((eval (x3, x, y)) ** 2.)));;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr;;\n\nlet e_num = 2.718281828;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      if (eval (x1, x, y)) < (eval (x2, x, y))\n      then eval (x3, x, y)\n      else eval (x4, x, y)\n  | CosE (x1,x2,x3) ->\n      (cos ((pi *. (eval (x1, x, y))) *. (eval (x2, x, y)))) *.\n        (e_num ** ((- pi) *. ((eval (x3, x, y)) ** 2.)));;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value doRandomGray\n", "Error: Unbound value buildX\nHint: Did you mean build?\n", "Error: Unbound value doRandomGray\n"], "bad": ["\nlet g3 = (12, 1219, 5301);;\n\nlet _ = doRandomGray g3;;\n", "\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (5, 8) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 -> buildSine (build (rand, (depth - 1)))\n       | 6 -> buildCosine (build (rand, (depth - 1)))\n       | 7 ->\n           buildCosE\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))));;\n", "\nlet g3 = (12, 1219, 5301);;\n\nlet _ = doRandomGray g3;;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: Unbound value doRandomGray\n", "Error: Unbound value doRandomGray\n", "Error: Unbound constructor VarX\n"], "bad": ["\nlet g3 = (10, 1219, 5301);;\n\nlet _ = doRandomGray g3;;\n", "\nlet g3 = (10, 1219, 5301);;\n\nlet _ = doRandomGray g3;;\n", "\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      if (eval (x1, x, y)) < (eval (x2, x, y))\n      then eval (x3, x, y)\n      else eval (x4, x, y)\n  | CosE (x1,x2,x3) ->\n      (cos ((pi *. (eval (x1, x, y))) +. (eval (x2, x, y)))) *.\n        (e_num ** ((-. pi) *. ((eval (x3, x, y)) ** 2.)));;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value doRandomGray\n"], "bad": ["\nlet g3 = (10, 1219, 5301);;\n\nlet _ = doRandomGray g3;;\n"]}
{"fix": [], "hw": "hw2", "problem": "expr", "message": ["Error: Unbound value doRandomGray\n"], "bad": ["\nlet g3 = (10, 1219, 5301);;\n\nlet _ = doRandomGray g3;;\n"]}
{"fix": ["let rec assoc (d,k,l) = match l with\n| []        -> d\n| (n,v)::t  -> if k = n \nthen v\nelse assoc (d,k,t)"], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value doRandomGray\n"], "bad": ["\nlet g3 = (10, 2, 6);;\n\nlet _ = doRandomGray g3;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value a\n", "Error: Unbound value x\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value base\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = base in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x (a) in\nlet base = () in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value a\n", "Error: Unbound value x\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base = a in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base = f in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x (a ) in\nlet base = fun x->x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: Unbound value p\n", "Error: This expression has type 'a but an expression was expected of type\n         'a -> 'b\n       The type variable 'a occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = 0 (+) in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = 0 (+) in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x (a p) in let base = p in List.fold_left f base fs;;\n", "\nlet pipe fs p =\n  let f a x = x (a p) in let base = p in List.fold_left f base fs;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sepConcat sep t  in\nlet base = h in\nlet l =  t in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ sep in\n      let base = h in let l = sepConcat sep t in List.fold_left f base l;;\n"]}
{"fix": ["let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l) ) ^ \"]\""], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ (sepConcat sep t)) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" List.map f l) ^ \"]\");;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ (sepConcat sep t)) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" List.map f l) ^ \"]\");;\n"]}
{"fix": ["let rec clone x n = \nmatch n with \n| 0 -> []\n| _ -> x :: (clone x (n-1) )"], "hw": "hw3", "problem": "clone", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: Unbound value helper\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n =\n  let helper = match n with | 0 -> [] | _ -> x :: ((clone x n) - 1) in\n  helper n;;\n", "\nlet rec clone x n =\n  let helper = match n with | 0 -> [] | _ -> x :: (clone x (n - 1)) in\n  helper n;;\n", "\nlet rec clone x n =\n  let helper = match n with | 0 -> [] | _ -> x :: ((helper n) - 1) in\n  helper n;;\n", "\nlet rec clone x n =\n  let rec helper = match n with | 0 -> [] | _ -> x :: ((helper n) - 1) in\n  helper n;;\n", "\nlet rec clone x n =\n  let rec helper = match n with | 0 -> [] | _ -> x :: ((helper n) - 1) in\n  helper n;;\n", "\nlet rec clone x n =\n  let rec helper = match n with | 0 -> [] | _ -> (helper n) - 1 in helper n;;\n", "\nlet rec clone x n =\n  let rec helper n = match n with | 0 -> [] | _ -> (helper n) - 1 in helper n;;\n", "\nlet rec clone x n = match n with | 0 -> [] | _ -> x :: ((clone x n) - 1);;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (a1,a2) (x1,x2) = ( (x1+x2+a1) / 10, ((x1+x2+a1) mod 10) :: a2 ) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 (l2) ))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  (((clone 0 ((List.length l2) - (List.length l1))) @ l1),\n    ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (a1,a2) (x1,x2) =\n      ((((x1 + x2) + a1) / 10), ((((x1 + x2) + a1) mod 10) :: a2)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev 0) :: l1) ((List.rev 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let rec sumList xs = failwith \"TBD:sumList\""], "hw": "hw1", "problem": "sumList", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec sumList xs = if (xs :: 1) = 1 then 0;;\n", "\nlet rec sumList xs = if (xs :: 1) = 1 then 0;;\n"]}
{"fix": ["let rec sumList xs = failwith \"TBD:sumList\""], "hw": "hw1", "problem": "sumList", "message": ["Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: Unbound value list\n", "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n", "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n", "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n", "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n", "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n", "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n", "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n"], "bad": ["\nlet rec length = function | [] -> 0 | _::l -> 1 + (length l);;\n\nlet rec sumList xs = if (length xs) = 0 then 0;;\n", "\nlet rec length = function | [] -> 0 | _::l -> 1 + (length l);;\n\nlet rec sumList xs = if (length xs) = 0 then xs = 0;;\n", "\nlet rec sumList xs =\n  match list with | [] -> 0 | head::tail -> head + (sumList tail);;\n", "\nlet rec sumList xs =\n  match sumList with | [] -> 0 | head::tail -> head + (sumList tail);;\n", "\nlet rec sumList xs =\n  match sumList with | [] -> 0 | head::tail -> head + (sumList tail);;\n", "\nlet rec sumList xs =\n  match sumList with | [] -> 0 | head::tail -> head + (sumList tail);;\n", "\nlet rec sumList xs =\n  match sumList with | [] -> 0 | head::tail -> head + (sumList tail);;\n", "\nlet rec sumList xs =\n  match sumList with | [] -> 0 | head::tail -> head + (sumList tail);;\n", "\nlet rec sumList xs = match sumList with | head::tail -> head + (sumList tail);;\n", "\nlet rec sumList xs = match sumList with | head::tail -> head + (sumList tail);;\n"]}
{"fix": ["let rec sumList xs = match xs with\n[] -> 0 \n| h::t -> h + sumList t"], "hw": "hw1", "problem": "sumList", "message": ["Error: Unbound value h\n", "Error: Unbound value int\n", "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n", "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n", "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n", "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b -> 'c\n"], "bad": ["\nlet rec sumList xs = h :: t;;\n", "\nlet rec sumList xs = match int with | [] -> 0 | h::t -> h + (sumList t);;\n", "\nlet rec sumList xs = match sumList with | [] -> 0 | h::t -> h + (sumList t);;\n", "\nlet rec sumList xs = match sumList with | h::t -> h + (sumList t);;\n", "\nlet rec sumList xs = match sumList with | [] -> 0 | h::t -> h + (sumList t);;\n", "\nlet rec sumList xs = match sumList with | [] -> 0 | h::t -> h + (sumList t);;\n"]}
{"fix": ["let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n"], "bad": ["\nlet rec digitsOfInt n = if n < 0 then [];;\n", "\nlet rec digitsOfInt n = if n < 0 then [];;\n"]}
{"fix": ["let additivePersistence n = \ndigits n"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: Unbound value x\n", "Error: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n = let digits n = x in sumList x;;\n", "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n = digits n sumList n;;\n"]}
{"fix": ["let additivePersistence n = \nsumList (digits n)"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet additivePersistence n = (digits n) = n;;\n"]}
{"fix": ["let additivePersistence n = failwith \"TBD\""], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type int but an expression was expected of type\n         unit\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         unit\n"], "bad": ["\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n = if (sumList (digits n)) > 9 then 0;;\n", "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet additivePersistence n = sumList (digits n);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n =\n  if (sumList (digits n)) > 9 then additivePersistence (sumList (digits n));;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: This expression has type int but an expression was expected of type\n         unit\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         unit\n", "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int but an expression was expected of type\n         unit\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type int but an expression was expected of type\n         unit\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         unit\n"], "bad": ["\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digitalRoot n = failwith \"TBD\";;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9 then digitalRoot (sumList (digits n));;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9 then digitalRoot (sumList (digits n));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9\n  then digitalRoot (sumList (digits n))\n  else sumList (digits n);;\n", "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digitalRoot n = failwith \"TBD\";;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9 then digitalRoot (sumList (digits n));;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9 then digitalRoot (sumList (digits n));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9\n  then digitalRoot (sumList (digits n))\n  else sumList digits n;;\n", "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digitalRoot n = failwith \"TBD\";;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9 then digitalRoot (sumList (digits n));;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9 then digitalRoot (sumList (digits n));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9\n  then digitalRoot (sumList (digits n))\n  else sumList (digits n);;\n", "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digitalRoot n = failwith \"TBD\";;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9 then digitalRoot (sumList (digits n));;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9 then digitalRoot (sumList (digits n));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9\n  then digitalRoot (sumList (digits n))\n  else sumList (digits n);;\n"]}
{"fix": ["let rec digitalRoot n = \nif sumList (digits n) > 9\nthen digitalRoot (sumList (digits n))\nelse sumList (digits n)"], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digitalRoot n = failwith \"TBD\";;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9 then digitalRoot (sumList (digits n));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet digitalRoot n =\n  if (sumList (digits n)) > 9 then digitalRoot (sumList (digits n));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet digitalRoot n =\n  let x = sumList (digits n) in if x > 9 then digitalRoot x else sumList x;;\n", "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let x = sumList (digits n) in if x > 9 then digitalRoot x else sumList x;;\n"]}
{"fix": ["let listReverse l = \nlet rec aux acc = function\n| [] -> acc\n| h::t -> aux (h::acc) t in\naux [] l"], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value list\n"], "bad": ["\nlet listReverse l =\n  let rec aux acc = function | [] -> acc | h::t -> aux (h :: acc) t in\n  aux [] list;;\n"]}
{"fix": ["let additivePersistence n = \nlet rec helper n count =\nlet rec digitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse count\nin digitalRoot n\nin helper n 0"], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: This expression has type bool but an expression was expected of type\n         int\nError: Unbound value sumList\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type bool but an expression was expected of type\n         int\n"], "bad": ["\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet rec digitalRoot n =\n  if (sumList (digits n)) > 9\n  then digitalRoot (sumList (digits n))\n  else sumList (digits n);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n =\n  let rec helper n count =\n    (digitalRoot n) =\n      (if (sumList (digits n)) > 9\n       then helper (sumList (digits n)) (count + 1)\n       else count) in\n  helper n 0;;\n"]}
{"fix": ["let listReverse l = \nlet rec helper xs = function\n| [] -> []\n| hd::tl -> helper (hd::xs) tl\nin helper [] l"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet listReverse l =\n  let rec helper xs =\n    match xs with | [] -> [] | hd::tl -> helper (hd :: xs) tl in\n  helper [] l;;\n"]}
{"fix": ["let listReverse l = \nlet rec helper xs = function\n| [] -> xs\n| hd::tl -> helper (hd::xs) tl\nin helper [] l"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type 'a list\n"], "bad": ["\nlet listReverse l =\n  let rec helper xs = function | [] -> xs | hd::tl -> helper (hd :: xs) in\n  helper [] l;;\n"]}
{"fix": ["let listReverse l = \nlet rec helper xs l  = match l with\n| [] -> []\n| hd::tl -> helper (hd::xs) l\nin helper [] l"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type 'a list\n", "Error: Unbound value n\n"], "bad": ["\nlet listReverse l =\n  let rec helper xs n = function | [] -> xs | hd::tl -> helper (hd :: xs) tl in\n  helper [] l;;\n", "\nlet listReverse l =\n  let rec helper xs l =\n    match n with | [] -> [] | hd::tl -> helper (hd :: xs) l in\n  helper [] l;;\n"]}
{"fix": ["let listReverse l = reverse [] l"], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value list\n"], "bad": ["\nlet rec reverse res list =\n  match list with | [] -> [] | hd::tl -> reverse (hd :: res) list;;\n\nlet listReverse l = reverse [] list;;\n"]}
{"fix": ["let rec sumList xs = match xs with\n| [] -> 0 \n| h::t -> h + sumList t"], "hw": "hw1", "problem": "sumList", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec mylength xs = match xs with | [] -> 0 | hd::tl -> 1 + (mylength tl);;\n\nlet digitsOfInt n =\n  let rec digits n x list =\n    if n < 10\n    then n :: list\n    else\n      digits ((n / 10) + (n mod 10)) (((mylength n) / 10) + (n mod 10)) list in\n  digits n (mylength n) [];;\n"]}
{"fix": ["let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: \n(digits x/10 l)\nelse numdig :: l\nin digits n []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then ((x / ((10 ** numdig) - 1)) mod 10) :: l\n    else numdig :: 1 in\n  digits n [];;\n", "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then ((x / ((10 ** numdig) - 1)) mod 10) :: l\n    else numdig :: 1 in\n  digits n [];;\n", "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then ((x / (((int_of_float 10) ** numdig) - 1)) mod 10) :: l\n    else numdig :: 1 in\n  digits n [];;\n", "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then ((x / (((float_of_int 10) ** numdig) - 1)) mod 10) :: l\n    else numdig :: 1 in\n  digits n [];;\n", "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then ((x / ((float_of_int 10) ** (float_of_int (numdig - 1)))) mod 10) ::\n      l\n    else numdig :: 1 in\n  digits n [];;\n", "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      ((x / (int_of_float ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n         mod 10)\n      :: l\n    else numdig :: 1 in\n  digits n [];;\n"]}
{"fix": ["let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen match l with\n| [] -> []\n| hd::tl -> \nx/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: \n(digits (x/10) tl)\nelse numdig :: l\nin digits n []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a -> int list\n       but an expression was expected of type int\n"], "bad": ["\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      ((x / (int_of_float ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n         mod 10)\n      :: ((digits x) / (10 l))\n    else numdig :: l in\n  digits n [];;\n"]}
{"fix": ["let digitsOfInt n =\nif n < 10 then n :: []\nelse\n(digitsOfInt (n/10)) @ [n/int_of_float(float_of_int 10 ** float_of_int ((num_of_digits n) -1)) mod 10]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: Unbound value numdig\n", "Error: Unbound value x\nError: Unbound value num_of_digits\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value x\n"], "bad": ["\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      match l with\n      | hd::tl ->\n          ((x /\n              (int_of_float\n                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n             mod 10)\n          :: (digits (x / 10) tl)\n    else numdig :: l in\n  digits n [];;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    [(digitsOfInt n) / 10;\n    (n / (int_of_float ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n      mod 10];;\n", "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      match l with\n      | hd::tl ->\n          ((x /\n              (int_of_float\n                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n             mod 10)\n          :: (digits (x / 10) tl)\n    else numdig :: l in\n  digits n [];;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    [digitsOfInt (n / 10);\n    (n / (int_of_float ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n      mod 10];;\n", "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      match l with\n      | hd::tl ->\n          ((x /\n              (int_of_float\n                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n             mod 10)\n          :: (digits (x / 10) tl)\n    else numdig :: l in\n  digits n [];;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    (digitsOfInt (n / 10)) @\n      [(n / (int_of_float ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n         mod 10];;\n", "\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      match l with\n      | hd::tl ->\n          ((x /\n              (int_of_float\n                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n             mod 10)\n          :: (digits (x / 10) tl)\n    else numdig :: l in\n  digits n [];;\n\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    (digitsOfInt (n / 10)) @\n      [(n /\n          (int_of_float\n             ((float_of_int 10) ** (float_of_int ((num_of_digits x) - 1)))))\n         mod 10];;\n"]}
{"fix": ["let digitsOfInt n =\nlet rec recurse x l =\nif x < 10 then x :: l\nelse\nrecurse (x/10) [x mod 10]\nin recurse n []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value num_of_digits\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       but an expression was expected of type int\n", "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\nError: Unbound value num_of_digits\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value num_of_digits\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      match l with\n      | hd::tl ->\n          ((x /\n              (int_of_float\n                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n             mod 10)\n          :: (digits (x / 10) tl)\n    else numdig :: l in\n  digits n [];;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    (digitsOfInt (n / 10)) @\n      [(n /\n          (int_of_float\n             ((float_of_int 10) ** (float_of_int ((num_of_digits n) - 1)))))\n         mod 10];;\n\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    (digitsOfInt (n / 10)) @\n      [(n /\n          (int_of_float\n             ((float_of_int 10) ** (float_of_int ((num_of_digits n) - 1)))))\n         mod 10];;\n\nlet digitsOfInt n =\n  if n < 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digitsOfInt n = if n < 10 then [n] else [digitsOfInt (n / 10); n mod 10];;\n", "\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      match l with\n      | hd::tl ->\n          ((x /\n              (int_of_float\n                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n             mod 10)\n          :: (digits (x / 10) tl)\n    else numdig :: l in\n  digits n [];;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    (digitsOfInt (n / 10)) @\n      [(n /\n          (int_of_float\n             ((float_of_int 10) ** (float_of_int ((num_of_digits n) - 1)))))\n         mod 10];;\n\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    (digitsOfInt (n / 10)) @\n      [(n /\n          (int_of_float\n             ((float_of_int 10) ** (float_of_int ((num_of_digits n) - 1)))))\n         mod 10];;\n\nlet digitsOfInt n =\n  if n < 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else (match n with | hd::tl -> [hd (digitsOfInt (n / 10)); n mod 10]);;\n", "\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      match l with\n      | hd::tl ->\n          ((x /\n              (int_of_float\n                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n             mod 10)\n          :: (digits (x / 10) tl)\n    else numdig :: l in\n  digits n [];;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    (digitsOfInt (n / 10)) @\n      [(n /\n          (int_of_float\n             ((float_of_int 10) ** (float_of_int ((num_of_digits n) - 1)))))\n         mod 10];;\n\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    (digitsOfInt (n / 10)) @\n      [(n /\n          (int_of_float\n             ((float_of_int 10) ** (float_of_int ((num_of_digits n) - 1)))))\n         mod 10];;\n\nlet digitsOfInt n =\n  if n < 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digitsOfInt n = if n < 10 then [n] else [digitsOfInt (n / 10); n mod 10];;\n"]}
{"fix": ["let listReverse l = \nlet rec recurse x xs = match x with\n| [] -> xs\n| hd::tl -> recurse tl (hd::xs)\nin recurse l []"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet listReverse l =\n  let rec recurse x xs =\n    match x with | [] -> [] | hd::tl -> (recurse tl hd) :: xs in\n  recurse l [];;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen)\nthen (h :: seen)\nelse seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type unit\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"]}
{"fix": ["let buildX()                       = VarX"], "hw": "hw2", "problem": "build", "message": ["Error: This variant pattern is expected to have type expr\n       The constructor None does not belong to type expr\n", "Error: This expression has type expr * expr * expr * expr -> expr\n       but an expression was expected of type expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> exprToString buildThresh (a, b, c, d)\n  | Times (a,b) -> exprToString buildTimes (a, b)\n  | Average (a,b) -> exprToString buildAverage (a, b)\n  | Cosine a -> exprToString buildCosine a\n  | Sine a -> exprToString buildSine a\n  | VarY  -> exprToString buildY\n  | VarX  -> exprToString buildX\n  | None  -> 0;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> exprToString buildThresh (a, b, c, d)\n  | Times (a,b) -> exprToString buildTimes (a, b)\n  | Average (a,b) -> exprToString buildAverage (a, b)\n  | Cosine a -> exprToString buildCosine a\n  | Sine a -> exprToString buildSine a\n  | VarY  -> exprToString buildY\n  | VarX  -> exprToString buildX;;\n"]}
{"fix": ["let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> let e' = buildThresh(a,b,c,d) in exprToString e'\n| Times (a,b) -> let e' = buildTimes(a,b) in exprToString e'\n| Average (a,b) -> let e' = buildAverage(a,b) in exprToString e'\n| Cosine (a) -> let e' = buildCosine(a) in exprToString e'\n| Sine (a) -> let e' = buildSine(a) in exprToString e'\n| VarY -> exprToString VarX\n| VarX -> exprToString VarY"], "hw": "hw2", "problem": "build", "message": ["Error: This function has type expr -> 'a * 'b * 'c * 'd\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: The constructor Thresh expects 4 argument(s),\n       but is applied here to 0 argument(s)\n", "Error: The constructor Thresh expects 4 argument(s),\n       but is applied here to 0 argument(s)\n", "Error: This expression has type expr * expr * expr * expr -> expr\n       but an expression was expected of type expr\n", "Error: This expression has type expr * expr -> expr\n       but an expression was expected of type expr\n", "Error: This expression has type unit -> expr\n       but an expression was expected of type expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> ((exprToString Thresh a), b, c, d)\n  | Times (a,b) -> exprToString buildTimes (a, b)\n  | Average (a,b) -> exprToString buildAverage (a, b)\n  | Cosine a -> exprToString buildCosine a\n  | Sine a -> exprToString buildSine a\n  | VarY  -> exprToString buildY\n  | VarX  -> exprToString buildX;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> exprToString Thresh (a, b, c, d)\n  | Times (a,b) -> exprToString buildTimes (a, b)\n  | Average (a,b) -> exprToString buildAverage (a, b)\n  | Cosine a -> exprToString buildCosine a\n  | Sine a -> exprToString buildSine a\n  | VarY  -> exprToString buildY\n  | VarX  -> exprToString buildX;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> exprToString Thresh (((a * b) * c) * d)\n  | Times (a,b) -> exprToString buildTimes (a, b)\n  | Average (a,b) -> exprToString buildAverage (a, b)\n  | Cosine a -> exprToString buildCosine a\n  | Sine a -> exprToString buildSine a\n  | VarY  -> exprToString buildY\n  | VarX  -> exprToString buildX;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> exprToString buildThresh (a, b, c, d)\n  | Times (a,b) -> exprToString buildTimes (a, b)\n  | Average (a,b) -> exprToString buildAverage (a, b)\n  | Cosine a -> exprToString buildCosine a\n  | Sine a -> exprToString buildSine a\n  | VarY  -> exprToString buildY\n  | VarX  -> exprToString buildX;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> let a = buildThresh (a, b, c, d) in exprToString a\n  | Times (a,b) -> exprToString buildTimes (a, b)\n  | Average (a,b) -> exprToString buildAverage (a, b)\n  | Cosine a -> exprToString buildCosine a\n  | Sine a -> exprToString buildSine a\n  | VarY  -> exprToString buildY\n  | VarX  -> exprToString buildX;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> let e' = buildThresh (a, b, c, d) in exprToString e'\n  | Times (a,b) -> let e' = buildTimes (a, b) in exprToString e'\n  | Average (a,b) -> let e' = buildAverage (a, b) in exprToString e'\n  | Cosine a -> let e' = buildCosine a in exprToString e'\n  | Sine a -> let e' = buildSine a in exprToString e'\n  | VarY  -> exprToString buildY\n  | VarX  -> exprToString buildX;;\n"]}
{"fix": [], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ ((\"+\" exprToString b) ^ \")/20\"))\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | VarY  -> \"x\"\n  | VarX  -> \"y\";;\n"]}
{"fix": ["let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b ^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d ^ \")\"\n| Times (a,b) -> exprToString a ^ \"*\" ^ exprToString b\n| Average (a,b) -> \"((\" ^ exprToString a ^ \"+\" ^ exprToString b ^ \")/20\"\n| Cosine (a) -> \"cos(pi*\" ^ exprToString a ^ \")\"\n| Sine (a) -> \"sin(pi*\" ^ exprToString a ^ \")\"\n| VarY -> \"y\"\n| VarX -> \"x\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ ((\"+\" exprToString b) ^ \")/20\"))\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | VarY  -> \"x\"\n  | VarX  -> \"y\";;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y)) /. 2.0\n| Cosine (a) -> cos( pi ** (eval (a,x,y)))\n| Sine (a) -> sin (pi ** eval (a,x,y) )\n| VarY ->  y\n| VarX ->  x"], "hw": "hw2", "problem": "eval", "message": ["Error: Unbound value t\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This function has type float -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type float -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type\n         expr * 'a * 'b -> (float -> float -> float) -> 'c -> 'd -> 'e\n       but an expression was expected of type 'c\n       The type variable 'c occurs inside\n       expr * 'a * 'b -> (float -> float -> float) -> 'c -> 'd -> 'e\n", "Error: This expression has type (float -> float -> float) -> 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside\n       (float -> float -> float) -> 'a -> 'b\n", "Error: This function has type expr * 'a * 'b -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, t))) / 2\n  | Cosine a -> cos (pi * (eval (a, x, y)))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, y))) / 2\n  | Cosine a -> cos (pi * (eval (a, x, y)))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, y))) / 2\n  | Cosine a -> cos (pi * (eval (a, x, y)))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> float_of_int x\n  | VarX  -> float_of_int y;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, y))) / 2\n  | Cosine a -> cos (pi * (float_of_int eval (a, x, y)))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, y))) / 2\n  | Cosine a -> cos (pi * (float_of_int (eval (a, x, y))))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, y))) / 2\n  | Cosine a -> int_of_float cos (pi * (float_of_int (eval (a, x, y))))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, y))) / 2\n  | Cosine a -> int_of_float cos (pi * (float_of_int (eval (a, x, y))))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, y))) / 2\n  | Cosine a -> cos (pi * (float_of_int (eval (a, x, y))))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, y))) / 2\n  | Cosine a -> cos (pi * pi)\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, y))) / 2\n  | Cosine a -> cos pi\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> eval (a, x, y) ( *. ) eval (b, x, y)\n  | Average (a,b) -> (eval (a, x, y) ( *. ) eval (b, x, y)) / 2\n  | Cosine a -> cos (pi * (float_of_int (eval (a, x, y))))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) ( *. ) (eval (b, x, y))\n  | Average (a,b) -> (eval (a, x, y) ( *. ) eval (b, x, y)) / 2\n  | Cosine a -> cos (pi * (float_of_int (eval (a, x, y))))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> (eval (a, x, y) ( *. ) eval (b, x, y)) / 2\n  | Cosine a -> cos (pi * (float_of_int (eval (a, x, y))))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) / 2\n  | Cosine a -> cos (pi * (float_of_int (eval (a, x, y))))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi * (float_of_int (eval (a, x, y))))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi * (eval (a, x, y)))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n"]}
{"fix": ["let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value b'\n"], "bad": ["\nlet rec wwhile (f,b) =\n  if (f b) = (b', c') then wwhile (f, b) else wwhile (f, b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value eval\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n", "\nlet fixpoint (f,b) = ((wwhile (b = (f b))), b);;\n", "\nlet fixpoint (f,b) = wwhile (f, b);;\n", "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet fixpoint (f,b) = ((wwhile (fixpoint (f, (f b)))), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ( (fun x -> \nlet a = (f x) \nin (a, a!=x) ),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) = wwhile ((fun x  -> let xx = f x in (xx, (xx != xx))), b);;\n", "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "\nlet fixpoint (f,b) = wwhile ((fun x  -> let xx = f x in (xx, (xx != x))), b);;\n", "\nlet fixpoint (f,b) = wwhile ((fun x  -> let xx = f x in (xx, (xx != x))), b);;\n"]}
{"fix": ["let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value doRandomGray\n"], "bad": ["\nlet _ = doRandomGray (10, 10, 34);;\n"]}
{"fix": ["let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value doRandomGray\n", "Error: Unbound value doRandomGray\n"], "bad": ["\nlet _ = doRandomGray (10, 11, 34);;\n", "\nlet _ = doRandomGray (10, 11, 34);;\n"]}
{"fix": ["let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value doRandomColor\n", "Error: Unbound value doRandomColor\n", "Error: Unbound value doRandomColor\n", "Error: Unbound value buildX\nHint: Did you mean build?\n", "Error: Unbound value buildY\nHint: Did you mean build?\n", "Error: Unbound value buildY\nHint: Did you mean build?\n", "Error: Unbound value buildY\nHint: Did you mean build?\n", "Error: Unbound value buildY\nHint: Did you mean build?\n", "Error: Unbound value doRandomColor\n"], "bad": ["\nlet _ = doRandomColor (8, 2, 25);;\n", "\nlet _ = doRandomColor (10, 11, 34);;\n", "\nlet _ = doRandomColor (5, 2, 10);;\n", "\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (1, 3) in match x with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 9 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 3) in\n    match x with\n    | 0 -> buildY ()\n    | 1 -> buildX ()\n    | 2 -> buildY ()\n    | 3 -> buildX ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 9 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1|2|3 -> buildY () | 1 -> buildX ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 9 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1|3|5|7|9 -> buildY () | 2|4|6|8|10 -> buildX ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 9 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1|3|5|7|9 -> buildY () | 2|4|6|8|10|0 -> buildX ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 9 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "\nlet _ = doRandomColor (5, 2, 10);;\n"]}
{"fix": ["let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value doRandomColor\n", "Error: Only character intervals are supported in patterns.\n"], "bad": ["\nlet _ = doRandomColor (3, 19, 25);;\n", "\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1..5 -> buildY () | 6..10 -> buildX ()\n  else\n    (let x = rand (1, 10) in\n     match x with\n     | 6|1 -> buildSine (build (rand, (depth - 1)))\n     | 7|2 -> buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"]}
{"fix": ["let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value seed1\n"], "bad": ["\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  Format.printf \"red   = %s \\n\" (exprToString e1);;\n"]}
{"fix": ["let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value doRandomColor\n", "Error: Unbound value buildY\nHint: Did you mean build?\n"], "bad": ["\nlet _ = doRandomColor (8, 5, 25);;\n", "\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (1, 10) in (if x < 5 then buildY () else buildX ())\n  else\n    (let x = rand (1, 10) in\n     match x with\n     | 6|1 -> buildSine (build (rand, (depth - 1)))\n     | 7|2 -> buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x\n  | Abs a ->\n      if (eval (a, x, y)) < 0\n      then (eval (a, x, y)) *. (-1.0)\n      else eval (a, x, y);;\n"]}
{"fix": ["let rec assoc (d,k,l) = match l with\n| [] -> a\n| (n,v)::t -> \nif n = k then v\nelse assoc (d,k,t)"], "hw": "hw2", "problem": "assoc", "message": ["Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a * 'b) list\n"], "bad": ["\nlet rec assoc (d,k,l) =\n  let rec helper (a,b,c) =\n    match c with\n    | [] -> a\n    | (n,v)::t -> if n = c then v else helper (a, b, t) in\n  helper (d, k, l);;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value a\n"], "bad": ["\nlet rec assoc (d,k,l) =\n  match l with | [] -> a | (n,v)::t -> if n = k then v else assoc (d, k, t);;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a*a + x in\nlet base = 0 in\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = [] in List.fold_left f base xs;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a*a + x in\nlet base = 0 in\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type int but an expression was expected of type\n         string\n", "Error: This expression has type int but an expression was expected of type\n         ('a, 'b, 'c, 'd, 'e, 'f) format6 =\n           ('a, 'b, 'c, 'd, 'e, 'f) CamlinternalFormatBasics.format6\n"], "bad": ["\nlet sqsum xs =\n  let f a x = (a ** 2) + x in let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = a ^ (2 + x) in let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = a ^^ (2 + x) in let base = 0 in List.fold_left f base xs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = match x with\n| x::xs' -> x a\nin\nlet base = (fun _ x -> x) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type int but an expression was expected of type\n         'a -> 'a\n"], "bad": ["\nlet pipe fs =\n  let f a x = match x with | [] -> (fun b  -> b) in\n  let base = 0 in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = (fun y -> a x)in\nlet base = (fun y -> y) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'a -> 'c -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'c -> 'b\n"], "bad": ["\nlet pipe fs =\n  let f a x b c = a x in let base y = y in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = ( fun c -> x ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: Unbound value y\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base y = y in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x c = y in let base b = b in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = ( fun y -> a (x y) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value f\n", "Error: Unbound value f\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'a -> 'c -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'c -> 'b\n", "Error: Unbound value f\n"], "bad": ["\nlet pipe fs =\n  let f a x c = f a x in let base b = b in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x c = f (a x) in let base b = b in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x c d = a x in let base b = b in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x x = f (g x) in let base b = b in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = ( fun y -> a (x y) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'c -> ('c -> 'a) -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'c -> 'a -> 'b\n       The type variable 'a occurs inside 'c -> 'a\n"], "bad": ["\nlet pipe fs =\n  let f a x y = a (y x) in let base b = b in List.fold_left f base fs;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: Unbound value cc\n", "Error: This expression has type string but an expression was expected of type\n         string -> string -> string\n", "Error: This expression has type string -> string -> string\n       but an expression was expected of type string\n", "Error: This expression has type string but an expression was expected of type\n         string -> string -> string\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x acc x = x ^ cc in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x acc x = x ^ acc in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x acc x = x ^ acc in\n      let base = h in let l = t in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x acc x = x ^ acc in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n"]}
{"fix": ["let stringOfList f l = \n\"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\""], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f (sepConcat \";\") l;;\n"]}
{"fix": ["let rec clone x n = match n with\n| 0 -> []\n| _ -> clone x (n-1) @ [x]"], "hw": "hw3", "problem": "clone", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec clone x n = match n with | 0 -> [] | _ -> [clone x (n - 1); h];;\n", "\nlet rec clone x n = match n with | 0 -> [] | _ -> [clone x (n - 1); x];;\n", "\nlet rec clone x n = match n with | 0 -> [] | 1 -> [clone x (n - 1); x];;\n"]}
{"fix": ["let rec removeZero l = match l with\n| [] -> l\n| h::t ->\nif h = 0 \nthen removeZero t\nelse l"], "hw": "hw3", "problem": "removeZero", "message": ["Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type 'a list\n       but an expression was expected of type unit\n"], "bad": ["\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t;;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t;;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a -> 'a list -> 'a list\n       but an expression was expected of type 'a -> 'a list -> 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This expression has type int list\n       but an expression was expected of type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor false does not belong to type unit\n", "Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type int list list * int list list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list list * int list list\n       but an expression was expected of type unit\n", "Error: This expression has type int list list * int list list\n       but an expression was expected of type 'a list\n", "Error: This expression has type int list list * int list list\n       but an expression was expected of type 'a list\n", "Error: This expression has type int list list * int list list\n       but an expression was expected of type int list\n", "Error: This expression has type int but an expression was expected of type\n         unit\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a -> 'a list -> 'a list\n       but an expression was expected of type 'a -> 'a list -> 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n"], "bad": ["\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a :: x in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if t1 + t2 then [t1 + t2] in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (t1 + t2) > 9 then [t1 + t2] in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then [h1 + h2] in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then [] in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then [1 + h1] @ a in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then [1 + h1] @ a in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then false in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> 0\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then 9 in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then x a in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> a\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then x in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> a\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then a @ x in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> 0\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then a @ x in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> 0 :: a\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then a @ x in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> 0 | h::t -> if h > 9 then 8 in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + (x * x) in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a :: x in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x :: a in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value h\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This expression has type int but an expression was expected of type\n         unit\n"], "bad": ["\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let a = h :: t in\n      match x with\n      | (x1,x2) ->\n          if ((x1 + x2) + h) > 9 then 1 :: (h = ((x1 + x2) + (h mod 10))) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | (h::t,(x1,x2)) ->\n          if ((x1 + x2) + h) > 9 then 1 :: (h = ((x1 + x2) + (h mod 10))) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | (h::t,(x1,x2)) ->\n          if ((x1 + x2) + h) > 9 then 1 :: ((x1 + x2) + (h mod 10)) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | (h::t,(x1,x2)) ->\n          if ((x1 + x2) + h) > 9 then 1 :: ((x1 + x2) + (h mod 10)) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | (h::t,(x1,x2)::t2) ->\n          if ((x1 + x2) + h) > 9 then 1 :: ((x1 + x2) + (h mod 10)) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with | (h::t,(x1,x2)::t2) -> if ((x1 + x2) + h) > 9 then 9 in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nlet carry =\nmatch a with\n| (x,y) -> x in\nmatch x with\n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n", "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: Variable h1 is bound several times in this matching\n", "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"], "bad": ["\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | h::t -> [] in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | h -> [] in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h1) -> [] in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> [] in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> (h2, h1) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> [h2] in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> [h2] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  f + g + carry mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n", "Error: Unbound value t\n", "Error: This expression has type int * 'a list\n       but an expression was expected of type int * int\n       Type 'a list is not compatible with type int \n", "Error: This expression has type int * 'a list -> int * int -> int * int\n       but an expression was expected of type\n         int * 'a list -> int * int -> int * 'a list\n       Type int is not compatible with type 'a list \n", "Error: This expression has type int * 'a list\n       but an expression was expected of type int * int\n       Type 'a list is not compatible with type int \n", "Error: Unbound value newcarry\nHint: Did you mean carry?\n"], "bad": ["\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let digit =\n        match x with\n        | (f,g)::t ->\n            if ((f + g) + carry) > 9\n            then (1, (((f + g) + (carry mod 10)) :: t))\n            else (0, (((f + g) + (carry mod 10)) :: t)) in\n      digit in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let digit =\n        match x with\n        | (f,g) ->\n            if ((f + g) + carry) > 9\n            then (1, (((f + g) + (carry mod 10)) :: t))\n            else (0, (((f + g) + (carry mod 10)) :: t)) in\n      digit in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let digit =\n        match x with\n        | (f,g) ->\n            if ((f + g) + carry) > 9\n            then (1, ((f + g) + (carry mod 10)))\n            else (0, ((f + g) + (carry mod 10))) in\n      digit in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g::[]) -> f in\n      let digit =\n        match x with\n        | (f,g) ->\n            if ((f + g) + carry) > 9\n            then (1, ((f + g) + (carry mod 10)))\n            else (0, ((f + g) + (carry mod 10))) in\n      digit in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let digit =\n        match x with\n        | (f,g) ->\n            if ((f + g) + carry) > 9\n            then (1, ((f + g) + (carry mod 10)))\n            else (0, ((f + g) + (carry mod 10))) in\n      digit in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> (f + g) + (carry mod 10) in\n      match a with | (o,p) -> (newcarry, (digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int * int\n"], "bad": ["\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit =\n        match x with | (f,g) -> ((f + g) + carry) mod 10 | [] -> carry in\n      match a with | (o,p) -> (newc, (digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let rec mulByDigit i l = \nif i = 0 then l\nelse\nlet a = i :: [] in\nbigAdd (mulByDigit (i-1) l) (mulByDigit (i-1) l)"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then l\n  else\n    (let a = [i] in bigAdd ((mulByDigit i) - (1 l)) ((mulByDigit i) - (1 l)));;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = match a with\n| (_,y) -> (0, bigAdd y x) in\nlet base = (0,[]) in\nlet args = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h b) :: acc) a t\nin\nconstructargs [] l1 (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"], "bad": ["\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd a x in\n  let base = [] in\n  let args =\n    let rec constructargs acc a b =\n      match b with\n      | [] -> acc\n      | h::t -> constructargs ((mulByDigit h b) :: acc) a t in\n    constructargs [] l1 (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,y) -> (0, (bigAdd a x)) in\n  let base = (0, []) in\n  let args =\n    let rec constructargs acc a b =\n      match b with\n      | [] -> acc\n      | h::t -> constructargs ((mulByDigit h b) :: acc) a t in\n    constructargs [] l1 (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let unzeroed = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h a) :: acc) a t\nin\nconstructargs [] [1;2;3] (List.rev [4;5;6])\nin \nlet rec addZeroes num somelist = match num with\n| 0 -> somelist \n| _ -> addZeroes (num-1) (List.append somelist [0])\nin\nlet rec addZeroesWhole acc a = match a with\n| [] -> acc\n| h::t -> addZeroesWhole ( (addZeroes (List.length t) h) :: acc ) t\nin\naddZeroesWhole [] unzeroed"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet _ =\n  let unzeroed =\n    let rec constructargs acc a b =\n      match b with\n      | [] -> acc\n      | h::t -> constructargs ((mulByDigit h a) :: acc) a t in\n    constructargs [] [1; 2; 3] (List.rev [4; 5; 6]) in\n  let rec addZeroes num somelist =\n    match num with\n    | 0 -> somelist\n    | _ -> addZeroes (num - 1) (List.append somelist 0) in\n  let rec addZeroesWhole acc a =\n    match a with\n    | [] -> acc\n    | h::t -> addZeroesWhole ((addZeroes (List.length t) h) :: acc) t in\n  addZeroesWhole [] unzeroed;;\n"]}
{"fix": ["let rec mulByDigit i l = \nif i <= 0 then [0] else\nif i = 1 then l\nelse\nbigAdd (mulByDigit (i-1) l)  l"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then 0 else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n"]}
{"fix": ["let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x :: xs' -> x + sumList xs'"], "hw": "hw1", "problem": "sumList", "message": ["Error: Unbound value sum\n", "Error: Unbound value sum\n"], "bad": ["\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sum xs');;\n", "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sum xs');;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n < 0 then []\nelse let x = n/10 and y = n mod 10\nin digitsOfInt x @ [y]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (let x = n / 10\n        and y = n mod 10 in (digitsOfInt x) @ y);;\n"]}
{"fix": ["let x = sumList (digitsOfInt 10)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList digitsOfInt 10;;\n", "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList digitsOfInt 10;;\n"]}
{"fix": ["let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse l'"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l =\n  match l with | [] -> 0 | x::l' -> (listReverse l') @ [x];;\n", "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l =\n  match l with | [] -> 0 | x::l' -> (listReverse [l']) @ [x];;\n", "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l =\n  match l with | [] -> 0 | x::l' -> (listReverse [l']) @ [x];;\n"]}
{"fix": ["let rec listReverse l = \nmatch l with\n| [] -> []\n| head::tail -> listReverse tail @ head"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l =\n  match l with | [] -> 0 | x::l' -> (listReverse l') :: x;;\n", "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l = match l with | [] -> 0 | x::l' -> [listReverse l'; x];;\n", "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l = match l with | [] -> 0 | x::xl -> [listReverse x];;\n", "\nlet rec listReverse l = match l with | [] -> 0 | x::xl -> [listReverse xl];;\n", "\nlet rec listReverse l = match l with | [] -> 0 | head::tail -> tail;;\n", "\nlet rec listReverse l = match l with | [] -> 0 | head::tail -> tail;;\n"]}
{"fix": ["let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] ->[x]\n| head::tail -> listReverse tail @ [head]"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail -> (listReverse tail) @ head;;\n"]}
{"fix": ["let palindrome w = \n(listReverse (explode w))"], "hw": "hw1", "problem": "palindrome", "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type string but an expression was expected of type\n         char list\n"], "bad": ["\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail -> (listReverse tail) @ [head];;\n\nlet palindrome w = if (listReverse explode w) = w then true else false;;\n", "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail -> (listReverse tail) @ [head];;\n\nlet palindrome w = if (listReverse (explode w)) = w then true else false;;\n"]}
{"fix": ["let palindrome w = \nif (listReverse (explode w)) = explode w then true\nelse false"], "hw": "hw1", "problem": "palindrome", "message": ["Error: This expression has type string but an expression was expected of type\n         char list\n"], "bad": ["\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail -> (listReverse tail) @ [head];;\n\nlet palindrome w = if (listReverse (explode w)) = w then 1 else 0;;\n"]}
{"fix": [], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list list\n       but an expression was expected of type 'a list\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec listReverse l =\n  match l with\n  | _ -> []\n  | x -> [x]\n  | head::tail -> (listReverse tail) :: head;;\n", "\nlet x = 123;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0) then [] else (digitsOfInt x) @ [y]);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet x = sumList (digitsOfInt 30);;\n\nlet rec listReverse l =\n  match l with | x::[] -> x | head::tail -> [listReverse tail; head];;\n"]}
{"fix": ["let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::third -> head::[tail]"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet x = [1; 2; 3];;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail::t::s -> s :: t :: tail :: head;;\n", "\nlet x = [1; 2; 3];;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail::t::s -> s :: t :: tail :: head;;\n", "\nlet x = [1; 2; 3];;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail::t::s::l -> s :: t :: tail :: head;;\n", "\nlet x = [1; 2; 3];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::[] -> [x] | head::tail::third -> head :: tail;;\n"]}
{"fix": ["let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::third::fourth::fifth -> fourth::third::tail::[head]"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet x = [1; 2; 3];;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail::third::fourth -> [fourth; third; tail; head];;\n"]}
{"fix": ["let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail -> head::listReverse tail"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet x = [1; 2; 3];;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | x::[] -> [x]\n  | head::tail -> head :: (listReverse tail) :: tail;;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverseInt n 0/10 \nand y = reverseInt n 0 mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value m\n", "Error: Unbound value m\n", "Error: Unbound value m\n", "Error: Unbound value m\n", "Error: Unbound value m\n", "Error: This expression has type int -> int\n       but an expression was expected of type int\n", "Error: This expression has type int -> int\n       but an expression was expected of type int\n", "Error: This expression has type int -> int\n       but an expression was expected of type int\n"], "bad": ["\nlet listReverse l =\n  let rec helper l a =\n    match l with | [] -> a | head::tail -> helper tail (head :: a) in\n  helper l [];;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = n / 10\n     and y = n mod 10 in\n     if (x = 0) && (y = 0)\n     then []\n     else (let result = y :: (digitsOfInt x) in listReverse result));;\n\nlet _ =\n  let x = m / 10\n  and y = m mod 10 in if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x);;\n", "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let m = n\n     and x = m / 10\n     and y = m mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let m = n\n     and x = m / 10\n     and y = m mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let m = n\n     and x = m / 10\n     and y = m mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "\nlet rec reverseInt x y =\n  if x != 0 then reverseInt (x / 10) ((y * 10) + (10 mod 10)) else y;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let m = reverseInt n\n     and x = m / 10\n     and y = m mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "\nlet rec reverseInt x y =\n  if x != 0 then reverseInt (x / 10) ((y * 10) + (10 mod 10)) else y;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let m = reverseInt n in\n     let x = m / 10\n     and y = m mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "\nlet rec reverseInt x y =\n  if x != 0 then reverseInt (x / 10) ((y * 10) + (10 mod 10)) else y;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = (reverseInt n) / 10\n     and y = (reverseInt n) mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "\nlet rec reverseInt x y =\n  if x != 0 then reverseInt (x / 10) ((y * 10) + (10 mod 10)) else y;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = (reverseInt n 0) / 10\n     and y = (reverseInt n) mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverse (string_of_int n) \nand y= x /10 \nand z = x mod 10 in \nif y = 0 && z = 0 then []\nelse z::digitsOfInt y"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type string but an expression was expected of type\n         int\n"], "bad": ["\nlet x = \"13\";;\n\nlet _ = string_of_int x;;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n < 0 then [];\nif z = 0 then \nlet s = reverse (string_of_int n) in\nlet n2 = int_of_string s then z++ in\ndigitsOfInt n2;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type string but an expression was expected of type\n         int\nError: Unbound value x\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type string but an expression was expected of type\n         int\n", "Error: This expression has type string but an expression was expected of type\n         int\nError: Unbound value x\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type string but an expression was expected of type\n         int\n", "Error: This expression has type string but an expression was expected of type\n         int\nError: Unbound value x\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type string but an expression was expected of type\n         int\n", "Error: This expression has type string but an expression was expected of type\n         int\nError: Unbound value x\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type string but an expression was expected of type\n         int\n", "Error: This expression has type string but an expression was expected of type\n         int\nError: Unbound value x\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type string but an expression was expected of type\n         int\n", "Error: This function has type string -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound value s\n", "Error: This expression has type string but an expression was expected of type\n         int\n"], "bad": ["\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = reverse (string_of_int n)\n     and y = x / 10\n     and z = x mod 10 in\n     if (y = 0) && (z = 0) then [] else z :: (digitsOfInt y));;\n", "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = reverse (string_of_int n)\n     and y = x / 10\n     and z = x mod 10 in\n     if (y = 0) && (z = 0) then [] else z :: (digitsOfInt y));;\n", "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = reverse (string_of_int n)\n     and y = x / 10\n     and z = x mod 10 in\n     if (y = 0) && (z = 0) then [] else z :: (digitsOfInt y));;\n", "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = reverse (string_of_int n)\n     and y = x / 10\n     and z = x mod 10 in\n     if (y = 0) && (z = 0) then [] else z :: (digitsOfInt y));;\n", "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = reverse (string_of_int n)\n     and y = x / 10\n     and z = x mod 10 in\n     if (y = 0) && (z = 0) then [] else z :: (digitsOfInt y));;\n", "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let x = int_of_string reverse (string_of_int n)\n     and y = x / 10\n     and z = x mod 10 in\n     if (y = 0) && (z = 0) then [] else z :: (digitsOfInt y));;\n", "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet x = \"123\";;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let s = reverse (string_of_int n)\n     and n2 = int_of_string s\n     and z = x mod 10 in\n     if (y = 0) && (z = 0) then [] else z :: (digitsOfInt y));;\n", "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet x = \"123\";;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let s = reverse (string_of_int n) in\n     let n2 = int_of_string s\n     and z = x mod 10 in\n     if (y = 0) && (z = 0) then [] else z :: (digitsOfInt y));;\n"]}
{"fix": ["let rec digitsOfInt n =\nlet s = string_of_int n in\nlet s2 = String.length s in\nfor i=0 to (s2-1)/2 do\nlet c = s2.[i] in\ns2.[i] <- s2.[n-i-1];\ns2.[n-i-1] <- c;\ndone;\nint_of_string s2"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value n2\n", "Error: Unbound value n2\n", "Error: Unbound value n2\n", "Error: Unbound value n2\n", "Error: Unbound value n2\n", "Error: Unbound value n2\n", "Error: Unbound value n2\n", "Error: Unbound value n2\n", "Error: Unbound value n2\n", "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "Error: Unbound value n2\n"], "bad": ["\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let s = reverse (string_of_int n) in\n     let n2 = int_of_string s in\n     let x = n2 / 10\n     and y = n2 mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n\nlet _ =\n  let x = n2 / 10\n  and y = n2 mod 10 in\n  if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x);;\n", "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let s = reverse (string_of_int n) in\n     let n2 = int_of_string s in\n     let x = n2 / 10\n     and y = n2 mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n\nlet _ =\n  let x = n2 / 10\n  and y = n2 mod 10 in\n  if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x);;\n", "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let s = reverse (string_of_int n) in\n     let n2 = int_of_string s in\n     let x = n2 / 10\n     and y = n2 mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n\nlet _ =\n  let x = n2 / 10\n  and y = n2 mod 10 in\n  if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x);;\n", "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let s = reverse (string_of_int n) in\n     let n2 = int_of_string s in\n     let x = n2 / 10\n     and y = n2 mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n\nlet _ =\n  let x = n2 / 10\n  and y = n2 mod 10 in\n  if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x);;\n", "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let s = reverse (string_of_int n) in\n     let n2 = int_of_string s in\n     let x = n2 / 10\n     and y = n2 mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n\nlet _ =\n  let x = n2 / 10\n  and y = n2 mod 10 in\n  if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x);;\n", "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let s = reverse (string_of_int n) in\n     let n2 = int_of_string s in\n     let x = n2 / 10\n     and y = n2 mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n\nlet _ =\n  let x = n2 / 10\n  and y = n2 mod 10 in\n  if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x);;\n", "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let s = reverse (string_of_int n) in\n     let n2 = int_of_string s in\n     let x = n2 / 10\n     and y = n2 mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n\nlet _ =\n  let x = n2 / 10\n  and y = n2 mod 10 in\n  if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x);;\n", "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let s = reverse (string_of_int n) in\n     let n2 = int_of_string s in\n     let x = n2 / 10\n     and y = n2 mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n\nlet _ =\n  let x = n2 / 10\n  and y = n2 mod 10 in\n  if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x);;\n", "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let s = reverse (string_of_int n) in\n     let n2 = int_of_string s in\n     let x = n2 / 10\n     and y = n2 mod 10 in\n     if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n\nlet _ =\n  let x = n2 / 10\n  and y = n2 mod 10 in\n  if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x);;\n", "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet z = 0;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if z = 0\n    then\n      (let n2 = reverse (string_of_int n)\n       and z = 1 in\n       digitsOfInt n2;\n       (let x = n2 / 10\n        and y = n2 mod 10 in\n        if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x)));;\n", "\nlet rec reverse s =\n  let n = String.length s in\n  for i = 0 to (n - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(n - i) - 1]; s.[(n - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet z = 0;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if z = 0\n    then (let n2 = reverse (string_of_int n)\n          and z = 1 in digitsOfInt n2)\n    else\n      (let x = n2 / 10\n       and y = n2 mod 10 in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int but an expression was expected of type\n         string\n", "Error: This expression has type int but an expression was expected of type\n         string\n"], "bad": ["\nlet rec digitsOfInt n =\n  let s = string_of_int n in\n  let s2 = String.length s in\n  for i = 0 to (s2 - 1) / 2 do\n    (let c = s2.[i] in s2.[i] <- s2.[(n - i) - 1]; s2.[(n - i) - 1] <- c)\n  done;\n  int_of_string s2;;\n", "\nlet rec digitsOfInt n =\n  let s = string_of_int n in\n  let s2 = String.length s in\n  for i = 0 to (s2 - 1) / 2 do\n    (let c = s2.[i] in s2.[i] <- s2.[(n - i) - 1]; s2.[(n - i) - 1] <- c)\n  done;\n  int_of_string s2;;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value z\n"], "bad": ["\nlet rec reverse s =\n  let s2 = String.length s in\n  for i = 0 to (s2 - 1) / 2 do\n    (let c = s.[i] in s.[i] <- s.[(s2 - i) - 1]; s.[(s2 - i) - 1] <- c)\n  done;\n  int_of_string s;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if z = 0\n    then (let n2 = reverse (string_of_int n)\n          and z = 1 in digitsOfInt n2)\n    else\n      (let x = n / 10\n       and y = n mod 10 in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n"]}
{"fix": ["let digitsOfInt n = \nlet rec helper n a =\nmatch n with\n| n < 0 -> []\n| n < 10 -> [n]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value digitsOfInt\n", "Error: Unbound value reverse\n", "Error: Unbound value reverse\n", "Error: Unbound value digitsOfInt\n"], "bad": ["\nlet _ = digitsOfInt 3124;;\n", "\nlet rec digitsOfInt n z =\n  if n < 0\n  then []\n  else\n    if z = 0\n    then (let n2 = reverse (string_of_int n)\n          and z = 1 in digitsOfInt n2)\n    else\n      (let x = n / 10\n       and y = n mod 10 in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "\nlet rec digitsOfInt n z =\n  if n < 0\n  then []\n  else\n    if z = 0\n    then (let n2 = reverse (string_of_int n)\n          and z = 1 in digitsOfInt n2 0)\n    else\n      (let x = n / 10\n       and y = n mod 10 in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "\nlet _ = digitsOfInt (-42313);;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n) in\nlet rest = n - 1* int_of_float (10. ** float_of_int s) then\nhead::digitsOfInt rest"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: Unbound value s\n", "Error: Unbound value y\n"], "bad": ["\nlet rec getFirst n = if n < 10 then n else getFirst (n / 10);;\n\nlet x = 9800;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else\n      (let head = getFirst n\n       and s = String.length (string_of_int n)\n       and rest = n - (1 * (10 ** s)) in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "\nlet rec getFirst n = if n < 10 then n else getFirst (n / 10);;\n\nlet x = 9800;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else\n      (let head = getFirst n\n       and s = String.length (string_of_int n)\n       and rest = (float_of_int n) - (1. * (10. ** (float_of_int s))) in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "\nlet rec getFirst n = if n < 10 then n else getFirst (n / 10);;\n\nlet x = 9800;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else\n      (let head = getFirst n\n       and s = String.length (string_of_int n)\n       and rest = (float_of_int n) - (1. * (10. ** (float_of_int s))) in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "\nlet rec getFirst n = if n < 10 then n else getFirst (n / 10);;\n\nlet x = 9800;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else\n      (let head = getFirst n\n       and s = String.length (string_of_int n)\n       and rest = n - (1 * (int_of_float (10 ** (float_of_int s)))) in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "\nlet rec getFirst n = if n < 10 then n else getFirst (n / 10);;\n\nlet x = 9800;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else\n      (let head = getFirst n\n       and s = String.length (string_of_int n)\n       and rest = n - (1 * (int_of_float (10. ** (float_of_int s)))) in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n", "\nlet rec getFirst n = if n < 10 then n else getFirst (n / 10);;\n\nlet x = 9800;;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n < 10\n    then [n]\n    else\n      (let head = getFirst n\n       and s = String.length (string_of_int n) in\n       let rest = n - (1 * (int_of_float (10. ** (float_of_int s)))) in\n       if (x = 0) && (y = 0) then [] else y :: (digitsOfInt x));;\n"]}
{"fix": ["let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (a,i)::t -> \nif a = k then i \nelse \nassoc (d,k,t)"], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ = fixpoint (collatz, 9001);;\n"]}
{"fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n", "Error: Unbound value y\n", "Error: Unbound value failwiaht\nHint: Did you mean failwith?\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile ((y b), b);;\n", "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile ((failwiaht \"to be written\"), b);;\n"]}
{"fix": ["let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sine(pi*\" ^ exprToString e1 ^ \")\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine  -> \"sine(pi*\" ^ ((exprToString d) ^ \")\");;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine  -> \"sine(pi*\" ^ ((exprToString e) ^ \")\");;\n"]}
{"fix": ["let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\" ^ exprToString e1 ^ \")\"\n| Cosine e2 -> \"cos(pi*\" ^ exprToString e2 ^ \")\"\n| Average (e3,e4) -> \"((\" ^ exprToString e3 ^ \"+\" ^ exprToString e4 ^ \")/2)\"\n| Times (e5,e6) -> exprToString e5 ^ \"*\" ^ exprToString e6\n| Thresh (e7,e8,e9,e10) -> \"(\" ^ exprToString e7 ^ \"<\" ^ exprToString e8 ^ \"?\" ^ exprToString e9 ^ \":\" ^ exprToString e10 ^ \")\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ ((\"+\" exprToString e4) ^ \")/2)\"));;\n"]}
{"fix": ["let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/2"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi * (eval (e, x, y)))\n  | Cosine e -> cos (pi * (eval (e, x, y)));;\n"]}
{"fix": ["let rec eval (e,x,y) = \nmatch e with\n| VarX -> float_of_int x\n| VarY -> float_of_int y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) + eval(e2,x,y))/2"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2;;\n"]}
{"fix": ["let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.\n| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float_of_int x\n  | VarY  -> float_of_int y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) / 2;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float_of_int x\n  | VarY  -> float_of_int y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) ->\n      (float_of_int ((eval (e1, x, y)) + (eval (e2, x, y)))) / 2;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) /. 2;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) /. 2;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2;;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\nError: Unbound value sampleExpr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e1, x, y)\n      else eval (e2, x, y);;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile (fun y  -> fun b  -> if (f b) = b then (b, true) else ((y b), b));;\n", "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> fun b  -> (((f b), true), b));;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: This function expects too many arguments, it should have type\n'a -> 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile ((fun y  -> fun b  -> ((f b), true)), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile (let y x =\nlet xx = f x in\n(xx, xx != x) in y, b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression has type int but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type int but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This function expects too many arguments, it should have type\n'a -> 'a * bool\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> fun b  -> (((f b), ((f b) = b)), b));;\n", "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (((f b), ((f b) = b)), b);;\n", "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> (((f b), ((f b) = b)), b));;\n", "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> (((f b), ((f b) != b)), b));;\n", "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> fun b  -> (((f b), ((f b) != b)), b));;\n", "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile (fun y  -> let x = f b in if x = b then ((x, true), b));;\n", "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile\n    (fun y  ->\n       fun b  -> let x = f b in if x = b then (x, true) else ((y x), b));;\n", "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile\n    (fun y  ->\n       fun x  -> let z = f x in if z = b then (x, true) else ((y z), b));;\n", "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let f x = let xx = (x * x) * x in (xx, (xx < 100)) in\n     ((wwhile (f, 2)), b));;\n", "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let f x = let xx = (x * x) * x in (xx, (xx < 100)) in\n     ((wwhile (f, 2)), b));;\n", "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> fun x  -> (((f x), ((f x) != b)), b));;\n", "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile ((fun y  -> fun x  -> ((f x), ((f x) != b))), b);;\n", "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> (((f b), ((f b) != b)), b));;\n", "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> (((f b), ((f b) != b)), b));;\n", "\nlet rec wwhile (f,b) =\n  let (number,boolean) = f b in\n  if boolean then wwhile (f, number) else number;;\n\nlet fixpoint (f,b) = wwhile (fun y  -> fun b  -> (((f b), ((f b) != b)), b));;\n"]}
{"fix": ["let rec build (rand, depth) = \nlet rand = makeRand (1,7) in\nlet x = rand(1,7) in"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value rand\nHint: Did you mean land?\n", "Error: This function has type expr * expr * expr * expr -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type expr * expr * expr * expr -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet _ = rand (1, 2);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ()))) makeRand (1, 2);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ()))) makeRand (1, 2);;\n"]}
{"fix": ["let rec build (rand, depth) = \nlet x = rand"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value rand\nHint: Did you mean land?\n"], "bad": ["\nlet x = rand (1, 7);;\n"]}
{"fix": ["let rec build (rand, depth) = \nlet x = rand(0,6) in \nmatch x with \n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 3 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value buildAverge\nHint: Did you mean buildAverage?\nError: Unbound value buildAverge\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value buildAverge\nHint: Did you mean buildAverage?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let x = rand (1, 7) in\n  match x with\n  | 1 -> buildX ()\n  | 2 -> buildY ()\n  | 3 ->\n      if depth = 0\n      then build (rand, depth)\n      else buildSine (build (rand, (depth - 1)))\n  | 4 ->\n      if depth = 0\n      then build (rand, depth)\n      else\n        buildAverge\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"]}
{"fix": ["exprToString s"], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | AddThree of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e2 -> \"cos(pi*\" ^ ((exprToString e2) ^ \")\")\n  | Average (e3,e4) ->\n      \"((\" ^ ((exprToString e3) ^ (\"+\" ^ ((exprToString e4) ^ \")/2)\")))\n  | Times (e5,e6) -> (exprToString e5) ^ (\"*\" ^ (exprToString e6))\n  | Thresh (e7,e8,e9,e10) ->\n      \"(\" ^\n        ((exprToString e7) ^\n           (\"<\" ^\n              ((exprToString e8) ^\n                 (\"?\" ^\n                    ((exprToString e9) ^ (\":\" ^ ((exprToString e10) ^ \")\")))))))\n  | Power (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"**\" ^ ((exprToString e2) ^ \")\")))\n  | AddThree (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ ((\"+\" exprToString e3) ^ \")\"))));;\n"]}
{"fix": ["let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.\n| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh(e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then \neval(e3,x,y)\nelse eval(e4,x,y)\n| Power(e1,e2) -> eval(e1,x,y) ** eval(e2,x,y)\n| AddThree(e1,e2,e3) -> eval(e1,x,y) +. eval(e2,x,y) +. eval(e3,x,y)"], "hw": "hw2", "problem": "eval", "message": ["Error: Unbound value **.\nHint: Did you mean *. or **?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | AddThree of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) **. (eval (e2, x, y));;\n"]}
{"fix": [], "hw": "hw2", "problem": "exprToString", "message": ["Error: Unbound constructor Averge\n", "Error: Unbound constructor Average\n"], "bad": ["\nlet s = Averge (VarX, VarY);;\n", "\nlet s = Average (VarX, VarY);;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value exprToString\n"], "bad": ["\nlet _ = exprToString sampleExpr1;;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: Unbound value eval\n"], "bad": ["\nlet _ = eval ((AddThree (VarX, VarY, VarX)), 2., 5.);;\n"]}
{"fix": ["let rec build (rand, depth) = \nlet x = rand(0,5) in \nmatch x with \n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 3 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 4 -> if depth = 0 then build(rand,depth)\nelse buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 5 -> if depth = 0 then build(rand,depth)\nelse buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 6 -> if depth = 0 then build(rand,depth)\nelse buildPower(build(rand,depth-1),build(rand,depth-1))\n| 7 -> if depth = 0 then build(rand,depth)\nelse buildAddThree(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ -> buildX()"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value buildX\nHint: Did you mean build?\n"], "bad": ["\nlet rec build (rand,depth) =\n  let x = rand (0, 7) in\n  match x with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2 ->\n      if depth = 0\n      then build (rand, depth)\n      else buildSine (build (rand, (depth - 1)))\n  | 3 ->\n      if depth = 0\n      then build (rand, depth)\n      else\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 4 ->\n      if depth = 0\n      then build (rand, depth)\n      else\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      if depth = 0\n      then build (rand, depth)\n      else\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      if depth = 0\n      then build (rand, depth)\n      else\n        buildPower ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      if depth = 0\n      then build (rand, depth)\n      else\n        buildAddThree\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))));;\n"]}
{"fix": [], "hw": "hw3", "problem": "stringOfList", "message": ["Error: Unbound value sepConcat\n"], "bad": ["\nlet stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l));;\n"]}
{"fix": [], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value pipe\n", "Error: Unbound value pipe\n", "Error: Unbound value pipe\n", "Error: Unbound value base\n"], "bad": ["\nlet _ = pipe [] 3;;\n", "\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "\nlet pipe fs = let f a x = x base in le;;\n"]}
{"fix": [], "hw": "hw3", "problem": "sepConcat", "message": ["Error: Unbound value pipe\n"], "bad": ["\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"]}
{"fix": ["\n\n\r\nlet rec removeZero l = match l with\n| [] -> []\n| h::t -> if h != 0 then t\nelse  removeZero t\n"], "hw": "hw3", "problem": "removeZero", "message": ["Error: Unbound value padZero\n"], "bad": ["\nlet _ = padZero [9; 9] [1; 0; 0; 2] let _ = padZero [1; 0; 0; 2] [9; 9];;\n"]}
{"fix": [], "hw": "hw3", "problem": "sqsum", "message": ["Error: Unbound value pipe\n"], "bad": ["\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)];;\n"]}
{"fix": [], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type int list -> int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else bigAdd (mulByDigit (i - 2) l) ((mulByDigit i) - (2 l));;\n"]}
{"fix": ["let d = bigAdd c x"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet x = [9; 9; 9; 9];;\n\nlet 5 = bigAdd 4 x;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (int_of_float float_of_int x*.(10.**List.length res)) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1, (mulByDigit (x * (10 ** (List.length res))) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (x*10 ** List.length res) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1, (mulByDigit (x * (10 exp List.length res)) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x *. 10. ** float_of_int List.length res)) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1, (mulByDigit (x * (10 ** (List.length res))) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit ((int_of_float (float_of_int x *. 10. ** float_of_int List.length res)) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This function has type int -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This function has type int -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1,\n          (mulByDigit\n             (int_of_float\n                ((float_of_int x) *. (10. ** (float_of_int List.length res))))\n             list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit x list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1,\n          (mulByDigit\n             ((int_of_float (float_of_int x)) *.\n                (10. ** (float_of_int List.length res))) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1,\n          (mulByDigit\n             ((int_of_float (float_of_int x)) *.\n                (10. ** (float_of_int (List.length res)))) list1)) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*10) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int list -> int list\n       but an expression was expected of type int\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list -> int list\n       but an expression was expected of type int\n", "Error: Unbound value List.lengh\nHint: Did you mean length?\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value List.lengh\nHint: Did you mean length?\n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1, (bigAdd res ((mulByDigit x) * (List.lengh res list1)))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1, (bigAdd res (mulByDigit (x * (List.lengh res)) list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit x list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int list -> int list\n       but an expression was expected of type int\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list -> int list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         float\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         float\n", "Error: This function has type int -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value bigAdd\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This function has type int -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1,\n          (bigAdd res\n             ((mulByDigit x) *\n                ((int_of_float (10. ** (List.length res))) list1)))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1,\n          (bigAdd res\n             (mulByDigit (x * (int_of_float (10. ** (List.length res))))\n                list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet y = bigAdd x x;;\n\nlet z = bigAdd y x;;\n\nlet a = bigAdd z x;;\n\nlet b = bigAdd a x;;\n\nlet c = bigAdd b x;;\n\nlet d = bigAdd c x;;\n\nlet e = bigAdd d x;;\n\nlet f = bigAdd e x;;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet g = bigAdd f x;;\n\nlet x = [9; 9; 9; 9];;\n\nlet h = bigAdd g x;;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then l else removeZero t;;\n\nlet t = bigAdd x z;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list2,res) ->\n          (match list2 with\n           | [] -> ([], res)\n           | h::t ->\n               (match res with\n                | [] -> (t, ((h + x) :: res))\n                | h2::t2 ->\n                    if h2 >= 10\n                    then\n                      (t,\n                        ((if t != []\n                          then ((h + x) + 1) :: (h2 mod 10) :: t2\n                          else\n                            if ((h + x) + 1) >= 10\n                            then 1 :: (((h + x) + 1) mod 10) :: (h2 mod 10)\n                              :: t2\n                            else ((h + x) + 1) :: (h2 mod 10) :: t2)))\n                    else\n                      (t,\n                        (if t != []\n                         then (h + x) :: res\n                         else\n                           if (h + x) >= 10\n                           then 1 :: ((h + x) mod 10) :: res\n                           else (h + x) :: res)))) in\n    let base = ((List.rev l2), []) in\n    let args = List.rev l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then [] else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (list1,res) ->\n        (list1,\n          (bigAdd res\n             (mulByDigit\n                (x * (int_of_float (10. ** (float_of_int List.length res))))\n                list1))) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let rec sumList xs =\nmatch xs with\n[] -> 0 | h::t -> h + sumList t"], "hw": "hw1", "problem": "sumList", "message": ["Error: This expression has type int list -> int\n       but an expression was expected of type int\n", "Error: This expression has type int list -> int\n       but an expression was expected of type int\n"], "bad": ["\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + sumList;;\n", "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + sumList;;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value %\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | n -> [((digitsOfInt n) / (10 n)) % 10];;\n", "\nlet rec digitsOfInt n = match n with | 0 -> [] | n -> [(digitsOfInt n) / 10];;\n", "\nlet rec digitsOfInt n = match n with | 0 -> [] | n -> [digitsOfInt n];;\n", "\nlet rec digitsOfInt n = match n with | 0 -> [] | n -> [(digitsOfInt n) / 10];;\n"]}
{"fix": ["let rec digitsOfInt n =\nmatch n with\n0  -> [] \n| _  -> digitsOfInt (n/10) @  [n mod 10]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value %\n"], "bad": ["\nlet rec digitsOfInt n =\n  match n with | 0 -> [] | _ -> (digitsOfInt (n / 10)) @ [n % 10];;\n"]}
{"fix": ["let rec digitsOfInt n =\nmatch n with\n_  -> cat (digitsOfInt (n/10)) (n mod 10)\n| 0  -> []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value hDigitsofInt\nHint: Did you mean digitsOfInt?\n", "Error: Unbound value hDigitsofInt\nHint: Did you mean digitsOfInt?\n"], "bad": ["\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec digitsOfInt n =\n  if n = 0\n  then [0]\n  else\n    (hDigitsofInt n) =\n      ((match n with | 0 -> [] | _ -> cat (digitsOfInt (n / 10)) (n mod 10)));;\n", "\nlet rec digitsOfInt n = if n = 0 then [0] else hDigitsofInt n;;\n"]}
{"fix": ["let rec digitsOfInt n =\nif n = 0 then [0]\nelse help n"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression should not be a function, the expected type is\nint list\n"], "bad": ["\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec digitsOfInt n =\n  if n = 0\n  then [0]\n  else\n    (fun help  ->\n       fun n  -> match n with | 0 -> [] | _ -> cat (help (n / 10)) (n mod 10));;\n"]}
{"fix": ["let rec listReverse l = \nmatch l with\n[]   -> []\n| h::t -> listReverse ((cat l h))"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a list list\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a list list\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l = match l with | [] -> [] | h::t -> (cat l h) :: t;;\n", "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l = match l with | [] -> [] | h::t -> (cat t h) :: l;;\n", "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse ((cat l h) :: t);;\n", "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse (t :: (cat l h));;\n"]}
{"fix": [], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value listReverse\n", "Error: Unbound value cat\n", "Error: Unbound value cat\n", "Error: Unbound value cat\n"], "bad": ["\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> cat h (listReverse t);;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> cat l (listReverse t h);;\n", "\nlet rec listReverse l = match l with | [] -> [] | h::t -> cat listReverse t h;;\n"]}
{"fix": ["let palindrome w = \nexplode w = listReverse (explode w)"], "hw": "hw1", "problem": "palindrome", "message": ["Error: Unbound value listReverse\n", "Error: Unbound value listReverse\n"], "bad": ["\nlet reverse = listReverse l;;\n", "\nlet reverse = listReverse l;;\n"]}
{"fix": ["let rec assoc (d,k,l) = match l with\n[]   -> d\n| h::t -> \nif k = h then 10 else assoc (d,k,t)"], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value k\n"], "bad": ["\nlet _ =\n  let rec assoc (d,k,l) = match l with | [] -> d | h::t -> assoc (d, k, l) in\n  if k = h then 10 else assoc (d, k, t);;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h::seen else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: This expression has type 'a list list -> bool\n       but an expression was expected of type bool\n", "Error: This expression has type ('a * 'a list) list -> bool\n       but an expression was expected of type bool\n", "Error: This expression has type 'a list -> bool\n       but an expression was expected of type bool\n", "Error: This expression has type ('a * 'a list) list -> bool\n       but an expression was expected of type bool\n", "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This expression has type 'a list\n       but an expression was expected of type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "Error: This expression has type 'a list list\n       but an expression was expected of type 'a list\n       The type variable 'a occurs inside 'a list\n", "Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem t then h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h, t) then h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h then h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h, t) then h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then h @ [] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then [] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"]}
{"fix": ["let rec wwhile (f,b) = match f with\n(num, b00l)-> if b00l then num else wwhile (f, num)"], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type int but an expression was expected of type\n         bool\n"], "bad": ["\nlet rec wwhile (f,b) = match b with | true  -> f | false  -> wwhile (f, b);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n"]}
{"fix": ["let rec wwhile (f,b) = match f with\n(num, b00l)-> if b00l then num else wwhile (f, num)"], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type int -> int * bool\n       but an expression was expected of type 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f with | (num,b00l) -> if b00l then num else wwhile (f, num);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n"]}
{"fix": ["let rec wwhile (f,b) = match f b with\n(num, b00l)-> if b00l then num else wwhile (f, num)"], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value b00l\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | () -> if b00l then num else wwhile (f, num);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile (f b,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"], "bad": ["\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, b)), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((f b),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile (b, b);;\n", "\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, b)), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile (wwhile(f b),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((f b),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type\n         int ->\n         ((int -> int * bool) -> (int -> int * bool) * bool) *\n         (int -> int * bool)\n       Type int is not compatible with type\n         ((int -> int * bool) -> (int -> int * bool) * bool) *\n         (int -> int * bool) \n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((wwhile (f b)), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type unit but an expression was expected of type\n         'a -> 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((fun x -> let y = (f x) in (y, y != x)),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside 'a * 'b\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let y = (f, x) in (y, (y != b))), b);;\n"]}
{"fix": ["let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin (pi*\" ^ exprToString e ^\")\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type 'a but an expression was expected of type\n         expr -> expr -> expr -> 'a\n       The type variable 'a occurs inside expr -> expr -> expr -> 'a\n", "Error: This expression has type 'a * 'b * 'c * 'd\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * 'b * 'c * 'd\n", "Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: Unbound value exprString\nHint: Did you mean exprToString?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Thresh (a,b,c,d) -> exprToString a b c d;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      ((exprToString a), (exprToString b), (exprToString c),\n        (exprToString d));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX x -> \"x\"\n  | VarY y -> \"y\"\n  | Sine s -> \"sin (pi*\" ^ ((exprString e) ^ \")\");;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprString e) ^ \")\");;\n"]}
{"fix": ["let rec exprToString e = match e with\nVarX           -> \"x\"\n| VarY           -> \"y\"\n| Sine e         -> \"sin (pi*\" ^ exprToString e ^\")\"\n| Cosine e       -> \"cos (pi*\" ^ exprToString e ^\")\"\n| Average (e,f)  -> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)  -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: This variant pattern is expected to have type expr\n       The constructor Averages does not belong to type expr\nHint: Did you mean Average?\n", "Error: The constructor Average expects 2 argument(s),\n       but is applied here to 1 argument(s)\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Averages  ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString e) ^ \")/2)\")))\n  | Times  -> \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString e) ^ \")\")))\n  | Thresh  ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString e) ^\n                 (\"?\" ^ ((exprToString e) ^ (\":\" ^ ((exprToString e) ^ \")\")))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average e ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString e) ^ \")/2)\")))\n  | Times e -> \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString e) ^ \")\")))\n  | Thresh e ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString e) ^\n                 (\"?\" ^ ((exprToString e) ^ (\":\" ^ ((exprToString e) ^ \")\")))))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type expr but an expression was expected of type\n         float\n", "Error: This expression has type expr but an expression was expected of type\n         float\n", "Error: This expression has type expr but an expression was expected of type\n         float\n", "Error: This expression has type expr but an expression was expected of type\n         float\n", "Error: The constructor Average expects 2 argument(s),\n       but is applied here to 1 argument(s)\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e -> sin (pi * e)\n  | Cosine e -> cos (pi * e)\n  | Average (x,y) -> (x +. y) /. 2.0\n  | Times (x,y) -> x *. y\n  | Thresh (e,f,g,h) -> failwith \"sad\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e -> sin (pi *. e)\n  | Cosine e -> cos (pi *. e)\n  | Average (x,y) -> (x +. y) /. 2.0\n  | Times (x,y) -> x *. y\n  | Thresh (e,f,g,h) -> failwith \"sad\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (x,y) -> (x +. y) /. 2.0\n  | Times (x,y) -> x *. y\n  | Thresh (e,f,g,h) -> failwith \"sad\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (x,y) -> (x +. y) /. 2.0\n  | Times (x,y) -> x *. y\n  | Thresh (e,f,g,h) -> failwith \"sad\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (x,y) -> (x +. y) /. 2.0\n  | Times (x,y) -> x *. y\n  | Thresh (e,f,g,h) -> failwith \"sad\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average e -> (x +. y) /. 2.0\n  | Times (x,y) -> x *. y\n  | Thresh (e,f,g,h) -> failwith \"sad\";;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> failwith \"sad\""], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type expr but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (x,y) -> ((eval (e, x, y)) +. (eval (e, x, y))) /. 2.0\n  | Times (x,y) -> (eval (e, x, y)) *. (eval (e, x, y))\n  | Thresh (e1,e2,e3,e4) -> failwith \"sad\";;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)"], "hw": "hw2", "problem": "eval", "message": ["Error: Unbound type constructor e4\n", "Error: This function has type expr * float * float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      ((eval (e1, x, y)) < (eval (e2, x, y) ?eval (e3, x, y)) : e4);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      (eval (e1, x, y)) < (eval (e2, x, y) ?eval (e3, x, y));;\n"]}
{"fix": ["let rec build (rand, depth) = \nif(depth > 0) then\nif rand mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rand mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value %\n", "Error: Unbound value %.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    (if (rand % 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rand % 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rand % 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rand % 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    if (rand % 2) = 0\n    then buildAverage ((buildX ()), (buildY ()))\n    else buildTimes ((buildX ()), (buildY ()));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    (if (rand %. 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rand % 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rand % 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rand % 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    if (rand % 2) = 0\n    then buildAverage ((buildX ()), (buildY ()))\n    else buildTimes ((buildX ()), (buildY ()));;\n"]}
{"fix": ["let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand 0 100 in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand 0 100 in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n", "Error: This expression has type int -> int -> int\n       but an expression was expected of type int\n"], "bad": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    (if (rand mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rand mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rand mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rand mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    if (rand mod 2) = 0\n    then buildAverage ((buildX ()), (buildY ()))\n    else buildTimes ((buildX ()), (buildY ()));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand 0 100 in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand 0 100 in\n     if (rand mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n"]}
{"fix": ["let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 100) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 100) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"], "bad": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand 0 100 in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand 0 100 in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"]}
{"fix": ["let rec build (rand, depth) = \n(*Format.sprintf \"%d\" depth in*)\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value depth\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) = Format.sprintf \"%d\" depth in\n  if depth > 0\n  then\n    let rnd = rand (0, 51) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 51) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n"]}
{"fix": ["let rec build (rand, depth) = \n\nif(depth > 0) then\nFormat.printf \"%d\" depth"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type string but an expression was expected of type\n         unit\n"], "bad": ["\nlet rec build (rand,depth) = if depth > 0 then Format.sprintf \"%d\" depth;;\n"]}
{"fix": ["let rec build (rand, depth) = \nlet _ = Format.printf \"%d\" depth in\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type unit but an expression was expected of type\n         expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = if depth > 0 then Format.printf \"%d\" depth;;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: Unbound value doRandomGray\n"], "bad": ["\nlet _ = doRandomGray (2, 13, 312);;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value exprToString\n"], "bad": ["\nlet _ = exprToString sampleExpr1;;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value doRandomGray\n"], "bad": ["\nlet _ = doRandomGray (2, 13, 312);;\n"]}
{"fix": [], "hw": "hw2", "problem": "expr", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) + (cos (pi *. (eval (e, x, y))))) *\n        (cos (pi *. (eval (e, x, y))));;\n"]}
{"fix": ["let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) + (cos (pi *. (eval (e, x, y))))) *\n        (cos (pi *. (eval (e, x, y))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) +. (cos (pi *. (eval (e, x, y))))) *\n        (cos (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) ->\n      (sin (pi *. (eval (e, x, y)))) / (cos (pi *. (eval (e, x, y))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: The constructor Timmy1 expects 2 argument(s),\n       but is applied here to 3 argument(s)\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) ** 2.0) *.\n        (cos (pi *. (eval (e, x, y))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr\n  | Timmy2 of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))))\n  | Timmy1 (e1,e2) ->\n      \"sin^2(pi*\" ^\n        ((exprToString e1) ^ (\")*\" ^ (\"cos(pi*\" ^ ((exprToString e2) ^ \")\"))))\n  | Timmy2 (e1,e2,e3) ->\n      \"sin^2(pi*\" ^\n        ((exprToString e1) ^\n           (\")*\" ^\n              (\"(cos^2(pi*\" ^\n                 ((exprToString e2) ^\n                    (\")*\" ^ ((\"cos(\" exprToString e3) ^ \"))\"))))));;\n"]}
{"fix": ["let pipe fs = \nlet f a x = a+x in\nlet base = 0 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x =  fun a -> x  in\nlet base =  fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "bad": ["\nlet pipe fs = let f a x = a + x in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x =  (fun a->x) a  in\nlet base =  fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n", "Error: Unbound value f\n"], "bad": ["\nlet pipe fs = let f a x x = a in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = f (fun a  -> x) a in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x =   (fun a->x) x in\nlet base =  fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type (('a -> 'b) -> 'c) -> 'b -> 'c\n       but an expression was expected of type\n         (('a -> 'b) -> 'c) -> 'b -> ('a -> 'b) -> 'c\n       The type variable 'c occurs inside ('a -> 'b) -> 'c\n"], "bad": ["\nlet pipe fs =\n  let f a x = a (fun a  -> x) in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x =   (fun x->a) a in\nlet base =  0 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n", "Error: Unbound value a\n"], "bad": ["\nlet pipe fs =\n  let f a x = (fun x  -> a) a in let base = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = (fun x  -> a) a in let base = a in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x =   fun b -> (x b) a in\nlet base =  fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> ('b -> 'a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('b -> 'a -> 'c) -> 'c\n"], "bad": ["\nlet pipe fs =\n  let f a x b = (b x) a in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x in\nlet base = h^sep in\nlet l = t in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: Unbound value a\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ sep in\n      let base = a in let l = t in List.fold_left f base l;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep in\nlet base = h in\nlet l = t in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: Unbound value x\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ sep in\n      let base = h ^ x in let l = t in List.fold_left f base l;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep  in\nlet base = h in\nlet l = t in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type string list\n       but an expression was expected of type (string -> string) list\n       Type string is not compatible with type string -> string \n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (a ^ sep) x in\n      let base = h in let l = t in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x (a ^ sep) in\n      let base = h in let l = t in List.fold_left f base l;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^sep  in\nlet base = h in\nlet l = t in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: Unbound value x\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ sep in\n      let base = h in let l = x in List.fold_left f base l;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x  in\nlet base = h in\nlet l = t in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: Unbound value a\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ sep in\n      let base = a in let l = t in List.fold_left f base l;;\n"]}
{"fix": ["let stringOfList f l =  List.map f l"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type ('a -> 'b) -> 'a list -> 'b list\n       but an expression was expected of type ('c -> 'c) list\n"], "bad": ["\nlet pipe fs =\n  let f a x b = x (a b) in let base x = x in List.fold_left f base fs;;\n\nlet stringOfList f l = f (pipe List.map l);;\n"]}
{"fix": ["let stringOfList f l =  sepConcat \"\" (List.map f l)"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat f (List.map f l);;\n"]}
{"fix": ["let stringOfList f l =  sepConcat \"[]\" (List.map f l)"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type string\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat l (List.map f l);;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (List.map f l) l;;\n"]}
{"fix": ["let stringOfList f l =  sepConcat \"\" (List.map f l)"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n", "Error: This expression has type string but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f (sepConcat \"\" l);;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f (sepConcat \"\" l);;\n"]}
{"fix": ["let rec clone x n = match n with\n0    -> []\n| _ ->  x::clone x (n-1)"], "hw": "hw3", "problem": "clone", "message": ["Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n"], "bad": ["\nlet rec clone x n = match n with | 0 -> [] | h::t -> x :: (clone x (n - 1));;\n"]}
{"fix": ["let padZero l1 l2 =\nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) \nelse if (s2<s1) then (l1, (clone 0 (s1-s2))@l2)\nelse (l1,l2)"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then ((clone 0 l1), l2)\n  else if s2 < s1 then (l1, (clone 0 l2)) else (l1, l2);;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, (((clone 0 s1) - s2) @ l2)) else (l1, l2);;\n"]}
{"fix": ["let rec removeZero l = match l with\n[]  -> []\n| h1::h2::t-> if(h1=0 && h2!=0) then removeZero t else h1::removeZero t"], "hw": "hw3", "problem": "removeZero", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: Unbound value h\n"], "bad": ["\nlet rec removeZero l =\n  match l with\n  | h -> if h != 0 then []\n  | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n", "\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h1::h2::t ->\n      if (h1 = 0) && (h2 != 0) then removeZero t else h :: (removeZero t);;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: Unbound value %\n", "Error: This expression has type (int * int) list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type (int * int) list\n       but an expression was expected of type 'a * 'b\n", "Error: Unbound value a\n", "Error: Unbound value a\n", "Error: Unbound value x\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: Unbound value a\n", "Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((x / 10), (x % 10)) :: a in\n    let base = [] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((x / 10), (x mod 10)) :: a in\n    let base = [] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((x / 10), (x mod 10)) :: a in\n    let base = [] in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x mod 10) :: a in\n    let base = [] in\n    let args = a + x in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x mod 10) :: a in\n    let base = [] in\n    let args = a + x in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x mod 10) :: a in\n    let base = [] in\n    let args = x in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x mod 10) :: a in\n    let base = [] in\n    let args = 1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x mod 10) :: a in\n    let base = [] in\n    let args = a in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x mod 10) :: a in\n    let base = [] in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x mod 10) :: a in\n    let base = (match l1 with | h -> h) + (match l2 with | h -> h) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"\"\nin\nlet base = ([],[]) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type 'c list\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"\" in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> [] | h::t -> [] in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> [] | h::t -> [] in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type 'c list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> ([], []) | h::t -> ([], []) in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | ([],[]) -> [] in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> [] in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> [] in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"\"\nin\nlet base =  ([], []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list * 'b list\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> [] in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"\" in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list * 'b list\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a list * 'b list -> 'c -> 'd list\n       but an expression was expected of type\n         'a list * 'b list -> 'c -> 'a list * 'b list\n       Type 'd list is not compatible with type 'a list * 'b list \n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type 'c list\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n", "Error: This expression has type 'a list -> 'b -> 'c list * 'd list\n       but an expression was expected of type 'a list -> 'b -> 'a list\n       Type 'c list * 'd list is not compatible with type 'a list \n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'b * 'c\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | ([],[]) -> [] in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | ([],[]) -> [] in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | [] -> [] in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> [] in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> ([], []) in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | [] -> ([], []) in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"\" in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"\" in\n    let base x = x in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (snd a) with\n[]  -> (fst x + snd x, ((fst x + snd x)/10)::[(fst x + snd x) mod 10]) \n|h::t -> (0, [] )\nin\nlet base =  (0, []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b list -> 'c -> 'd list\n       but an expression was expected of type\n         'a * 'b list -> 'c -> 'a * 'b list\n       Type 'd list is not compatible with type 'a * 'b list \n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (c,h::t) -> [] in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let rec mulByDigit i l = match i with\n0 -> []\n| 1 -> l\n| 2 -> bigAdd l l\n| _ -> bigAdd (mulByDigit (i-2) l) (mulByDigit i l)"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type 'c list\n", "Error: Unbound value mulBydigit\nHint: Did you mean mulByDigit?\n"], "bad": ["\nlet rec mulByDigit i l =\n  let lr = List.rev l in\n  match lr with\n  | (_,[]) -> ((((fst x) * (snd x)) / 10), [((fst x) * (snd x)) mod 10])\n  | (c,h::t) ->\n      let sum = c + ((fst x) * (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a)));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | 0 -> []\n  | 1 -> l\n  | 2 -> bigAdd l l\n  | _ -> bigAdd (mulByDigit (i - 2) l) (mulBydigit i l);;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) x)) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "Error: This expression has type 'a * 'b list -> int * 'c -> int list\n       but an expression was expected of type\n         'a * 'b list -> int * 'c -> 'a * 'b list\n       Type int list is not compatible with type 'a * 'b list \n", "Error: This variant expression is expected to have type int list\n       The constructor () does not belong to type list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec accumulator n ls acc =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd ls acc\n    | _ -> accumulator (n - 1) ls (bigAdd ls acc) in\n  accumulator i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (_,[]) -> mulByDigit (fst x) l1\n    | (c,h::t) -> (c, (mulByDigit h x)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec accumulator n ls acc =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd ls acc\n    | _ -> accumulator (n - 1) ls (bigAdd ls acc) in\n  accumulator i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,[]) -> mulByDigit (fst x) l1 in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet bigMul l1 l2 =\n  let f a x = ((fst a), (bigAdd () ())) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) x )) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This function has type int list -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec accumulator n ls acc =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd ls acc\n    | _ -> accumulator (n - 1) ls (bigAdd ls acc) in\n  accumulator i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x = (((fst a) + 1), (bigAdd snd x (mulByDigit (fst a) x))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) (x@ clone 0 (fst a)) )) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec accumulator n ls acc =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd ls acc\n    | _ -> accumulator (n - 1) ls (bigAdd ls acc) in\n  accumulator i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x = (((fst a) + 1), (bigAdd x (mulByDigit (fst a) (snd x)))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = \n((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) )) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let rec accumulator n ls acc =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd ls acc\n    | _ -> accumulator (n - 1) ls (bigAdd ls acc) in\n  accumulator i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    (((fst a) + 1), (bigAdd x (mulByDigit x (l1 @ (clone 0 (fst a)))))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = match a with\n(0, [])   -> (0, mulByDigit x (l1@ clone 0 0))\n| (c, a) -> (c+1, bigAdd a (mulByDigit x (l1@clone 0 c)))\n(*((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) ))*)\n\nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let rec accumulator n ls acc =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd ls acc\n    | _ -> accumulator (n - 1) ls (bigAdd ls acc) in\n  accumulator i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (0,[]) -> (0, (mulByDigit x (l1 @ (clone 0 []))))\n    | (c,a) -> ((c + 1), (bigAdd a (mulByDigit x (l1 @ (clone 0 c))))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0"], "hw": "hw1", "problem": "sumList", "message": ["Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type int list\n"], "bad": ["\nlet rec sumList xs =\n  if (List.length xs) > 0 then (List.hd xs) + (sumList List.tl xs) else 0;;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n>0 then\n[2]\nelse\n[1]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value digitOfInt\nHint: Did you mean digitsOfInt?\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n > 0 then ((digitOfInt n) / 10) @ [n mod 10] else [];;\n", "\nlet rec digitsOfInt n =\n  if n > 0 then ((digitsOfInt n) / 10) @ [n mod 10] else [];;\n", "\nlet rec digitsOfInt n =\n  if n > 0 then ((digitsOfInt n) / 10) @ [n mod 10] else [];;\n", "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt n) / 10 else [];;\n", "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt n) / 10 else [1];;\n", "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt n) / 10 else [1];;\n", "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt n) / 10 else [1];;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n>0 then\n[5]@ digitsOfInt (n/10)\nelse\n[1]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt n) / 10 else [];;\n", "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt n) / 10 else [];;\n", "\nlet rec digitsOfInt n = if n > 0 then [5] @ ((digitsOfInt n) / 10) else [1];;\n"]}
{"fix": ["let rec additivePersistence n =\nif n>0 then\n1+ additivePersistence (help n)\nelse\n0"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int\n"], "bad": ["\nlet rec help n = if n > 0 then (n mod 10) + (help (n / 10)) else 0;;\n\nlet rec additivePersistence n =\n  if n > 0 then 1 + (additivePersistence help n) else 0;;\n"]}
{"fix": ["let rec listReverse l = \nif List.length l >0 then\n(List.hd l ::[])\nelse\n[]"], "hw": "hw1", "problem": "listReverse", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list -> int\n", "Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type 'b list\n"], "bad": ["\nlet rec listReverse l =\n  if List.length > 0 then (listReverse List.tl l) @ [List.hd l] else [];;\n", "\nlet rec listReverse l =\n  if (List.length l) > 0 then (listReverse List.tl l) @ [List.hd l] else [];;\n"]}
{"fix": ["let palindrome w = \n(explode w)=(listReverse (explode w))"], "hw": "hw1", "problem": "palindrome", "message": ["Error: Unbound value go\n"], "bad": ["\nlet rec listReverse l =\n  if (List.length l) > 0 then (listReverse (List.tl l)) @ [List.hd l] else [];;\n\nlet palindrome w = (go w) = (listReverse (go w));;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n>=100 then\n[n mod 10]\nelse\n[n]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n > 10 then [digitsOfInt (n / 10); n mod 10] else n;;\n", "\nlet rec digitsOfInt n = if n > 10 then [n; n mod 10] else n;;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n>=10 then\ndigitsOfInt (n/10) @ [n mod 10]\nelse\n[n]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n", "Error: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n > 10 then app ((digitsOfInt (n / 10)) [n mod 10]) else [n];;\n", "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n > 10 then app ((digitsOfInt (n / 10)) [n mod 10]) else [n];;\n", "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ((digitsOfInt (n / 10)) [n mod 10]) else [n];;\n", "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else [n];;\n", "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app digitsOfInt (n / 10) [n mod 10] else [n];;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n>=10 then\n(digitsOfInt (n/10)) @ ([n mod 10])\nelse\n[n]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int -> 'a\n       but an expression was expected of type 'b list\n", "Error: This expression has type int list -> int list\n       but an expression was expected of type int list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n", "Error: This expression has type int but an expression was expected of type\n         int list -> int list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n"], "bad": ["\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then (app digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n", "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ((digitsOfInt (n / 10)) @ [n mod 10]) else [n];;\n", "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else [n];;\n", "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else [n];;\n", "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else [n];;\n", "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else n;;\n", "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ((digitsOfInt (n / 10)) [n mod 10]) else [n];;\n", "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ((digitsOfInt (n / 10)) [n mod 10]) else [n + 0];;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n>=10 then\n(n/(helpFac n 1))::digitsOfInt (n/10)\nelse\n[n]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec help n = if n > 0 then (n mod 10) + (help (n / 10)) else 0;;\n\nlet rec digitsOfInt n =\n  if n >= 10 then (n / (help n 1)) :: (digitsOfInt (n / 10)) else [n];;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n>=10 then\napp [5] [n mod 10] \nelse\napp [3] [8]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n", "Error: This expression has type int list\n       but an expression was expected of type int list -> int list\n", "Error: This expression has type int list\n       but an expression was expected of type int list -> int list\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else [n];;\n", "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else app [n] [];;\n", "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else app [n] [8];;\n", "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ([n / 10] [n mod 10]) else app [3] [8];;\n", "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ([n / 10] [n mod 10]) else app [3] [8];;\n", "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ([n / 10] [n mod 10]) else app [3] [8];;\n", "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ([n / 10] [n mod 10]) else app [3] [8];;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10)) [n mod 10] \nelse\napp [3] [8]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int -> 'a\n       but an expression was expected of type 'b list\n", "Error: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then (app digitsOfInt n) / (10 [n mod 10]) else app [3] [8];;\n", "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app digitsOfInt (n / 10) [n mod 10] else app [3] [8];;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app digitsOfInt (n / 10) [n mod 10] else [n];;\n"]}
{"fix": ["let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) (n mod 10::ls)\nelse\n[n]\nin\ndriver n []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value driver\n", "Error: This expression has type 'a -> 'b\n       but an expression was expected of type int\n"], "bad": ["\nlet digitsOfInt n =\n  let driver n ls =\n    if n >= 10 then (driver n) / (10 ((n mod 10) :: ls)) else [n] in\n  driver n [];;\n", "\nlet digitsOfInt n =\n  let rec driver n ls =\n    if n >= 10 then (driver n) / (10 ((n mod 10) :: ls)) else [n] in\n  driver n [];;\n"]}
{"fix": ["let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) ((n mod 10)::ls)\nelse\nls\nin\ndriver (n*10) []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int list -> int list\n       but an expression was expected of type int\n"], "bad": ["\nlet digitsOfInt n =\n  let rec driver n ls =\n    if n >= 10 then driver (n / 10) ((n mod 10) :: ls) else ls in\n  (driver n) * (10 []);;\n"]}
{"fix": ["let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) ((n mod 10)::ls)\nelse\nls\nin\ndriver n []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This function has type int -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet digitsOfInt n =\n  let rec driver n ls =\n    if n >= 10 then driver (n / 10) ((n mod 10) :: ls) else ls in\n  (driver n [] 3124) mod 10;;\n"]}
{"fix": ["let additivePersistence n =let rec county n=\nif n>=10 then\n1+ additivePersistence (help n)\nelse\n0\nin \ncounty n"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type int\n       This is not a function; it cannot be applied.\nError: Unbound value help\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec additivePersistence n =\n  if n >= 10 then 1 + (additivePersistence (help n)) else 0;;\n\nlet additivePersistence n =\n  let county = if n >= 10 then 1 + (additivePersistence (help n)) else 0 in\n  additivePersistence n;;\n\nlet rec help n = if n > 0 then (n mod 10) + (help (n / 10)) else 0;;\n\nlet additivePersistence n =\n  let rec county = if n >= 10 then 1 + (additivePersistence (help n)) else 0 in\n  county n;;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then\nseen \nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \n\nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: This expression has type 'a list list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list list\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem seen h then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then\nseen \nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \n\nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev helper ([], l);;\n"]}
{"fix": ["let rec wwhile (f,b) = match f b with\n|(a,c)->if not c then\na\nelse\nwwhile (f,a)"], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type 'a -> ('b -> 'c) * bool\n       but an expression was expected of type ('a -> ('b -> 'c) * bool) * 'a\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile f a;;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet _ = wwhile (f, 2);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile (let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value y\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let g y x = y b in ((g y b), b));;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile (let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type ('a -> 'a) -> 'a * bool\n       but an expression was expected of type ('a -> 'a) -> ('a -> 'a) * bool\n       The type variable 'a occurs inside 'a -> 'a\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let g y x =\n       let sec s fi m = if s = fi then (s, (s = (m s))) else (s, false) in\n       sec (y x) x in\n     ((g f b), b));;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile (let g x=\n\nin\n(g (f b),false)\n\n,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type ('a -> 'a) -> 'a * bool\n       but an expression was expected of type ('a -> 'a) -> ('a -> 'a) * bool\n       The type variable 'a occurs inside 'a -> 'a\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "Error: This function has type 'a -> 'a * bool\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let g y x =\n       let sec s fi m = if s = fi then (s, (s = (m s))) else (s, false) in\n       sec (y x) x in\n     ((g f b), b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let g y x = ((y x), false) in ((g f b), b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let g x = (x, false) in ((g f b), b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let g x = (x, false) in ((g (f b)), b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let g x = (x, false) in ((g (f b)), b));;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile (f\n\n,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let g x = x in (((g (f b)), false), b));;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile (g b f\n,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let g x y = ((x y), false) in ((g f b), b));;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile (let g x f= (f x,(f x)=x)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "bad": ["\nlet g x y = ((y (y x)), false);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((g b f), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (b, b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((b, false), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let g z = (z, false) in ((g b), b));;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "bad": ["\nlet g x f = ((f x), ((f x) = x));;\n\nlet h q x y = q x y;;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((h g f b), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile (h b f\n,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let h x y = ((y x), false) in ((h b f), b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let h x y = ((y x), (x = x)) in ((h b f), b));;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile (h b f,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "bad": ["\nlet h x y = ((y x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((h b f), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile (h,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "bad": ["\nlet h x b = ((b x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((h b f), b);;\n", "\nlet h x b = ((b x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((h b f), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile (let h a= f a\nin h b,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: Unbound value a\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let h = f in ((h, false), b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let h = f in ((h, false), b));;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile (let h a = f in ((h a), b));;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile (let h x= (f x,(f x)=x) in\nh,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((let h a = ((f a), false) in h b), b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * ('a -> 'b -> 'c) * ('a -> 'b -> 'c)\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval expr x y))\n  | Cosine expr -> cos (pi *. (eval expr x y))\n  | Average (expr,expr1) -> ((eval expr x y) +. (eval expr1 x y)) /. 2\n  | Times (expr,expr1) -> (eval expr x y) *. (eval expr1 x y)\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval expr x y) < (eval expr1 x y)\n      then eval expr2 x y\n      else eval expr3 x y;;\n"]}
{"fix": ["let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/. 2\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type expr\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) -> ((eval (expr x y)) +. (eval (expr1 x y))) /. 2\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n"]}
{"fix": ["let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) -> ((eval (expr, x, y)) +. (eval (expr1, x, y))) / 2\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value emitGrayscale\nError: Unbound constructor Average\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value emitGrayscale\n"], "bad": ["\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = emitGrayscale ((eval_fn sampleExpr), 150, \"sample\");;\n"]}
{"fix": ["let rec build (rand, depth) = let res=rand(0,4) in match depth with\n0-> if (res mod 2)=0 then\nbuildX()\nelse\nbuildY()\n|_ ->let nd=depth-1 in\nmatch res with\n|0->buildAverage(build(rand,nd),build(rand,nd))\n|1->buildThresh(build(rand,nd),build(rand,nd),\nbuild(rand,nd),build(rand,nd))\n|2->buildTimes(build(rand,nd),build(rand,nd))\n|3->buildSine(build(rand,nd))\n|4->buildCosine(build(rand,nd))\n|_->buildX()"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let res = rand (0, 4) in\n  match depth with\n  | 0 -> if (res mod 2) = 0 then buildX () else buildY ()\n  | _ ->\n      let nd = depth - 1 in\n      (match res with\n       | 0 -> buildAverage ((build (rand, nd)), (build (rand, nd)))\n       | 1 ->\n           buildThresh\n             ((build (rand, nd)), (build (rand, nd)), (build (rand, nd)),\n               (build (rand, nd)))\n       | 2 -> buildTimes ((build (rand, nd)), (build (rand, nd)))\n       | 3 -> buildSine (build (rand, nd))\n       | 4 -> buildCosine ((build rand), nd));;\n"]}
{"fix": ["et rec exprToString e = match e \nwith  \nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine  expr -> \"sin(pi*\"^(exprToString expr)^\")\"\n| Cosine expr-> \"cos(pi*\"^(exprToString expr)^\")\"\n| Average (expr,expr1)->\"((\"^(exprToString expr)^\"+\"\n^(exprToString expr1)^\")/2)\"\n|Times   (expr,expr1)->(exprToString expr)^\"*\"^(exprToString expr1)\n|Nom (expr1,expr2,expr3)->let res1,res2,res3=(exprToString expr1),\n(exprToString expr2),\n(exprToString expr3) \nin\n\"(\"^res1^\"+\"^res2^\"+\"^res3^\")/(abs(\"^res1^\")+abs(\"^res2^\")+abs(\"\n^res3^\"))\"\n\n|Squa expr -> let res=exprToString expr in\n\"abs(\"^res^\")/(abs\"^res^\"+\"^res^\"^2)\"\n| Thresh  (expr,expr1,expr2,expr3)->\"(\"^(exprToString expr)^\"<\"\n^(exprToString expr1)^\"?\"\n^(exprToString expr2)^\":\"^\n(exprToString expr3)"], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type string but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       ((\")\" / \"(abs(\") ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in\n      \"abs(\" ^ (res ^ (\")/(abs\" ^ (res ^ (\"+\" ^ (res ^ \"^2)\")))))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^ ((exprToString expr2) ^ (\":\" ^ (exprToString expr3)))))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value xprToString\nHint: Did you mean exprToString?\nError: Unbound value xprToString\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value xprToString\nHint: Did you mean exprToString?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet sampleExpr2 = Squa (Nom (VarX, VarY, VarX));;\n\nlet _ = xprToString sampleExpr2;;\n"]}
{"fix": ["let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"], "hw": "hw2", "problem": "eval", "message": ["Error: Unbound value r1\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r +. r2) +. r3) /.\n        (((abs_float r1) +. (abs_float r2)) +. (abs_float r3))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n"]}
{"fix": ["exprToString sampleExpr1"], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine expr -> \"sin(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Cosine expr -> \"cos(pi*\" ^ ((exprToString expr) ^ \")\")\n  | Average (expr,expr1) ->\n      \"((\" ^ ((exprToString expr) ^ (\"+\" ^ ((exprToString expr1) ^ \")/2)\")))\n  | Times (expr,expr1) -> (exprToString expr) ^ (\"*\" ^ (exprToString expr1))\n  | Nom (expr1,expr2,expr3) ->\n      let (res1,res2,res3) =\n        ((exprToString expr1), (exprToString expr2), (exprToString expr3)) in\n      \"(\" ^\n        (res1 ^\n           (\"+\" ^\n              (res2 ^\n                 (\"+\" ^\n                    (res3 ^\n                       (\")/(abs(\" ^\n                          (res1 ^\n                             (\")+abs(\" ^ (res2 ^ (\")+abs(\" ^ (res3 ^ \"))\")))))))))))\n  | Squa expr ->\n      let res = exprToString expr in res ^ (\"/(abs(\" ^ (res ^ \")+1)\"))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      \"(\" ^\n        ((exprToString expr) ^\n           (\"<\" ^\n              ((exprToString expr1) ^\n                 (\"?\" ^\n                    ((exprToString expr2) ^\n                       (\":\" ^ ((exprToString expr3) \")\")))))));;\n"]}
{"fix": ["let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Squa expr->let res=eval(expr,x,y) in res /. ((abs_float res )+. 1.0)\n| Nom (expr,expr1,expr2)-> let r1,r2,r3=(eval(expr,x,y),eval(expr1,x,y),\neval(expr2,x,y)) in\n(r1 +. r2 +. r3) /. ((abs_float r1)+.(abs_float r2)+.(abs_float r3))\n\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)"], "hw": "hw2", "problem": "eval", "message": ["Error: This function has type 'a -> unit\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        (((abs_float r1) +. (abs_float r2)) +. (abs_float r3))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\"))) eval\n    ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n"]}
{"fix": ["let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)"], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound constructor X\n", "Error: Unbound constructor X\n"], "bad": ["\nlet _ = X;;\n", "\nlet _ = X;;\n"]}
{"fix": ["removeDuplicates [1;6;2;4;12;2;13;6;9;99;99;-99;0]"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: Unbound value assoc\n"], "bad": ["\nlet _ =\n  assoc ((-1), \"bob\", [(\"ranj it\", 85); (\"william\", 23); (\"moose\", 44)]);;\n"]}
{"fix": ["fixpoint (g,0)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet _ = wwhile (f, 2);;\n"]}
{"fix": ["fixpoint (g,0)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet _ = wwhile (f, 2);;\n"]}
{"fix": ["fixpoint (g,0)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n"]}
{"fix": [], "hw": "hw2", "problem": "expr", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n"]}
{"fix": ["let buildNom(e,e1,e2)\t\t   = Nom(e,e1,e2)"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value e\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet buildNom (e,e1,e2) = Nom (e, e1, e2);;\n\nlet _ = buildNom (e, e1, e2);;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = (fun j y->y) in \nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base j y = y in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base = (fun z->z) in \nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value y\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = y in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base =  (fun y->y) in \nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value a\n", "Error: Unbound value x\n", "Error: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n"], "bad": ["\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x a in\nlet base =  (fun x _->x) in \nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = x in\nlet base =  (fun x ->x) in \nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun j->fun y-> x a in\nlet base =  (fun x ->x) in \nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b -> 'c -> 'd -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'd -> 'a\n"], "bad": ["\nlet pipe fs = let f a x j x = a in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type string but an expression was expected of type\n         string list\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = sepConcat sep t in List.fold_left f base l;;\n"]}
{"fix": ["let stringOfList f l = List.map f l"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: Unbound value map\nHint: Did you mean max?\n", "Error: Unbound value map\nHint: Did you mean max?\n", "Error: Unbound value map\nHint: Did you mean max?\n"], "bad": ["\nlet stringOfList f l = map f l;;\n", "\nlet stringOfList f l = map f l;;\n", "\nlet stringOfList f l = map f l;;\n"]}
{"fix": ["let stringOfList f l =\"[\"^ (sepConcat \"; \" (List.map f l) )^\"]\""], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound value sepList\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" sepList.map f l) ^ \"]\");;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (sepList.map f l)) ^ \"]\");;\n"]}
{"fix": ["let rec clone x n = let rec  helper xs sub depth=match depth with\n0->xs\n|_->helper (sub::xs) sub (depth-1)\nin helper [] x n"], "hw": "hw3", "problem": "clone", "message": ["Error: Unbound value helper\n"], "bad": ["\nlet rec clone x n =\n  let helper xs sub depth =\n    match depth with | 0 -> xs | _ -> helper (sub :: xs) sub (depth - 1) in\n  helper [] x n;;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in \nlet car,res=(res/10),(res mod 10) in\nlet c1,c2=a in\nmatch c1 with\n[]->([car],res::c2)\n|y::s->(car::s,(res+y)::c2) in\nlet base = ([],[]) in\nlet args = List.combine (List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value %\n", "Error: This function has type 'a list -> 'b list -> ('a * 'b) list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec clone x n =\n  let rec helper xs sub depth =\n    match depth > 0 with\n    | false  -> xs\n    | true  -> helper (sub :: xs) sub (depth - 1) in\n  helper [] x n;;\n\nlet rec padZero l1 l2 =\n  let sizeDif = (List.length l1) - (List.length l2) in\n  let appendS = clone 0 (abs sizeDif) in\n  if sizeDif < 0 then ((appendS @ l1), l2) else (l1, (appendS @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (op1,op2) ->\n          let res = op1 + op2 in\n          let (car,res) = ((res / 10), (res % 10)) in\n          let (c1,c2) = a in\n          (match c1 with\n           | [] -> ([car], (res :: c2))\n           | y::s -> ((car :: s), ((res + y) :: c2))) in\n    let base = ([], []) in\n    let args = List.combine List.rev l1 List.rev l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n =\n  let rec helper xs sub depth =\n    match depth > 0 with\n    | false  -> xs\n    | true  -> helper (sub :: xs) sub (depth - 1) in\n  helper [] x n;;\n\nlet rec padZero l1 l2 =\n  let sizeDif = (List.length l1) - (List.length l2) in\n  let appendS = clone 0 (abs sizeDif) in\n  if sizeDif < 0 then ((appendS @ l1), l2) else (l1, (appendS @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (op1,op2) ->\n          let res = op1 + op2 in\n          let (car,res) = ((res / 10), (res mod 10)) in\n          let (c1,c2) = a in\n          (match c1 with\n           | [] -> ([car], (res :: c2))\n           | y::s -> ((car :: s), ((res + y) :: c2))) in\n    let base = ([], []) in\n    let args = List.combine List.rev l1 List.rev l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in\nlet p1,p2=a in\nmatch p2 with \n[]->(p1,(res/10)::(res mod 10)::[])\n|a::b->let re=a+(res mod 10)  in\n(p1,(re/10)::(re mod 10)::b )in\nlet base = ([],[]) in\nlet args = List.combine (List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * int list -> int * int -> int list\n       but an expression was expected of type\n         'a * int list -> int * int -> 'a * int list\n       Type int list is not compatible with type 'a * int list \n"], "bad": ["\nlet rec clone x n =\n  let rec helper xs sub depth =\n    match depth > 0 with\n    | false  -> xs\n    | true  -> helper (sub :: xs) sub (depth - 1) in\n  helper [] x n;;\n\nlet rec padZero l1 l2 =\n  let sizeDif = (List.length l1) - (List.length l2) in\n  let appendS = clone 0 (abs sizeDif) in\n  if sizeDif < 0 then ((appendS @ l1), l2) else (l1, (appendS @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (op1,op2) ->\n          let res = op1 + op2 in\n          let (p1,p2) = a in\n          (match p2 with\n           | [] -> [res / 10; res mod 10]\n           | a::b ->\n               let re = a + (res mod 10) in (re / 10) :: (re mod 10) :: b) in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigMul", "message": ["Error: Unbound value s\n"], "bad": ["\nlet bigMul l1 l2 =\n  let f a x = s in\n  let base = ([0], [0]) in\n  let args = (l1, l2) in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = let b,c=a in match b with \nd::t-> ((d*10)::t, t)\n|_    ->a\nin\n\nlet base =(1::l2,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int list\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec clone x n =\n  let rec helper xs sub depth =\n    match depth > 0 with\n    | false  -> xs\n    | true  -> helper (sub :: xs) sub (depth - 1) in\n  helper [] x n;;\n\nlet rec padZero l1 l2 =\n  let sizeDif = (List.length l1) - (List.length l2) in\n  let appendS = clone 0 (abs sizeDif) in\n  if sizeDif < 0 then ((appendS @ l1), l2) else (l1, (appendS @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (op1,op2) ->\n          let res = op1 + op2 in\n          let (p1,p2) = a in\n          (match p2 with\n           | [] -> (p1, [res / 10; res mod 10])\n           | a::b ->\n               let re = a + res in (p1, ((re / 10) :: (re mod 10) :: b))) in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i l acc =\n    match i with | 0 -> acc | _ -> helper (i - 1) l (bigAdd l acc) in\n  helper i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (b,c) = a in\n    match b with\n    | d::t -> (((d * 10) :: t), (bigAdd ((mulByDigit (d * x) t) c)))\n    | _ -> a in\n  let base = ((1 :: l2), [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile(f, b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = ((wwhile (wwhile (f, (f b)))), b);;\n", "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, (f b));;\n", "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, (f b));;\n", "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f (f b)), b);;\n", "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, (f b));;\n"]}
{"fix": ["let rec fixpoint (f,b) = wwhile(f, b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value ffixpoint\nHint: Did you mean fixpoint?\n", "Error: This expression has type 'a but an expression was expected of type\n         'a -> 'a * bool\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a but an expression was expected of type\n         'a -> 'a * bool\n       The type variable 'a occurs inside 'a -> 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile ((ffixpoint (f, (f b))), b);;\n", "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n", "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile ((((fixpoint (f, (f b))) * (f b)) = b), b);;\n", "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (((fixpoint (f, (f b))), ((f b) = b)), b);;\n", "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (((fixpoint (f, (f b))), (f b)), b);;\n", "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (((fixpoint (f, (f b))), ((f b) = b)), b);;\n", "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type ('d -> 'd * bool) * 'd\n", "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type 'a * 'b * 'c\n       but an expression was expected of type ('d -> 'd * bool) * 'd\n", "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b -> 'b * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a * 'b\n       but an expression was expected of type unit\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, ((f b) = b), b);;\n", "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile ((f ((f b) = b)), b);;\n", "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile ((f * ((f b) = b)), b);;\n", "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f ((f b) = b)), b);;\n", "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (f, ((f b) = b), b);;\n", "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f ((f b) = b)), b);;\n", "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f :: ((f b) = b)), b);;\n", "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (if (f b) = b then (f, b));;\n", "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (if (f b) = b then ((f b), b));;\n", "\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (if (f b) != b then ((fixpoint (f, (f b))), b));;\n"]}
{"fix": ["let rec wwhile (f,b) = \nlet rec helper (b', c')=\nif c' = true then helper(f b')\nelse b'\nin helper (f b)"], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f, b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile((fun b ->  (f b, (f b) = b)), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a -> 'b -> 'c\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b -> 'c\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "Error: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"], "bad": ["\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f, (f b)), b);;\n", "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f f b), b);;\n", "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (((f b), b), b);;\n", "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) = b)), b);;\n", "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) = b)), b);;\n", "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet fixpoint (f,b) = wwhile (fun x  -> (((f b), ((f b) = b)), b));;\n", "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet rec wwhile (f,b) =\n  let rec helper (b',c') = if c' = true then helper (f b') else b' in\n  helper (f b);;\n\nlet rec fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile((fun b ->  (f b, (f b) != b)), b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 1);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n"], "bad": ["\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 107);;\n", "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 3);;\n", "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 3);;\n"]}
{"fix": [], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value removeDuplicates\n"], "bad": ["\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile((fun b ->  (f b, b != f b)) , b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 48);;\n"]}
{"fix": ["let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)"], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: Unbound value sprintf\n", "Error: Unbound value sprintf\n", "Error: Unbound module Output\n", "Error: Unbound module Module\n", "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "Error: Variable e is bound several times in this matching\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: Unbound value sprintf\n", "Error: This expression has type expr but an expression was expected of type\n         string\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type expr but an expression was expected of type\n         string\n", "Error: This expression has type string but an expression was expected of type\n         string -> string\n", "Error: This expression has type unit but an expression was expected of type\n         string -> string\n", "Error: This expression has type expr but an expression was expected of type\n         int\n", "Error: This expression has type expr but an expression was expected of type\n         int\n", "Error: This expression has type string but an expression was expected of type\n         string -> string\n", "Error: This expression has type string but an expression was expected of type\n         string -> string\n", "Error: This expression has type string -> string\n       but an expression was expected of type string\n", "Error: This expression has type string -> string\n       but an expression was expected of type string\n", "Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: The constructor VarY expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: The constructor VarY expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: This expression has type expr but an expression was expected of type\n         string\n", "Error: This expression has type expr but an expression was expected of type\n         string\n", "Error: This expression has type expr but an expression was expected of type\n         string\n", "Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: This expression has type expr but an expression was expected of type\n         string\n", "Error: This expression has type expr but an expression was expected of type\n         string list\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type expr but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"%s\" e;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> sprintf \"%s\" e;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> sprintf \"%s\" e;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Output.sprintf \"%s\" e;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> Module.sprintf \"%s\" e;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine  -> \"%s\" e\n  | Cosine  -> \"%s\" e\n  | Average  -> \"%s\" e\n  | Times  -> \"%s\" e\n  | Thresh  -> \"%s\" e;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine  -> \"%s %s\" e e\n  | Cosine  -> \"%s\" e\n  | Average  -> \"%s\" e\n  | Times  -> \"%s\" e\n  | Thresh  -> \"%s\" e;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine  -> \"%s %s\" e\n  | Cosine  -> \"%s\" e\n  | Average  -> \"%s\" e\n  | Times  -> \"%s\" e\n  | Thresh  -> \"%s\" e;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine e -> \"%s\" e\n  | Cosine e -> \"%s\" e\n  | Average (e,e) -> \"%s\" e\n  | Times (e,e) -> \"%s\" e\n  | Thresh (e,e,e,e) -> \"%s\" e;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine e1 -> \"%s\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> sprintf \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine e1 -> \"%s\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\" e\n  | VarY  -> \"%s\" e\n  | Sine e1 -> \"%s\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> \"%s\" e\n  | Sine e1 -> \"%s\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"%s\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"e1\"\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.printf \"e1\"\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"%d\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"%x\" e1\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"e1\"\n  | Cosine e2 -> \"%s\" e2\n  | Average (e3,e4) -> \"%s %s\" e3 e4\n  | Times (e5,e6) -> \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> \"%s %s %s %s\" e7 e8 e9 e0;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"e1\"\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\"\n  | VarY  -> Printf.sprintf \"%s\"\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX x -> x\n  | VarY y -> y\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY y -> y\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY y -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%s\" e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX e -> e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" e2\n  | Average (e3,e4) -> Printf.sprintf \"%s %s\" e3 e4\n  | Times (e5,e6) -> Printf.sprintf \"%s %s\" e5 e6\n  | Thresh (e7,e8,e9,e0) -> Printf.sprintf \"%s %s %s %s\" e7 e8 e9 e0\n  | _ -> \"\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX e -> e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"\" :: e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"%d\" e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"%d\" e\n  | VarY  -> e\n  | Sine e1 -> Printf.sprintf \"%s\" (exprToString e1)\n  | Cosine e2 -> Printf.sprintf \"%s\" (exprToString e2)\n  | Average (e3,e4) ->\n      Printf.sprintf \"%s %s\" (exprToString e3) (exprToString e4)\n  | Times (e5,e6) ->\n      Printf.sprintf \"%s %s\" (exprToString e5) (exprToString e6)\n  | Thresh (e7,e8,e9,e0) ->\n      Printf.sprintf \"%s %s %s %s\" (exprToString e7) (exprToString e8)\n        (exprToString e9) (exprToString e0)\n  | _ -> \"\";;\n"]}
{"fix": ["let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         expr * expr\n", "Error: This expression has type expr but an expression was expected of type\n         expr * expr\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand mod 2) = 0 then buildX () else buildY ())\n  else\n    if (rand mod 5) = 0\n    then buildSine (build (rand, (depth - 1)))\n    else\n      if (rand mod 5) = 1\n      then buildCosine (build (rand, (depth - 1)))\n      else\n        if (rand mod 5) = 2\n        then buildAverage (build (rand, (depth - 1)))\n        else\n          if (rand mod 5) = 3\n          then buildAverage (build (rand, (depth - 1)))\n          else\n            if (rand mod 5) = 4 then buildThresh (build (rand, (depth - 1)));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand mod 2) = 0 then buildX () else buildY ())\n  else\n    if (rand mod 5) = 0\n    then buildSine (build (rand, (depth - 1)))\n    else\n      if (rand mod 5) = 1\n      then buildCosine (build (rand, (depth - 1)))\n      else\n        if (rand mod 5) = 2\n        then\n          buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n        else\n          if (rand mod 5) = 3\n          then buildAverage (build (rand, (depth - 1)))\n          else\n            if (rand mod 5) = 4 then buildThresh (build (rand, (depth - 1)));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand mod 2) = 0 then buildX () else buildY ())\n  else\n    if (rand mod 5) = 0\n    then buildSine (build (rand, (depth - 1)))\n    else\n      if (rand mod 5) = 1\n      then buildCosine (build (rand, (depth - 1)))\n      else\n        if (rand mod 5) = 2\n        then\n          buildAverage\n            ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n        else\n          if (rand mod 5) = 3\n          then\n            buildTimes\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if (rand mod 5) = 4\n            then\n              buildThresh\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                  (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value buildCos\nHint: Did you mean build, buildCosine, buildY or buildX?\nError: Unbound value buildCos\nHint: Did you mean build, buildY or buildX?\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value buildCos\nHint: Did you mean build, buildCosine, buildY or buildX?\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n", "Error: This expression has type expr but an expression was expected of type\n         unit\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand mod 2) = 0 then buildX () else buildY ())\n  else if (rand > 0) & (rand < 20) then buildCos (build (rand, (depth - 1)));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand mod 2) = 0 then buildX () else buildY ())\n  else\n    if (rand > 0) & (rand < 20) then buildCosine (build (rand, (depth - 1)));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then (if (rand mod 2) = 0 then buildX () else buildY ())\n  else\n    if (rand > 0) & (rand < 20) then buildCosine (build (rand, (depth - 1)));;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value %\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> if (rand % 2) = 0 then buildX () else buildY ()\n  | 1 ->\n      if (rand % 2) = 0\n      then buildSin (build (rand, (depth - 1)))\n      else buildCos (build (rand, (depth - 1)));;\n"]}
{"fix": ["let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), build(rand, depth - 2))\n| 3 ->\nbuildTimes(build(rand, depth - 2), build(rand, depth - 2))\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))\n| _ -> buildY()"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type int * int -> int\n       but an expression was expected of type int\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (match rand with\n     | 0 -> buildSine (build ((makeRand (0, 6)), (depth - 1))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then buildX ()\n  else\n    (match rand with\n     | 0 -> buildSine (build ((rand (0, 5)), (depth - 1)))\n     | 1 -> buildCosine (build ((rand (0, 5)), (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build ((rand (0, 5)), (depth - 2))),\n             (build ((rand (0, 5)), (depth - 2))))\n     | 3 ->\n         buildTimes\n           ((build ((rand (0, 5)), (depth - 2))),\n             (build ((rand (0, 5)), (depth - 2))))\n     | 4 ->\n         buildThresh\n           ((build ((rand (0, 5)), (depth - 4))),\n             (build ((rand (0, 5)), (depth - 4))),\n             (build ((rand (0, 5)), (depth - 4))),\n             (build ((rand (0, 5)), (depth - 4)))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | POS of expr* expr* expr* expr\n  | SOP of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e0 -> sin (pi *. (eval (e0, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e2,e3) -> ((eval (e2, x, y)) +. (eval (e3, x, y))) /. 2.0\n  | Times (e4,e5) -> (eval (e4, x, y)) *. (eval (e5, x, y))\n  | Thresh (e6,e7,e8,e9) ->\n      if (eval (e6, x, y)) < (eval (e7, x, y))\n      then eval (e8, x, y)\n      else eval (e9, x, y)\n  | POS (a,b,c,d) ->\n      ((eval (a, x, y)) +. (eval (b, x, y))) *.\n        ((eval (c, x, y)) +. (eval (d, x, y)))\n  | SOP (f,g,h) -> (eval (f, x, y)) + ((eval (g, x, y)) *. (eval (h, x, y)));;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| h::t -> f h h\n| [] -> fun x -> x in \nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type (('a -> 'b) * ('b -> 'a)) list\n       but an expression was expected of type ('b -> 'b) list\n       Type ('a -> 'b) * ('b -> 'a) is not compatible with type 'b -> 'b \n", "Error: This expression has type ('a -> 'b) list\n       but an expression was expected of type 'c -> 'a\n"], "bad": ["\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | (b,c)::t -> f b c | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | h::t -> f h t | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n"]}
{"fix": [], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'a) list\n       but an expression was expected of type (('b -> 'a) -> 'b -> 'a) list\n       The type variable 'a occurs inside 'b -> 'a\n"], "bad": ["\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | h::t -> f h | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type string but an expression was expected of type\n         string list\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = h in let l = h in List.fold_left f base l;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| [] -> fun x -> x \n| h::t -> f (fun x -> x) h in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) list\n       but an expression was expected of type 'c -> 'a\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b -> 'c\n"], "bad": ["\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | [] -> (fun x  -> x) | h::t -> f h t in\n  List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | [] -> (fun x  -> x) | h::t -> f t h in\n  List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| [] -> fun x -> x * 1\n| h::t -> f (fun x -> x * 1) h in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b\n       but an expression was expected of type int\n"], "bad": ["\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | [] -> 0 | h::t -> f (fun x  -> x) h in\n  List.fold_left f base fs;;\n"]}
{"fix": ["let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet g a x = a ^ \";\" ^ x in\nlet base = f h in \nlet x = t in\nList.fold_left g base l"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet stringOfList f l =\n  match l with\n  | [] -> \"\"\n  | h::t ->\n      let g a x = a ^ (\";\" ^ x) in\n      let base = f h in let x = f t in List.fold_left g base x;;\n"]}
{"fix": ["let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet m b = \"[\" ^ b ^ \"]\" in\nlet n a x = a ^ \" ;\" ^ x in\nlet base = f h in \nList.fold_left n base t"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: Unbound value g\n"], "bad": ["\nlet stringOfList f l =\n  match l with\n  | [] -> \"\"\n  | h::t ->\n      let m b = \"[\" ^ (b ^ \"]\") in\n      let n a x = a ^ (\" ;\" ^ x) in let base = f h in List.fold_left g base t;;\n"]}
{"fix": ["let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet m a b = \"[\" ^ a ^ \";\" ^ b ^ \"]\" in\nlet base = f h in \nList.fold_left m base l"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet stringOfList f l =\n  match l with\n  | [] -> \"\"\n  | h::t ->\n      let m a b = \"[\" ^ (a ^ ((\";\" b) ^ \"]\")) in\n      let base = f h in List.fold_left m base l;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = fun y -> y in \nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value t\n"], "bad": ["\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | [] -> (fun x  -> x) | h::t -> f (fun x  -> x) h in\n  List.fold_left f base t;;\n"]}
{"fix": [], "hw": "hw3", "problem": "sepConcat", "message": ["Error: Unbound value top\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left top helper;;\n"]}
{"fix": ["let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\""], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" f l) ^ \"]\");;\n"]}
{"fix": ["let padZero l1 l2 = \nif List.length l1 < List.length l2 then\n(clone 0 (List.length l2 - List.length l1)::l1),l2\nelse if List.length l2 > List.length l2 then\nl1, (clone 0 (List.length l1 - List.length l2)::l2)\nelse \nl1, l2"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type int but an expression was expected of type\n         unit\n"], "bad": ["\nlet padZero l1 l2 = if l1 < l2 then 0;;\n"]}
{"fix": ["let padZero l1 l2 = \nlet first = List.length l1 in\nlet sec = List.length l2 in\nif first < sec then\nList.append (clone 0 (sec - first)) l1, l2\nelse if first > sec then\nl1, List.append (clone 0 (first - sec)) l2\nelse \nl1, l2"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int list list\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then (clone 0 (sec - first)) :: l1\n  else\n    if first > sec then (l1, ((clone 0 (first - sec)) :: l2)) else (l1, l2);;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then List.append l1 ((clone 0 (first - sec)) :: l2)\n    else (l1, l2);;\n"]}
{"fix": ["let rec removeZero l = match l with\n| [] -> []\n| h::t -> \nif h = 0 then removeZero t\nelse t"], "hw": "hw3", "problem": "removeZero", "message": ["Error: Unbound value t\n"], "bad": ["\nlet rec removeZero l = match l with | 0 -> removeZero t | _ -> l;;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type ('a * 'b) list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = List.combine (List.rev l1) (List.rev l2) in\n    let args = List.split base in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type ('c * 'd) list\n", "Error: This expression has type int * int\n       but an expression was expected of type int\n", "Error: This expression has type int * int\n       but an expression was expected of type int list\n", "Error: This expression has type int but an expression was expected of type\n         int * int\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = (0, 0) in\n    let args =\n      let combo = List.combine (List.rev l1) (List.rev l2) in\n      match combo with\n      | (i,j) -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> (0, 0) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = (0, 0) in\n    let args =\n      let combo = List.combine (List.rev l1) (List.rev l2) in\n      match combo with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> (0, 0) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args =\n      let combo = List.combine (List.rev l1) (List.rev l2) in\n      match combo with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> (0, 0) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> (0, 0) in\n    let base = 0 in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> (0, 0) in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> (0, 0) in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n", "Error: This expression has type 'a list\n       but an expression was expected of type int * int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int * int\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b * 'c\n", "Error: This expression has type 'a list\n       but an expression was expected of type int * int\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> a in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> a in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> a in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j) -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | _ -> a in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j) ->\n          if (i + j) > 9 then a :: (1, ((i + j) - 10)) else a :: (0, (i + j))\n      | _ -> a in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j) -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> a in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j)) in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      if (i + j) > 9\n      then (1, ((i + j) - 10))\n      else if (i + j) <= 9 then (0, (i + j)) in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      if (i + j) > 9\n      then (1, ((i + j) - 10))\n      else if (i + j) <= 9 then (0, (i + j)) in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      if (i + j) > 9\n      then (1, ((i + j) - 10))\n      else if (i + j) <= 9 then (0, (i + j)) in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      if (i + j) > 9\n      then (1, ((i + j) - 10))\n      else if (i + j) <= 9 then (0, (i + j)) in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i+j+s)/10, ((i+j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "Error: Unbound value %\n", "Error: This expression has type int -> int * int -> int * int\n       but an expression was expected of type int -> int * int -> int\n       Type int * int is not compatible with type int \n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n", "Error: This expression has type int * 'a list\n       but an expression was expected of type int * int\n       Type 'a list is not compatible with type int \n", "Error: This expression has type int * 'a list\n       but an expression was expected of type int * int\n       Type 'a list is not compatible with type int \n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int * int -> int * int -> bool\n       but an expression was expected of type\n         int * int -> int * int -> int * int\n       Type bool is not compatible with type int * int \n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      if (i + j) > 9\n      then (1, ((i + j) - 10))\n      else if (i + j) <= 9 then (0, (i + j)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (i,j) = x in ((((i + j) + a) / 10), (((i + j) + a) % 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in ((((i + j) + a) / 10), (((i + j) + a) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (i,j) = x in a :: (((i + j) / 10), ((i + j) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in a ::\n        (((((i + j) + s) + t) / 10), ((((i + j) + s) + t) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in\n      (((((i + j) + s) + t) / 10), ((((i + j) + s) + t) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in\n      (((((i + j) + s) + t) / 10), ((((i + j) + s) + t) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in a ::\n        (((((i + j) + s) + t) / 10), ((((i + j) + s) + t) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in (s, t) ::\n        (((((i + j) + s) + t) / 10), ((((i + j) + s) + t) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (i,j) = x in a :: (((i + j) / 10), ((i + j) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (i,j) = x in (((i + j) mod 10), (a :: ((i + j) / 10))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in (((i + j) / 10), (t :: ((i + j) mod 10))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in (((i + j) / 10), ((i + j) mod 10)) = a in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in (((i + j) / 10), (t :: ((i + j) mod 10))) = a in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), (t :: (((i + j) + s) mod 10))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), (t @ (((i + j) + s) mod 10))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), (t :: (((i + j) + s) mod 10))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in\n      a = ((((i + j) + s) / 10), (t :: (((i + j) + s) mod 10))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i+j+s)/10, ((i+j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int list -> int list * int list\n       but an expression was expected of type 'a list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (padZero l1)) (List.rev (padZero l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i+j+s)/10, ((i+j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type (int list * int list) list\n       but an expression was expected of type (int * int) list\n       Type int list is not compatible with type int \n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev l1) :: 0) ((List.rev l2) :: 0) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev 0) :: l1) ((List.rev 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev l1) :: 0) ((List.rev 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev 0) :: l1) ((List.rev 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev [0]) :: l1) ((List.rev 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev [0]) :: l1) ((List.rev [0]) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let rec mulByDigit i l =\nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i*j+s)/10, ((i*j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev (0::l1)) (List.rev (clone (List.length l) i)) in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'b * int list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec mulByDigit i l =\n  let mul (i1,l1) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args =\n      List.combine (List.rev (0 :: l1)) (List.rev (clone (List.length l) i)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (mul l);;\n"]}
{"fix": ["let rec mulByDigit i l =\nlet f a x = \nlet (i,j) = x in \nlet (s,t) =  a in \n((i*j+s)/10, ((i*j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev (0::l1)) (clone i (List.length l+1)) in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type 'a list -> int\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet l1 = [9; 9; 9];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args =\n    List.combine (List.rev (0 :: l1)) (clone i ((List.length + 1) l)) in\n  let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in\nmultiplier (float_of_int i) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int list -> int list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type\n         float * int list list -> int -> int * int list list\n       but an expression was expected of type\n         float * int list list -> int -> float * int list list\n       Type int is not compatible with type float \n", "Error: This expression has type\n         float * int list list -> int -> int * int list list\n       but an expression was expected of type\n         float * int list list -> int -> float * int list list\n       Type int is not compatible with type float \n", "Error: Unbound value multipler\nHint: Did you mean multiplier?\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    (((List.length l1) - 1), (((mulByDigit x) * ((10 ** i) l2)) :: j)) in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    (((List.length l1) - 1), ((mulByDigit (x * (10 ** i)) l2) :: j)) in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    (((List.length l1) - 1), ((mulByDigit (x * ((float_of_int 10) ** i)) l2)\n      :: j)) in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    (((List.length l1) - 1),\n      ((mulByDigit (x * (int_of_float ((float_of_int 10) ** i))) l2) :: j)) in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    (((List.length l1) - 1),\n      ((mulByDigit (x * (int_of_float ((float_of_int 10) ** i))) l2) :: j)) in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      (((List.length l1) - 1), ((mulByDigit (x * (int_of_float (m ** i))) l2)\n        :: n)) in\n    multipler (float_of_int i) j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      (((List.length l1) - 1), ((mulByDigit (x * (int_of_float (m ** i))) l2)\n        :: n)) in\n    multiplier (float_of_int i) j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      (((List.length l1) - 1),\n        ((mulByDigit (x * (int_of_float (m ** 10))) l2) :: n)) in\n    multiplier (float_of_int i) j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(i-1, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in\nmultiplier (float_of_int ((List.length l1)-1)) j in\n\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      ((m - 1), ((mulByDigit (x * (int_of_float (m ** 10.0))) l2) :: n)) in\n    multiplier (float_of_int ((List.length l1) - 1)) j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      ((m - 1.0), ((mulByDigit (x * (int_of_float (m ** 10.0))) l2) :: n)) in\n    multiplier (float_of_int ((List.length l1) - 1)) j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(i-1, (mulByDigit x l2)::(clone 0 m)::n) in\nmultiplier ((List.length l1)-1) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      ((i - 1), (((mulByDigit x l2) * (int_of_float (10 ** m))) :: n)) in\n    multiplier (float_of_int ((List.length l1) - 1)) j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n = ((i - 1), ((mulByDigit x l2) :: (clone 0 m) :: n)) in\n    multiplier (float_of_int ((List.length l1) - 1)) j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(i-1, bigAdd ((mulByDigit x l2)@(clone 0 m)) n) in\nmultiplier ((List.length l1)-1) j in\nlet base = (0, []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      ((i - 1), (bigAdd ((mulByDigit x l2) :: (clone 0 m)) n)) in\n    multiplier ((List.length l1) - 1) j in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(m+1, bigAdd ((mulByDigit x l2)@(clone 0 m)) n) in\nmultiplier 0 j in\nlet base = ((List.length l1) - 1 , []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type 'a list -> int\n       but an expression was expected of type int\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a list -> int\n       but an expression was expected of type int\n"], "bad": ["\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,j) = a in\n    let multiplier m n =\n      ((m + 1), (bigAdd ((mulByDigit x l2) @ (clone 0 m)) n)) in\n    multiplier 0 j in\n  let base = ((List.length - 1), []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let rec mulByDigit i l =\nlet f a x = match i with \n| 0 -> (0,[])\n| _ ->\nlet (i,j) = x in \nlet (s,t) =  a in \n((i*j+s)/10, ((i*j+s) mod 10)::t) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev (0::l)) (clone i ((List.length l)+1)) in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match i with\n    | 0 -> []\n    | _ ->\n        let (i,j) = x in\n        let (s,t) = a in\n        ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args = List.combine (List.rev (0 :: l)) (clone i ((List.length l) + 1)) in\n  let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n < 0 then []\nelse n mod 10 :: digitsOfInt (n/10)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value %\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n < 0 then [] else (n % 10) :: (digitsOfInt (n / 10));;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n <= 0 then []\nelse n/10 :: digitsOfInt (n/10)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n <= 0 then []\nelse n mod 10 :: digitsOfInt (n/10)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n <= 0 then [] (* BUG *)\nelse digitsOfInt (n/10) @ [n mod 10]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else ((digitsOfInt n) / 10) @ [n mod 10];;\n"]}
{"fix": ["let rec additivePersistence n = \nif n = 0 then 0\nelse 1 + additivePersistence (sumList (digits n))"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec digitsOfIntHelper n =\n  if n > 0 then (digitsOfIntHelper (n / 10)) @ [n mod 10] else [];;\n\nlet rec digitsOfInt n = if n == 0 then [0] else digitsOfIntHelper n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n\nlet rec additivePersistence n =\n  if n = 0 then 0 else 1 + (additivePersistence sumList (digits n));;\n", "\nlet rec digitsOfIntHelper n =\n  if n > 0 then (digitsOfIntHelper (n / 10)) @ [n mod 10] else [];;\n\nlet rec digitsOfInt n = if n == 0 then [0] else digitsOfIntHelper n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n\nlet rec additivePersistence n =\n  if n = 0 then 0 else 1 + (additivePersistence (sumList digits n));;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n > 0 then (n mod 10) :: digitsOfInt (n/10)\nelse []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n > 0 then ((digitsOfInt n) mod 10) :: (n / 10) else [];;\n", "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n mod 10)) :: (n / 10) else [];;\n", "\nlet rec digitsOfInt n =\n  if n > 0 then digitsOfInt ((n mod 10) :: (n / 10)) else [];;\n", "\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: ((digitsOfInt n) / 10) else [];;\n"]}
{"fix": ["let rec digitsOfInt n = \nif n > 0 then \nlet k = digitsOfInt (n/10) in\n(n mod 10) :: k\nelse []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n > 0 then let k = digitsOfInt (n / 10) in k :: (n mod 10) else [];;\n"]}
{"fix": ["let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t else false\n| _ -> false)\n| _ -> false"], "hw": "hw1", "problem": "palindrome", "message": ["Error: Unbound value palindromeHelper\n", "Error: Unbound value palindromeHelper\n", "Error: Unbound value palindromeHelper\n", "Error: This expression has type bool but an expression was expected of type\n         unit\n", "Error: This expression has type bool but an expression was expected of type\n         unit\n", "Error: This expression has type bool but an expression was expected of type\n         unit\n", "Error: This expression has type bool but an expression was expected of type\n         unit\n", "Error: This expression has type bool but an expression was expected of type\n         unit\n"], "bad": ["\nlet palindromeHelper w r =\n  match w with\n  | [] -> (match r with | [] -> true | _ -> false)\n  | x::s ->\n      (match r with\n       | y::t -> if x == y then palindromeHelper s t\n       | _ -> false);;\n", "\nlet palindromeHelper w r =\n  match w with\n  | [] -> (match r with | [] -> true | _ -> false)\n  | x::s ->\n      (match r with\n       | y::t -> if x == y then palindromeHelper s t\n       | _ -> false)\n  | _ -> false;;\n", "\nlet palindromeHelper w r =\n  match w with\n  | [] -> (match r with | [] -> true | _ -> false)\n  | x::s ->\n      (match r with | y::t -> if x = y then palindromeHelper s t | _ -> false);;\n", "\nlet rec palindromeHelper w r =\n  match w with\n  | [] -> (match r with | [] -> true | _ -> false)\n  | x::s ->\n      (match r with | y::t -> if x = y then palindromeHelper s t | _ -> false);;\n", "\nlet rec palindromeHelper w r =\n  match w with\n  | [] -> (match r with | [] -> true | _ -> false)\n  | x::s ->\n      (match r with | y::t -> if x = y then palindromeHelper s t | _ -> false);;\n", "\nlet rec palindromeHelper w r =\n  match w with\n  | [] -> (match r with | [] -> true | _ -> false)\n  | x::s ->\n      (match r with | y::t -> if x = y then palindromeHelper s t | _ -> false);;\n", "\nlet rec palindromeHelper w r =\n  match w with\n  | [] -> (match r with | [] -> true | _ -> false)\n  | x::s ->\n      (match r with | y::t -> if x = y then palindromeHelper s t | _ -> false)\n  | _ -> false;;\n", "\nlet rec palindromeHelper w r =\n  match w with\n  | [] -> (match r with | [] -> true | _ -> false)\n  | x::s ->\n      (match r with | y::t -> if x = y then palindromeHelper s t | _ -> false)\n  | _ -> false;;\n"]}
{"fix": ["let rec digitsOfInt n = \nlet rec digitsOfIntHelper n result = \nif n > 0 then digitsOfIntHelper (n/10) (n mod 10 :: result)\nelse result in \ndigitsOfIntHelper n []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  let rec digitsOfIntHelper n result =\n    if n > 0\n    then (digitsOfIntHelper (n / 10) (n mod 10)) :: result\n    else result in\n  digitsOfIntHelper n [];;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l)) removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9]\n    [1; 6; 2; 4; 12; 13; 9];;\n"]}
{"fix": ["let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\"  ^ exprToString x ^ \"*\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b \n^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d"], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type string but an expression was expected of type\n         int\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> (\"sin(pi*\" + (exprToString x)) + \")\"\n  | Cosine x -> (\"cos(pi*\" + (exprToString x)) + \")\"\n  | Average (x,y) ->\n      (((\"((\" + (exprToString x)) + \"*\") + (exprToString y)) + \")/2)\"\n  | Times (x,y) -> ((exprToString x) + \"*\") + (exprToString y)\n  | Thresh (a,b,c,d) ->\n      (((((\"(\" + (exprToString a)) + \"<\") + (exprToString b)) +\n          (\"?\" exprToString c))\n         + \":\")\n        + (exprToString d);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 ((\"?\" exprToString c) ^ (\":\" ^ (exprToString d))))));;\n"]}
{"fix": ["let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\"  ^ exprToString x ^ \"*\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b \n^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d"], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type string but an expression was expected of type\n         int\n", "Error: This expression has type string but an expression was expected of type\n         int\n", "Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> (\"sin(pi*\" + (exprToString x)) + \")\"\n  | Cosine x -> (\"cos(pi*\" + (exprToString x)) + \")\"\n  | Average (x,y) ->\n      (((\"((\" + (exprToString x)) + \"*\") + (exprToString y)) + \")/2)\"\n  | Times (x,y) -> ((exprToString x) + \"*\") + (exprToString y)\n  | Thresh (a,b,c,d) ->\n      (((((\"(\" + (exprToString a)) + \"<\") + (exprToString b)) +\n          (\"?\" exprToString c))\n         + \":\")\n        + (exprToString d);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> ((exprToString x) + \"*\") ^ (exprToString y)\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 ((\"?\" exprToString c) ^ (\":\" ^ (exprToString d))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"*\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 ((\"?\" exprToString c) ^ (\":\" ^ (exprToString d))))));;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)"], "hw": "hw2", "problem": "eval", "message": ["Error: This variant pattern is expected to have type expr\n       The constructor Cos does not belong to type expr\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "Error: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "Error: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type expr but an expression was expected of type\n         expr * float * float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> sin (pi *. (eval u))\n  | Cos u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> sin (pi *. (eval u))\n  | Cosine u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval u)\n  | Cosine u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval u)\n  | Cosine u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi\n  | Cosine u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval u)\n  | Cosine u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi * (eval u)\n  | Cosine u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval u)\n  | Cosine u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> ((pi *. (eval u)) * 1) * 1\n  | Cosine u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval (u, x, y))\n  | Cosine u -> cos (pi *. (eval u))\n  | Average (u,v) -> ((eval u) +. (eval v)) /. 2\n  | Times (u,v) -> (eval u) *. (eval v)\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval (u, x, y))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> pi *. (eval (u, x, y))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v;;\n"]}
{"fix": ["let rec build (rand,depth) = \nif depth = 1 then \nif rand(0,1) = 0 then VarX\nelse VarY\nelse (* depth > 1 *)\nmatch rand(0,4) with\n| 0 -> Sine (build (rand, depth-1))\n| 1 -> Cosine (build (rand, depth-1))\n| 2 -> Average ((build (rand, depth-1)), (build (rand, depth-1)))\n| 3 -> Times ((build (rand, depth-1)), (build (rand, depth-1)))\n| 4 -> Thresh ((build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)))"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 1\n  then (if (rand (0, 1)) = 0 then VarX else VarY)\n  else\n    (match rand (0, 4) with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | 1 -> Cosine (build (rand, (depth - 1)))\n     | 2 ->\n         ((Average (build (rand, (depth - 1)))), (build (rand, (depth - 1))))\n     | 3 ->\n         ((Times (build (rand, (depth - 1)))), (build (rand, (depth - 1))))\n     | 4 ->\n         ((Thresh (build (rand, (depth - 1)))), (build (rand, (depth - 1))),\n           (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 1\n  then (if (rand (0, 1)) = 0 then VarX else VarY)\n  else\n    (match rand (0, 4) with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | 1 -> Cosine (build (rand, (depth - 1)))\n     | 2 ->\n         Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         ((Times (build (rand, (depth - 1)))), (build (rand, (depth - 1))))\n     | 4 ->\n         ((Thresh (build (rand, (depth - 1)))), (build (rand, (depth - 1))),\n           (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n"]}
{"fix": [], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type\n         (('a -> 'b) -> ('a -> 'b) * bool) * ('a -> 'b)\n", "Error: This expression has type int -> int\n       but an expression was expected of type\n         (('a -> 'b) -> ('a -> 'b) * bool) * ('a -> 'b)\n", "Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"], "bad": ["\nlet fptest x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet _ = wwhile fptest 0;;\n", "\nlet fptest x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet _ = wwhile fptest (0, false);;\n", "\nlet fptest x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet _ = wwhile (fptest, 0);;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: Unbound value sampleExpr1\nHint: Did you mean sampleExpr2 or sampleExpr?\nError: Unbound value sampleExpr1\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sampleExpr1\nHint: Did you mean sampleExpr2 or sampleExpr?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine u -> sin (pi *. (eval (u, x, y)))\n  | Cosine u -> cos (pi *. (eval (u, x, y)))\n  | Average (u,v) -> ((eval (u, x, y)) +. (eval (v, x, y))) /. 2.0\n  | Times (u,v) -> (eval (u, x, y)) *. (eval (v, x, y))\n  | Thresh (s,t,u,v) ->\n      if (eval (s, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (v, x, y);;\n\nlet _ = eval (sampleExpr1, 0.5, 0.2);;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\nlet _ = 0.232 mod 0.12;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type int but an expression was expected of type\n         int -> int -> int\n", "Error: Unbound value sum\n"], "bad": ["\nlet sqsum xs =\n  let f a x sum x = sum + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "\nlet sqsum xs =\n  let f a x = sum + (x * x) in let base = 0 in List.fold_left f base xs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = a in\nlet base = [] in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n", "Error: Unbound value x\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: Unbound value x\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base = f x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base = f in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base = [] in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base = [] in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun a -> x in\nlet base = fun f x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'b -> 'c\n", "Error: Unbound value x\n", "Error: Unbound value a\n"], "bad": ["\nlet pipe fs = let f a x a = x in let base = [] in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x a = x in let base = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x a = x in let base = a in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun a -> x in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b -> 'c\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x a = x in let base = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x a = x in let base = [] in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x a = a x in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun c -> x (a c) in\nlet base =  fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value x\n", "Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n", "Error: Unbound value x\n", "Error: Unbound value x\n", "Error: Unbound value x\n", "Error: Unbound value x\n", "Error: Unbound value x\n", "Error: Unbound value x\n", "Error: This expression has type int but an expression was expected of type\n         ('a -> 'b) -> 'b\n"], "bad": ["\nlet pipe fs = let f a x a = x in let base = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x a = x in let base = 0 in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x y a = x in let base a = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x y a = x in let base f = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x y a = x in let base = f x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x y a = x in let base a = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x x = a in let base a = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x a = a x in let base a = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x a = a x in let base = 0 in List.fold_left f base fs;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = [] in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: Unbound value l\n", "Error: This expression has type string -> string -> 'a -> string\n       but an expression was expected of type string -> string -> string\n       Type 'a -> string is not compatible with type string \n", "Error: This expression has type string but an expression was expected of type\n         string list\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x c = a ^ (sep ^ x) in\n      let base = \"\" in let l = l in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x c = a ^ (sep ^ x) in\n      let base = \"\" in let l = \"\" in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = \"\" in List.fold_left f base l;;\n"]}
{"fix": ["let padZero l1 l2 = \nlet leng1 = List.length l1 in\nlet leng2 = List.length l2 in\n(clone 0 (leng1-leng2) @ l1 , clone 0 (leng2-leng1) @ l2)"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  ((((clone 0 leng1) - leng2) @ l1), (((clone 0 leng2) - leng1) @ l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value padZero\n", "Error: Unbound value padZero\n", "Error: Unbound value padZero\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type 'c list list\n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type ('c list * 'd list) list\n", "Error: This expression has type int but an expression was expected of type\n         ('a list * 'b list) list\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n", "Error: Unbound record field first\n", "Error: This expression has type 'a -> 'b -> 'a * 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'a * 'a\n", "Error: This expression has type 'a -> 'b -> 'a * 'b\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'a * 'b\n", "Error: Unbound value padZero\n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type int\n", "Error: Unbound record field first\n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type int\n", "Error: Unbound value padZero\n", "Error: This expression has type 'a -> 'b -> 'a list\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type int\n", "Error: This expression has type 'a -> 'b -> 'a * 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'a * 'a\n", "Error: This expression has type 'a -> 'b -> 'a list * 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'a list * 'a\n", "Error: This expression has type (int list -> 'a) -> 'b -> 'a\n       but an expression was expected of type\n         (int list -> 'a) -> 'b -> int list -> 'a\n       The type variable 'a occurs inside int list -> 'a\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: Unbound value padZero\n", "Error: This expression has type 'a list * 'b list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: Unbound value padZero\n", "Error: Unbound value bigAdd\n", "Error: Unbound record field first\n", "Error: Unbound record field fst\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n", "Error: Unbound record field snd\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: This expression has type 'a * 'b -> 'b\n       but an expression was expected of type 'c * ('d -> 'e)\n", "Error: Unbound value %\n", "Error: This expression has type int but an expression was expected of type\n         int * int\n", "Error: This expression has type int but an expression was expected of type\n         int * int\n"], "bad": ["\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = l1 in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = [] in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = [] in\n    let args = ([], []) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = ([], []) in\n    let args = ([], []) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = ([], []) in\n    let args = 0 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((a.first + x.first), (a.second + x.second)) in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a, a) in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a, x) in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x.first in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = [a] in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + 1 in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a, a) in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([a], a) in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a [0] in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = ([], []) in\n    let args = 0 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = ([], []) in\n    let args = [0] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + 1 in\n    let base = ([], []) in\n    let args = [0] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + 1 in\n    let base = 5 in\n    let args = [0] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((a.first), (a.second)) in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((a.fst), (a.snd)) in\n    let base = ([], []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | [] -> [].snd a\n      | h::t -> (t, ((((fst h) + (snd h)) % 10) :: (snd a))) in\n    let base = ((List.combine ((rev l1), (rev l2))), []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | [] -> ([], (snd a))\n      | h::t -> (t, ((((fst h) + (snd h)) % 10) :: (snd a))) in\n    let base = ((List.combine ((rev l1), (rev l2))), []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | [] -> ([], (snd snd a))\n      | h::t -> (t, ((((fst h) + (snd h)) % 10) :: (snd a))) in\n    let base = ((List.combine ((rev l1), (rev l2))), []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match snd a with\n      | [] -> ([], (snd a))\n      | h::t -> (t, ((((fst h) + (snd h)) % 10) :: (snd a))) in\n    let base = ((List.combine ((rev l1), (rev l2))), []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match snd a with\n      | [] -> ([], (snd a))\n      | h::t -> (t, ((((fst h) + (snd h)) mod 10) :: (snd a))) in\n    let base = ((List.combine ((rev l1), (rev l2))), []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match snd a with\n      | [] -> ([], (snd a))\n      | h::t -> (t, ((((fst h) + (snd h)) mod 10) :: (snd a))) in\n    let base = ((List.combine ((rev l1), (rev l2))), []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "bad": ["\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match fst a with\n      | [] -> ([], (snd a))\n      | h::t -> (t, ((((fst h) + (snd h)) mod 10) :: (snd a))) in\n    let base = ((List.combine ((rev l1), (rev l2))), []) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = List.combine l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a list -> ('b * 'a) list\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a list -> ('b * 'a) list\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a list -> ('b * 'a) list\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([], []) in\n    let args = List.rev List.combine (l1, l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([], []) in\n    let args = List.rev (List.combine (l1, l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([], []) in\n    let args = List.rev (List.combine (l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([], []) in\n    let args = List.combine (l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([], []) in\n    let args = List.combine (l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([], []) in\n    let args = List.combine (l1, l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([], []) in\n    let args = [List.combine (l1, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemeneted\" in\n    let args = [List.combine (l1, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemeneted\" in\n    let args = [List.combine (l1, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = [List.combine (l1, l2)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list -> ('b * 'a) list\n       but an expression was expected of type 'c list\n", "Error: This expression has type ('a list -> ('b * 'a) list) * 'c\n       but an expression was expected of type 'd list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemeneted\" in\n    let args = List.combine l1 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemeneted\" in\n    let args = ((List.combine l1), l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = [0, 0] in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemeneted\" in\n    let args = [List.combine (l1, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> a\n| h::t  -> ( (fst h + snd h) / 10, (fst h + snd h) mod 10 :: t )in \nlet base = (0, []) in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type (int * int) list\n       but an expression was expected of type 'a * 'b\n", "Error: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [(0, 0)] in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = (0, 0) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> a\n| h::t  -> a in \nlet base = (0, []) in\nlet args = List.combine (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n", "Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n", "Error: This expression has type int * 'a list\n       but an expression was expected of type (int * int) list\n", "Error: This expression has type (('a list -> ('b * 'a) list) * 'c) list\n       but an expression was expected of type (int * int) list list\n       Type ('a list -> ('b * 'a) list) * 'c is not compatible with type\n         (int * int) list \n", "Error: This expression has type (('a list -> ('b * 'a) list) * 'c) list\n       but an expression was expected of type (int * int) list list\n       Type ('a list -> ('b * 'a) list) * 'c is not compatible with type\n         (int * int) list \n", "Error: This expression has type (('a list -> ('b * 'a) list) * 'c) list\n       but an expression was expected of type 'd list list\n       Type ('a list -> ('b * 'a) list) * 'c is not compatible with type\n         'd list \n", "Error: This expression has type (('a list -> ('b * 'a) list) * 'c) list\n       but an expression was expected of type 'd list list\n       Type ('a list -> ('b * 'a) list) * 'c is not compatible with type\n         'd list \n", "Error: This expression has type (('a list -> ('b * 'a) list) * 'c) list\n       but an expression was expected of type 'd list list\n       Type ('a list -> ('b * 'a) list) * 'c is not compatible with type\n         'd list \n", "Error: This expression has type int * 'a list\n       but an expression was expected of type 'b list\n", "Error: This expression has type (('a list -> ('b * 'a) list) * 'c) list\n       but an expression was expected of type 'd list list\n       Type ('a list -> ('b * 'a) list) * 'c is not compatible with type\n         'd list \n", "Error: This expression has type ('a list -> ('b * 'a) list) * 'c\n       but an expression was expected of type 'd list list\n", "Error: This expression has type ('a list -> ('b * 'a) list) * 'c\n       but an expression was expected of type 'd list list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | [] -> a\n      | h::t ->\n          ((((fst h) + (snd h)) / 10), ((((fst h) + (snd h)) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | [] -> a\n      | h::t ->\n          ((((fst h) + (snd h)) / 10), ((((fst h) + (snd h)) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | [] -> a\n      | h::t -> ((((fst h) + (snd h)) / 10), (((fst h) + (snd h)) mod 10)) ::\n          t in\n    let base = (0, []) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | [] -> a\n      | h::t ->\n          ((((fst h) + (snd h)) / 10), ((((fst h) + (snd h)) mod 10) ::\n            (snd a))) in\n    let base = (0, []) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | [] -> a\n      | h::t ->\n          ((((fst h) + (snd h)) / 10), ((((fst h) + (snd h)) mod 10) ::\n            (snd a))) in\n    let base = (0, []) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a | h::t -> a in\n    let base = (0, []) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a | h::t -> a in\n    let base = (0, []) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a in\n    let base = (0, []) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> x | h::t -> x in\n    let base = (0, []) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a | h::t -> a in\n    let base = (0, []) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a | h::t -> a in\n    let base = (0, []) in\n    let args = ((List.combine l1), l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a | h::t -> a in\n    let base = (0, []) in\n    let args = ((List.combine l1), l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: Unbound value l1\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a | h::t -> a in\n    let base = (0, []) in\n    let args = List.combine (l1, l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a | h::t -> a in\n    let base = (0, []) in\n    let args = List.combine (l1, l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet _ = List.combine l1 l2;;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a | h::t -> a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| [] -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a | h::t -> a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (fst x + snd x) / 10, ((fst x + snd x) mod 10 :: snd a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type unit list\n       Type 'a * 'b is not compatible with type unit \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type int list\n       Type 'a * 'b is not compatible with type int \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type char list\n       Type 'a * 'b is not compatible with type char \n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | () -> a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | 5 -> a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | 'a' -> a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let rec mulByDigit i l = \nlet f x a = let digitRes = (x * i) + fst a in\ndigitRes / 10, (digitRes mod 10) :: snd a in\nlet base  = (0, []) in\nlet (_, result) = List.fold_right f (l) base in\nresult"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n"], "bad": ["\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f ((0, 0) :: l) base in result;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = \nlet value = mulByDigit x l1 @ clone 0 (fst a) in\nfst a + 1, bigAdd value (snd a) in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: Unbound value bigSum\n", "Error: This function has type int list -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x = let value = mulByDigit l1 x in (0, (bigSum value snd a)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x = let value = mulByDigit l1 x in (0, (bigAdd value snd a)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x = let value = mulByDigit l1 x in (0, (bigAdd value (snd a))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x = let value = mulByDigit l1 x in (0, (bigAdd value x)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x = let value = mulByDigit l1 x in (0, (bigAdd value x)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let value = mulByDigit l1 x in (0, ((bigAdd value x) :: (snd a))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let value = mulByDigit l1 x in (0, ((bigAdd value x) :: (snd a))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let value = mulByDigit l1 x in (0, ((bigAdd value x) :: (snd a))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let value = mulByDigit l1 x in (0, ((bigAdd value x) :: (snd a))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n"]}
{"fix": ["let rec sumList xs =\nmatch xs with\n[] -> 0\n| head::tail -> head  (sumList tail)"], "hw": "hw1", "problem": "sumList", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec sumList xs =\n  match xs with | [] -> [] | head::tail -> head + (sumList tail);;\n"]}
{"fix": ["let rec digitalRoot n = \nif n < 10 then n\nelse digitalRoot (sumList (digitsOfInt n))"], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: Unbound value digitalOfInt\nHint: Did you mean digitsOfInt?\nError: Unbound value digitalOfInt\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value digitalOfInt\nHint: Did you mean digitsOfInt?\n"], "bad": ["\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitalOfInt n));;\n"]}
{"fix": ["let palindrome w = \nif ((explode w) = (listReverse (explode w))) then true\nelse false"], "hw": "hw1", "problem": "palindrome", "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n"], "bad": ["\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | head::tail -> (listReverse tail) @ [head];;\n\nlet palindrome w =\n  if (explode w) = (explode (listReverse w)) then true else false;;\n"]}
{"fix": [], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: Unbound value append\n", "Error: Unbound value append\n", "Error: This expression has type 'a list list\n       but an expression was expected of type 'a list\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else append h seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else append h seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet rec append_new xs1 xs2 =\n  match xs1 with | [] -> xs2 | head::tail -> head :: (append_new tail xs2);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else append_new h seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"]}
{"fix": ["let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value uncomment\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f b with | (b',false ) -> b | (b',true ) -> wwhile (f, b');;\n\nlet _ = uncomment after implementing wwhile;;\n"]}
{"fix": [], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type string but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine var1 -> (\"sin (pi*\" + (exprToString var1)) + \")\"\n  | Cosine var2 -> (\"cos (pi*\" + (exprToString var2)) + \")\"\n  | Average (var3,var4) ->\n      (((\"((\" exprToString var3) + \" + \") + (exprToString var4)) + \")/2)\"\n  | Times (var5,var6) -> ((exprToString var5) + \" * \") + (exprToString var6)\n  | Thresh (var7,var8,var9,var0) ->\n      (((((((\"(\" exprToString var7) + \"<\") + (exprToString var8)) + \" ? \") +\n           (exprToString var9))\n          + \" : \")\n         + (exprToString var0))\n        + \")\";;\n"]}
{"fix": ["let rec exprToString e =\nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine var1 -> \"sin (pi*\" ^ exprToString var1 ^ \")\"\n| Cosine var2 -> \"cos (pi*\" ^ exprToString var2 ^ \")\"\n| Average (var3, var4) -> \"((\" ^ exprToString var3 ^ \" + \" ^ exprToString var4 ^ \")/2)\"\n| Times (var5, var6) -> exprToString var5 ^ \" * \" ^ exprToString var6\n| Thresh (var7, var8, var9, var0) -> \"(\" ^ exprToString var7 ^ \"<\" ^ exprToString var8 ^ \" ? \" ^ exprToString var9 ^ \" : \" ^ exprToString var0 ^ \")\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine var1 -> \"sin (pi*\" ^ ((exprToString var1) ^ \")\")\n  | Cosine var2 -> \"cos (pi*\" ^ ((exprToString var2) ^ \")\")\n  | Average (var3,var4) ->\n      \"((\" ^ ((exprToString var3) ^ (\" + \" ^ ((exprToString var4) ^ \")/2)\")))\n  | Times (var5,var6) -> (exprToString var5) ^ (\" * \" ^ (exprToString var6))\n  | Thresh (var7,var8,var9,var0) ->\n      (\"(\" exprToString var7) ^\n        (\"<\" ^\n           ((exprToString var8) ^\n              (\" ? \" ^\n                 ((exprToString var9) ^ (\" : \" ^ ((exprToString var0) ^ \")\"))))));;\n"]}
{"fix": ["let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0\n| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine var1 -> sin (pi * (eval (var1, x, y)))\n  | Cosine var2 -> cos (pi * (eval (var2, x, y)))\n  | Average (var3,var4) -> ((eval (var3, x, y)) + (eval (var4, x, y))) / 2\n  | Times (var5,var6) -> (eval (var5, x, y)) * (eval (var6, x, y))\n  | Thresh (var7,var8,var9,var0) ->\n      if (eval (var7, x, y)) < (eval (var8, x, y))\n      then eval (var9, x, y)\n      else eval (var0, x, y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine var1 -> sin (pi *. (eval (var1, x, y)))\n  | Cosine var2 -> cos (pi *. (eval (var2, x, y)))\n  | Average (var3,var4) -> ((eval (var3, x, y)) + (eval (var4, x, y))) / 2\n  | Times (var5,var6) -> (eval (var5, x, y)) * (eval (var6, x, y))\n  | Thresh (var7,var8,var9,var0) ->\n      if (eval (var7, x, y)) < (eval (var8, x, y))\n      then eval (var9, x, y)\n      else eval (var0, x, y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine var1 -> sin (pi *. (eval (var1, x, y)))\n  | Cosine var2 -> cos (pi *. (eval (var2, x, y)))\n  | Average (var3,var4) -> ((eval (var3, x, y)) + (eval (var4, x, y))) / 2\n  | Times (var5,var6) -> (eval (var5, x, y)) * (eval (var6, x, y))\n  | Thresh (var7,var8,var9,var0) ->\n      if (eval (var7, x, y)) < (eval (var8, x, y))\n      then eval (var9, x, y)\n      else eval (var0, x, y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine var1 -> sin (pi *. (eval (var1, x, y)))\n  | Cosine var2 -> cos (pi *. (eval (var2, x, y)))\n  | Average (var3,var4) -> ((eval (var3, x, y)) + (eval (var4, x, y))) / 2\n  | Times (var5,var6) -> (eval (var5, x, y)) * (eval (var6, x, y))\n  | Thresh (var7,var8,var9,var0) ->\n      if (eval (var7, x, y)) < (eval (var8, x, y))\n      then eval (var9, x, y)\n      else eval (var0, x, y);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine var1 -> sin (pi *. (eval (var1, x, y)))\n  | Cosine var2 -> cos (pi *. (eval (var2, x, y)))\n  | Average (var3,var4) -> ((eval (var3, x, y)) +. (eval (var4, x, y))) /. 2\n  | Times (var5,var6) -> (eval (var5, x, y)) *. (eval (var6, x, y))\n  | Thresh (var7,var8,var9,var0) ->\n      if (eval (var7, x, y)) < (eval (var8, x, y))\n      then eval (var9, x, y)\n      else eval (var0, x, y);;\n"]}
{"fix": ["let rec build (rand, depth) = \nif (depth<1) then let base = (rand 0 2) in match base with \n| 0 -> buildX()\n| 1 -> buildY()\nelse let recurse = (rand 0 5) in match recurse with\n| 0 -> buildSine(build(rand, depth-1))\n| 1 -> buildCosine(build(rand, depth-1))\n| 2 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 3 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type unit -> expr\n       but an expression was expected of type unit\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 1\n  then let base = rand 0 2 in match base with | 0 -> buildX | 1 -> buildY;;\n"]}
{"fix": ["let rec build (rand, depth) = \nif (depth<1) then let base = (rand 0 2) in match base with \n| 0 -> buildX()\n| 1 -> buildY()\nelse let recurse = (rand 0 5) in match recurse with\n| 0 -> buildSine(build(rand, depth-1))\n| 1 -> buildCosine(build(rand, depth-1))\n| 2 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 3 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"], "bad": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine var1 -> sin (pi *. (eval (var1, x, y)))\n  | Cosine var2 -> cos (pi *. (eval (var2, x, y)))\n  | Average (var3,var4) ->\n      ((eval (var3, x, y)) +. (eval (var4, x, y))) /. 2.0\n  | Times (var5,var6) -> (eval (var5, x, y)) *. (eval (var6, x, y))\n  | Thresh (var7,var8,var9,var0) ->\n      if (eval (var7, x, y)) < (eval (var8, x, y))\n      then eval (var9, x, y)\n      else eval (var0, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 1\n  then\n    let base = rand 0 2 in match base with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let recurse = rand 0 5 in\n     match recurse with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine var1 -> \"sin(pi*\" ^ ((exprToString var1) ^ \")\")\n  | Cosine var2 -> \"cos(pi*\" ^ ((exprToString var2) ^ \")\")\n  | Average (var3,var4) ->\n      \"((\" ^ ((exprToString var3) ^ (\"+\" ^ ((exprToString var4) ^ \")/2)\")))\n  | Times (var5,var6) -> (exprToString var5) ^ (\"*\" ^ (exprToString var6))\n  | Thresh (var7,var8,var9,var0) ->\n      \"(\" ^\n        ((exprToString var7) ^\n           (\"<\" ^\n              ((exprToString var8) ^\n                 (\"?\" ^\n                    ((exprToString var9) ^\n                       (\":\" ^ ((exprToString var0) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"]}
{"fix": [], "hw": "hw3", "problem": "padZero", "message": ["Error: Unbound value padZero\n", "Error: Unbound value padZero\n"], "bad": ["\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then padZero l1 ([0] @ l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero ([0] @ l1) l2\n    else (l1, l2);;\n", "\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then padZero l1 ([0] @ l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero ([0] @ l1) l2\n    else (l1, l2);;\n"]}
{"fix": ["let padZero l1 l2 = \nlet lenl1 = List.length l1 in \nlet lenl2 = List.length l2 in \n((List.append(clone 0 (lenl1 - lenl2)) l1), (List.append (clone 0 (lenl1 - lenl2)) l2))"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  List.append\n    ((clone 0 (lenl1 - lenl2) l1),\n      (List.append (clone 0 (lenl1 - lenl2)) l2));;\n"]}
{"fix": ["let padZero l1 l2 = \nlet lenl1 = List.length l1 in \nlet lenl2 = List.length l2 in \n((List.append(clone 0 (lenl1 - lenl2)) l1), (List.append (clone 0 (lenl1 - lenl2)) l2))"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 < lenl2\n  then\n    ((List.append (clone 0 (lenl1 - lenl2)) l1),\n      (List.append (clone 0 (lenl1 - lenl2)) l2));;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This function has type char -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else int_of_char explode (string_of_int n);;\n"]}
{"fix": ["let rec additivePersistence n = \n\nsumList (digitsOfInt n)"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: Unbound value digitOfInt\nHint: Did you mean digitsOfInt?\nError: Unbound value digitOfInt\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value digitOfInt\nHint: Did you mean digitsOfInt?\n"], "bad": ["\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n = sumList digitOfInt n;;\n", "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n = sumList (digitOfInt n);;\n"]}
{"fix": ["let rec additivePersistence n = \nif n<10 then a\nelse  additivePersistence (sumList (digitsOfInt n))"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This expression has type bool but an expression was expected of type\n         int\n", "Error: This expression has type bool but an expression was expected of type\n         int\n", "Error: Unbound value n\n", "Error: Unbound value n\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec loop n a = if n = 0 then a else loop (n / 10) ((n mod 10) :: a) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  if n < 10 then n else n = (sumList (digitsOfInt n));;\n", "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec loop n a = if n = 0 then a else loop (n / 10) ((n mod 10) :: a) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ =\n  let rec additivePersistence n =\n    if n < 10 then n else n = (sumList (digitsOfInt n)) in\n  match n with | 0 -> 0 | _ -> n;;\n", "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec loop n a = if n = 0 then a else loop (n / 10) ((n mod 10) :: a) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ =\n  let rec additivePersistence n =\n    if n < 10 then n else sumList (digitsOfInt n) in\n  match n with | 0 -> 0 | _ -> n;;\n", "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec loop n a = if n = 0 then a else loop (n / 10) ((n mod 10) :: a) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ =\n  let rec additivePersistence n a =\n    if n < 10 then a else sumList (digitsOfInt n) in\n  match n with | 0 -> 0 | _ -> n;;\n"]}
{"fix": ["let rec listReverse l = \nlet rec a acc=function\n|[]-> acc\n|h::t -> a(h::acc) t in\na [] l"], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value list\n"], "bad": ["\nlet rec listReverse l =\n  let rec a acc = function | [] -> acc | h::t -> a (h :: acc) t in a [] list;;\n"]}
{"fix": [], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: Unbound constructor False\nHint: Did you mean false?\n", "Error: This expression has type bool but an expression was expected of type\n         ('a * 'b) list -> bool\n", "Error: This expression has type 'a list\n       but an expression was expected of type unit\n", "Error: This expression has type 'a list\n       but an expression was expected of type unit\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type unit\n", "Error: This expression has type 'a list\n       but an expression was expected of type unit\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem (h, seen)) = False then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem (h, seen)) = false then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"]}
{"fix": ["let rec wwhile (f,b) = match f with\n| (x,true)->x"], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type 'a * bool\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a * bool\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a * 'b\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet rec wwhile (f,b) = match f with | (x,true ) -> f x | (x,false ) -> x;;\n", "\nlet rec wwhile (f,b) =\n  match f with | (x,true ) -> wwhile (f x) | (x,false ) -> x;;\n", "\nlet rec wwhile (f,b) = match f with | (n,boo) -> f b;;\n"]}
{"fix": ["let rec wwhile (f,b) = match f b with\n| (x,true) -> wwhile(f,x)\n| (x,false)-> x"], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type int -> int * bool\n       but an expression was expected of type 'a * bool\n"], "bad": ["\nlet rec wwhile (f,b) =\n  match f with | (x,false ) -> x | (x,true ) -> wwhile (f, x);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value fixpoint\n", "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"], "bad": ["\nlet _ = fixpoint (collatz, 1);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) = wwhile ((let (x,y) = f b in x != b), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) = wwhile ((let (x,y) = f b in x <> b), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) = wwhile ((let (x,y) = f b in (x > b) or (x < b)), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let (x,y) = f b in\n      if (x <> b) && (y = true) then (x, y) else if x = b then (x, false)),\n      b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let (x,y) = f b in\n      if (x <> b) && (y = true) then (x, true) else if x = b then (x, false)),\n      b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,x<>b)in a),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: Unbound value fixpoint\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type int\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"], "bad": ["\nlet _ = fixpoint (collatz, 1);;\n", "\nlet _ = fixpoint (collatz, 1);;\n", "\nlet _ = fixpoint (collatz, 1);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let f f b =\n        if ((f b) = (b, true)) && ((b, true) = ((f b) - 1)) then (b, false) in\n      f), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let f f b =\n        if ((f b) = (b, true)) && ((b, true) = (f (b - 1))) then (b, false) in\n      f), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let (x,y) = f b in (x, ((x <> b) && ((x, y) <> (f (b - 1)))))), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) = wwhile ((let (x,y) = f b in (x, (x <> b))), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) = wwhile ((let (x,y) = f b in (x, (x != b))), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) =\n  wwhile ((let (x,y) = f b in (x, ((x > b) || (x < b)))), b);;\n", "\nlet rec wwhile (f,b) =\n  match f b with | (x,true ) -> wwhile (f, x) | (x,false ) -> x;;\n\nlet fixpoint (f,b) = wwhile ((let (x,y) = f b in (x, (x < 100))), b);;\n"]}
{"fix": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  exprToString e\n| Cosine e-> exprToString e"], "hw": "hw2", "problem": "exprToString", "message": ["Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "Error: The constructor Cosine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine  -> VarY @ (\"/\" @ VarX)\n  | Cosine  -> VarX @ (\"/\" @ VarY);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine  -> VarY ^ (\"/\" ^ VarX)\n  | Cosine  -> VarX ^ (\"/\" ^ VarY);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine  -> exprToString e\n  | Cosine  -> exprToString e;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine  -> exprToString e\n  | Cosine  -> exprToString e;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine  -> exprToString VarX\n  | Cosine  -> exprToString e;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> exprToString e\n  | Cosine  -> exprToString e;;\n"]}
{"fix": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e)^\"+\"^(exprToString e)^\")/2\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: The constructor Average expects 2 argument(s),\n       but is applied here to 1 argument(s)\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average e ->\n      \"(\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString e) ^ \")/2\")));;\n"]}
{"fix": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e)^\"+\"^(exprToString e)^\")/2\"\n| Times (e1,e2) -> exprToString e1 ^\"*\"^exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString e) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           ((\"<\" exprToString e2) ^\n              (\" ? \" ^\n                 ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\"))))));;\n"]}
{"fix": ["let aa =exprToString VarX"], "hw": "hw2", "problem": "exprToString", "message": ["Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString e) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet aa = exprToString Average (VarX, VarY);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString e) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet aa = exprToString Average (VarX, VarY);;\n"]}
{"fix": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\")/2\"\n| Times (e1,e2) -> exprToString e1 ^\"*\"^exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\""], "hw": "hw2", "problem": "exprToString", "message": ["Error: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"(\" ^ ((exprToString e) ^ (\"+\" ^ ((exprToString e) ^ \")/2\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet aa = exprToString Average (VarY, VarX);;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY"], "hw": "hw2", "problem": "build", "message": ["Error: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n", "Error: This expression has type expr but an expression was expected of type\n         unit -> expr\n", "Error: This expression has type expr but an expression was expected of type\n         unit -> expr\n", "Error: This expression has type expr but an expression was expected of type\n         unit -> expr\n", "Error: This expression has type expr but an expression was expected of type\n         unit -> expr\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine  -> buildSine e;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine e -> buildSine e;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine e -> buildSine x;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine e1 -> buildSine e1;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine e1 -> buildSine e1;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine e -> 0.34 * e;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX | VarY  -> buildY | Sine e -> build (pi * e);;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type unit -> expr\n       but an expression was expected of type int\n", "Error: This expression has type unit -> expr\n       but an expression was expected of type int\n", "Error: This expression has type expr but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> buildX * 1.0 | VarY  -> buildY * 1.0;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> buildX * 1.0;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> (buildX ()) * 1.0;;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x * 1.0;;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | VarY  -> y | Sine e -> pi * e;;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type expr but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> VarX\n  | VarY  -> VarY\n  | Sine e -> buildSine e\n  | Cosine e -> buildCosine e\n  | Average (e1,e2) -> buildAverage (e1, e2)\n  | Times (e1,e2) -> buildTimes (e1, e2)\n  | Thresh (e1,e2,e3,e4) -> buildThresh (e1, e2, e3, e4);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type int -> float\n       but an expression was expected of type int\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi * e\n  | Cosine e -> pi * e\n  | Average (e1,e2) -> buildAverage (e1, e2)\n  | Times (e1,e2) -> buildTimes (e1, e2)\n  | Thresh (e1,e2,e3,e4) -> buildThresh (e1, e2, e3, e4);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x * 1.00\n  | VarY  -> y * 1.00\n  | Sine e -> pi * e\n  | Cosine e -> pi * e\n  | Average (e1,e2) -> buildAverage (e1, e2)\n  | Times (e1,e2) -> buildTimes (e1, e2)\n  | Thresh (e1,e2,e3,e4) -> buildThresh (e1, e2, e3, e4);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float * x\n  | VarY  -> float * y\n  | Sine e -> pi * e\n  | Cosine e -> pi * e\n  | Average (e1,e2) -> buildAverage (e1, e2)\n  | Times (e1,e2) -> buildTimes (e1, e2)\n  | Thresh (e1,e2,e3,e4) -> buildThresh (e1, e2, e3, e4);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi * e\n  | Cosine e -> pi * e\n  | Average (e1,e2) -> buildAverage (e1, e2)\n  | Times (e1,e2) -> buildTimes (e1, e2)\n  | Thresh (e1,e2,e3,e4) -> buildThresh (e1, e2, e3, e4);;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type expr but an expression was expected of type\n         float\n", "Error: This expression has type expr but an expression was expected of type\n         int\n", "Error: This expression has type expr but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi * x\n  | Cosine e -> pi * y\n  | Average (e1,e2) -> (e1 + e2) / 2\n  | Times (e1,e2) -> e1 * e2\n  | Thresh (e1,e2,e3,e4) -> (e1 < (e2 ?e3) : e4);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> (e1 +. e2) / 2\n  | Times (e1,e2) -> e1 *. e2\n  | Thresh (e1,e2,e3,e4) -> (e1 < (e2 ?e3) : e4);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> (float (e1 + e2)) / 2\n  | Times (e1,e2) -> e1 *. e2\n  | Thresh (e1,e2,e3,e4) -> (e1 < (e2 ?e3) : e4);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> ((float_of_int e1) +. (float_of_int e2)) / 2\n  | Times (e1,e2) -> (float_of_int e1) *. (float_of_int e2)\n  | Thresh (e1,e2,e3,e4) ->\n      ((float_of_int e1) < (float_of_int e2 ?float_of_int e3) : float_of_int\n                                                                  e4);;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type expr but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi * x\n  | Cosine e -> pi * y\n  | Average (e1,e2) -> (e1 + e2) / 2\n  | Times (e1,e2) -> e1 *. e2\n  | Thresh (e1,e2,e3,e4) -> (e1 < (e2 ?e3) : e4);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> (e1 +. e2) / 2\n  | Times (e1,e2) -> e1 *. e2\n  | Thresh (e1,e2,e3,e4) -> (e1 < (e2 ?e3) : e4);;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         float\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> buildAverage (e1, e2);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi * x\n  | Cosine e -> pi * y\n  | Average (e1,e2) -> buildAverage (e1, e2);;\n"]}
{"fix": ["let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type expr but an expression was expected of type\n         int\n", "Error: This expression has type expr but an expression was expected of type\n         int\n", "Error: Unbound value evail\nHint: Did you mean eval?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> ((e1 * 1.00) + (e2 * 1.00)) /. 2.0;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> ((e1 * 1.00) +. (e2 * 1.00)) /. 2.0;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. x\n  | Cosine e -> pi *. y\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (evail (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (evail (e2, x, y));;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: Unbound value eval\n", "Error: Unbound value eval\n", "Error: Unbound constructor VarX\n", "Error: Unbound value eval\n", "Error: Unbound value eval\n"], "bad": ["\nlet _ = eval ((Sine VarX), (pi /. 2.0), 0.0);;\n", "\nlet _ = eval ((Sine VarX), (pi /. 2.0), 0.0);;\n", "\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> pi *. (eval (e, VarX, VarY))\n  | Cosine e -> pi *. (eval (e, VarX, VarY))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "\nlet _ = eval ((Sine VarX), 0.5, (-0.5));;\n", "\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value emitGrayscale\n"], "bad": ["\nlet _ = emitGrayscale ((eval_fn sampleExpr), 150, \"sample\");;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\nError: Unbound value sampleExpr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> sin (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         bool\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  match rand depth with | (1,d) -> (d = (d - 1)) && (buildX ());;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type expr but an expression was expected of type\n         bool\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand depth with\n  | (1,d) -> (d = (d - 1)) && (buildX ())\n  | (2,d) -> (d = (d - 1)) && (buildY ());;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type 'a but an expression was expected of type\n         'b -> 'a * int\n       The type variable 'a occurs inside 'b -> 'a * int\n"], "bad": ["\nlet rec build (rand,depth) =\n  match rand depth with | (r,0) -> build (r, 0) | (r,d) -> (r, (d - 1));;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value r\n", "Error: Unbound value r\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    let build r = if r = 1 then buildX () else buildY () in\n    ((depth - 1), (depth > 0)) in\n  build r;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    let build r = if r = 1 then buildX () else buildY () in\n    ((depth - 1), (depth > 0)) in\n  build r;;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "Error: Unbound value buildd\nHint: Did you mean build, buildY or buildX?\n", "Error: Unbound value r1\n", "Error: Unbound value r1\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    let buildd (r,d) =\n      if r = 1\n      then buildX ()\n      else\n        if r = 2\n        then buildY ()\n        else\n          if r = 3\n          then buildSine (build (r, d))\n          else\n            if r = 4\n            then buildCosine (build (r, d))\n            else\n              if r = 5\n              then buildTimes ((build (r1, d1)), (build (r2, d2)))\n              else\n                buildThresh\n                  ((build (r1, d1)), (build (r2, 2)), (build (r2, d2)),\n                    (build (r2, d2))) in\n    ((depth - 1), (depth > 0)) in\n  buildd (rand, depth);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    let buildd (r,d) =\n      if r = 1\n      then buildX ()\n      else\n        if r = 2\n        then buildY ()\n        else\n          if r = 3\n          then buildSine (build (r, d))\n          else\n            if r = 4\n            then buildCosine (build (r, d))\n            else\n              if r = 5\n              then buildTimes ((build (r1, d1)), (build (r2, d2)))\n              else\n                buildThresh\n                  ((build (r1, d1)), (build (r2, 2)), (build (r2, d2)),\n                    (build (r2, d2))) in\n    ((depth - 1), (depth > 0)) in\n  buildd (rand, depth);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    let buildd (r,d) =\n      if r = 1\n      then buildX ()\n      else\n        if r = 2\n        then buildY ()\n        else\n          if r = 3\n          then buildSine (build (r, d))\n          else\n            if r = 4\n            then buildCosine (build (r, d))\n            else\n              if r = 5\n              then buildTimes ((build (r1, d1)), (build (r2, d2)))\n              else\n                buildThresh\n                  ((build (r1, d1)), (build (r2, 2)), (build (r2, d2)),\n                    (build (r2, d2))) in\n    ((d - 1), (d > 0)) in\n  buildd (rand, depth);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    let buildd (r,d) =\n      if r = 1\n      then buildX ()\n      else\n        if r = 2\n        then buildY ()\n        else\n          if r = 3\n          then buildSine (buildd (r, d))\n          else\n            if r = 4\n            then buildCosine (buildd (r, d))\n            else\n              if r = 5\n              then buildTimes ((buildd (r1, d1)), (buildd (r2, d2)))\n              else\n                buildThresh\n                  ((buildd (r1, d1)), (buildd (r2, 2)), (buildd (r2, d2)),\n                    (buildd (r2, d2))) in\n    ((d - 1), (d > 0)) in\n  buildd (rand, depth);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    let rec helper (r,d) =\n      if r = 1\n      then buildX ()\n      else\n        if r = 2\n        then buildY ()\n        else\n          if r = 3\n          then buildSine (helper (r1, d1))\n          else\n            if r = 4\n            then buildCosine (helper (r1, d1))\n            else\n              if r = 5\n              then buildAverage ((helper (r1, d1)), (helper (r2, d2)))\n              else\n                if r = 6\n                then buildTimes ((helper (r1, d1)), (helper (r2, d2)))\n                else\n                  buildTresh\n                    ((helper (r1, d1)), (helper (r2, d2)), (helper (r3, d3)),\n                      (helper (r4, d4))) in\n    (d, (d >= 0)) in\n  helper (rand, depth);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    let rec helper (r,d) =\n      if r = 1\n      then buildX ()\n      else\n        if r = 2\n        then buildY ()\n        else\n          if r = 3\n          then buildSine (helper (r, d))\n          else\n            if r = 4\n            then buildCosine (helper (r1, d1))\n            else\n              if r = 5\n              then buildAverage ((helper (r1, d1)), (helper (r2, d2)))\n              else\n                if r = 6\n                then buildTimes ((helper (r1, d1)), (helper (r2, d2)))\n                else\n                  buildTresh\n                    ((helper (r1, d1)), (helper (r2, d2)), (helper (r3, d3)),\n                      (helper (r4, d4))) in\n    (d, (d >= 0)) in\n  helper (rand, depth);;\n"]}
{"fix": [], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: Unbound value buildd\nHint: Did you mean build, buildY or buildX?\n", "Error: This expression has type 'a -> 'a list -> bool\n       but an expression was expected of type 'b ref\n", "Error: This expression has type bool but an expression was expected of type\n         ('a * 'b) list -> bool\n", "Error: This expression has type bool but an expression was expected of type\n         ('a * 'b) list -> bool\n", "Error: This expression has type ('a * 'b) list -> bool\n       but an expression was expected of type bool\n", "Error: This expression has type 'a list -> bool\n       but an expression was expected of type bool\n", "Error: Unbound value seen'\nHint: Did you mean seen?\n", "Error: This expression has type 'a list\n       but an expression was expected of type unit\n", "Error: This expression has type 'a list list\n       but an expression was expected of type 'a list\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type unit\n", "Error: This expression has type 'a list\n       but an expression was expected of type unit\n", "Error: This expression has type 'a list list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list list\n", "Error: This expression has type 'a list list\n       but an expression was expected of type 'a list\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type unit\n", "Error: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "Error: This expression has type 'a list\n       but an expression was expected of type unit\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type unit\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    let buildd (r,d) =\n      if r = 1\n      then buildX ()\n      else\n        if r = 2\n        then buildY ()\n        else\n          if r = 3\n          then buildSine (buildd (r1, (d1 - 1)))\n          else\n            if r = 4\n            then buildCosine (buildd (r1, (d1 - 1)))\n            else\n              if r = 5\n              then buildTimes ((buildd (r1, d1)), (buildd (r2, d2)))\n              else\n                buildThresh\n                  ((buildd (r1, d1)), (buildd (r2, 2)), (buildd (r2, d2)),\n                    (buildd (r2, d2))) in\n    ((d - 1), (d > 0)) in\n  buildd (rand, depth);;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (!List.mem) h seen then [h] @ seen' in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem (h, seen)) = false then [h] @ seen' in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem (seen, h)) = false then [h] @ seen' in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h, seen) then [h] @ seen' in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (seen h) then [h] @ seen' in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [h] @ seen' in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then h @ [seen] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then h @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then (seen []) @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then [seen] @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"]}
{"fix": [], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type unit\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: This expression has type int * int -> int\n       but an expression was expected of type 'a -> (int * int -> int) * 'b\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand depth with\n  | (r,depth) ->\n      (match r (0, 6) with\n       | 0 -> buildX ()\n       | 1 -> buildY ()\n       | 2 -> buildSine (build (r, (depth - 1)))\n       | 3 -> buildCosine (build (r, (depth - 1)))\n       | 4 ->\n           buildAverage ((build (r, (depth - 1))), (build (r, (depth - 1))))\n       | 5 -> buildTimes ((build (r, (depth - 1))), (build (r, (depth - 1))))\n       | 6 ->\n           buildThresh\n             ((build (r, (depth - 1))), (build (r, (depth - 1))),\n               (build (r, (depth - 1))), (build (r, (depth - 1)))));;\n"]}
{"fix": ["let rec build (rand, depth) = match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"], "hw": "hw2", "problem": "build", "message": ["Error: This expression has type int * int -> int\n       but an expression was expected of type 'a -> (int * int -> int) * 'b\n", "Error: Unbound value depth\n", "Error: Unbound value depth\n", "Error: Unbound value depth\n", "Error: This expression has type int but an expression was expected of type\n         int * int -> int\n", "Error: This expression has type int but an expression was expected of type\n         int * int -> int\n", "Error: Unbound value depth\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    match rand depth with\n    | (r,depth) ->\n        (match r (0, 6) with\n         | 0 -> buildX ()\n         | 1 -> buildY ()\n         | 2 -> buildSine (build (r, (depth - 1)))\n         | 3 -> buildCosine (build (r, (depth - 1)))\n         | 4 ->\n             buildAverage\n               ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 5 ->\n             buildTimes ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 6 ->\n             buildThresh\n               ((build (r, (depth - 1))), (build (r, (depth - 1))),\n                 (build (r, (depth - 1))), (build (r, (depth - 1))))) in\n  (depth, (depth >= 0));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    match (rand, depth) with\n    | (r,depth) ->\n        (match r (0, 6) with\n         | 0 -> buildX ()\n         | 1 -> buildY ()\n         | 2 -> buildSine (build (r, (depth - 1)))\n         | 3 -> buildCosine (build (r, (depth - 1)))\n         | 4 ->\n             buildAverage\n               ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 5 ->\n             buildTimes ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 6 ->\n             buildThresh\n               ((build (r, (depth - 1))), (build (r, (depth - 1))),\n                 (build (r, (depth - 1))), (build (r, (depth - 1))))) in\n  (depth, (depth >= 0));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    match (rand, depth) with\n    | (r,depth) ->\n        (match r (0, 7) with\n         | 0 -> buildX ()\n         | 1 -> buildY ()\n         | 2 -> buildSine (build (r, (depth - 1)))\n         | 3 -> buildCosine (build (r, (depth - 1)))\n         | 4 ->\n             buildAverage\n               ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 5 ->\n             buildTimes ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 6 ->\n             buildThresh\n               ((build (r, (depth - 1))), (build (r, (depth - 1))),\n                 (build (r, (depth - 1))), (build (r, (depth - 1))))) in\n  (depth, (depth >= 0));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    match (rand, depth) with\n    | (r,depth) ->\n        (match r (0, 7) with\n         | 0 -> buildX ()\n         | 1 -> buildY ()\n         | 2 -> buildSine (build (r, (depth - 1)))\n         | 3 -> buildCosine (build (r, (depth - 1)))\n         | 4 ->\n             buildAverage\n               ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 5 ->\n             buildTimes ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | _ ->\n             buildThresh\n               ((build (r, (depth - 1))), (build (r, (depth - 1))),\n                 (build (r, (depth - 1))), (build (r, (depth - 1))))) in\n  (depth, (depth >= 0));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    match (rand, depth) with\n    | (r,depth) ->\n        let r = rand (0, 7) in\n        (match r with\n         | 0 -> buildX ()\n         | 1 -> buildY ()\n         | 2 -> buildSine (build (r, (depth - 1)))\n         | 3 -> buildCosine (build (r, (depth - 1)))\n         | 4 ->\n             buildAverage\n               ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 5 ->\n             buildTimes ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | _ ->\n             buildThresh\n               ((build (r, (depth - 1))), (build (r, (depth - 1))),\n                 (build (r, (depth - 1))), (build (r, (depth - 1))))) in\n  (depth, (depth >= 0));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    match (rand, depth) with\n    | (_,depth) ->\n        let r = rand (0, 7) in\n        (match r with\n         | 0 -> buildX ()\n         | 1 -> buildY ()\n         | 2 -> buildSine (build (r, (depth - 1)))\n         | 3 -> buildCosine (build (r, (depth - 1)))\n         | 4 ->\n             buildAverage\n               ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | 5 ->\n             buildTimes ((build (r, (depth - 1))), (build (r, (depth - 1))))\n         | _ ->\n             buildThresh\n               ((build (r, (depth - 1))), (build (r, (depth - 1))),\n                 (build (r, (depth - 1))), (build (r, (depth - 1))))) in\n  (depth, (depth >= 0));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) =\n    match (rand, depth) with\n    | (r,depth) ->\n        let r = rand (0, 7) in\n        (match r with\n         | 0 -> buildX ()\n         | 1 -> buildY ()\n         | 2 -> buildSine (build (rand, (depth - 1)))\n         | 3 -> buildCosine (build (rand, (depth - 1)))\n         | 4 ->\n             buildAverage\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         | 5 ->\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         | _ ->\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1))))) in\n  (depth, (depth >= 0));;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: Unbound value doRandomColor\n"], "bad": ["\nlet c3 () = doRandomColor (9, 21, 12);;\n"]}
{"fix": [], "hw": "hw2", "problem": "expr", "message": ["Error: This variant pattern is expected to have type expr\n       The constructor ArcSine does not belong to type expr\nHint: Did you mean Sine?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> sin (pi *. (eval (e, x, y)))\n  | ArcSine e -> 1 /. (sin (pi *. (eval (e, x, y))))\n  | ArcCosine e -> 1 /. (cos (pi *. (eval (e, x, y))))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | ArcSine of expr\n  | ArcCosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> sin (pi *. (eval (e, x, y)))\n  | ArcSine e -> 1 /. (sin (pi *. (eval (e, x, y))))\n  | ArcCosine e -> 1 /. (cos (pi *. (eval (e, x, y))))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^a in\nlet base = h^sep in\nlet l = sl in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type string\n", "Error: This expression has type 'a list\n       but an expression was expected of type string\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (List.rev x) ^ a in\n      let base = sep in let l = sl in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (List.rev t) ^ a in\n      let base = h ^ sep in let l = sl in List.fold_left f base l;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ (x^a)in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type string list\n       but an expression was expected of type string list list\n       Type string is not compatible with type string list \n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sepConcat a x) in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int -> int -> int list\n       but an expression was expected of type int -> int -> int\n       Type int list is not compatible with type int \n", "Error: This expression has type int -> int -> int list\n       but an expression was expected of type int -> int -> int\n       Type int list is not compatible with type int \n", "Error: Unbound value add\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int but an expression was expected of type\n         'a -> 'b\n", "Error: This variant expression is expected to have type 'a list\n       The constructor L1 does not belong to type list\n", "Error: This expression has type int -> int list -> int list\n       but an expression was expected of type int -> int list -> int\n       Type int list is not compatible with type int \n"], "bad": ["\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a * 10) + (x * 10) in\n    let base = List.hd l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = [a + x] in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = [a + x] in\n    let base = List.hd l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = add (List.combine a x) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (+) (List.combine a x) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = List.hd + (List.combine a x) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = List.hd l1 in\n    let args = List.hd l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = List.map (+) a x in\n    let base = List.hd L1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = List.map (a + x) in\n    let base = List.hd L1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = List.map (fun x  -> x + a) x in\n    let base = List.hd L1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = List.map (fun x  -> x + a) x in\n    let base = List.hd l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value removeZero\n"], "bad": ["\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (w,res) = a in\n      let (y,z) = x in\n      let total = (y + z) + w in ((total / 10), ((total mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "removeZero", "message": ["Error: Unbound value l1\n"], "bad": ["\nlet padZero l1 l2 =\n  let l1 = if (List.length l1) < (List.length l2) then [0; 0] @ l1 else l1 in\n  let l2 = if (List.length l2) < (List.length l1) then [0; 0] @ l2 else l2 in\n  (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else [h] @ (removeZero t);;\n\nlet _ =\n  let add (l1,l2) =\n    let f a x =\n      let (w,res) = a in\n      let (y,z) = x in\n      let total = (y + z) + w in ((total / 10), ((total mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> [] @ [(n mod 10)]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int but an expression was expected of type\n         'a list list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | hd::tl -> hd :: (digitsOfInt tl));;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [] @ (n mod 10));;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [] :: (n mod 10));;\n"]}
{"fix": ["let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> [] @ [(n mod 10)]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list list\n       but an expression was expected of type 'a list\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [] @ [digitsOfInt (n mod 10)]);;\n"]}
{"fix": ["let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> [] @ [(n mod 10)]"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [] @ (n mod 10));;\n"]}
{"fix": ["let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> n mod 10 :: []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: Unbound value %\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [digitsOfInt n]);;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [digitsOfInt (n % 10)]);;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [digitsOfInt (n mod 10)]);;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [digitsOfInt (n mod 10)]);;\n"]}
{"fix": ["let digitsOfInt n = \nlet rec addDigit n acc = \nif n <= 0 then []\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> addDigit n []"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value digitsOfInt\n", "Error: Unbound value digitsOfInt\n", "Error: Unbound value digitsOfInt\n", "Error: Unbound value digitsOfInt\n", "Error: Unbound value digitsOfInt\n"], "bad": ["\nlet _ = digitsOfInt 3124;;\n", "\nlet _ = digitsOfInt 3124;;\n", "\nlet _ = digitsOfInt 3124;;\n", "\nlet _ = digitsOfInt 3124;;\n", "\nlet _ = digitsOfInt 3124;;\n"]}
{"fix": [], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: Unbound value sumList\n", "Error: Unbound value sumList\n", "Error: Unbound value sumList\n"], "bad": ["\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec additivePersistence n count =\n  match n with | [] -> count | _ -> sumList (digitsOfInt n) (count + 1);;\n", "\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec additivePersistence n count =\n  match n with\n  | [] -> count\n  | _ -> additivePersistence (sumList (digitsOfInt n) (count + 1));;\n", "\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec additivePersistence n count =\n  match n with\n  | [] -> count\n  | _ -> additivePersistence ((sumList (digitsOfInt n)) (count + 1));;\n"]}
{"fix": ["let digits n = digitsOfInt (abs n)"], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value sumList\n"], "bad": ["\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec additivePersistence n count =\n  match n with\n  | 0 -> count\n  | _ -> additivePersistence ((sumList (digitsOfInt n)) (count + 1));;\n"]}
{"fix": ["let rec additivePersistence n = \nmatch n with\n| 0 -> 0\n| _ -> (sumList (digitsOfInt n))"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet digitsOfInt n =\n  let rec lastDigit n accu =\n    if n <= 0 then accu else lastDigit (n / 10) ((n mod 10) :: accu) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec additivePersistence n =\n  match n with | 0 -> 0 | _ -> additivePersistence sumList digitsOfInt n;;\n", "\nlet digitsOfInt n =\n  let rec lastDigit n accu =\n    if n <= 0 then accu else lastDigit (n / 10) ((n mod 10) :: accu) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec additivePersistence n =\n  match n with | 0 -> 0 | _ -> additivePersistence sumList (digitsOfInt n);;\n"]}
{"fix": ["let rec additivePersistence n = \nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList digitsOfInt n = 1)\nthen additivePersistence(sumList (digitsOfInt n))\nelse 4"], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: Unbound value additivePersistence\n", "Error: Unbound value additivePersistence\n"], "bad": ["\nlet _ = additivePersistence 9876;;\n", "\nlet _ = additivePersistence 9876;;\n"]}
{"fix": [], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: Unbound value digitsOfInt\n", "Error: Unbound value digitsOfInt\n", "Error: Unbound value additivePersistence\n", "Error: Unbound value additivePersistence\n", "Error: Unbound value additivePersistence\n", "Error: Unbound value digitsOfInt\n", "Error: Unbound value digitsOfInt\n", "Error: Unbound value digitsOfInt\n"], "bad": ["\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet rec additivePersistence n =\n  match n with\n  | 0 -> 0\n  | _ ->\n      if not ((lengthOfList digitsOfInt n) = 1)\n      then additivePersistence (sumList (digitsOfInt n))\n      else 4;;\n", "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet rec additivePersistence n =\n  match n with\n  | 0 -> 0\n  | _ ->\n      if not ((lengthOfList (digitsOfInt n)) = 1)\n      then additivePersistence (sumList (digitsOfInt n))\n      else 4;;\n", "\nlet _ = additivePersistence 9876;;\n", "\nlet _ = additivePersistence 9876;;\n", "\nlet _ = additivePersistence 9876;;\n", "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec additiveSequence n count =\n    match n with\n    | 0 -> 0\n    | _ ->\n        if not ((lengthOfList (digitsOfInt n) 0) = 1)\n        then (additivePersistence (sumList (digitsOfInt n)) count) + 1\n        else count in\n  count = 0;;\n", "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec additiveSequence n count =\n    match n with\n    | 0 -> 0\n    | _ ->\n        if not ((lengthOfList (digitsOfInt n) 0) = 1)\n        then additivePersistence ((sumList (digitsOfInt n) count) + 1)\n        else count in\n  count = 0;;\n", "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec additiveSequence n count =\n    match n with\n    | 0 -> 0\n    | _ ->\n        if not ((lengthOfList (digitsOfInt n) 0) = 1)\n        then additivePersistence (((sumList (digitsOfInt n)) count) + 1)\n        else count in\n  count = 0;;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value digitsOfInt\n", "Error: Unbound value sumDigits\n"], "bad": ["\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec additiveSequence n count =\n    match n with\n    | 0 -> 0\n    | _ ->\n        if not ((lengthOfList (digitsOfInt n) 0) = 1)\n        then (additivePersistence sumList (digitsOfInt n) count) + 1\n        else count in\n  count = 0;;\n", "\nlet _ = sumDigits 123;;\n"]}
{"fix": [], "hw": "hw1", "problem": "additivePersistence", "message": ["Error: Unbound value sumDigits\n", "Error: Unbound value digitsOfInt\n", "Error: Unbound value digitsOfInt\n", "Error: Unbound value digitsOfInt\n", "Error: Unbound value digitsOfInt\n", "Error: Unbound value digitsOfInt\n", "Error: Unbound value additivePersistence\n", "Error: Unbound value sumDigits\n", "Error: Unbound value sumList\n", "Error: Unbound value sumList\n", "Error: Unbound value additivePersistence\n"], "bad": ["\nlet _ = sumDigits 123;;\n", "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec additiveSequence n count =\n    match n with\n    | 0 -> 0\n    | _ ->\n        if not ((lengthOfList (digitsOfInt n) 0) = 1)\n        then (additivePersistence sumDigits n count) + 1\n        else count in\n  count = 0;;\n", "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec additiveSequence n count =\n    match n with\n    | 0 -> 0\n    | _ ->\n        if not ((lengthOfList (digitsOfInt n) 0) = 1)\n        then additivePersistence sumDigits n (count + 1)\n        else count in\n  count = 0;;\n", "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec additiveSequence n count =\n    match n with\n    | 0 -> 0\n    | _ ->\n        if not ((lengthOfList (digitsOfInt n) 0) = 1)\n        then (additivePersistence (sumDigits n) count) + 1\n        else count in\n  count = 0;;\n", "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec additiveSequence n count =\n    match n with\n    | 0 -> 0\n    | _ ->\n        if not ((lengthOfList (digitsOfInt n) 0) = 1)\n        then (additiveSequence sumDigits n count) + 1\n        else count in\n  count = 0;;\n", "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec additiveSequence n count =\n    match n with\n    | 0 -> 0\n    | _ ->\n        if not ((lengthOfList (digitsOfInt n) 0) = 1)\n        then (additiveSequence (sumDigits n) count) + 1\n        else count in\n  count = 0;;\n", "\nlet _ = additivePersistence 9876;;\n", "\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec sequence n i =\n    if (lengthOfList (digitsOfInt n) 0) = 1\n    then i\n    else (sequence (sumDigits n) i) + 1 in\n  match n with | _ -> sequence n 0;;\n", "\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec sequence n i =\n    if (lengthOfList (digitsOfInt n) 0) = 1\n    then i\n    else (sequence sumList (digitsOfInt x) i) + 1 in\n  match n with | _ -> sequence n 0;;\n", "\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec sequence n i =\n    if (lengthOfList (digitsOfInt n) 0) = 1\n    then i\n    else (sequence (sumList (digitsOfInt x)) i) + 1 in\n  match n with | _ -> sequence n 0;;\n", "\nlet _ = additivePersistence 9876;;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: Unbound value additivePersistence\n", "Error: Unbound value digitalRoot\n", "Error: Unbound value digitalRoot\n", "Error: Unbound value digitalRoot\n", "Error: Unbound value digitalRoot\n", "Error: Unbound value digitalRoot\n"], "bad": ["\nlet _ = additivePersistence 9876;;\n", "\nlet _ = digitalRoot 9876;;\n", "\nlet _ = digitalRoot 9876;;\n", "\nlet _ = digitalRoot 9876;;\n", "\nlet _ = digitalRoot 9876;;\n", "\nlet _ = digitalRoot 9876;;\n"]}
{"fix": ["let listReverse l = \nlet rec reverse l acc = \nreverse l acc in\nmatch l with\n| hd::tl -> reverse l []"], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value digitalRoot\n"], "bad": ["\nlet _ = digitalRoot 9876;;\n"]}
{"fix": [], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value hd\n"], "bad": ["\nlet listReverse l =\n  let rec reverse l acc = (reverse l hd) :: acc in\n  match l with | [] -> [] | hd::tl -> reverse tl [];;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitsOfInt", "message": ["Error: Unbound value digitsOfInt\n"], "bad": ["\nlet _ = digitsOfInt 352663;;\n"]}
{"fix": [], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value tl\n", "Error: Unbound value tl\n", "Error: Unbound value tl\n"], "bad": ["\nlet listReverse l =\n  let rec accReverse l acc =\n    if l = [] then acc else (accReverse tl hd) :: acc in\n  match l with | [] -> [] | l -> accReverse l [];;\n", "\nlet listReverse l =\n  let rec accReverse l acc =\n    if l = [] then acc else (accReverse tl hd) :: acc in\n  match l with | [] -> [] | hd::tl -> accReverse l [];;\n", "\nlet listReverse l =\n  let rec accReverse l acc =\n    if l = [] then acc else (accReverse tl hd) :: acc in\n  match l with | [] -> [] | hd::tl -> (accReverse hd) :: (tl []);;\n"]}
{"fix": [], "hw": "hw1", "problem": "digitalRoot", "message": ["Error: Unbound value additivePersistence\n"], "bad": ["\nlet _ = additivePersistence 9876;;\n"]}
{"fix": [], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value accu\nHint: Did you mean acc?\n"], "bad": ["\nlet listReverse l =\n  let rec accReverse l acc =\n    match l with | [] -> accu | hd::tl -> accReverse tl (hd :: accu) in\n  accReverse l acc;;\n"]}
{"fix": ["let palindrome w = (explode w = listReverse(explode w))"], "hw": "hw1", "problem": "palindrome", "message": ["Error: Unbound value at\n", "Error: Unbound value s\n"], "bad": ["\nlet _ = at 3 [1; 3; 4; 5; 1];;\n", "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec accReverse l accu =\n    match l with | [] -> accu | hd::tl -> accReverse tl (hd :: accu) in\n  accReverse l [];;\n\nlet palindrome w x = (explode s) = (listReverse (explode s));;\n"]}
{"fix": [], "hw": "hw1", "problem": "listReverse", "message": ["Error: Unbound value digitalRoot\n"], "bad": ["\nlet _ = digitalRoot 9876;;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: This function has type bool -> bool\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a list\n       but an expression was expected of type unit\n", "Error: This expression has type 'a list\n       but an expression was expected of type unit\n", "Error: This expression has type 'a list\n       but an expression was expected of type unit\n", "Error: This expression has type 'a list\n       but an expression was expected of type unit\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if not List.mem h seen\n        then let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if not (List.mem h seen)\n        then let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if List.mem h seen\n        then let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if List.mem h seen\n        then let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if List.mem h seen\n        then let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nhelper ([],l)"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type unit\n", "Error: Unbound value h\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if List.mem h seen\n        then let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    if List.mem h seen\n    then\n      match rest with\n      | [] -> seen\n      | h::t ->\n          let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: This function has type bool -> bool\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type 'a but an expression was expected of type\n         'a list list\n       The type variable 'a occurs inside 'a list list\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if not List.mem seen h\n        then let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if not (List.mem seen h)\n        then let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a list list\n       The type variable 'a occurs inside 'a list list\n", "Error: This expression has type 'a list list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list list\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if not (List.mem seen h)\n        then let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if not (List.mem seen h)\n        then let seen' = h :: rest in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"]}
{"fix": ["let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif List.mem h seen then\nlet seen' = seen in\nlet rest' = t in\nhelper (seen', rest')\nelse\nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"], "hw": "hw2", "problem": "removeDuplicates", "message": ["Error: Unbound value seen'\nHint: Did you mean seen?\n"], "bad": ["\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if List.mem h seen\n        then let seen' = seen' in let rest' = t in helper (seen', rest')\n        else\n          (let seen' = h :: seen in let rest' = t in helper (seen', rest')) in\n  List.rev (helper ([], l));;\n"]}
{"fix": ["let wwhile (f,b) =\nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f,x) (x,y)\n| false -> x\nin helper (f,b) (b, true)"], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type 'a * bool -> 'b\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside 'a * bool -> 'b\n", "Error: This expression has type 'a * 'b\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) | false  -> x in\n  (f, b) (b, true);;\n", "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (x, y) | false  -> x in\n  (f, b) (b, true);;\n"]}
{"fix": ["let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value f\n", "Error: This expression has type 'a but an expression was expected of type\n         'b -> 'a\n       The type variable 'a occurs inside 'b -> 'a\n", "Error: Unbound value f\n", "Error: This expression has type 'a but an expression was expected of type\n         'b -> 'a\n       The type variable 'a occurs inside 'b -> 'a\n", "Error: This expression has type 'a but an expression was expected of type\n         'b -> 'a\n       The type variable 'a occurs inside 'b -> 'a\n"], "bad": ["\nlet _ = f 8;;\n", "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) f b | false  -> x in\n  helper (f, b) (b, true);;\n", "\nlet _ = f 8;;\n", "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) f b | false  -> x in\n  helper (f, b) (b, true);;\n", "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) f b | false  -> x in\n  helper (f, b) (b, true);;\n"]}
{"fix": [], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n"]}
{"fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "\nlet fixpoint (f,b) = wwhile (f, b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet fixpoint (f,b) = wwhile (f, b);;\n", "\nlet fixpoint (f,b) = wwhile (f, b);;\n"]}
{"fix": ["let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet _ = wwhile (f, b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((f f b),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"], "bad": ["\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (b, b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((f b),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a -> 'b -> 'c\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b -> 'c\n", "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"], "bad": ["\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f f b), b);;\n", "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f (f b)), b);;\n"]}
{"fix": ["let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"], "bad": ["\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((f (f b)),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"], "bad": ["\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (b, b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"], "bad": ["\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f (f b)), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile ((f b),b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"], "bad": ["\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((wwhile (f, b)), b);;\n"]}
{"fix": ["let fixpoint (f,b) = wwhile (f,b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n"], "bad": ["\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, (f b));;\n", "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, (f b));;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"], "bad": ["\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ = fixpoint (collatz, 9001);;\n"]}
{"fix": ["let fixpoint (f,b) = \nwwhile (f, if b = (f b) then b else b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: Unbound value xx\n", "Error: This function has type 'a -> 'b * bool\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let f x = x in wwhile (f, b);;\n", "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ =\n  let fixpoint (f,b) = let f x = xx = (f x) in (xx, (xx != b)) in\n  f wwhile (f, b);;\n", "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) =\n  let f x = let xx = f x in (xx, (xx != b)) in f wwhile (f, b);;\n"]}
{"fix": ["let f b = f -> f;\nlet fixpoint (f,b) = \nwwhile (\n, b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n"], "bad": ["\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, (if b = (f b) then b else b));;\n", "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, (if b = (f b) then b else b));;\n"]}
{"fix": [], "hw": "hw2", "problem": "wwhile", "message": ["Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"], "bad": ["\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((let f b = b in b), b);;\n"]}
{"fix": ["let fixpoint (f,b) = \nlet g b = (b, (f b)) in \nwwhile (g, b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"], "bad": ["\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((let f b = b in b), b);;\n", "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let g b = b in wwhile (g, b);;\n", "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let g b = b in wwhile (g, b);;\n", "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let g b = b in wwhile ((g, true), b);;\n"]}
{"fix": ["let fixpoint (f,b) = \nif b != f b then\nlet f b = b, (f b) in\nwwhile(f, b)\nelse b"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * 'b\n", "Error: Unbound value g\n"], "bad": ["\nlet f b = b;;\n\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ =\n  let fixpoint (f,b) = let f x = (b, (f b)) in b = (f b) in wwhile (f, b);;\n", "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ =\n  let fixpoint (f,b) = let g x = (b, (f b)) in b = (f b) in wwhile (g, b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n"], "bad": ["\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) =\n  if b != (f b) then let f b = (b, (f b)) in wwhile (f, b) else b;;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n"]}
{"fix": [], "hw": "hw2", "problem": "assoc", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n"], "bad": ["\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = if b != (f b) then let b = f b in wwhile (f, b) else b;;\n"]}
{"fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type ('a -> 'a) * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "Error: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "Error: This expression has type 'a but an expression was expected of type\n         (('a -> 'a * bool) * 'a) * bool\n       The type variable 'a occurs inside (('a -> 'a * bool) * 'a) * bool\n"], "bad": ["\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = if b != (f b) then let b = f b in wwhile (f, b) else b;;\n", "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = if b != (f b) then wwhile (f, (f b)) else b;;\n", "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = if b != (f b) then wwhile (f, (f b)) else b;;\n", "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) =\n  if b != (f b) then let f = (f, true) in wwhile (f, (f b)) else b;;\n", "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) =\n  if b != (f b) then let f = ((f b), true) in wwhile (f, (f b)) else b;;\n", "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) =\n  if b != (f b) then let f b = (b, true) in wwhile (f, (f b)) else b;;\n", "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) =\n  if b != (f b)\n  then let f b = (b, true) in wwhile (f, (f b))\n  else wwhile (f b);;\n"]}
{"fix": ["let fixpoint (f,b) =\nlet g b = (f b, (b = f b)) in\nwwhile(g, f b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) =\n  if b = (f b) then b else (let g b = ((f b), true) in wwhile (g, (f b)));;\n"]}
{"fix": ["let fixpoint (f,b) =\nlet g x = (f b, (b = f b)) in\nwwhile(g, f b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) = let g b = ((f b), (b = (f b))) in wwhile (g, (f b));;\n"]}
{"fix": ["let fixpoint (f,b) =\nlet f x = (f b, (b = f b)) in\nwwhile(f, f b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) = let g x = ((f b), (b = (f b))) in wwhile (g, (f b));;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet fixpoint (f,b) = let f x = ((f b), (b = (f b))) in wwhile (f, (f b));;\n", "\nlet fixpoint (f,b) = let g x = ((f b), (b = (f b))) in wwhile (g, (f b));;\n", "\nlet fixpoint (f,b) = let g x = (f, (b = (f b))) in wwhile (g, (f b));;\n", "\nlet fixpoint (f,b) = let g x = ((f b), (b = (f b))) in wwhile (g, b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value fixpoint\n"], "bad": ["\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "\nlet fixpoint (f,b) = let g x = ((f b), (b = (f b))) in wwhile (g, b);;\n"]}
{"fix": [], "hw": "hw2", "problem": "wwhile", "message": ["Error: Unbound value fixpoint\n", "Error: Unbound value wwhile\n"], "bad": ["\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 4);;\n"]}
{"fix": [], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value wwhile\n", "Error: Unbound value fixpoint\n"], "bad": ["\nlet fixpoint (f,b) = let g x = ((f b), (b = (f b))) in wwhile (g, b);;\n", "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n"]}
{"fix": ["let fixpoint (f,b) =\nlet y = f b in (y, (b = f b)) in\nwwhile(y, b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "Error: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "bad": ["\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let y = ((f b), (b = (f b))) in wwhile (y, b);;\n", "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let y x = ((f b), (b = (f b))) in wwhile ((y b), b);;\n"]}
{"fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: Unbound value y\n", "Error: Unbound value f\n", "Error: Unbound value y\n", "Error: Unbound value y\n", "Error: Unbound value f\n", "Error: Unbound value y\n"], "bad": ["\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ = let fixpoint (f,b) = let y = f b in (y, (b = (f b))) in wwhile (y, b);;\n", "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ = let fixpoint (f,b) = let y = f b in (y, (b = (f b))) in wwhile (f, b);;\n", "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ = let fixpoint (f,b) = let y = f b in (y, (b = (f b))) in wwhile (y, b);;\n", "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ = let fixpoint (f,b) = let y = f b in (y, (b = (f b))) in wwhile (y, b);;\n", "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ =\n  let fixpoint (f,b) = let y = f b in (y, (b = (f b))) in wwhile ((f b), b);;\n", "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ =\n  let fixpoint (f,b) = let y x = f b in (y, (b = (f b))) in wwhile (y, b);;\n"]}
{"fix": ["let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n"], "bad": ["\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let y x = ((f b), (b = (f b))) in wwhile (f, b);;\n"]}
{"fix": ["let fixpoint (f,b) =\nlet f x = (f b, (f b = b)) in\nwwhile(f, b)"], "hw": "hw2", "problem": "fixpoint", "message": ["Error: This expression has type 'a but an expression was expected of type\n         'a -> 'a\n       The type variable 'a occurs inside 'a -> 'a\n", "Error: This expression has type ('a -> 'a) * bool\n       but an expression was expected of type 'a -> 'a\n", "Error: Unbound value x\n", "Error: This expression has type ('a -> 'a) * bool\n       but an expression was expected of type 'b -> 'b * bool\n"], "bad": ["\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let f x = (f, ((f b) = b)) in wwhile (f, b);;\n", "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let f x = (f, ((f b) = b)) in wwhile (f, (f b));;\n", "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let f x = (f, ((f b) = b)) in wwhile (f, x);;\n", "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let f x = (f, ((f b) = b)) in wwhile ((f b), b);;\n"]}
{"fix": ["let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin(pi\" ^ exprToString e ^ \")\"\n| Cosine e -> \"cos(pi\" ^ exprToString e ^ \")\"\n| Average (e1,e2) -> exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"/2\"\n| Times (e1,e2) -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1,e2,e3,e4) -> exprToString e1^\"<\" ^exprToString e2^ \"?\" ^ exprToString e3 ^\":\" ^ exprToString e4"], "hw": "hw2", "problem": "exprToString", "message": ["Error: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "Error: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type expr\n", "Error: Unbound value printf\n", "Error: Unbound value printf\n", "Error: This expression has type expr but an expression was expected of type\n         string\n", "Error: This expression has type\n         ('a -> 'b, Format.formatter, unit, unit, unit, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, Format.formatter, unit, unit, unit, unit)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type unit \n", "Error: This expression has type expr but an expression was expected of type\n         string\n", "Error: This expression has type expr but an expression was expected of type\n         string\n", "Error: This expression has type expr but an expression was expected of type\n         string\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX e -> printf \"%s\" e\n  | VarY e -> printf \"%s\" e\n  | Sine e -> printf \"sin(%s)\" e\n  | Cosine e -> printf \"cos(%s)\" e\n  | (Average e1,e2) -> printf \"%s+%s/2\" e1 e2\n  | (Times e1,e2) -> printf \"%s*%s\" e1 e2\n  | (Thresh e1,e2,e3,e4) -> printf \"(%s<%s?%s:%s)\" e1 e2 e3 e4;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> printf \"x\"\n  | VarY  -> printf \"y\"\n  | Sine e -> printf \"sin(%s)\" e\n  | Cosine e -> printf \"cos(%s)\" e\n  | (Average e1,e2) -> printf \"%s+%s/2\" e1 e2\n  | (Times e1,e2) -> printf \"%s*%s\" e1 e2\n  | (Thresh e1,e2,e3,e4) -> printf \"(%s<%s?%s:%s)\" e1 e2 e3 e4;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> printf \"x\"\n  | VarY  -> printf \"y\"\n  | Sine e -> printf \"sin(%s)\" e\n  | Cosine e -> printf \"cos(%s)\" e\n  | Average (e1,e2) -> printf \"%s+%s/2\" e1 e2\n  | Times (e1,e2) -> printf \"%s*%s\" e1 e2\n  | Thresh (e1,e2,e3,e4) -> printf \"(%s<%s?%s:%s)\" e1 e2 e3 e4;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.printf \"x\"\n  | VarY  -> printf \"y\"\n  | Sine e -> printf \"sin(%s)\" e\n  | Cosine e -> printf \"cos(%s)\" e\n  | Average (e1,e2) -> printf \"%s+%s/2\" e1 e2\n  | Times (e1,e2) -> printf \"%s*%s\" e1 e2\n  | Thresh (e1,e2,e3,e4) -> printf \"(%s<%s?%s:%s)\" e1 e2 e3 e4;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.printf \"x\"\n  | VarY  -> Format.printf \"y\"\n  | Sine e -> Format.printf \"sin(%s)\" e\n  | Cosine e -> Format.printf \"cos(%s)\" e\n  | Average (e1,e2) -> Format.printf \"%s+%s/2\" e1 e2\n  | Times (e1,e2) -> Format.printf \"%s*%s\" e1 e2\n  | Thresh (e1,e2,e3,e4) -> Format.printf \"(%s<%s?%s:%s)\" e1 e2 e3 e4;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.printf \"x\"\n  | VarY  -> Format.printf \"y\"\n  | Sine e -> Format.printf \"sin(%s)\" to_string e\n  | Cosine e -> Format.printf \"cos(%s)\" e\n  | Average (e1,e2) -> Format.printf \"%s+%s/2\" e1 e2\n  | Times (e1,e2) -> Format.printf \"%s*%s\" e1 e2\n  | Thresh (e1,e2,e3,e4) -> Format.printf \"(%s<%s?%s:%s)\" e1 e2 e3 e4;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(\" ^ (e ^ \")\")\n  | Cosine e -> \"cos(\" ^ (e ^ \")\")\n  | Average (e1,e2) -> e1 ^ (\"+\" ^ (e2 ^ \"/2\"))\n  | Times (e1,e2) -> e1 ^ (\"*\" ^ e2)\n  | Thresh (e1,e2,e3,e4) -> e1 ^ (\"<\" ^ (e2 ^ (\"?\" ^ (e3 ^ (\":\" ^ e4)))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(\" ^ (e ^ \")\")\n  | Average (e1,e2) -> e1 ^ (\"+\" ^ (e2 ^ \"/2\"))\n  | Times (e1,e2) -> e1 ^ (\"*\" ^ e2)\n  | Thresh (e1,e2,e3,e4) -> e1 ^ (\"<\" ^ (e2 ^ (\"?\" ^ (e3 ^ (\":\" ^ e4)))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) -> (exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2\"))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) -> e1 ^ (\"<\" ^ (e2 ^ (\"?\" ^ (e3 ^ (\":\" ^ e4)))));;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*. e)\n| Cosine e-> cos(pi*. e)\n| Average (e1,e2) -> (eval(e,x,y) +. eval(e,x,y)) /. 2.\n| Times (e1,e2) -> eval(e,x,y) *. eval(e,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e,x,y) < eval(e,x,y) then eval(e,x,y) else eval(e,x,y)"], "hw": "hw2", "problem": "eval", "message": ["Error: Unbound value eval\n", "Error: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval e))\n  | Cosine e -> cos (pi *. (eval e))\n  | Average (e1,e2) -> ((eval e1) +. (eval e2)) /. 2\n  | Times (e1,e2) -> (eval e1) *. (eval e2)\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval e1) < (eval e2) then eval e3 else eval e4;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e, x, y)) +. (eval (e, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e, x, y)) *. (eval (e, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e, x, y)) < (eval (e, x, y))\n      then eval (e, x, y)\n      else eval (e, x, y);;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*. eval(e,x,y))\n| Cosine e-> cos(pi*. eval(e,x,y))\n| Average (e1,e2) -> (eval(e,x,y) +. eval(e,x,y)) /. 2.\n| Times (e1,e2) -> eval(e,x,y) *. eval(e,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e,x,y) < eval(e,x,y) then eval(e,x,y) else eval(e,x,y)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type expr but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. e)\n  | Cosine e -> cos (pi *. e)\n  | Average (e1,e2) -> ((eval (e, x, y)) +. (eval (e, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e, x, y)) *. (eval (e, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e, x, y)) < (eval (e, x, y))\n      then eval (e, x, y)\n      else eval (e, x, y);;\n"]}
{"fix": [], "hw": "hw2", "problem": "eval", "message": ["Error: This variant pattern is expected to have type expr\n       The constructor Square does not belong to type expr\nHint: Did you mean Squared?\n", "Error: This expression has type expr but an expression was expected of type\n         float\n", "Error: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "Error: This expression has type int but an expression was expected of type\n         float\n", "Error: This expression has type int but an expression was expected of type\n         float\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Square e -> eval (e ** 2)\n  | Root e -> eval (e ** (1 / 2));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> eval (e ** 2)\n  | Root e -> eval (e ** (1 / 2));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval e) ** 2\n  | Root e -> (eval e) ** (1 / 2);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2\n  | Root e -> (eval (e, x, y)) ** (1 / 2);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** (1 / 2);;\n"]}
{"fix": ["let rec build (rand, depth) = \nif depth = 0 || depth = 1 then\nlet r = rand(0,1) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,9) in\nmatch r with\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 -> buildSquared(build(rand,depth-1))\n| 8 -> buildRoot(build(rand,depth-1))"], "hw": "hw2", "problem": "build", "message": ["Error: Unbound value buildSquare\nHint: Did you mean buildSquared?\nError: Unbound value buildSquare\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value buildSquare\nHint: Did you mean buildSquared?\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildRoot e = Root e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if (depth = 0) || (depth = 1)\n  then let r = rand (0, 1) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 9) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildSquare (build (rand, (depth - 1)))\n     | 8 -> buildRoot (build (rand, (depth - 1))));;\n"]}
{"fix": ["let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi *. eval(e,x,y))\n| Cosine e-> cos(pi *. eval(e,x,y))\n| Average (e1,e2) -> ((eval(e1,x,y) +. eval(e2,x,y)) /. 2.)\n| Times (e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y) \nelse eval(e4,x,y)\n| Squared e -> (eval(e,x,y) ** 2.)\n| Root e -> (eval(e,x,y) ** 0.5)"], "hw": "hw2", "problem": "eval", "message": ["Error: This expression has type float but an expression was expected of type\n         int\n", "Error: This expression has type float but an expression was expected of type\n         int\n"], "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = (a*x) in\nlet base = 0 in\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type int -> 'a -> 'b -> 'c -> int\n       but an expression was expected of type int -> 'a -> int\n       Type 'b -> 'c -> int is not compatible with type int \n"], "bad": ["\nlet sqsum xs =\n  let f a x f _ = a * a in let base = 0 in List.fold_left f base xs;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = (a*a) in\nlet base = 0 in\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: This expression has type int but an expression was expected of type\n         unit\n"], "bad": ["\nlet sqsum xs = let f a x = () in let base = 0 in List.fold_left f base xs;;\n"]}
{"fix": ["let sqsum xs = \nlet f a x = (a+x*x) in\nlet base = 0 in\nList.fold_left f base xs"], "hw": "hw3", "problem": "sqsum", "message": ["Error: Unbound value x\n"], "bad": ["\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = x in List.fold_left f base xs;;\n"]}
{"fix": [], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet pipe fs = let f a x = a + x in let base = fs in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = 0 in let base = fs in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = (a+x) in\nlet base = 0 in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value base\n"], "bad": ["\nlet pipe fs =\n  let f a x = a + x in let base = base in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = (x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type int -> int -> int\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n", "Error: This expression has type 'a -> 'a\n       but an expression was expected of type unit\n"], "bad": ["\nlet pipe fs = let f a x = a + x in let base = fs in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a + x in let base = fs in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a + x in let base = f in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a + x in let base = [] in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a + x in let base a = a in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = () in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = (x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"], "bad": ["\nlet pipe fs = let f a x = a + x in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun f -> (a x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: Unbound value f\n"], "bad": ["\nlet pipe fs =\n  let f a x x = f (a x) in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = (x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'a) -> 'a -> 'a\n       but an expression was expected of type ('a -> 'a) -> 'a\n       The type variable 'a occurs inside 'a -> 'a\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'c -> ('c -> 'a) -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'c -> 'a -> 'b\n       The type variable 'a occurs inside 'c -> 'a\n", "Error: Unbound value f\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs =\n  let f a x f = f (a x) in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x f = f x in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x f = a (f x) in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x = a (f x) in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = (x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": [], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = (x)a in\nlet base = (fun x -> x) in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = (x) in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "Error: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "\nlet x _ f = f;;\n\nlet pipe fs = let f a x = a x in let base = x in List.fold_left f base fs;;\n", "\nlet pipe fs = let f a x = a x in let base = () in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = (x a) in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n"], "bad": ["\nlet pipe fs = let f a x = x x in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let pipe fs = \nlet f a x = fun y -> x (a y) in\nlet base = fun x -> x in\nList.fold_left f base fs"], "hw": "hw3", "problem": "pipe", "message": ["Error: This expression has type ('a -> 'a) -> 'a -> 'a\n       but an expression was expected of type ('a -> 'a) -> 'a\n       The type variable 'a occurs inside 'a -> 'a\n", "Error: This expression has type ('a -> 'a) -> 'a -> 'a\n       but an expression was expected of type ('a -> 'a) -> 'a\n       The type variable 'a occurs inside 'a -> 'a\n"], "bad": ["\nlet pipe fs =\n  let f a x y = y (a y) in let base x = x in List.fold_left f base fs;;\n", "\nlet pipe fs =\n  let f a x y = y (a y) in let base x = x in List.fold_left f base fs;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type string list\n       but an expression was expected of type string\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h in\n      let base = \"\" in let l = h ^ t in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h in let base = t in let l = t in List.fold_left f base l;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n", "Error: Unbound value l\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h in let base = \"\" in let l = h in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h in let base = \"\" in let l = l in List.fold_left f base l;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type string but an expression was expected of type\n         'a list\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ sep in\n      let base = \"\" in let l = sepConcat sep t in List.fold_left f base l;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type string\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep :: (sepConcat (sep t))) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type string list\n       but an expression was expected of type string\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ (sepConcat (sep t))) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ t) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n"]}
{"fix": ["let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"], "hw": "hw3", "problem": "sepConcat", "message": ["Error: This expression has type string\n       This is not a function; it cannot be applied.\n", "Error: This expression has type string but an expression was expected of type\n         'a list\n", "Error: This expression has type string but an expression was expected of type\n         string list -> string\n", "Error: This expression has type 'a list -> string\n       but an expression was expected of type string\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ sep in\n      let base = \"\" in let l = sepConcat (sep t) in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ sep in\n      let base = \"\" in let l = sepConcat sep t in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = sepConcat (h ^ (sep t)) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (sepConcat h) ^ (sep t) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n"]}
{"fix": ["let stringOfList f l = List.map sepConcat"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type string but an expression was expected of type\n         string list\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat \"\";;\n"]}
{"fix": ["let stringOfList f l = List.map (sepConcat) (f l)"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type string but an expression was expected of type\n         string list\n", "Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n", "Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n", "Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n", "Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n", "Error: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat l \"\") f;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"\" l) f;;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"\" l);;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"\" (f l));;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"\" (f l));;\n", "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat f l;;\n"]}
{"fix": ["let stringOfList f l = List.map (sepConcat) (f l)"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"\" (f l)) (f l);;\n"]}
{"fix": [], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"\" (f l)) l;;\n"]}
{"fix": ["let stringOfList f l = List.map (sepConcat) (l)"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"\" (f l)) l;;\n"]}
{"fix": ["let stringOfList f l = List.map (sepConcat) (l)"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This expression has type string but an expression was expected of type\n         'a -> 'b\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"\" (f l)) l;;\n"]}
{"fix": ["let stringOfList f l = List.map (sepConcat) (f l)"], "hw": "hw3", "problem": "stringOfList", "message": ["Error: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat f l;;\n"]}
{"fix": ["let clone x n = \nlet rec helper x n acc =\nif n <= 0 then acc\nelse helper x (n-1) (x::acc)\nin helper x n []"], "hw": "hw3", "problem": "clone", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int but an expression was expected of type\n         int -> int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list -> 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet rec clone x n = if n <= 0 then [] else x :: ((clone x n) - 1);;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: ((clone x n) - 1);;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: (clone ((x n) - 1));;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: ((clone x n) - 1);;\n", "\nlet rec clone x n = if n <= 0 then [] else (clone x n) - 1;;\n", "\nlet rec clone x n = if n <= 0 then [] else x :: ((clone x n) - 1);;\n", "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else ((helper x n) - (1 x)) :: acc in\n  helper x n [];;\n"]}
{"fix": ["let padZero l1 l2 =\nif (List.length l1) < (List.length l2) then\nList.append [(clone 0 (List.length l2 - List.length l1)) @ l1] [l2]\nelse\nList.append [l1] [(clone 0 (List.length l1 - List.length l2)) @ l2]"], "hw": "hw3", "problem": "padZero", "message": ["Error: This function has type 'a list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This function has type 'a list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n", "Error: This expression has type int\n       This is not a function; it cannot be applied.\n"], "bad": ["\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l2) <\n      (List.length l1 List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n", "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l2) <\n      (List.length l1 List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n", "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l2) <\n      (List.length l1 List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n", "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l2) <\n      (List.length l1 List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n", "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l2) <\n      (List.length l1 List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n", "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l2) <\n      ((List.length l1) List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n", "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l1) >\n      ((List.length l2) List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n"]}
{"fix": ["let padZero l1 l2 =\nif (List.length l1) < (List.length l2) then\n((clone 0 (List.length l2 - List.length l1)) @ l1, l2)\nelse\n(l1, (clone 0 (List.length l1 - List.length l2)) @ l2)"], "hw": "hw3", "problem": "padZero", "message": ["Error: This expression has type int list\n       but an expression was expected of type int\n"], "bad": ["\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else ([l1], ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n"]}
{"fix": ["let padZero l1 l2 =\nif (List.length l1) < (List.length l2) then\n(List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\nelse\n(l1, List.append (clone 0 (List.length l1 - List.length l2)) l2)"], "hw": "hw3", "problem": "padZero", "message": ["Error: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"], "bad": ["\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((List.append clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type ('a -> 'a) list\n       but an expression was expected of type int\n", "Error: This expression has type int list\n       but an expression was expected of type int\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type int list\n       Type 'a * 'b is not compatible with type int \n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n", "Error: This expression has type int but an expression was expected of type\n         'a * 'b\n"], "bad": ["\nlet x x = x;;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [] in\n    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in\n  (removeZero (add (padZero l1 l2)) 0 0 9 9) + (1 0 0 2);;\n", "\nlet x x = x;;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [l1] in\n    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in\n  (removeZero (add (padZero l1 l2)) 0 0 9 9) + (1 0 0 2);;\n", "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet x x = x;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [x] in\n    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in\n  (removeZero (add (padZero l1 l2)) 0 0 9 9) + (1 0 0 2);;\n", "\nlet x x = x;;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [1] in\n    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in\n  (removeZero (add (padZero l1 l2)) 0 0 9 9) + (1 0 0 2);;\n", "\nlet x x = x;;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in\n  (removeZero (add (padZero l1 l2)) 0 0 9 9) + (1 0 0 2);;\n", "\nlet x x = x;;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = [l1] in let (_,res) = List.fold_left f base args in res in\n  (removeZero (add (padZero l1 l2)) 0 0 9 9) + (1 0 0 2);;\n", "\nlet x x = x;;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = [l1] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value res\nHint: Did you mean ref?\n", "Error: Unbound value base\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n", "Error: This expression has type int but an expression was expected of type\n         int list\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: This expression has type 'a -> 'b -> 'a * 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'a * 'a\n", "Error: This expression has type (int * int) list -> int list -> int list\n       but an expression was expected of type\n         (int * int) list -> int list -> (int * int) list\n       Type int is not compatible with type int * int \n", "Error: This expression has type (int * int) list -> 'a -> int\n       but an expression was expected of type\n         (int * int) list -> 'a -> (int * int) list\n       Type int is not compatible with type (int * int) list \n"], "bad": ["\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (q,w)::t -> (q + w) :: res in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (q,w)::t -> (q + w) :: base in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (q,w)::t -> (q + w) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (q,w)::t -> (q + w) :: a | _ -> a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = [(1, 2)] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (1, 2) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> [h1 + h2] in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> h1 + h2 in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) acc =\n    let f a x = match x with | (h1,h2)::t -> (h1 + h2) :: acc in\n    let base = acc in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) acc =\n    let f a x = match x with | (h1,h2)::t -> (h1 + h2) :: acc in\n    let base = acc in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2) []);;\n", "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = [] in\n    let args = l1 @ l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a, a) in\n    let base = [] in\n    let args = l1 @ l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (a1,a2)::aa -> (a1 + a2) :: x in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (a1,a2)::aa -> a1 + a2 in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n", "Error: This expression has type (int * int) list -> int list -> int list\n       but an expression was expected of type\n         (int * int) list -> int list -> (int * int) list\n       Type int is not compatible with type int * int \n", "Error: This expression has type (int * int) list -> int list -> int list\n       but an expression was expected of type\n         (int * int) list -> int list -> (int * int) list\n       Type int is not compatible with type int * int \n", "Error: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "Error: This expression has type (int * int) list -> int list -> int list\n       but an expression was expected of type\n         (int * int) list -> int list -> (int * int) list\n       Type int is not compatible with type int * int \n", "Error: This expression has type (int * int) list -> int list -> int list\n       but an expression was expected of type\n         (int * int) list -> int list -> (int * int) list\n       Type int is not compatible with type int * int \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n", "Error: This expression has type (int * int) list -> int list -> int list\n       but an expression was expected of type\n         (int * int) list -> int list -> (int * int) list\n       Type int is not compatible with type int * int \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n"], "bad": ["\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = [] in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (x1,x2)::xs -> (x1 + x2) :: x in\n    let base = [] in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (x1,x2)::xs -> (x1 + x2) :: x in\n    let base = [] in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (x1,x2)::xs -> (x1 + x2) :: x in\n    let base = [] in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (x1,x2)::xs -> (x1 + x2) :: x in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (x1,x2)::xs -> (x1 + x2) :: x in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (a1,a2)::aa -> ((a1 + a2), 0) :: x in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (a1,a2)::aa -> (a1 + a2) :: x in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (a1,a2)::aa -> (a1 + a2) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [(0, [])] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value a\n", "Error: This expression has type 'a * 'b\n       but an expression was expected of type (int * 'c list) list\n", "Error: This expression has type int * ('a * 'b) list\n       but an expression was expected of type (int * 'c list) list\n", "Error: This expression has type int * 'a\n       but an expression was expected of type (int * 'b list) list\n", "Error: This expression has type int * 'a\n       but an expression was expected of type (int * 'b list) list\n", "Error: This expression has type int * 'a list\n       but an expression was expected of type (int * 'b list) list\n"], "bad": ["\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (a, b) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = (0, (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = (0, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = (0, l1) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = (0, []) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [(0, [])] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type (int list * int list) list\n       but an expression was expected of type int list\n       Type int list * int list is not compatible with type int \n"], "bad": ["\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [(l1, l2)])] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [ (3, [] ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int list * int list\n       but an expression was expected of type int * int\n       Type int list is not compatible with type int \n"], "bad": ["\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [((l1 + l2), [])] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a in\nlet base = (0, []) in\nlet args = [ (0, [] ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int list list\n       but an expression was expected of type int list\n       Type int list is not compatible with type int \n"], "bad": ["\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, [l1]) in\n    let args = [(3, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| x'::xs -> x' in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [[ (h, l2 ) ]] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * 'c list) list list\n       Type 'a * 'b is not compatible with type (int * 'c list) list \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * 'c list) list list\n       Type 'a * 'b is not compatible with type (int * 'c list) list \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * 'c list) list list\n       Type 'a * 'b is not compatible with type (int * 'c list) list \n"], "bad": ["\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | x::xs -> x in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | x::xs -> x in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | x'::xs -> x' in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (c,d) -> (c,d) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b -> 'c -> 'a\n       but an expression was expected of type 'a * 'b -> 'c -> 'a * 'b\n       The type variable 'a occurs inside 'a * 'b\n"], "bad": ["\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (c,d) -> c in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d) -> a in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a -> 'b * 'c -> 'b * 'a\n       but an expression was expected of type 'a -> 'b * 'c -> 'a\n       The type variable 'a occurs inside 'b * 'a\n"], "bad": ["\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d) -> (c, a) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d) -> a in\nlet base = (0, [1]) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type (int * int) list\n       but an expression was expected of type int list\n       Type int * int is not compatible with type int \n"], "bad": ["\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d) -> a in\n    let base = (0, [(1, 1)]) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> a in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int * 'a list\n       but an expression was expected of type int list\n", "Error: This expression has type int * 'a list\n       but an expression was expected of type int list\n", "Error: This expression has type int list -> int * int list -> int list * 'a\n       but an expression was expected of type\n         int list -> int * int list -> int list\n       Type int list * 'a is not compatible with type int list \n", "Error: This expression has type int * 'a list\n       but an expression was expected of type int list\n"], "bad": ["\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d) -> (c + d) :: a in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c + d) :: a in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (((c + d) :: a), l2) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c + d) :: a in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,d::t) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int * 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int * 'a list\n       but an expression was expected of type int list\n", "Error: This expression has type int list * int list\n       but an expression was expected of type (int * 'a list) list * 'b list\n       Type int is not compatible with type int * 'a list \n", "Error: This expression has type int list * int list\n       but an expression was expected of type int list * 'a list list\n       Type int is not compatible with type 'a list \n", "Error: This expression has type int list * int list\n       but an expression was expected of type int list * 'a list list\n       Type int is not compatible with type 'a list \n"], "bad": ["\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> c + d in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c + d) :: a in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> c in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, d) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, d) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,t) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a -> 'b * 'c list -> 'b * 'a\n       but an expression was expected of type 'a -> 'b * 'c list -> 'a\n       The type variable 'a occurs inside 'b * 'a\n", "Error: This expression has type 'a -> 'b * 'c list -> 'b * 'a list\n       but an expression was expected of type 'a -> 'b * 'c list -> 'a\n       The type variable 'a occurs inside 'b * 'a list\n"], "bad": ["\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, a) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, [a]) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,t) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, List.rev l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int list * int list\n       but an expression was expected of type int list * 'a list list\n       Type int is not compatible with type 'a list \n"], "bad": ["\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, d) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,t) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, List.rev l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a list\n       but an expression was expected of type int\n"], "bad": ["\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, (c + t)) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, (c + t)) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type\n         'a list list -> 'b * 'a list -> 'b * 'a list list\n       but an expression was expected of type\n         'a list list -> 'b * 'a list -> 'a list list\n       Type 'b * 'a list list is not compatible with type 'a list list \n", "Error: This expression has type 'a -> 'b * 'a list -> 'b * 'a list\n       but an expression was expected of type 'a -> 'b * 'a list -> 'a\n       The type variable 'a occurs inside 'b * 'a list\n", "Error: This expression has type 'a -> 'b * 'c list -> 'b * 'a\n       but an expression was expected of type 'a -> 'b * 'c list -> 'a\n       The type variable 'a occurs inside 'b * 'a\n", "Error: This expression has type 'a -> 'b * 'c list -> 'b * 'a\n       but an expression was expected of type 'a -> 'b * 'c list -> 'a\n       The type variable 'a occurs inside 'b * 'a\n", "Error: This expression has type int * 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int * 'a list\n       but an expression was expected of type int list\n", "Error: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type 'c list\n", "Error: This expression has type int * 'a list\n       but an expression was expected of type int list\n", "Error: This expression has type int but an expression was expected of type\n         'a list\n", "Error: This expression has type int * 'a list\n       but an expression was expected of type int list\n", "Error: This expression has type (int * int) list -> int list -> int list\n       but an expression was expected of type\n         (int * int) list -> int list -> (int * int) list\n       Type int is not compatible with type int * int \n"], "bad": ["\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, (t :: a)) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, (a :: t)) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, a) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, a) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> h1 + h2 in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> (h1 + h2) :: a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | h::(t1,t2) -> t1 + t2 in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> (h1 + h2) :: a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> (h1 + h2) @ a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> [h1 + h2] @ a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (h1,h2)::t -> (h1 + h2) :: x in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2) -> (d1+d2, d1+d2::\nmatch a with \n| (a1,a2)->a2) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type\n         (int * int) list -> int list -> int * int list\n       but an expression was expected of type\n         (int * int) list -> int list -> (int * int) list\n       Type int * int list is not compatible with type (int * int) list \n", "Error: This expression has type\n         (int * int) list -> int list -> int * int list\n       but an expression was expected of type\n         (int * int) list -> int list -> (int * int) list\n       Type int * int list is not compatible with type (int * int) list \n", "Error: This expression has type (int * int) list -> 'a -> int * int\n       but an expression was expected of type\n         (int * int) list -> 'a -> (int * int) list\n       Type int * int is not compatible with type (int * int) list \n", "Error: This expression has type int * 'a list\n       but an expression was expected of type (int * int) list\n", "Error: This expression has type 'a * (int * int) list -> int list -> int list\n       but an expression was expected of type\n         'a * (int * int) list -> int list -> 'a * (int * int) list\n       Type int list is not compatible with type 'a * (int * int) list \n", "Error: This expression has type\n         int * (int * int) list -> int list -> int * int list\n       but an expression was expected of type\n         int * (int * int) list -> int list -> int * (int * int) list\n       Type int is not compatible with type int * int \n", "Error: This expression has type int * (int * int) list -> 'a -> int * int\n       but an expression was expected of type\n         int * (int * int) list -> 'a -> int * (int * int) list\n       Type int is not compatible with type (int * int) list \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n", "Error: This expression has type int * 'a list\n       but an expression was expected of type unit\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n", "Error: This expression has type\n         int * int -> (int * int) list -> int * (int * int) list\n       but an expression was expected of type\n         int * int -> (int * int) list -> int * int\n       Type (int * int) list is not compatible with type int \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * 'c list) list list\n       Type 'a * 'b is not compatible with type (int * 'c list) list \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * 'c list) list list\n       Type 'a * 'b is not compatible with type (int * 'c list) list \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * 'c list) list list\n       Type 'a * 'b is not compatible with type (int * 'c list) list \n", "Error: This expression has type 'a -> (int * int) list -> int * 'a\n       but an expression was expected of type 'a -> (int * int) list -> 'a\n       The type variable 'a occurs inside int * 'a\n", "Error: This expression has type int * 'a list\n       but an expression was expected of type int\n", "Error: This expression has type 'a -> (int * int) list -> int * 'a\n       but an expression was expected of type 'a -> (int * int) list -> 'a\n       The type variable 'a occurs inside int * 'a\n", "Error: This expression has type\n         int * int -> (int * int) list -> int * (int * int) list\n       but an expression was expected of type\n         int * int -> (int * int) list -> int * int\n       Type (int * int) list is not compatible with type int \n", "Error: This expression has type\n         int * int -> (int * int) list -> int * (int * int) list\n       but an expression was expected of type\n         int * int -> (int * int) list -> int * int\n       Type (int * int) list is not compatible with type int \n", "Error: This expression has type 'a -> (int * int) list -> int * 'a\n       but an expression was expected of type 'a -> (int * int) list -> 'a\n       The type variable 'a occurs inside int * 'a\n", "Error: This expression has type int * 'a list\n       but an expression was expected of type int\n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n", "Error: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n", "Error: This expression has type 'a -> (int * int) list -> int * 'a\n       but an expression was expected of type 'a -> (int * int) list -> 'a\n       The type variable 'a occurs inside int * 'a\n", "Error: This expression has type 'a -> (int * int) list -> int * 'a\n       but an expression was expected of type 'a -> (int * int) list -> 'a\n       The type variable 'a occurs inside int * 'a\n", "Error: This expression has type int list -> int * int -> int * int list\n       but an expression was expected of type\n         int list -> int * int -> int list\n       Type int * int list is not compatible with type int list \n"], "bad": ["\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (h1,h2)::t -> ((h1 + h2), ((h1 + h2) :: x)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (h1,h2)::t -> ((h1 + h2), ((h1 + h2) :: x)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (h1,h2)::t -> ((h1 + h2), (h1 + h2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (h1,h2)::t -> ((h1 + h2), (h1 + h2)) :: x in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (c,(d1,d2)::ds) -> (d1 + d2) :: x in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,(d1,d2)::ds) -> ((d1 + (d2 mod 10)), ((d1 + d2) :: x)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with | (c,(d1,d2)::ds) -> ((d1 + (d2 mod 10)), (d1 + d2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (c,(d1,d2)::ds) -> ((d1 + (d2 mod 10)), x) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (c,(d1,d2)::ds) -> ((d1 + (d2 mod 10)), x) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> () in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), ds) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + (d2 mod 10)), (a :: ds)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> (d1, d2) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> (d1, d2) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> (d1, d2) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), a) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> d1 + d2 in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), a) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), (a :: x)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), (a :: x)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), a) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> d1 + d2 in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), []) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), []) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), a) in\n    let base = (0, []) in\n    let args = [List.rev (List.combine l1 l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), a) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2) -> ((d1 + d2), ((d1 + d2) :: a)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (o,p) = a in\nmatch x with \n| (d1,d2) -> (((d1+d2) mod 10 -(d1+d2))/10, (d1+d2) mod 10+o::p) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: Unbound value a2\n"], "bad": ["\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (((((d1 + d2) mod 10) - (d1 + d2)) / 10),\n            (((d1 + d2) mod 10) + ((match a with | (a1,a2) -> a1))))\n          :: a2 in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (o,p) = a in\nmatch x with \n| (d1,d2) -> ( (d1+d2+o)/10, ((d1+d2+o) mod 10) ::p) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type int\n"], "bad": ["\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      match x with\n      | (d1,d2) -> ((((d1 + d2) + a) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (o,p) = a in\nlet (d1,d2) = x in ( (d1+d2+o)/10, ((d1+d2+o) mod 10) ::p) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"], "hw": "hw3", "problem": "bigAdd", "message": ["Error: This expression has type int but an expression was expected of type\n         'a list\n"], "bad": ["\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      let (d1,d2) = x in\n      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev ((List.combine 0) :: (l1 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"]}
{"fix": ["let mulByDigit i l = \nlet rec helper i l acc =\nmatch l with\n| [] -> acc\n| h::t -> (h*i) :: acc \nin helper i l []"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type 'a list -> 'b\n       but an expression was expected of type int\n", "Error: This expression has type int list -> 'a\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside int list -> 'a\n"], "bad": ["\nlet rec mulByDigit i l = let h::t = List.rev l in (mulByDigit h) * i;;\n", "\nlet rec mulByDigit i l = let h::t = List.rev l in mulByDigit (h * i);;\n"]}
{"fix": ["let mulByDigit i l = \nlet rec helper i l acc =\nmatch l with\n| [] -> acc\n| h::t -> h*i :: acc \nin helper i l []"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type 'a list\n       but an expression was expected of type int\n", "Error: This expression has type int list -> 'a list -> 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside int list -> 'a list -> 'a list\n"], "bad": ["\nlet mulByDigit i l =\n  let rec helper i l acc =\n    match l with | [] -> acc | h::t -> (helper (t * i)) :: acc in\n  helper i l [];;\n", "\nlet mulByDigit i l =\n  let rec helper i l acc =\n    match l with | [] -> acc | h::t -> (helper (h * i)) :: acc in\n  helper i l [];;\n"]}
{"fix": ["let rec mulByDigit i l = mulByDigit (i-1) (bigAdd l l)"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: This expression has type 'a -> 'b\n       but an expression was expected of type int\n"], "bad": ["\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      let (d1,d2) = x in\n      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = (mulByDigit i) - (1 (bigAdd l l));;\n"]}
{"fix": [], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: Unbound value bigAdd\n", "Error: Unbound value mulByDigit\n", "Error: Unbound value mulByDigit\n", "Error: Unbound value mulByDigit\n", "Error: Unbound value mulByDigit\n", "Error: Unbound value mulByDigit\n", "Error: Unbound value mulByDigit\n", "Error: Unbound value mulByDigit\n", "Error: Unbound value mulByDigit\n"], "bad": ["\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9; 9];;\n", "\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n"]}
{"fix": [], "hw": "hw3", "problem": "bigMul", "message": ["Error: Unbound value mulByDigit\n"], "bad": ["\nlet _ = mulByDigit 0 [1; 1];;\n"]}
{"fix": ["let a1::a2::t = l1 in\nbigAdd (mulByDigit a2 (mulByDigit a1 l2))"], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: Unbound value mulByDigit\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n", "Error: Unbound value bigAdd\n"], "bad": ["\nlet l1 = [9; 9; 9; 9];;\n\nlet l2 = [9; 9; 9; 9];;\n\nlet _ = let a::t = l1 in mulByDigit a l2;;\n", "\nlet l1 = [9; 9; 9; 9];;\n\nlet l2 = [9; 9; 9; 9];;\n\nlet _ = let a1::a2::t = l1 in bigAdd (mulByDigit a1 l2) (mulByDigit a2 l2);;\n", "\nlet l1 = [9; 9; 9; 9];;\n\nlet l2 = [9; 9; 9; 9];;\n\nlet _ =\n  let a1::a2::t = l1 in\n  bigAdd (mulByDigit a1 l2) (mulByDigit a2 (mulByDigit a1 l2));;\n", "\nlet l1 = [9; 9; 9; 9];;\n\nlet l2 = [9; 9; 9; 9];;\n\nlet _ =\n  let a1::a2::t = l1 in\n  List.rev (bigAdd (mulByDigit a1 l2) (mulByDigit a2 (mulByDigit a1 l2)));;\n", "\nlet l1 = [9; 9; 9; 9];;\n\nlet l2 = [9; 9; 9; 9];;\n\nlet _ =\n  let a1::a2::t = l1 in\n  bigAdd (mulByDigit a1 l2) (mulByDigit a2 (mulByDigit a1 l2));;\n", "\nlet l1 = [9; 9; 9; 9];;\n\nlet l2 = [9; 9; 9; 9];;\n\nlet _ = let a1::a2::t = l1 in bigAdd (mulByDigit a2 (mulByDigit a1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "mulByDigit", "message": ["Error: Unbound value bigAdd\n"], "bad": ["\nlet l1 = [9; 9; 9; 9];;\n\nlet l2 = [9; 9; 9; 9];;\n\nlet _ = let a1::a2::t = l1 in bigAdd (mulByDigit a2 (mulByDigit a1 l2));;\n"]}
{"fix": [], "hw": "hw3", "problem": "sqsum", "message": ["Error: Unbound value mulByDigit\n"], "bad": ["\nlet l1 = [9; 9; 9; 9];;\n\nlet l2 = [9; 9; 9; 9];;\n\nlet _ = let a1::a2::t = l1 in mulByDigit a2 (mulByDigit a1 l2);;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet h::t = x in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o) )in\nlet base = (0,[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: Unbound value b\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value b\n"], "bad": ["\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      let (d1,d2) = x in\n      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet mulByDigit i l =\n  let rec helper i l hold =\n    match i with | 0 -> hold | _ -> helper (i - 1) l (bigAdd l hold) in\n  helper i l [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (o,p) = a in\n    let h::t = x in ((o + 1), ((bigAdd (mulByDigit h l2) p) @ (clone 0 b))) in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet (h::t,y) = x in (o+1, bigAdd (mulByDigit h y) (p @ clone 0 o) ) in\nlet base = (0,[]) in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      let (d1,d2) = x in\n      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet mulByDigit i l =\n  let rec helper i l hold =\n    match i with | 0 -> hold | _ -> helper (i - 1) l (bigAdd l hold) in\n  helper i l [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (o,p) = a in\n    let h::t = x in ((o + 1), (bigAdd (mulByDigit h l2) (p @ (clone 0 o)))) in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet (h::t,y) = x in (o+1, l1 ) in\nlet base = (0,[]) in\nlet args = [(l1, l2)] in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type 'a * 'b\n       but an expression was expected of type (int list * int list) list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type 'a * 'b\n       but an expression was expected of type (int list * int list) list\n"], "bad": ["\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      let (d1,d2) = x in\n      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet mulByDigit i l =\n  let rec helper i l hold =\n    match i with | 0 -> hold | _ -> helper (i - 1) l (bigAdd l hold) in\n  helper i l [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (o,p) = a in\n    let (h::t,y) = x in\n    ((o + 1), (bigAdd (mulByDigit h y) (p @ (clone 0 o)))) in\n  let base = (0, []) in\n  let args = (l1, l2) in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet (h::t) = x in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o)) in\nlet base = (0,[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: Unbound value y\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: Unbound value y\n"], "bad": ["\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      let (d1,d2) = x in\n      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet mulByDigit i l =\n  let rec helper i l hold =\n    match i with | 0 -> hold | _ -> helper (i - 1) l (bigAdd l hold) in\n  helper i l [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (o,p) = a in\n    let h::t = x in ((o + 1), (bigAdd (mulByDigit h y) (p @ (clone 0 o)))) in\n  let base = (0, []) in\n  let args = [l1] in let (_,res) = List.fold_left f base args in res;;\n"]}
{"fix": ["let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet h::t = [x] in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o)) in\nlet base = (0,[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres"], "hw": "hw3", "problem": "bigMul", "message": ["Error: This expression has type int but an expression was expected of type\n         int list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nError: This expression has type int but an expression was expected of type\n         int list\n"], "bad": ["\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      let (d1,d2) = x in\n      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet mulByDigit i l =\n  let rec helper i l hold =\n    match i with | 0 -> hold | _ -> helper (i - 1) l (bigAdd l hold) in\n  helper i l [];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (o,p) = a in\n    let h::t = x in ((o + 1), (bigAdd (mulByDigit h l2) (p @ (clone 0 o)))) in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n"]}
