{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| x::xs' -> x + sumList xs'", "bad": "let rec sumList xs = match xs with\n| [] -> []\n| h1::h2::t -> h1+h2 sumList t", "annotated": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n| [] -> []\n| h1::h2::t -> h1+h2 sumList t"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| x::xs' -> x + sumList xs'", "bad": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x+1 sumList xs'", "annotated": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n| [] -> []\n| (x::xs') -> x+1 sumList xs'"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| x::xs' -> x + sumList xs'", "bad": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x sumList xs'", "annotated": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n| [] -> []\n| (x::xs') -> x sumList xs'"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| x::xs' -> x + sumList xs'", "bad": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x + sumList xs'", "annotated": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n| [] -> []\n| (x::xs') -> x + sumList xs'"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| x::xs' -> x + sumList xs'", "bad": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') ->  1 sumList xs'", "annotated": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n| [] -> []\n| (x::xs') ->  1 sumList xs'"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| x::xs' -> x + sumList xs'", "bad": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x sumList xs'", "annotated": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n| [] -> []\n| (x::xs') -> x sumList xs'"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| x::xs' -> x + sumList xs'", "bad": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x + sumList xs'", "annotated": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n| [] -> []\n| (x::xs') -> x + sumList xs'"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| x::xs' -> x + sumList xs'", "bad": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x sumList xs'", "annotated": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n| [] -> []\n| (x::xs') -> x sumList xs'"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| x::xs' -> x + sumList xs'", "bad": "let rec sumList xs = match xs with\n| [] -> []\n| x::xs' -> x sumList xs'", "annotated": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n| [] -> []\n| x::xs' -> x sumList xs'"}
{"fix": "let rec digitsOfInt n = match n with\n| _ -> (n mod 10) + digitsOfInt  (n/10)", "bad": "let rec digitsOfInt n = match n with\n| n < 0 -> []\n| _     -> n%10 digitsOfInt  n/10", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  match n with\n| n < 0 -> []\n| _     -> n%10 digitsOfInt  n/10"}
{"fix": "let rec digitsOfInt n = match n with\n| _ -> (n mod 10) + digitsOfInt  (n/10)", "bad": "let rec digitsOfInt n = match n with\n| _     -> n%10 digitsOfInt  n/10", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  match n with\n| _     -> n%10 digitsOfInt  n/10"}
{"fix": "let rec digitsOfInt n = match n with\n| _ -> (n mod 10) + digitsOfInt  (n/10)", "bad": "let rec digitsOfInt n = match n with\n| _     -> n mod 10 digitsOfInt  n/10", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  match n with\n| _     -> n mod 10 digitsOfInt  n/10"}
{"fix": "let rec digitsOfInt n = match n with\n| _ -> (n mod 10) + digitsOfInt  (n/10)", "bad": "let rec digitsOfInt n = match n with\n| (n mod 10) + digitsOfInt  (n/10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  match n with\n| (n mod 10) + digitsOfInt  (n/10)"}
{"fix": "let rec digitsOfInt n = \nif (n<0) \nthen 0\nelse\n(n mod 10) + digitsOfInt  (n/10)", "bad": "let rec digitsOfInt n = match true with\n| n<0 -> 0\n| _ -> (n mod 10) + digitsOfInt  (n/10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  match true with\n| n<0 -> 0\n| _ -> (n mod 10) + digitsOfInt  (n/10)"}
{"fix": "let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)", "bad": "let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\ndigitsOfInt  (n/10) :: (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif (n<=0) \nthen []\nelse\ndigitsOfInt  (n/10) :: (n mod 10)"}
{"fix": "let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)", "bad": "let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\ndigitsOfInt (n/10) :: (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif (n<=0) \nthen []\nelse\ndigitsOfInt (n/10) :: (n mod 10)"}
{"fix": "let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)", "bad": "let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\n(digitsOfInt (n/10) ):: (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif (n<=0) \nthen []\nelse\n(digitsOfInt (n/10) ):: (n mod 10)"}
{"fix": "let rec sum n = \nif n < 0 \nthen failwith\"TBD\"\nelse (n mod 10) + digitalRoot n/10", "bad": "let rec digitalRoot n = \nlet temp = (sum n) in \nif temp > 10\nthen digitalRoot temp", "annotated": "let rec digitalRoot : int -> int = fun  n  ->  \nlet temp = (sum n) in \nif temp > 10\nthen digitalRoot temp"}
{"fix": "let rec sum n = \nif n < 0 \nthen failwith\"TBD\"\nelse (n mod 10) + digitalRoot n/10", "bad": "let rec sum n = \nif n < 0 \nthen failwith\"TBD\"\nelse n%10 + digitalRoot n/10", "annotated": "let rec sum n = \nif n < 0 \nthen failwith\"TBD\"\nelse n%10 + digitalRoot n/10"}
{"fix": "let rec additivePersistence n = additivePersistence_helper (n, 0)", "bad": "let rec additivePersistence n = additivePersistence (n, 0)", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  additivePersistence (n, 0)"}
{"fix": "let rec sum (n, i) = \nif n < 10\nthen (sumList (digitsOfInt n), i)\nelse (sumList (digitsOfInt n), 1+1)", "bad": "let rec sum (n, i) = \nif n < 10\nthen sumList (digitsOfInt n) i\nelse sumList (digitsOfInt n) 1+1", "annotated": "let rec sum (n, i) = \nif n < 10\nthen sumList (digitsOfInt n) i\nelse sumList (digitsOfInt n) 1+1"}
{"fix": "let rec sum (n, i) = \nif n < 10\nthen (sumList (digitsOfInt n), i)\nelse (sumList (digitsOfInt n), 1+1)", "bad": "let rec sum [n;i] = \nif n < 10 || []\nthen [sumList (digitsOfInt n); i]\nelse [sumList (digitsOfInt n); 1+1]", "annotated": "let rec sum [n;i] = \nif n < 10 || []\nthen [sumList (digitsOfInt n); i]\nelse [sumList (digitsOfInt n); 1+1]"}
{"fix": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  hd :: listReverse tl", "bad": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> tl :: listReverse hd", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> []\n| hd::tl -> tl :: listReverse hd"}
{"fix": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  hd :: listReverse tl", "bad": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  listReverse tl :: hd", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> []\n| hd::tl ->  listReverse tl :: hd"}
{"fix": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  (listReverse tl) @ hd", "bad": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  (listReverse tl) :: hd", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> []\n| hd::tl ->  (listReverse tl) :: hd"}
{"fix": "let rec listReverse l = match l with\n| [] -> []\n| _::tl -> listReverse tl", "bad": "let _ = listReverse [1; 2; 3; 4]", "annotated": "let _ = listReverse [1; 2; 3; 4]"}
{"fix": "let rec listReverse l = match l with\n| [] -> []\n| _::tl -> listReverse tl", "bad": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  \nif hd != [] \nthen (listReverse tl) :: hd\nelse hd", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> []\n| hd::tl ->  \nif hd != [] \nthen (listReverse tl) :: hd\nelse hd"}
{"fix": "let rec last l = match l with \n| x::[] -> x\n| hd::tl -> last tl \n| [] -> failwith \"NO ELEMENT\"", "bad": "let rec listReverse l = match l with\n| [] -> []\n| _ -> let x = last tl", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> []\n| _ -> let x = last tl"}
{"fix": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse (hd::l)", "bad": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> let x = last l", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> []\n| hd::tl -> let x = last l"}
{"fix": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse (hd::l)", "bad": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> let x = last l in\nif x > 0\nthen x\nelse x", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> []\n| hd::tl -> let x = last l in\nif x > 0\nthen x\nelse x"}
{"fix": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse (hd::l)", "bad": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> let x = last l in\nif x > 0\nthen x::x\nelse x::x", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> []\n| hd::tl -> let x = last l in\nif x > 0\nthen x::x\nelse x::x"}
{"fix": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse (hd::l)", "bad": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse(hd::l) tl", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> []\n| hd::tl -> listReverse(hd::l) tl"}
{"fix": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl @ hd", "bad": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl @ hd", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> []\n| hd::tl -> listReverse tl @ hd"}
{"fix": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl @ [hd]", "bad": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl :: [hd]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> []\n| hd::tl -> listReverse tl :: [hd]"}
{"fix": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl @ [hd]", "bad": "let _ = listReverse [1; 2; 3; 4]", "annotated": "let _ = listReverse [1; 2; 3; 4]"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl @ [hd]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> []\n| hd::tl -> listReverse tl @ [hd]"}
{"fix": "let _ = palindrome \"malayalam\"", "bad": "let palindrome w = \nif explode w = listReverse (explode w)\nthen true\nelse false", "annotated": "let palindrome : string -> bool = fun  w  ->  \nif explode w = listReverse (explode w)\nthen true\nelse false"}
{"fix": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "bad": "let rec listReverse l = \nfailwith \"err\"", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nfailwith \"err\""}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l = match l with \n| [] -> 0\n| hd::tl -> listReverse tl", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with \n| [] -> 0\n| hd::tl -> listReverse tl"}
{"fix": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "bad": "let rec digitsOfInt n = \nlistReverse reversed n", "annotated": "let rec digitsOfInt n = \nlistReverse reversed n"}
{"fix": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "bad": "let _ = digitsOfInt 3124", "annotated": "let _ = digitsOfInt 3124"}
{"fix": "let fixpoint (f,b) = \nwwhile (f,b)", "bad": "let fixpoint (f,b) = \nlet b' = f b in\nif b'=b then\nb\nelse \nfixpoint (f,b')", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet b' = f b in\nif b'=b then\nb\nelse \nfixpoint (f,b')"}
{"fix": "let fixpoint (f,b) = \nlet f b = (f b, b=f b) in\nwwhile (f,b)", "bad": "let fixpoint (f,b) = \nlet b' = (b, (f b = b)) in \nwwhile (f,b')", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet b' = (b, (f b = b)) in \nwwhile (f,b')"}
{"fix": "let fixpoint (f,b) = \nlet f b = (f b, b=f b) in\nwwhile (f,b)", "bad": "let fixpoint (f,b) = \nlet b' = (b, (f b < b)) in \nwwhile (f,b')", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet b' = (b, (f b < b)) in \nwwhile (f,b')"}
{"fix": "let fixpoint (f,b) = \nlet f b = (f b, b=f b) in\nwwhile (f,b)", "bad": "let fixpoint (f,b) = \nlet f' = (f b, f'=b ) in\nwwhile (f',b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet f' = (f b, f'=b ) in\nwwhile (f',b)"}
{"fix": "let fixpoint (f,b) = \nlet f b = (f b, b=f b) in\nwwhile (f,b)", "bad": "let fixpoint (f,b) = \nlet f' = (f b, f b=b ) in\nwwhile (f',b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet f' = (f b, f b=b ) in\nwwhile (f',b)"}
{"fix": "let fixpoint (f,b) = \nlet f b = (f b, b=f b) in\nwwhile (f,b)", "bad": "let fixpoint (f,b) = \nlet f b = (f b, b=f b) in\nwwhile (f,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet f b = (f b, b=f b) in\nwwhile (f,b)"}
{"fix": "let fixpoint (f,b) =\nlet f b = (f b, f b = b) in\nwwhile (f, b)", "bad": "let fixpoint (f,b) = \nlet f' = f b -> (f b, b=f b) in\nwwhile(f',b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet f' = f b -> (f b, b=f b) in\nwwhile(f',b)"}
{"fix": "let fixpoint (f,b) =\nlet f b = (f b, f b = b) in\nwwhile (f, b)", "bad": "let fixpoint (f,b) = \nlet f' = fun f -> fun b -> (f b, b=f b) in\nwwhile(f',b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet f' = fun f -> fun b -> (f b, b=f b) in\nwwhile(f',b)"}
{"fix": "let fixpoint (f,b) =\nlet f b = (f b, f b = b) in\nwwhile (f, b)", "bad": "let fixpoint (f,b) =\nfailwith \"to be d\"", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nfailwith \"to be d\""}
{"fix": "let fixpoint (f,b) =\nlet f b = let b' = f b in b=b' in b'", "bad": "let fixpoint (f,b) =\nlet f b = let b' = f b in b=b'", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nlet f b = let b' = f b in b=b'"}
{"fix": "let fixpoint (f,b) =\nlet f b = let b' = f b in b=b' in b'", "bad": "let fixpoint (f,b) =\nlet f b = let b' = f b in b=b' in\n\nlet g x = (x-1) in fixpoint (g,8)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nlet f b = let b' = f b in b=b' in\n\nlet g x = (x-1) in fixpoint (g,8)"}
{"fix": "let b = exprToString Sine(VarX)", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin\"^ exprToString m", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin\"^ exprToString m"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"", "bad": "let b = exprToString (Sine(VarX))", "annotated": "let b = exprToString (Sine(VarX))"}
{"fix": "let b = exprToString (Cosine(VarX))", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m -> \"cos(\" ^ exprToString m ^ \")\"\n| Average (m,n) -> \"((\" ^ exprToStirng m ^ \"+\" ^ exprToString n ^ \")/2)\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m -> \"cos(\" ^ exprToString m ^ \")\"\n| Average (m,n) -> \"((\" ^ exprToStirng m ^ \"+\" ^ exprToString n ^ \")/2)\""}
{"fix": "let b = exprToString (Cosine(VarX))", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m -> \"cos(\" ^ exprToString m ^ \")\"\n| Average (m,n) -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m -> \"cos(\" ^ exprToString m ^ \")\"\n| Average (m,n) -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\""}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m -> \"cos(\" ^ exprToString m ^ \")\"\n| Average (m,n) -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n) -> exprToString m ^ \"*\" ^ exprToString n\n| Tresh (m,n,o,p) -> \n\"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^exprToString o^\":\"^exprToString p", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m -> \"cos(\" ^ exprToString m ^ \")\"\n| Average (m,n) -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n) -> exprToString m ^ \"*\" ^ exprToString n", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m -> \"cos(\" ^ exprToString m ^ \")\"\n| Average (m,n) -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n) -> exprToString m ^ \"*\" ^ exprToString n"}
{"fix": "let b = exprToString (Average(Cosine(VarX),VarY))", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m -> \"cos(\" ^ exprToString m ^ \")\"\n| Average (m,n) -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n) -> exprToString m ^ \"*\" ^ exprToString n\n| Thresh (m,n,o,p) -> \n\"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^exprToString o^\":\"^exprToString p", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine m -> \"sin(\"^ exprToString m ^ \")\"\n| Cosine m -> \"cos(\" ^ exprToString m ^ \")\"\n| Average (m,n) -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n) -> exprToString m ^ \"*\" ^ exprToString n\n| Thresh (m,n,o,p) -> \n\"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^exprToString o^\":\"^exprToString p"}
{"fix": "let _ = eval(Sine,0.5,0.)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| Sine m -> sin(pi*. (eval m))\n| _ -> x", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| Sine m -> sin(pi*. (eval m))\n| _ -> x"}
{"fix": "let _ = eval(Sine,0.5,0.)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| _ -> x", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| _ -> x"}
{"fix": "let _ = eval((Sine(VarX)),0.3,0.)", "bad": "let _ = eval((Sine(VarX)),0.5,0.)", "annotated": "let _ = eval((Sine(VarX)),0.5,0.)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m, n) -> eval(m,x,y) *. eval(n,x,y)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y)+.eval (n,x,y))/2.", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y)+.eval (n,x,y))/2."}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m, n) -> eval(m,x,y) *. eval(n,x,y)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y))/2.", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y))/2."}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m, n) -> eval(m,x,y) *. eval(n,x,y)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2."}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| Thresh (m,n,o,p) -> \neval (m,x,y) < eval (n,x,y) ? eval (o,x,y) : eval (p,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| Thresh (m,n,o,p) -> \neval (m,x,y) < eval (n,x,y) ? eval (o,x,y) : eval (p,x,y)"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)"}
{"fix": "let rec build (rand, depth) = rand", "bad": "let rec build (rand, depth) = rand 1 2", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  rand 1 2"}
{"fix": "let rec build (rand, depth) = let num = rand 4 53 in\nmatch num with\n| _ -> VarX", "bad": "let rec build (rand, depth) = rand 3 4", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  rand 3 4"}
{"fix": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num = rand in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))", "bad": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num = rand in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nif depth = 0\nthen\nlet num = rand in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"}
{"fix": "let rec assoc (d,k,l) = match l with \n| []         -> d\n| (ki,vi)::t -> \nif ki=k\nthen vi\nelse assoc (d,k,t)", "bad": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "annotated": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}
{"fix": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet nums (a,b) = rand in\nlet num = rand in \nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet nums (a,b) = rand in\nlet num = rand in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))", "bad": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet nums (a,b) = rand in\nlet num = rand in \nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet nums (a,b) = rand in\nlet num = rand in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nif depth = 0\nthen\nlet nums (a,b) = rand in\nlet num = rand in \nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet nums (a,b) = rand in\nlet num = rand in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"}
{"fix": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))", "bad": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> Sine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"}
{"fix": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> buildSine(build(rand,depth-1))\n| _ -> buildCosine(build(rand,depth-1))", "bad": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> buildSine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> buildSine(build(rand,depth-1))\n| _ -> Cosine(build(rand,depth-1))"}
{"fix": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 2 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildCosine(build(rand,depth-1))", "bad": "let rec build (rand, depth) =\nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 2 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildCosine(build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nif depth = 0\nthen\nlet num  = rand (0, 2) in\nmatch num with\n| 0 -> VarX\n| _ -> VarY\nelse\nlet num = rand (0, 5) in\nmatch num with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 2 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildCosine(build(rand,depth-1))"}
{"fix": "let _ = exprToString(Divide(Divide(VarX,VarY),VarX))", "bad": "let _ = exprToString(Divide(VarX,VarY))", "annotated": "let _ = exprToString(Divide(VarX,VarY))"}
{"fix": "let _ = eval (Square(VarX),1.0,0.5)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Square m -> eval(m,x,y)**2\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Square m -> eval(m,x,y)**2\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)"}
{"fix": "let _ = eval (Square(VarX),1.0,0.5)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Square m -> eval(m,x,y)**2.0\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Square m -> eval(m,x,y)**2.0\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)"}
{"fix": "let rec exprToString e = match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine m           -> \"sin(pi*\"^ exprToString m ^ \")\"\n| Cosine m         -> \"cos(pi*\" ^ exprToString m ^ \")\"\n| Square m         -> \"(\" ^ exprToString m ^ \"^2)\"\n| Average (m,n)    -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n)      -> exprToString m ^ \"*\" ^ exprToString n\n| MyExpr (m,n,o)   -> \"(\" ^ exprToString m ^ \"<\" ^ exprToString n ^\"?sqrt(|\" ^\nexprToString o ^ \"|)\" ^ \":\" ^ \"(\" ^ exprToString o ^ \n\"/2)\"\n| Thresh (m,n,o,p) -> \"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^\nexprToString o^\":\"^exprToString p^\")\"", "bad": "let rec exprToString e = match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine m           -> \"sin(pi*\"^ exprToString m ^ \")\"\n| Cosine m         -> \"cos(pi*\" ^ exprToString m ^ \")\"\n| Square m         -> \"(\" ^ exprToString m ^ \"^2)\"\n| Average (m,n)    -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n)      -> exprToString m ^ \"*\" ^ exprToString n\n| MyExpr (m,n,o)   -> \"(\" ^ exprToString m ^ \"<\" ^ expToString  ^\"?sqrt(|\" ^\nexprToString o ^ \"|)\" ^ \":\" ^ \"(\" ^ exprToString o ^ \n\"/2)\"\n| Thresh (m,n,o,p) -> \"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^\nexprToString o^\":\"^exprToString p^\")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine m           -> \"sin(pi*\"^ exprToString m ^ \")\"\n| Cosine m         -> \"cos(pi*\" ^ exprToString m ^ \")\"\n| Square m         -> \"(\" ^ exprToString m ^ \"^2)\"\n| Average (m,n)    -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n)      -> exprToString m ^ \"*\" ^ exprToString n\n| MyExpr (m,n,o)   -> \"(\" ^ exprToString m ^ \"<\" ^ expToString  ^\"?sqrt(|\" ^\nexprToString o ^ \"|)\" ^ \":\" ^ \"(\" ^ exprToString o ^ \n\"/2)\"\n| Thresh (m,n,o,p) -> \"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^\nexprToString o^\":\"^exprToString p^\")\""}
{"fix": "let rec exprToString e = match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine m           -> \"sin(pi*\"^ exprToString m ^ \")\"\n| Cosine m         -> \"cos(pi*\" ^ exprToString m ^ \")\"\n| Square m         -> \"(\" ^ exprToString m ^ \"^2)\"\n| Average (m,n)    -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n)      -> exprToString m ^ \"*\" ^ exprToString n\n| MyExpr (m,n,o)   -> \"(\" ^ exprToString m ^ \"<\" ^ exprToString n ^\"?sqrt(|\" ^\nexprToString o ^ \"|)\" ^ \":\" ^ \"(\" ^ exprToString o ^ \n\"/2)\"\n| Thresh (m,n,o,p) -> \"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^\nexprToString o^\":\"^exprToString p^\")\"", "bad": "let _ = expToString(MyExpr(VarX,VarY,VarX))", "annotated": "let _ = expToString(MyExpr(VarX,VarY,VarX))"}
{"fix": "let rec exprToString e = match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine m           -> \"sin(pi*\"^ exprToString m ^ \")\"\n| Cosine m         -> \"cos(pi*\" ^ exprToString m ^ \")\"\n| Square m         -> \"(\" ^ exprToString m ^ \"^2)\"\n| Average (m,n)    -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n)      -> exprToString m ^ \"*\" ^ exprToString n\n| MyExpr (m,n,o)   -> \"(\" ^ exprToString m ^ \"<\" ^ exprToString n ^\"?sqrt(|\" ^\nexprToString o ^ \"|)\" ^ \":\" ^ \"(\" ^ exprToString o ^ \n\"/2)\"\n| Thresh (m,n,o,p) -> \"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^\nexprToString o^\":\"^exprToString p^\")\"", "bad": "let rec exprToString e = match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine m           -> \"sin(pi*\"^ exprToString m ^ \")\"\n| Cosine m         -> \"cos(pi*\" ^ exprToString m ^ \")\"\n| Square m         -> \"(\" ^ exprToString m ^ \"^2)\"\n| Average (m,n)    -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n)      -> exprToString m ^ \"*\" ^ exprToString n\n| MyExpr (m,n,o)   -> \"(\" ^ exprToString m ^ \"<\" ^ exprToString  ^\"?sqrt(|\" ^\nexprToString o ^ \"|)\" ^ \":\" ^ \"(\" ^ exprToString o ^ \n\"/2)\"\n| Thresh (m,n,o,p) -> \"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^\nexprToString o^\":\"^exprToString p^\")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine m           -> \"sin(pi*\"^ exprToString m ^ \")\"\n| Cosine m         -> \"cos(pi*\" ^ exprToString m ^ \")\"\n| Square m         -> \"(\" ^ exprToString m ^ \"^2)\"\n| Average (m,n)    -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n)      -> exprToString m ^ \"*\" ^ exprToString n\n| MyExpr (m,n,o)   -> \"(\" ^ exprToString m ^ \"<\" ^ exprToString  ^\"?sqrt(|\" ^\nexprToString o ^ \"|)\" ^ \":\" ^ \"(\" ^ exprToString o ^ \n\"/2)\"\n| Thresh (m,n,o,p) -> \"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^\nexprToString o^\":\"^exprToString p^\")\""}
{"fix": "let rec exprToString e = match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine m           -> \"sin(pi*\"^ exprToString m ^ \")\"\n| Cosine m         -> \"cos(pi*\" ^ exprToString m ^ \")\"\n| Square m         -> \"(\" ^ exprToString m ^ \"^2)\"\n| Average (m,n)    -> \"((\" ^ exprToString m ^ \"+\" ^ exprToString n ^ \")/2)\"\n| Times (m,n)      -> exprToString m ^ \"*\" ^ exprToString n\n| MyExpr (m,n,o)   -> \"(\" ^ exprToString m ^ \"<\" ^ exprToString n ^\"?sqrt(|\" ^\nexprToString o ^ \"|)\" ^ \":\" ^ \"(\" ^ exprToString o ^ \n\"/2)\"\n| Thresh (m,n,o,p) -> \"(\" ^ exprToString m^ \"<\" ^exprToString n^\"?\"^\nexprToString o^\":\"^exprToString p^\")\"", "bad": "let _ = exprToString(MyExpr(VarX,VarY,VarX))", "annotated": "let _ = exprToString(MyExpr(VarX,VarY,VarX))"}
{"fix": "let _ = eval (MyExpr(VarX,VarY,VarX),1.0, 2.0)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Square m -> eval(m,x,y)**2.0\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| MyExpr(m,n,o) -> \nif eval(m,x,y) < eval (n,x,y)\nthen sqrt(abs_float(eval(o,x,y)))\nelse eval(o,x,y) /. 2.\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine m -> sin(pi*. (eval (m,x,y)))\n| Cosine m -> cos(pi*. (eval (m,x,y)))\n| Square m -> eval(m,x,y)**2.0\n| Average (m,n) -> (eval (m,x,y) +. eval (n,x,y)) /. 2.\n| Times (m,n) -> eval(m,x,y) *. eval(n,x,y)\n| MyExpr(m,n,o) -> \nif eval(m,x,y) < eval (n,x,y)\nthen sqrt(abs_float(eval(o,x,y)))\nelse eval(o,x,y) /. 2.\n| Thresh (m,n,o,p) -> \nif eval (m,x,y) < eval (n,x,y) \nthen eval (o,x,y)\nelse eval (p,x,y)"}
{"fix": "let _ = eval (sampleExpr,0.5,0.2)", "bad": "let _ = eval (sampleExpr1,0.5,0.2)", "annotated": "let _ = eval (sampleExpr1,0.5,0.2)"}
{"fix": "let rec sumList xs = match xs with\nh :: t -> h + sumList t\n| [] -> 0", "bad": "let rec sumList [xs] =", "annotated": "let rec sumList : int list -> int = fun  [xs]  -> "}
{"fix": "let rec sumList xs = match xs with\nh :: t -> h + sumList t\n| [] -> 0", "bad": "let rec sumList xs[] =", "annotated": "let rec sumList : int list -> int = fun  xs[]  -> "}
{"fix": "let rec sumList xs = match xs with\nh :: t -> h + sumList t\n| [] -> 0", "bad": "let rec sumList xs = (* failwith \"TBD:sumList\" *) \n\nlet _ = sumList [1; 2; 3; 4]", "annotated": "let rec sumList : int list -> int = fun  xs  ->  (* failwith \"TBD:sumList\" *) \n\nlet _ = sumList [1; 2; 3; 4]"}
{"fix": "let _ = digitsOfInt (-352663)", "bad": "let _ = digitsOfInt -352663", "annotated": "let _ = digitsOfInt -352663"}
{"fix": "let rec digits n = digitsOfInt (abs n)", "bad": "let rec digits n = digitsOfInt (abs n)\n\ndigits (-124074)", "annotated": "let rec digits n = digitsOfInt (abs n)\n\ndigits (-124074)"}
{"fix": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "bad": "let rec assoc (d,k,l) = \nlet temp = l in\nlet rec helper acc (d,k,l) = \nmatch temp with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper (d,k,l) t\nin helper (d,k,l) acc", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  \nlet temp = l in\nlet rec helper acc (d,k,l) = \nmatch temp with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper (d,k,l) t\nin helper (d,k,l) acc"}
{"fix": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "bad": "uncomment after implementing assoc", "annotated": "uncomment after implementing assoc"}
{"fix": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "bad": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "bad": "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "bad": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper (d,k,l) acc", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper (d,k,l) acc"}
{"fix": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "bad": "uncomment after implementing assoc", "annotated": "uncomment after implementing assoc"}
{"fix": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "bad": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "bad": "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen)\nthen \nseen\nelse \nh :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "et _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "annotated": "et _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen)\nthen \nseen\nelse \nh :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "annotated": "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"}
{"fix": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\n| Cube     of expr\n| Addition of expr * expr", "bad": "let rec exprToString e = \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin(pi*\" ^ (exprToString a) ^ \")\"\n| Cosine a -> \"cos(pi*\" ^ (exprToString a) ^ \")\"\n| Average (a,b) -> \"((\" ^ (exprToString a) ^ \"+\" ^ (exprToString b) ^ \")/2)\"\n| Times (a,b) -> (exprToString a) ^ \"*\" ^ (exprToString b)\n| Thresh (a,b,c,d) -> \"(\" ^ (exprToString a) ^ \"<\" ^ (exprToString b) ^ \"?\" ^ (exprToString c) ^ \":\" ^ (exprToString d) ^ \")\"\n| _ -> \"_\"\n| Cube a -> \"(\" ^ (exprToString a) ^ \"*\" ^ (exprToString a) ^ \"*\" ^ (exprToString a) ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin(pi*\" ^ (exprToString a) ^ \")\"\n| Cosine a -> \"cos(pi*\" ^ (exprToString a) ^ \")\"\n| Average (a,b) -> \"((\" ^ (exprToString a) ^ \"+\" ^ (exprToString b) ^ \")/2)\"\n| Times (a,b) -> (exprToString a) ^ \"*\" ^ (exprToString b)\n| Thresh (a,b,c,d) -> \"(\" ^ (exprToString a) ^ \"<\" ^ (exprToString b) ^ \"?\" ^ (exprToString c) ^ \":\" ^ (exprToString d) ^ \")\"\n| _ -> \"_\"\n| Cube a -> \"(\" ^ (exprToString a) ^ \"*\" ^ (exprToString a) ^ \"*\" ^ (exprToString a) ^ \")\""}
{"fix": "let rec eval (e,x,y) = \nmatch e with\nVarX -> x\n| VarY -> y\n| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )\n| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )\n| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)\n| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )\n| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))\nthen (eval (c,x,y))\nelse (eval (d,x,y))\n| Cube a -> (eval (a,x,y) ) *. (eval  (a,x,y) ) *. (eval (a,x,y) )\n| Addition (a,b) -> eval(a,x,y) +. eval", "bad": "let rec eval (e,x,y) = \nmatch e with\nVarX -> x\n| VarY -> y\n| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )\n| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )\n| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)\n| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )\n| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))\nthen (eval (c,x,y))\nelse (eval (d,x,y))\n| Cube a -> (eval a) * (eval  a) *(eval a)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with\nVarX -> x\n| VarY -> y\n| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )\n| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )\n| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)\n| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )\n| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))\nthen (eval (c,x,y))\nelse (eval (d,x,y))\n| Cube a -> (eval a) * (eval  a) *(eval a)"}
{"fix": "let rec eval (e,x,y) = \nmatch e with\nVarX -> x\n| VarY -> y\n| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )\n| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )\n| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)\n| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )\n| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))\nthen (eval (c,x,y))\nelse (eval (d,x,y))\n| Cube a -> (eval (a,x,y) ) *. (eval  (a,x,y) ) *. (eval (a,x,y) )\n| Addition (a,b) -> eval(a,x,y) +. eval", "bad": "let rec eval (e,x,y) = \nmatch e with\nVarX -> x\n| VarY -> y\n| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )\n| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )\n| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)\n| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )\n| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))\nthen (eval (c,x,y))\nelse (eval (d,x,y))\n| Cube a -> (eval (a,x,y) ) * (eval  (a,x,y) ) * (eval (a,x,y) )", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with\nVarX -> x\n| VarY -> y\n| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )\n| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )\n| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)\n| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )\n| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))\nthen (eval (c,x,y))\nelse (eval (d,x,y))\n| Cube a -> (eval (a,x,y) ) * (eval  (a,x,y) ) * (eval (a,x,y) )"}
{"fix": "let rec eval (e,x,y) = \nmatch e with\nVarX -> x\n| VarY -> y\n| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )\n| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )\n| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)\n| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )\n| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))\nthen (eval (c,x,y))\nelse (eval (d,x,y))\n| Cube a -> (eval (a,x,y) ) *. (eval  (a,x,y) ) *. (eval (a,x,y) )\n| Addition (a,b) -> eval(a,x,y) +. eval", "bad": "let rec eval (e,x,y) = \nmatch e with\nVarX -> x\n| VarY -> y\n| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )\n| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )\n| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)\n| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )\n| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))\nthen (eval (c,x,y))\nelse (eval (d,x,y))\n| Cube a -> (eval (a,x,y) ) *. (eval  (a,x,y) ) *. (eval (a,x,y) )", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with\nVarX -> x\n| VarY -> y\n| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )\n| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )\n| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)\n| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )\n| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))\nthen (eval (c,x,y))\nelse (eval (d,x,y))\n| Cube a -> (eval (a,x,y) ) *. (eval  (a,x,y) ) *. (eval (a,x,y) )"}
{"fix": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "bad": "let rec build (rand,depth) =\nif depth = 0 \nthen\nmatch rand(1,3) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse \nmatch rand(1,10) with\n| 3 -> buildSine( build(rand,depth-1) ) \n| 4 -> buildCosine( build(rand,depth-1) )\n| 5 -> buildAverage( (build(rand,depth-1)), build(rand,depth-1) )\n| 6 -> buildTimes( (build(rand,depth-1)), build(rand,depth-1) )\n| 7 -> buildThresh( build(rand,depth-1), build(rand,depth-1), build(rand,depth-1), build(rand,depth-1) )\n| 8 -> buildCube( build(rand,depth-1) )\n| 9 -> buildAddition ( build(rand,depth-1),  build(rand,depth-1) )\n| _ -> build(rand,depth)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand,depth)  -> \nif depth = 0 \nthen\nmatch rand(1,3) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse \nmatch rand(1,10) with\n| 3 -> buildSine( build(rand,depth-1) ) \n| 4 -> buildCosine( build(rand,depth-1) )\n| 5 -> buildAverage( (build(rand,depth-1)), build(rand,depth-1) )\n| 6 -> buildTimes( (build(rand,depth-1)), build(rand,depth-1) )\n| 7 -> buildThresh( build(rand,depth-1), build(rand,depth-1), build(rand,depth-1), build(rand,depth-1) )\n| 8 -> buildCube( build(rand,depth-1) )\n| 9 -> buildAddition ( build(rand,depth-1),  build(rand,depth-1) )\n| _ -> build(rand,depth)"}
{"fix": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\n| Tan      of expr\n| Sin_Avg  of expr * expr * expr", "bad": "let rec exprToString e = \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin(pi*\" ^ (exprToString a) ^ \")\"\n| Cosine a -> \"cos(pi*\" ^ (exprToString a) ^ \")\"\n| Average (a,b) -> \"((\" ^ (exprToString a) ^ \"+\" ^ (exprToString b) ^ \")/2)\"\n| Times (a,b) -> (exprToString a) ^ \"*\" ^ (exprToString b)\n| Thresh (a,b,c,d) -> \"(\" ^ (exprToString a) ^ \"<\" ^ (exprToString b) ^ \"?\" ^ (exprToString c) ^ \":\" ^ (exprToString d) ^ \")\"\n| _ -> \"_\"\n| Tan a -> \"tan(pi*\" ^ (exprToString a) ^ \")\"\n| Arc (a,b,c) -> \"sin(pi*\" ^ (exprToString (a (b,c)) ) ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin(pi*\" ^ (exprToString a) ^ \")\"\n| Cosine a -> \"cos(pi*\" ^ (exprToString a) ^ \")\"\n| Average (a,b) -> \"((\" ^ (exprToString a) ^ \"+\" ^ (exprToString b) ^ \")/2)\"\n| Times (a,b) -> (exprToString a) ^ \"*\" ^ (exprToString b)\n| Thresh (a,b,c,d) -> \"(\" ^ (exprToString a) ^ \"<\" ^ (exprToString b) ^ \"?\" ^ (exprToString c) ^ \":\" ^ (exprToString d) ^ \")\"\n| _ -> \"_\"\n| Tan a -> \"tan(pi*\" ^ (exprToString a) ^ \")\"\n| Arc (a,b,c) -> \"sin(pi*\" ^ (exprToString (a (b,c)) ) ^ \")\""}
{"fix": "exprToString Sin_Avg(1,2,3)", "bad": "let rec exprToString e = \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin(pi*\" ^ (exprToString a) ^ \")\"\n| Cosine a -> \"cos(pi*\" ^ (exprToString a) ^ \")\"\n| Average (a,b) -> \"((\" ^ (exprToString a) ^ \"+\" ^ (exprToString b) ^ \")/2)\"\n| Times (a,b) -> (exprToString a) ^ \"*\" ^ (exprToString b)\n| Thresh (a,b,c,d) -> \"(\" ^ (exprToString a) ^ \"<\" ^ (exprToString b) ^ \"?\" ^ (exprToString c) ^ \":\" ^ (exprToString d) ^ \")\"\n| _ -> \"_\"\n| Tan a -> \"tan(pi*\" ^ (exprToString a) ^ \")\"\n| Sin_Avg (a,b,c) -> \"sin(pi*(\" ^ (exprToString  a) ^ \"+\" ^ (exprToString  b) ^ (exprToString c) ^ \")/3)\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin(pi*\" ^ (exprToString a) ^ \")\"\n| Cosine a -> \"cos(pi*\" ^ (exprToString a) ^ \")\"\n| Average (a,b) -> \"((\" ^ (exprToString a) ^ \"+\" ^ (exprToString b) ^ \")/2)\"\n| Times (a,b) -> (exprToString a) ^ \"*\" ^ (exprToString b)\n| Thresh (a,b,c,d) -> \"(\" ^ (exprToString a) ^ \"<\" ^ (exprToString b) ^ \"?\" ^ (exprToString c) ^ \":\" ^ (exprToString d) ^ \")\"\n| _ -> \"_\"\n| Tan a -> \"tan(pi*\" ^ (exprToString a) ^ \")\"\n| Sin_Avg (a,b,c) -> \"sin(pi*(\" ^ (exprToString  a) ^ \"+\" ^ (exprToString  b) ^ (exprToString c) ^ \")/3)\""}
{"fix": "exprToString (Tan VarX)", "bad": "exprToString (Sin_Avg (VarX, VarY, VarX))", "annotated": "exprToString (Sin_Avg (VarX, VarY, VarX))"}
{"fix": "let rec sqsum xs = \nmatch xs with\n[] -> 0\n| h::t -> (h*h) + (sqsum t)", "bad": "let rec sqsum xs = \nmatch xs with\n[] -> []\n| h::t -> (h*h) + (sqsum t)", "annotated": "let rec sqsum : int list -> int  = fun  xs  ->  \nmatch xs with\n[] -> []\n| h::t -> (h*h) + (sqsum t)"}
{"fix": "let sqsum xs = \nlet f a x = (a*a) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = (a*a) in\nlet base = [] in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = (a*a) in\nlet base = [] in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = a + 1 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a + (x*x) in\nlet base = a + 1 in\nList.fold_left f base xs"}
{"fix": "let pipe fs = \nlet f a x = a + x in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = match a with\n[] -> x\n| h::t -> h x in \nlet base = fs in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = match a with\n[] -> x\n| h::t -> h x in \nlet base = fs in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = a + x in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = match a with\n[] -> x\n| h::t -> h x in \nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = match a with\n[] -> x\n| h::t -> h x in \nlet base = 0 in\nList.fold_left f base fs"}
{"fix": "let _ = pipe []", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = match a with\n[] -> []\n| h::t -> h::[] in\nlet base = [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = match a with\n[] -> []\n| h::t -> (h x) \nin\nlet base = 3 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = match a with\n[] -> []\n| h::t -> (h x) \nin\nlet base = 3 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = match a with\n[] -> []\n| h::t -> h::[] in\nlet base = [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = match a with\n[] -> x\n| h::t -> (h x) in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = match a with\n[] -> x\n| h::t -> (h x) in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base fs"}
{"fix": "let _ = pipe [fun x -> x*x] 3", "bad": "let _ = pipe [fun x -> x; fun x -> x*x] 3", "annotated": "let _ = pipe [fun x -> x; fun x -> x*x] 3"}
{"fix": "let pipe fs = \nlet f a x = (fun x -> x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let _ = pipe [(fun x -> x + 1); (fun x -> x*x)] 3", "bad": "let _ = pipe [fun x -> x + 1; fun x -> x*x] 3", "annotated": "let _ = pipe [fun x -> x + 1; fun x -> x*x] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x*x); (fun x -> x + 1)] 3", "annotated": "let _ = pipe [(fun x -> x*x); (fun x -> x + 1)] 3"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ \" \" ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ \" \" x in\nlet base = [] in\nlet l = t in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ \" \" x in\nlet base = [] in\nlet l = t in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ \" \" ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ \" \" ^ x in\nlet base = [] in\nlet l = t in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ \" \" ^ x in\nlet base = [] in\nlet l = t in\nList.fold_left f base l"}
{"fix": "let stringOfList f l = sepConcat (f l)", "bad": "let stringOfList f l = ssepConcat (f l)", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  ssepConcat (f l)"}
{"fix": "let stringOfList f l = List.map f l", "bad": "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "annotated": "let _ = stringOfList string_of_int [1;2;3;4;5;6]"}
{"fix": "let stringOfList f l = List.map f l", "bad": "let _ = stringOfList (fun x -> x) [\"foo\"]", "annotated": "let _ = stringOfList (fun x -> x) [\"foo\"]"}
{"fix": "let stringOfList f l = List.map f l", "bad": "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "annotated": "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"}
{"fix": "let stringOfList f l = \"[\" ^ ( sepConcat \";\" (List.map f l) ) ^ \"]\"", "bad": "let stringOfList f l = List.map f (sepConcat l)", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map f (sepConcat l)"}
{"fix": "let stringOfList f l = \"[\" ^ ( sepConcat \";\" (List.map f l) ) ^ \"]\"", "bad": "let stringOfList f l = \"[\" ^ sepConcat ^ \";\" ^ List.map f l ^ \"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\" ^ sepConcat ^ \";\" ^ List.map f l ^ \"]\""}
{"fix": "let stringOfList f l = \"[\" ^ ( sepConcat \";\" (List.map f l) ) ^ \"]\"", "bad": "let stringOfList f l = \"[\" ^ (sepConcat \";\" List.map f l) ^ \"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\" ^ (sepConcat \";\" List.map f l) ^ \"]\""}
{"fix": "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "bad": "let _ = stringOfList float_of_int [1;2;3;4;5;6]", "annotated": "let _ = stringOfList float_of_int [1;2;3;4;5;6]"}
{"fix": "let rec clone x n = let i = 0 in\nif i < n\nthen x :: ( clone x (n-1) )\nelse []", "bad": "let rec clone x n = let i = 0 in\nif i < n\nthen x :: (clone x n-1)\nelse []", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n = let i  ->  0 in\nif i < n\nthen x :: (clone x n-1)\nelse []"}
{"fix": "let rec clone x n = let i = 0 in\nif i < n\nthen x :: ( clone x (n-1) )\nelse []", "bad": "let rec clone x n = let i = 0 in\nif i < n\nthen (clone x n-1) :: x :: []\nelse []", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n = let i  ->  0 in\nif i < n\nthen (clone x n-1) :: x :: []\nelse []"}
{"fix": "let padZero l1 l2 = if List.length l1 < List.length l2\nthen true\nelse false", "bad": "let padZero l1 l2 = let length_diff = (List.length l1 - List.length l2) in \nif length_diff < 0\nthen \nlength_diff = (List.length l1 - List.length l2)\nelse \nlength_diff", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let length_diff  ->  (List.length l1 - List.length l2) in \nif length_diff < 0\nthen \nlength_diff = (List.length l1 - List.length l2)\nelse \nlength_diff"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let pipe fs = \nlet f a x = (fun x a -> x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let _ = pipe [fun x -> x + 3] 3", "annotated": "let _ = pipe [fun x -> x + 3] 3"}
{"fix": "let pipe fs = \nlet f a x = (fun x a -> x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (fun x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (fun x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (fun x a -> x a) x a in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = (fun y -> x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (fun -> x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (fun -> x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (fun x a -> x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (fun a x -> x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (fun a x -> x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =  (fun x -> x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = function x a  in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = function x a  in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =  (fun x -> x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = function x  in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = function x  in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =  (x (a) ) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let rec mulByDigit i l = \nmatch l with\n| []   -> 0\n| h::t -> h*i", "bad": "let rec mulByDigit i l = \nmatch l with\n| []   -> []\n| h::t -> h*i", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nmatch l with\n| []   -> []\n| h::t -> h*i"}
{"fix": "let rec mulByDigit i l = \nmatch l with\n| []   -> 0\n| h::t -> h*i", "bad": "let _ = mulByDigit 9 [9;9;9;9]", "annotated": "let _ = mulByDigit 9 [9;9;9;9]"}
{"fix": "let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::m::t -> (mulByDigit m::t) @ ( (h*i)/10 ) + (m*i) mod 10 :: ( (h*i) mod 10 ) :: []", "bad": "let rec mulByDigit i l = \nmatch (List.rev l) with\n| []   -> []\n| h::m::t -> (mulByDigit m::t) :: ( (h*i)/10 ) + (m*i) mod 10 :: ( (h*i) mod 10 ) :: []", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nmatch (List.rev l) with\n| []   -> []\n| h::m::t -> (mulByDigit m::t) :: ( (h*i)/10 ) + (m*i) mod 10 :: ( (h*i) mod 10 ) :: []"}
{"fix": "List.map (fun x -> x + 1) [1;2;3]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> (h1 + h2, a)\nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> (h1 + h2, a)\nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "List.map (fun x -> x + 1) [1;2;3]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> h1 + h2\nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> h1 + h2\nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "List.map (fun x -> x + 1) [1;2;3]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> h1 + h2\nin\nlet base = 0 in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> h1 + h2\nin\nlet base = 0 in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "List.map (fun x -> x + 1) [1;2;3]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> h1 + h2\nin\nlet base = 0 in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> h1 + h2\nin\nlet base = 0 in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "List.map (fun x -> x + 1) [1;2;3]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> (a, h1 + h2)\nin\nlet base = 0 in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> (a, h1 + h2)\nin\nlet base = 0 in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "List.map (fun x -> x + 1) [1;2;3]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> a\nin\nlet base = 0 in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> a\nin\nlet base = 0 in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "List.map (fun x -> x + 1) [1;2;3]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> match a with (v1,v2) -> (v1+h1+v2+h2)\nin\nlet base = (0,0) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> match a with (v1,v2) -> (v1+h1+v2+h2)\nin\nlet base = (0,0) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "List.map (fun x -> x + 1) [1;2;3]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> match a with (v1,v2) -> (v1+h1, v2+h2)\nin\nlet base = (0,0) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> match a with (v1,v2) -> (v1+h1, v2+h2)\nin\nlet base = (0,0) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "List.map (fun x -> x + 1) [1;2;3]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> match a with (v1,v2) -> [(v1+h1, v2+h2)]\nin\nlet base = (0,0) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n(h1,h2)-> match a with (v1,v2) -> [(v1+h1, v2+h2)]\nin\nlet base = (0,0) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n(list1, list2) -> (list1, list2)\nin\nlet base = ([0],[0]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n(list1, list2) -> list1\nin\nlet base = ([0],[0]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n(list1, list2) -> list1\nin\nlet base = ([0],[0]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([],[]) -> ([],[])\n| (list1, list2) -> (list1, list2)\nin\nlet base = ([0],[0]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n(list1, list2) -> match (list1, list2) with\n[] -> ([], [])\nin\nlet base = ([0],[0]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n(list1, list2) -> match (list1, list2) with\n[] -> ([], [])\nin\nlet base = ([0],[0]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([],[]) -> match x with\n| ([],[]) -> a\n| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([],[]) -> match x with\n| [] -> ([], [])\n| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])\n| (list1, list2) -> ([1], [1])\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| ([],[]) -> match x with\n| [] -> ([], [])\n| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])\n| (list1, list2) -> ([1], [1])\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (lh1::lt1, lh2::lt2) -> (lh1::lt1, lh2::lt2)\n| ([],[]) -> match x with\n| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (lh1::lt1, lh2:;lt2) -> (lh1::lt1, lh2:;lt2)\n| ([],[]) -> match x with\n| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| (lh1::lt1, lh2:;lt2) -> (lh1::lt1, lh2:;lt2)\n| ([],[]) -> match x with\n| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (lh1::lt1, lh2::lt2) -> (lh1::lt1, lh2::lt2)\n| ([],[]) -> match x with\n| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (lh1::lt1, lh2::lt2) -> (lh1::lt1, lh2:;lt2)\n| ([],[]) -> match x with\n| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| (lh1::lt1, lh2::lt2) -> (lh1::lt1, lh2:;lt2)\n| ([],[]) -> match x with\n| (h1,h2) -> ((h1+h2)/10 :: [], (h1+h2) mod 10 :: [])\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(v1,v2) -> match a with\n(h1::t1, h2::t2) -> (v1 :: h1::t1, v2::h2::t2)\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(v1,v2) -> ( ( v1::a), (v2::a) )\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n(v1,v2) -> ( ( v1::a), (v2::a) )\nin\nlet base = ([],[]) in\nlet args = (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigMul l1 l2 = \nlet f a x = match x with\n(v1,v2) -> match a with\n(list1, list2) -> match list1 with\n| [] -> ( (v1*v2)/10::list1, (v1*v2) mod 10::list2 )\n| (h::t) -> (((v1*v2)+h)/10::list1, ((v1*v2)+h) mod 10 :: list2) in\nlet base = ([], []) in\nlet args = List.append (List.rev (List.combine l1 l2))  [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = match x with\n(v1,v2) -> match a with\n(list1, list2) -> match list1 with\n| [] -> ( (v1*v2)/10::list1, (v1*v2) mod 10::list2 )\n| (h::t) -> (((v1*v2)+h)/10::list1, ((v1*v2)+h) mod 10 :: list2) in\nlet base = ([]. []) in\nlet args = List.append (List.rev (List.combine l1 l2))  [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match x with\n(v1,v2) -> match a with\n(list1, list2) -> match list1 with\n| [] -> ( (v1*v2)/10::list1, (v1*v2) mod 10::list2 )\n| (h::t) -> (((v1*v2)+h)/10::list1, ((v1*v2)+h) mod 10 :: list2) in\nlet base = ([]. []) in\nlet args = List.append (List.rev (List.combine l1 l2))  [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let _ = bigAdd [8;1] [8;1;0]", "bad": "let _ = bigAdd [8;1] [8;1;0]\n\nList.map (fun x -> x*10 ) [1;2;3]", "annotated": "let _ = bigAdd [8;1] [8;1;0]\n\nList.map (fun x -> x*10 ) [1;2;3]"}
{"fix": "let _ = bigAdd [0] [81000; 8100; 810; 81]", "bad": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> false\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> []\n| h1::t1 -> let rec helper acc v = [v] = [0]\n(* if v = 0 \nthen \nacc \nelse \nhelper ( (v mod 10) :: acc) (v/10) *)\nin helper [] h1", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match (List.rev l) with\n| []   -> false\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t) ) ) @ h*i :: [] with \n| [] -> []\n| h1::t1 -> let rec helper acc v = [v] = [0]\n(* if v = 0 \nthen \nacc \nelse \nhelper ( (v mod 10) :: acc) (v/10) *)\nin helper [] h1"}
{"fix": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> 0\n| h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i )", "bad": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i ) :: []", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match (List.rev l) with\n| []   -> []\n| h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i ) :: []"}
{"fix": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> 0\n| h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i )", "bad": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i )", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match (List.rev l) with\n| []   -> []\n| h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i )"}
{"fix": "List.map (fun x -> x + 1) [1;2;3]", "bad": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i )", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match (List.rev l) with\n| []   -> []\n| h::t -> ( (mulByDigit i (List.rev t) * 10 ) + h*i )"}
{"fix": "let rec mulByDigit i l = match l with\n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10)\nin helper [] h", "bad": "let rec mulByDigit i l = match l with\n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper (v mod 10)::acc (v/10)\nin helper [] h", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match l with\n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper (v mod 10)::acc (v/10)\nin helper [] h"}
{"fix": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n[] -> []\n| h::t -> [h]\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )", "bad": "let rec mulByDigit i l = match (List.rev l) with\n[] -> int list []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n[] -> int list []\n| h::t -> bigAdd h (adder t)\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match (List.rev l) with\n[] -> int list []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n[] -> int list []\n| h::t -> bigAdd h (adder t)\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )"}
{"fix": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n[] -> []\n| h::t -> [h]\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )", "bad": "let rec mulByDigit i l = match (List.rev l) with\n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n[] -> []\n| h::t -> bigAdd h (adder t)\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match (List.rev l) with\n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n[] -> []\n| h::t -> bigAdd h (adder t)\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )"}
{"fix": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n[] -> []\n| h::t -> [h]\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )", "bad": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n[] -> []\n| h::t -> h\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n[] -> []\n| h::t -> h\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )"}
{"fix": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n| [] -> []\n| h::t -> ( bigAdd h (adder t) )\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )", "bad": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n| [] -> []\n| h::t -> [( bigAdd h (adder t) )]\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nlet rec adder x = match x with\n| [] -> []\n| h::t -> [( bigAdd h (adder t) )]\nin \nadder ( ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) )"}
{"fix": "let pipe fs = \nlet f a x = (x(a)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = (x(a)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = f(x(a)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = f(x(a)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (x(a)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun -> (x(a)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun -> (x(a)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (x(a)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a x -> (x(a)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a x -> (x(a)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}
{"fix": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) \nin ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: [])", "bad": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nmatch ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with\n[] -> []\n| x::y -> let rec adder w = match w with\n| [] -> []\n| a::b -> ( bigAdd a (adder b) )\nin \nadder (h::t)", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nmatch ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with\n[] -> []\n| x::y -> let rec adder w = match w with\n| [] -> []\n| a::b -> ( bigAdd a (adder b) )\nin \nadder (h::t)"}
{"fix": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) \nin\nmatch ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with\n| [] -> []\n| x::y -> let rec adder w = match w with\n| [] -> []\n| a::b -> ( bigAdd a (adder b) )\nin \n[adder (x::y)]", "bad": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) \nin\nmatch ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with\n| [] -> []\n| x::y -> let rec adder w = match w with\n| [] -> []\n| a::b -> ( bigAdd a (adder b) )\nin \nadder (h::t)", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) \nin\nmatch ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with\n| [] -> []\n| x::y -> let rec adder w = match w with\n| [] -> []\n| a::b -> ( bigAdd a (adder b) )\nin \nadder (h::t)"}
{"fix": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) \nin\nmatch ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with\n| [] -> []\n| x::y -> let rec adder w = match w with\n| [] -> []\n| a::b -> ( bigAdd a (adder b) )\nin \n[adder (x::y)]", "bad": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) \nin\nmatch ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with\n| [] -> []\n| x::y -> let rec adder w = match w with\n| [] -> []\n| a::b -> ( bigAdd a (adder b) )\nin \nadder (x::y)", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) \nin\nmatch ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with\n| [] -> []\n| x::y -> let rec adder w = match w with\n| [] -> []\n| a::b -> ( bigAdd a (adder b) )\nin \nadder (x::y)"}
{"fix": "let rec mulByDigit i l = \nmatch l with\n[] -> []\n| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []\nwith \n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen \nacc\nelse \nv mod 10 :: []\nin helper [] h", "bad": "let rec mulByDigit i l = \nmatch l with\n[] -> []\n| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []\nwith \n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen \nacc\nelse \nv mod 10\nin helper [] h", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nmatch l with\n[] -> []\n| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []\nwith \n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen \nacc\nelse \nv mod 10\nin helper [] h"}
{"fix": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin helper [] h", "bad": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> if v = 0\nthen\nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin helper [] h", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  -> \nmatch (List.rev l) with\n| [] -> []\n| h::t -> match (mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [] with\n| [] -> []\n| h::t -> if v = 0\nthen\nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin helper [] h"}
{"fix": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 in\nlet rec helper acc v = \nif v = 0\nthen\nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin helper [] ([List.fold_left f base ((mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [])])", "bad": "let rec mulByDigit i l =\nmatch (List.rev l) with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 in\nlet rec helper acc v = \nif v = 0\nthen\nacc\nelse\nhelper (v mod 10) :: acc (v/10)\nin helper [] ([List.fold_left f base ((mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [])])", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  -> \nmatch (List.rev l) with\n| [] -> []\n| h::t -> \nlet f a x = a + x in\nlet base = 0 in\nlet rec helper acc v = \nif v = 0\nthen\nacc\nelse\nhelper (v mod 10) :: acc (v/10)\nin helper [] ([List.fold_left f base ((mulByDigit i (List.rev (List.map (fun x -> x*10) t))) @ h*i :: [])])"}
{"fix": "let bigMul l1 l2 = \nlet f a x = match x with\n(k,v) -> ([k],v) in \nlet base = ([], [0]) in\nlet args = let rec helper acc l1 l2 = \nmatch l1 with \n| [] -> acc\n| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2\nin helper [] (List.rev l1) l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = match x with\n{k,v} -> ([k],v) in \nlet base = ([], [0]) in\nlet args = let rec helper acc l1 l2 = \nmatch l1 with \n| [] -> acc\n| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2\nin helper [] (List.rev l1) l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match x with\n{k,v} -> ([k],v) in \nlet base = ([], [0]) in\nlet args = let rec helper acc l1 l2 = \nmatch l1 with \n| [] -> acc\n| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2\nin helper [] (List.rev l1) l2\nin\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let somef i l = match (List.rev l) with\n| [] -> []\n| h::t ->\nlet rec helper acc v =  \nif v = 0\nthen \nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin bigAdd (mulByDigit i (List.rev (List.map (fun x -> x*10) t ) )) (helper [] (h*i))", "bad": "let somef i l = match (List.rev l) with\n| [] -> []\n| h::t ->\nlet rec helper acc v =  \nif v = 0\nthen \nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin bigAdd (mulByDigit i (List.rev (List.map (fun x -> x*10) t ) )) (helper [] (h*i)) *", "annotated": "let somef i l = match (List.rev l) with\n| [] -> []\n| h::t ->\nlet rec helper acc v =  \nif v = 0\nthen \nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin bigAdd (mulByDigit i (List.rev (List.map (fun x -> x*10) t ) )) (helper [] (h*i)) *"}
{"fix": "let somef i l = match (List.rev l) with\n| [] -> []\n| h::t ->\nlet rec helper acc v =  \nif v = 0\nthen \nacc\nelse\nhelper (v mod 10 :: acc) (v/10)\nin bigAdd (mulByDigit i (List.rev (List.map (fun x -> x*10) t ) )) (helper [] (h*i))", "bad": ")\n\nsomef 90000 [9;9]", "annotated": ")\n\nsomef 90000 [9;9]"}
{"fix": "[1;0] @ (clone 0 1)", "bad": "[1,0] @ clone 0 1", "annotated": "[1,0] @ clone 0 1"}
{"fix": "[1;0] @ (clone 0 1)", "bad": "[1,0] @ (clone 0 1)", "annotated": "[1,0] @ (clone 0 1)"}
{"fix": "let bigMul l1 l2 = \nlet f a x = match a with\n(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ((mulByDigit x l1) @ (clone 0 numZeroes)) (prevRes) )  in\nlet base = (1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = match a with\n(numZeroes, prevRes) -> (numZeroes+1, bigAdd ( (mulByDigit x l1) @ (clone 0 numZeroes) prevRes))", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match a with\n(numZeroes, prevRes) -> (numZeroes+1, bigAdd ( (mulByDigit x l1) @ (clone 0 numZeroes) prevRes))"}
{"fix": "let bigMul l1 l2 = \nlet f a x = match a with\n(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ((mulByDigit x l1) @ (clone 0 numZeroes)) (prevRes) )  in\nlet base = (1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let base = (1, []) in\nlet args = l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let base = (1, []) in\nlet args = l2\nin\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = match a with\n(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ((mulByDigit x l1) @ (clone 0 numZeroes)) (prevRes) )  in\nlet base = (1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = match a with\n(numZeroes, prevRes) -> (numZeroes+1, bigAdd ( (mulByDigit x l1) @ (clone 0 numZeroes) prevRes)) in\nlet base = (1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match a with\n(numZeroes, prevRes) -> (numZeroes+1, bigAdd ( (mulByDigit x l1) @ (clone 0 numZeroes) prevRes)) in\nlet base = (1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = match a with\n(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ((mulByDigit x l1) @ (clone 0 numZeroes)) (prevRes) )  in\nlet base = (1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = match a with\n(numZeroes, prevRes) -> (numZeroes+1, bigAdd ( ( (mulByDigit x l1) @ (clone 0 numZeroes) ) prevRes)) in\nlet base = (1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match a with\n(numZeroes, prevRes) -> (numZeroes+1, bigAdd ( ( (mulByDigit x l1) @ (clone 0 numZeroes) ) prevRes)) in\nlet base = (1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = match a with\n(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ((mulByDigit x l1) @ (clone 0 numZeroes)) (prevRes) )  in\nlet base = (1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = match a with\n(numZeroes, prevRes) -> (numZeroes+1, bigAdd ( ( (mulByDigit x l1) @ (clone 0 numZeroes) ) (prevRes) )) in\nlet base = (1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match a with\n(numZeroes, prevRes) -> (numZeroes+1, bigAdd ( ( (mulByDigit x l1) @ (clone 0 numZeroes) ) (prevRes) )) in\nlet base = (1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let rec mulByDigit i l = \nlet f a x = match a with\n(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( [i*x] @ (clone 0 numZeroes) ) (prevRes) ) in\nlet base = (0, []) in\nlet (_,res) = List.fold_left f base (List.rev l) in\nres", "bad": "let rec mulByDigit i l = \nlet f a x = match a with\n(numZeroes, prevRes) -> ( numZeroes+1, bigAdd (i*x @ (clone 0 numZeroes)) (prevRes) ) in\nlet base = (0, []) in\nlet (_,res) = List.fold f base (List.rev l) in\nres", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet f a x = match a with\n(numZeroes, prevRes) -> ( numZeroes+1, bigAdd (i*x @ (clone 0 numZeroes)) (prevRes) ) in\nlet base = (0, []) in\nlet (_,res) = List.fold f base (List.rev l) in\nres"}
{"fix": "let rec mulByDigit i l = \nlet f a x = match a with\n(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( [i*x] @ (clone 0 numZeroes) ) (prevRes) ) in\nlet base = (0, []) in\nlet (_,res) = List.fold_left f base (List.rev l) in\nres", "bad": "let rec mulByDigit i l = \nlet f a x = match a with\n(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( (i*x) @ (clone 0 numZeroes)) (prevRes) ) in\nlet base = (0, []) in\nlet (_,res) = List.fold f base (List.rev l) in\nres", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet f a x = match a with\n(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( (i*x) @ (clone 0 numZeroes)) (prevRes) ) in\nlet base = (0, []) in\nlet (_,res) = List.fold f base (List.rev l) in\nres"}
{"fix": "let rec mulByDigit i l = \nlet f a x = match a with\n(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( [i*x] @ (clone 0 numZeroes) ) (prevRes) ) in\nlet base = (0, []) in\nlet (_,res) = List.fold_left f base (List.rev l) in\nres", "bad": "let rec mulByDigit i l = \nlet f a x = match a with\n(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( [i*h] @ (clone 0 numZeroes) ) (prevRes) ) in\nlet base = (0, []) in\nlet (_,res) = List.fold f base (List.rev l) in\nres", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet f a x = match a with\n(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( [i*h] @ (clone 0 numZeroes) ) (prevRes) ) in\nlet base = (0, []) in\nlet (_,res) = List.fold f base (List.rev l) in\nres"}
{"fix": "let rec mulByDigit i l = \nlet f a x = match a with\n(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( [i*x] @ (clone 0 numZeroes) ) (prevRes) ) in\nlet base = (0, []) in\nlet (_,res) = List.fold_left f base (List.rev l) in\nres", "bad": "let rec mulByDigit i l = \nlet f a x = match a with\n(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( [i*x] @ (clone 0 numZeroes) ) (prevRes) ) in\nlet base = (0, []) in\nlet (_,res) = List.fold f base (List.rev l) in\nres", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet f a x = match a with\n(numZeroes, prevRes) -> ( numZeroes+1, bigAdd ( [i*x] @ (clone 0 numZeroes) ) (prevRes) ) in\nlet base = (0, []) in\nlet (_,res) = List.fold f base (List.rev l) in\nres"}
{"fix": "let digitalRoot n = (*failwith \"TBD\"*)\n\nlet rec loop x =\nsumList (digitsOfInt (abs n))", "bad": "let digitalRoot n = (*failwith \"TBD\"*)\n\nlet rec loop x = function\nsumList digitsOfInt (abs x)", "annotated": "let digitalRoot : int -> int = fun  n  ->  (*failwith \"TBD\"*)\n\nlet rec loop x = function\nsumList digitsOfInt (abs x)"}
{"fix": "let digitalRoot n = (*failwith \"TBD\"*)\n\nlet rec loop x =\nsumList (digitsOfInt (abs n))", "bad": "let digitalRoot n = (*failwith \"TBD\"*)\n\nlet rec loop x = function\nsumList (digitsOfInt (abs x))", "annotated": "let digitalRoot : int -> int = fun  n  ->  (*failwith \"TBD\"*)\n\nlet rec loop x = function\nsumList (digitsOfInt (abs x))"}
{"fix": "let digitalRoot n = (*failwith \"TBD\"*)\n\nlet rec loop x =\nsumList (digitsOfInt (abs n))", "bad": "let digitalRoot n = (*failwith \"TBD\"*)\n\nlet rec loop x = match n with\nsumList (digitsOfInt (abs x))", "annotated": "let digitalRoot : int -> int = fun  n  ->  (*failwith \"TBD\"*)\n\nlet rec loop x = match n with\nsumList (digitsOfInt (abs x))"}
{"fix": "let listReverse l = (*failwith \"TBD\"*)\nlet rec rev x l = match x with\n| [] -> x\n| h::t -> rev (h::x) t in\nrev[] l", "bad": "let listReverse l = (*failwith \"TBD\"*)\nlet rec rev x = match l with\n| [] -> x\n| h::t -> rev (h::x) t in\nrev[] l", "annotated": "let listReverse : 'a list -> 'a list = fun  l  ->  (*failwith \"TBD\"*)\nlet rec rev x = match l with\n| [] -> x\n| h::t -> rev (h::x) t in\nrev[] l"}
{"fix": "let listReverse l = (*failwith \"TBD\"*)\nlet rec rev x l = match x with\n| [] -> x\n| h::t -> rev (h::x) t in\nrev[] l", "bad": "let listReverse l = (*failwith \"TBD\"*)\nlet rec rev x = match x with\n| [] -> x\n| h::t -> rev (h::x) t in\nrev[] l", "annotated": "let listReverse : 'a list -> 'a list = fun  l  ->  (*failwith \"TBD\"*)\nlet rec rev x = match x with\n| [] -> x\n| h::t -> rev (h::x) t in\nrev[] l"}
{"fix": "let listReverse l = (*failwith \"TBD\"*)\nlet rec rev x = function\n| [] -> x\n| h::t -> rev (h::x) t in\nrev[] l", "bad": "let listReverse l = (*failwith \"TBD\"*)\nlet rec rev x l = function\n| [] -> x\n| h::t -> rev (h::x) t in\nrev[] l", "annotated": "let listReverse : 'a list -> 'a list = fun  l  ->  (*failwith \"TBD\"*)\nlet rec rev x l = function\n| [] -> x\n| h::t -> rev (h::x) t in\nrev[] l"}
{"fix": "let digitalRoot n = (*failwith \"TBD\"*)\nlet x = n in\nlet rec loop x =\nif x < 10 then x\nelse loop( sumList (digitsOfInt ( abs x ) ) )", "bad": "let digitalRoot n = (*failwith \"TBD\"*)\nlet x = n in\nlet rec loop x =\nif x < 10 then x\nelse loop( sumList (digitsOfInt ( abs x ) ) )", "annotated": "let digitalRoot : int -> int = fun  n  ->  (*failwith \"TBD\"*)\nlet x = n in\nlet rec loop x =\nif x < 10 then x\nelse loop( sumList (digitsOfInt ( abs x ) ) )"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = (*failwith \"to be written\" in*)\nif List.mem h seen then\nseen\nelse \nh::seen\nin (*list of seen elts*)\nlet rest' = (*failwith \"to be written\" in *)\nt\nin (*orig list*)\nhelper (seen',rest')\n\nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = (*failwith \"to be written\" in*)\n\nin (*list of seen elts*)\nlet rest' = (*failwith \"to be written\" in *)\nt\nin (*orig list*)\nif List.mem h seen then\nhelper (seen',rest')\nelse \nh::seen'\nhelper (seen', rest')\n\nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = (*failwith \"to be written\" in*)\n\nin (*list of seen elts*)\nlet rest' = (*failwith \"to be written\" in *)\nt\nin (*orig list*)\nif List.mem h seen then\nhelper (seen',rest')\nelse \nh::seen'\nhelper (seen', rest')\n\nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = (*failwith \"to be written\" in*)\nif List.mem h seen then\nseen\nelse \nh::seen\nin (*list of seen elts*)\nlet rest' = (*failwith \"to be written\" in *)\nt\nin (*orig list*)\nhelper (seen',rest')\n\nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(*let seen' = failwith \"to be written\" in*)\n\n(*in list of seen elts*)\nlet rest' = (*failwith \"to be written\" in *)\nt\nin (*orig list*)\nif List.mem h seen then\nhelper (seen',rest')\nelse \nh::seen'\nhelper (seen', rest')\n\nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(*let seen' = failwith \"to be written\" in*)\n\n(*in list of seen elts*)\nlet rest' = (*failwith \"to be written\" in *)\nt\nin (*orig list*)\nif List.mem h seen then\nhelper (seen',rest')\nelse \nh::seen'\nhelper (seen', rest')\n\nin\nList.rev (helper ([],l))"}
{"fix": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n|[] -> d\n|(ki,vi)::l -> if k = ki then vi\nelse assoc (d,k,l)", "bad": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "annotated": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}
{"fix": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet c' = f b in\n(*let b' = in*)\nif c' = b \nthen c'\nelse wwhile (f, c')", "bad": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet c' = f b in\nlet b' = b in\nif c' = b \nthen c'\nelse wwhile (c', b')", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  (* failwith \"to be written\" *)\nlet c' = f b in\nlet b' = b in\nif c' = b \nthen c'\nelse wwhile (c', b')"}
{"fix": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet helper = f b in\nmatch helper with\n| (x, y) -> if y \nthen wwhile (f, x)\nelse x", "bad": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet helper f b = \n(b', bool c') in\nmatch c' with\n| false -> b'\n| true -> wwhile (f, b')", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  (* failwith \"to be written\" *)\nlet helper f b = \n(b', bool c') in\nmatch c' with\n| false -> b'\n| true -> wwhile (f, b')"}
{"fix": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet helper = f b in\nmatch helper with\n| (x, y) -> if y \nthen wwhile (f, x)\nelse x", "bad": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet helper f b = \n(b', bool c') in\nmatch helper with\n| (int, bool) -> if c' = false then b'\nelse wwhile (f, b')", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  (* failwith \"to be written\" *)\nlet helper f b = \n(b', bool c') in\nmatch helper with\n| (int, bool) -> if c' = false then b'\nelse wwhile (f, b')"}
{"fix": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet helper = f b in\nmatch helper with\n| (x, y) -> if y \nthen wwhile (f, x)\nelse x", "bad": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet helper f b = \n(int b', bool c') in\nmatch helper with\n| false -> if c' = false then b'\n| true -> wwhile (f, b')", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  (* failwith \"to be written\" *)\nlet helper f b = \n(int b', bool c') in\nmatch helper with\n| false -> if c' = false then b'\n| true -> wwhile (f, b')"}
{"fix": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet helper = f b in\nmatch helper with\n| (x, y) -> if y \nthen wwhile (f, x)\nelse x", "bad": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet b' f b = \n(b', bool c') in\nmatch helper with\n| false -> if c' = false then b'\n| true -> wwhile (f, b')", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  (* failwith \"to be written\" *)\nlet b' f b = \n(b', bool c') in\nmatch helper with\n| false -> if c' = false then b'\n| true -> wwhile (f, b')"}
{"fix": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet helper = f b in\nmatch helper with\n| (x, y) -> if y \nthen wwhile (f, x)\nelse x", "bad": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet b' = f b in\nlet p = (b', bool c') in\nmatch c' with\n| false -> b'\n| true  -> wwhile (f, b')", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  (* failwith \"to be written\" *)\nlet b' = f b in\nlet p = (b', bool c') in\nmatch c' with\n| false -> b'\n| true  -> wwhile (f, b')"}
{"fix": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet helper = f b in\nmatch helper with\n| (x, y) -> if y \nthen wwhile (f, x)\nelse x", "bad": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet f b = (b', c') in\nmatch c' with\n| false -> b'\n| true  -> wwhile (f, b')", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  (* failwith \"to be written\" *)\nlet f b = (b', c') in\nmatch c' with\n| false -> b'\n| true  -> wwhile (f, b')"}
{"fix": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet helper = f b in\nmatch helper with\n| (x, y) -> if y \nthen wwhile (f, x)\nelse x", "bad": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet b' = int in\nlet c' = bool in\nlet f b = (b', c') in\nmatch c' with\n| false -> b'\n| true  -> wwhile (f, b')", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  (* failwith \"to be written\" *)\nlet b' = int in\nlet c' = bool in\nlet f b = (b', c') in\nmatch c' with\n| false -> b'\n| true  -> wwhile (f, b')"}
{"fix": "let fixpoint (f,b) = wwhile ((*(failwith \"to be written\")*)\nlet g b =\nlet self = f b in\nmatch self with\n| b -> (self, true)\n| _ -> (self, false)\nin g\n,b)", "bad": "let fixpoint (f,b) = wwhile ((*(failwith \"to be written\")*)\nlet g b =\nlet self = f b in\nmatch  with\n| b -> (self, true)\n| _ -> (self, false)\nin g\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((*(failwith \"to be written\")*)\nlet g b =\nlet self = f b in\nmatch  with\n| b -> (self, true)\n| _ -> (self, false)\nin g\n,b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile ((*(failwith \"to be written\")*)\nlet g =\nlet self = f b in\nmatch self with\n| b -> (self, true)\n| _ -> (self, false)\nin g\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((*(failwith \"to be written\")*)\nlet g =\nlet self = f b in\nmatch self with\n| b -> (self, true)\n| _ -> (self, false)\nin g\n,b)"}
{"fix": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet helper = f b in\nmatch helper with\n| (x, y) -> if y = false\nthen x\nelse wwhile (f, x)", "bad": "let _ = fixpoint (collatz, 1)", "annotated": "let _ = fixpoint (collatz, 1)"}
{"fix": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet helper = f b in\nmatch helper with\n| (x, y) -> if y = false\nthen x\nelse wwhile (f, x)", "bad": "let _ = fixpoint (collatz, 3)", "annotated": "let _ = fixpoint (collatz, 3)"}
{"fix": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet helper = f b in\nmatch helper with\n| (x, y) -> if y = false\nthen x\nelse wwhile (f, x)", "bad": "let _ = fixpoint (collatz, 48)", "annotated": "let _ = fixpoint (collatz, 48)"}
{"fix": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet helper = f b in\nmatch helper with\n| (x, y) -> if y = false\nthen x\nelse wwhile (f, x)", "bad": "let _ = fixpoint (collatz, 107)", "annotated": "let _ = fixpoint (collatz, 107)"}
{"fix": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet helper = f b in\nmatch helper with\n| (x, y) -> if y = false\nthen x\nelse wwhile (f, x)", "bad": "let _ = fixpoint (collatz, 9001)", "annotated": "let _ = fixpoint (collatz, 9001)"}
{"fix": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet helper = f b in\nmatch helper with\n| (x, y) -> if y = false\nthen x\nelse wwhile (f, x)", "bad": "let _ = fixpoint (collatz, 3)", "annotated": "let _ = fixpoint (collatz, 3)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile ((*(failwith \"to be written\")*)\nlet g b = \nlet helper = f b in\nmatch helper with\n| b -> if f = b\nthen (f, false)\nelse (f, true)\nin g\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((*(failwith \"to be written\")*)\nlet g b = \nlet helper = f b in\nmatch helper with\n| b -> if f = b\nthen (f, false)\nelse (f, true)\nin g\n,b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile ((*(failwith \"to be written\")*)\nlet g b = \nlet helper = f b in\nmatch helper with\n| f-> if f = b\nthen (f, false)\nelse (f, true)\nin g\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((*(failwith \"to be written\")*)\nlet g b = \nlet helper = f b in\nmatch helper with\n| f-> if f = b\nthen (f, false)\nelse (f, true)\nin g\n,b)"}
{"fix": "let rec eval (e,x,y) = (*failwith \"to be written\"*)\nmatch e with\nVarX           -> x\n| VarY           -> y\n| Sine e         -> sin(pi*. eval (e,x,y))\n| Cosine e       -> cos(pi*. eval (e,x,y))\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\n(*Thresh = e1<e2?e3:e4*)\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)", "bad": "let _ = eval (sampleExpr,0.5,0.2)", "annotated": "let _ = eval (sampleExpr,0.5,0.2)"}
{"fix": "let rec eval (e,x,y) = (*failwith \"to be written\"*)\nmatch e with\nVarX           -> x\n| VarY           -> y\n| Sine e         -> sin(pi*. eval (e,x,y))\n| Cosine e       -> cos(pi*. eval (e,x,y))\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\n(*Thresh = e1<e2?e3:e4*)\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)", "bad": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)"}
{"fix": "let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")", "bad": "let _ = eval (sampleExpr1,0.5,0.2)", "annotated": "let _ = eval (sampleExpr1,0.5,0.2)"}
{"fix": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n|[] -> d\n|(ki,vi)::l -> if k = ki then vi\nelse assoc (d,k,l)", "bad": "let rec build (rand, depth) = (*failwith \"to be implemented\"*)\nlet rng = rand(0,9) in\nif depth >= 0 then \nmatch rand 0 2 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \nmatch rng with\n| 0 -> build(rand,depth-1)\n| 1 -> build(rand,depth-1)\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\n| 7 -> buildExpwn(build(rand, depth-1))\n| 8 -> buildLogTen(build(rand, depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  (*failwith \"to be implemented\"*)\nlet rng = rand(0,9) in\nif depth >= 0 then \nmatch rand 0 2 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \nmatch rng with\n| 0 -> build(rand,depth-1)\n| 1 -> build(rand,depth-1)\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\n| 7 -> buildExpwn(build(rand, depth-1))\n| 8 -> buildLogTen(build(rand, depth-1))"}
{"fix": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n|[] -> d\n|(ki,vi)::l -> if k = ki then vi\nelse assoc (d,k,l)", "bad": "let rec build (rand, depth) = (*failwith \"to be implemented\"*)\nlet rng = rand(0,9) in\nif depth >= 0 then \nmatch rand (0,2) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \nmatch rng with\n| 0 -> build(rand,depth-1)\n| 1 -> build(rand,depth-1)\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\n| 7 -> buildExpwn(build(rand, depth-1))\n| 8 -> buildLogTen(build(rand, depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  (*failwith \"to be implemented\"*)\nlet rng = rand(0,9) in\nif depth >= 0 then \nmatch rand (0,2) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \nmatch rng with\n| 0 -> build(rand,depth-1)\n| 1 -> build(rand,depth-1)\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\n| 7 -> buildExpwn(build(rand, depth-1))\n| 8 -> buildLogTen(build(rand, depth-1))"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> []\n| _ -> digitsOfInt (n/10)@[n mod 10]", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| digitsOfInt(n/10)::(n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse match n with\n| digitsOfInt(n/10)::(n mod 10)"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> []\n| _ -> digitsOfInt (n/10)@[n mod 10]", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> [0]\n| digitsOfInt(n/10)::(n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse match n with\n| 0 -> [0]\n| digitsOfInt(n/10)::(n mod 10)"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> []\n| _ -> digitsOfInt (n/10)@[n mod 10]", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| digitsOfInt (n/10)::(n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse match n with\n| digitsOfInt (n/10)::(n mod 10)"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> []\n| _ -> digitsOfInt (n/10)@[n mod 10]", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| digitsOfInt n/10::(n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse match n with\n| digitsOfInt n/10::(n mod 10)"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> []\n| _ -> digitsOfInt (n/10)@[n mod 10]", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| digitsOfInt (n/10)::(n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse match n with\n| digitsOfInt (n/10)::(n mod 10)"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> []\n| _ -> digitsOfInt (n/10)@[n mod 10]", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| _ -> digitsOfInt (n/10)::(n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse match n with\n| _ -> digitsOfInt (n/10)::(n mod 10)"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> []\n| _ -> digitsOfInt (n/10)@[n mod 10]", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> []\n| _ -> digitsOfInt (n/10)::(n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse match n with\n| 0 -> []\n| _ -> digitsOfInt (n/10)::(n mod 10)"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> []\n| _ -> digitsOfInt (n/10)@[n mod 10]", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> []\n| _ -> digitsOfInt (n/10)@(n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse match n with\n| 0 -> []\n| _ -> digitsOfInt (n/10)@(n mod 10)"}
{"fix": "let rec digitsOfInt n = \nif n = 0 then [0]\nelse let rec getDigits n = match n with\n| 0 -> []\n| _ -> myAppend (getDigits (n/10)) (n mod 10)", "bad": "let rec digitsOfInt n = \nif n = 0 then [0]\nelse let rec getDigits n = match n with\n| 0 -> []\n| _ -> myAppend (getDigits (n/10) (n mod 10))", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n = 0 then [0]\nelse let rec getDigits n = match n with\n| 0 -> []\n| _ -> myAppend (getDigits (n/10) (n mod 10))"}
{"fix": "let rec digitsOfInt n = \nif n = 0 then [0]\nelse let rec getDigits n = \nif n > 0 then myAppend (getDigits (n/10)) (n mod 10)\nelse []", "bad": "let rec digitsOfInt n = \nif n = 0 then [0]\nelse let rec getDigits m = match m with\n| 0 -> []\n| _ -> myAppend (getDigits (m/10)) (m mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n = 0 then [0]\nelse let rec getDigits m = match m with\n| 0 -> []\n| _ -> myAppend (getDigits (m/10)) (m mod 10)"}
{"fix": "let rec additivePersistence n = match n with\n| 0 -> 1\n| _ -> 1 + additivePersistence (sumList digits n)", "bad": "let rec additivePersistence n = match n with\n| 0 -> 1\n| _ -> 1 + additivePersistence sumList digits n", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  match n with\n| 0 -> 1\n| _ -> 1 + additivePersistence sumList digits n"}
{"fix": "let rec sumList xs = match xs with \n| [] -> 0\n| h::t -> h + sumList t", "bad": "let palindrome w = listCompare (explode w) (listReverse (explode w))", "annotated": "let palindrome : string -> bool = fun  w  ->  listCompare (explode w) (listReverse (explode w))"}
{"fix": "let rec wwhile (f,b) = \nlet helper (b', c') = \nif c' then wwhile (f, b')\nelse b'\nin f b", "bad": "let rec wwhile (f,b) = \nlet helper (b', c') = \nif c' then wwhile (f, b')\nelse b'\nin f b'", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet helper (b', c') = \nif c' then wwhile (f, b')\nelse b'\nin f b'"}
{"fix": "let rec wwhile (f,b) = match f b with\n| (b', c') -> if c' then wwhile (f, b')\nelse b'", "bad": "let rec wwhile (f,b) = \nlet (b', c') = \nif c' then wwhile (f, b')\nelse b'\nin f b", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet (b', c') = \nif c' then wwhile (f, b')\nelse b'\nin f b"}
{"fix": "let rec wwhile (f,b) = match f b with\n| (b', c') -> if c' then wwhile (f, b')\nelse b'", "bad": "let rec wwhile (f,b) = \nif c' then wwhile (f, b')\nelse b'\nin f b(b', c')", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nif c' then wwhile (f, b')\nelse b'\nin f b(b', c')"}
{"fix": "let fixpoint (f,b) = wwhile ((fun f' -> (f b, b != (f b))),b)", "bad": "let fixpoint (f,b) = wwhile ((let f' = (f b, b != (f b))),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f' = (f b, b ! ->  (f b))),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((fun f' -> (f b, b != (f b))),b)", "bad": "let fixpoint (f,b) = wwhile ((let fun f' = (f b, b != (f b))),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let fun f' = (f b, b ! ->  (f b))),b)"}
{"fix": "et _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e' -> sin(pi *. (eval (e'(e', x, y))))\n| Average (e1, e2) -> (((eval (e1, x, y)) +. (eval (e2, x, y)))/2)\n| Times (e1, e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y)))\n| Thresh (e1, e2, e3, e4) -> (if ((eval (e1, x, y))<(eval (e2, x, y))) then (eval (e3, x, y)) else (eval (e4, x, y)))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e' -> sin(pi *. (eval (e'(e', x, y))))\n| Average (e1, e2) -> (((eval (e1, x, y)) +. (eval (e2, x, y)))/2)\n| Times (e1, e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y)))\n| Thresh (e1, e2, e3, e4) -> (if ((eval (e1, x, y))<(eval (e2, x, y))) then (eval (e3, x, y)) else (eval (e4, x, y)))"}
{"fix": "et _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e' -> sin(pi *. (eval (e', x, y)))\n| Average (e1, e2) -> (((eval (e1, x, y)) +. (eval (e2, x, y)))/2)\n| Times (e1, e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y)))\n| Thresh (e1, e2, e3, e4) -> (if ((eval (e1, x, y))<(eval (e2, x, y))) then (eval (e3, x, y)) else (eval (e4, x, y)))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e' -> sin(pi *. (eval (e', x, y)))\n| Average (e1, e2) -> (((eval (e1, x, y)) +. (eval (e2, x, y)))/2)\n| Times (e1, e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y)))\n| Thresh (e1, e2, e3, e4) -> (if ((eval (e1, x, y))<(eval (e2, x, y))) then (eval (e3, x, y)) else (eval (e4, x, y)))"}
{"fix": "et _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e' -> sin(pi *. (eval (e', x, y)))\n| Average (e1, e2) -> (((eval (e1, x, y)) +. (eval (e2, x, y)))/.(2.0))\n| Times (e1, e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y)))\n| Thresh (e1, e2, e3, e4) -> (if ((eval (e1, x, y))<(eval (e2, x, y))) then (eval (e3, x, y)) else (eval (e4, x, y)))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e' -> sin(pi *. (eval (e', x, y)))\n| Average (e1, e2) -> (((eval (e1, x, y)) +. (eval (e2, x, y)))/.(2.0))\n| Times (e1, e2) -> ((eval (e1, x, y)) *. (eval (e2, x, y)))\n| Thresh (e1, e2, e3, e4) -> (if ((eval (e1, x, y))<(eval (e2, x, y))) then (eval (e3, x, y)) else (eval (e4, x, y)))"}
{"fix": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "bad": "let stringOfList f l = \"[\" ^ (List.map f \"; \" l) ^ \"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\" ^ (List.map f \"; \" l) ^ \"]\""}
{"fix": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "bad": "let stringOfList f l = \"[\" ^ (List.map f (\"; \" l)) ^ \"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\" ^ (List.map f (\"; \" l)) ^ \"]\""}
{"fix": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "bad": "let stringOfList f l = \"[\" ^ (List.map (f \"; \") l) ^ \"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\" ^ (List.map (f \"; \") l) ^ \"]\""}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\n(len1 < len2) ? ((List.append (clone 0 (len2-len1)) l1), l2) : (l1, (List.append (clone 0 (len1-len2)) l2))", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\n(len1 < len2) ? ((List.append (clone 0 (len2-len1)) l1), l2) : (l1, (List.append (clone 0 (len1-len2)) l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\n(len1 < len2) ? ((List.append (clone 0 (len2-len1)) l1), l2) : (l1, (List.append (clone 0 (len1-len2)) l2))", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\n(len1 < len2) ? ((List.append (clone 0 (len2-len1)) l1), l2) : (l1, (List.append (clone 0 (len1-len2)) l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let rec mulByDigit i l = \nlet (i', l') = (0, (List.rev l)) in\nmatch l' with\n| [] -> []\n| h::t -> (((h*i)+i') mod 10)::(mulByDigit ((((h*i)+i')/10), t))\nin\nList.rev (mulByDigit i l)", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet (i', l') = (0, (List.rev l)) in\nmatch l' with\n| [] -> []\n| h::t -> (((h*i)+i') mod 10)::(mulByDigit ((((h*i)+i')/10), t))\nin\nList.rev (mulByDigit i l)"}
{"fix": "let rec mulByDigit i l = bigAdd l (mulByDigit (i-1) l)", "bad": "let rec mulByDigit i l = \nif i > 0 then mulByDigit ((i-1), (bigAdd l l))\nelse l", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nif i > 0 then mulByDigit ((i-1), (bigAdd l l))\nelse l"}
{"fix": "let rec mulByDigit i l = match i with\n| 0 -> l\n| _ -> bigAdd l (mulByDigit (i-1) l)", "bad": "let rec mulByDigit i l = if i > 0 then bigAdd l (mulByDigit (i-1) l)", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  if i > 0 then bigAdd l (mulByDigit (i-1) l)"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  match a with\n| (i, l) -> match x with\n| [] -> (i, [0])\n| h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i))) \nin\nlet base = (0, []) in\nlet args =  List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x =  match a with\n| (i, l) -> match x with\n| [] -> []\n| h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i) \nin\nlet base = (0, []) in\nlet args =  List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x =  match a with\n| (i, l) -> match x with\n| [] -> []\n| h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i) \nin\nlet base = (0, []) in\nlet args =  List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  match a with\n| (i, l) -> match x with\n| [] -> (i, [0])\n| h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i))) \nin\nlet base = (0, []) in\nlet args =  List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x =  match a with\n| (i, l) -> match x with\n| [] -> []\n| h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i)) \nin\nlet base = (0, []) in\nlet args =  List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x =  match a with\n| (i, l) -> match x with\n| [] -> []\n| h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i)) \nin\nlet base = (0, []) in\nlet args =  List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  match a with\n| (i, l) -> match x with\n| [] -> (i, [0])\n| h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i))) \nin\nlet base = (0, []) in\nlet args =  List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x =  match a with\n| (i, l) -> match x with\n| [] -> []\n| h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i))) \nin\nlet base = (0, []) in\nlet args =  List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x =  match a with\n| (i, l) -> match x with\n| [] -> []\n| h::t -> ((i+1), bigAdd l (List.append (mulByDigit h l1) (clone 0 i))) \nin\nlet base = (0, []) in\nlet args =  List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  match a with\n| (i, l) -> ((i+1), bigAdd l (List.append (mulByDigit x l1) (clone 0 i))) \nin\nlet base = (0, []) in\nlet args =  List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "annotated": "let _ = bigMul [9;9;9;9] [9;9;9;9]"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  match a with\n| (i, l) -> ((i+1), bigAdd l (List.append (mulByDigit x l1) (clone 0 i))) \nin\nlet base = (0, []) in\nlet args =  List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]", "annotated": "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]"}
{"fix": "let _ = additivePersistence 0", "bad": "let _ additivePersistence 0", "annotated": "let _ additivePersistence 0"}
{"fix": "let _ = additivePersistence 0", "bad": "let _ additivePersistence 10", "annotated": "let _ additivePersistence 10"}
{"fix": "let _ = listReverse [(1,2); (3,4)]", "bad": "let _ = listReverse [(a,b); (c,d)];\n\n\n\n(* explode : string -> char list \n* (explode s) is the list of characters in the string s in the order in \n*   which they appear\n* e.g.  (explode \"Hello\") is ['H';'e';'l';'l';'o']\n*)\nlet explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0", "annotated": "let _ = listReverse [(a,b); (c,d)];\n\n\n\n(* explode : string -> char list \n* (explode s) is the list of characters in the string s in the order in \n*   which they appear\n* e.g.  (explode \"Hello\") is ['H';'e';'l';'l';'o']\n*)\nlet explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0"}
{"fix": "let _ = listReverse [(1,2); (3,4)]", "bad": "let _ = listReverse [(a,b); (c,d)]", "annotated": "let _ = listReverse [(a,b); (c,d)]"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "wwhile (f, 3)", "annotated": "wwhile (f, 3)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) =\nlet b' = f b in\nif b' = b\nthen b\nelse fixpoint (f, b')", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nlet b' = f b in\nif b' = b\nthen b\nelse fixpoint (f, b')"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let rec fixpoint (f,b) =\nlet b' = f b in\nif b' = b\nthen b\nelse fixpoint (f, b')", "annotated": "let rec fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nlet b' = f b in\nif b' = b\nthen b\nelse fixpoint (f, b')"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sin e'    -> \"sin (pi*\"^expr e'^\")\"\n| Cos e'    -> \"cos (pi*\"^expr e'^\")\"\n| Average e1, e2  -> \"((\"^esprToString e1^\" + \"^exprToString e2^\"/2)\"\n| Times e1, e2    -> (exprToString e1)^\" * \"^exprToString e2\n| Thresh e1, e2, e3, e4    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sin e'    -> \"sin (pi*\"^expr e'^\")\"\n| Cos e'    -> \"cos (pi*\"^expr e'^\")\"\n| Average e1, e2  -> \"((\"^esprToString e1^\" + \"^exprToString e2^\"/2)\"\n| Times e1, e2    -> (exprToString e1)^\" * \"^exprToString e2\n| Thresh e1, e2, e3, e4    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\""}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e'    -> \"sin (pi*\"^expr e'^\")\"\n| Cosine e'    -> \"cos (pi*\"^expr e'^\")\"\n| Average e1, e2  -> \"((\"^esprToString e1^\" + \"^exprToString e2^\"/2)\"\n| Times e1, e2    -> (exprToString e1)^\" * \"^exprToString e2\n| Thresh e1, e2, e3, e4    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e'    -> \"sin (pi*\"^expr e'^\")\"\n| Cosine e'    -> \"cos (pi*\"^expr e'^\")\"\n| Average e1, e2  -> \"((\"^esprToString e1^\" + \"^exprToString e2^\"/2)\"\n| Times e1, e2    -> (exprToString e1)^\" * \"^exprToString e2\n| Thresh e1, e2, e3, e4    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\""}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e'    -> \"sin (pi*\"^expr e'^\")\"\n| Cosine e'    -> \"cos (pi*\"^expr e'^\")\"\n| Average (e1, e2)  -> \"((\"^esprToString e1^\" + \"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\" * \"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e'    -> \"sin (pi*\"^expr e'^\")\"\n| Cosine e'    -> \"cos (pi*\"^expr e'^\")\"\n| Average (e1, e2)  -> \"((\"^esprToString e1^\" + \"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\" * \"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\""}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e'    -> \"sin (pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos (pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^esprToString e1^\" + \"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\" * \"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e'    -> \"sin (pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos (pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^esprToString e1^\" + \"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\" * \"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\""}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e'    -> \"sin (pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos (pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^exprToString e1^\" + \"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\" * \"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e'    -> \"sin (pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos (pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^exprToString e1^\" + \"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\" * \"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\""}
{"fix": "let _ = buildX()", "bad": "let _ = buildSine(0.5)", "annotated": "let _ = buildSine(0.5)"}
{"fix": "let _ = buildX()", "bad": "let _ = buildSine(Sine 0.5)", "annotated": "let _ = buildSine(Sine 0.5)"}
{"fix": "let _ = buildX()", "bad": "let _ = buildSine(Sine VarX)", "annotated": "let _ = buildSine(Sine VarX)"}
{"fix": "let _ = eval (Average(VarX,VarY), 0.5, 0.5)", "bad": "let rec eval (e,x,y) = match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (eval x'+ eval y')/2", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (eval x'+ eval y')/2"}
{"fix": "let _ = eval (Average(VarX,VarY), 0.5, 0.5)", "bad": "let rec eval (e,x,y) = match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (eval x' y + eval x y')/2", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (eval x' y + eval x y')/2"}
{"fix": "let _ = eval (Average(VarX,VarY), 0.5, 0.5)", "bad": "let rec eval (e,x,y) = match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (eval VarX x' y + eval VarY x y')/2", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (eval VarX x' y + eval VarY x y')/2"}
{"fix": "let _ = eval (Average(VarX,VarY), 0.5, 0.5)", "bad": "let rec eval (e,x,y) = match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (eval (VarX, x', y) + eval (VarY, x, y'))/2", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (eval (VarX, x', y) + eval (VarY, x, y'))/2"}
{"fix": "let _ = eval (Average(VarX,VarY), 0.5, 0.5)", "bad": "let rec eval (e,x,y) = match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (x'+y')/2", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (x'+y')/2"}
{"fix": "let _ = eval (Average(VarX,VarY), 0.5, 0.5)", "bad": "let rec eval (e,x,y) = match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (x+y)/2", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX\t  -> x\n| VarY    -> y\n| Average (x', y') -> (x+y)/2"}
{"fix": "let _ = eval (Average(VarX,VarY), 0.5, 0.5)", "bad": "let rec eval (e,x,y) = match e with\n| Average (x', y') -> (x+y)/2", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Average (x', y') -> (x+y)/2"}
{"fix": "let _ = eval (Average(VarX,VarY), 0.5, 0.5)", "bad": "let rec eval (e,x,y) = match e with\n| Average (x', y') -> (x +. y)/2", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Average (x', y') -> (x +. y)/2"}
{"fix": "let _ = eval (Average(VarX,VarY), 0.5, 0.5)", "bad": "let rec eval (e,x,y) = match e with\n| Average (x', y') -> (x .+ y)/2", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Average (x', y') -> (x .+ y)/2"}
{"fix": "let _ = eval (Average(VarX,VarY), 0.5, 0.5)", "bad": "let rec eval (e,x,y) = match e with\n| Average (x', y') -> (x +. y)/2", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Average (x', y') -> (x +. y)/2"}
{"fix": "let _ = eval (Average(VarX,VarY), 0.5, 0.5)", "bad": "let rec eval (e,x,y) = match e with\n| Average (x', y') -> (x +. y) ./ 2", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Average (x', y') -> (x +. y) ./ 2"}
{"fix": "let _ = eval (Average(VarX,VarY), 0.5, 0.5)", "bad": "let rec eval (e,x,y) = match e with\n| Average (x', y') -> (x +. y) /. 2", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Average (x', y') -> (x +. y) /. 2"}
{"fix": "let _ = eval (Average(VarX,VarY), 0.5, 0.5)", "bad": "let rec eval (e,x,y) = match e with\n| Average (x', y') -> (x +. y) /. 2.0", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Average (x', y') -> (x +. y) /. 2.0"}
{"fix": "let _ = eval (Sine(VarX, VarY), 0.5,0.5)", "bad": "let rec eval (e,x,y) = match e with\n| Sine e'\t\t-> sin (pi *. eval(e'))\n| Cosine e'\t\t-> cos (pi *. eval(e'))\n| Average (x', y')      -> (x +. y) /. 2.0\n| Times (x', y')\t-> x *. y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Sine e'\t\t-> sin (pi *. eval(e'))\n| Cosine e'\t\t-> cos (pi *. eval(e'))\n| Average (x', y')      -> (x +. y) /. 2.0\n| Times (x', y')\t-> x *. y"}
{"fix": "let _ = eval (Sine(VarX, VarY), 0.5,0.5)", "bad": "let rec eval (e,x,y) = match e with\n| Sine e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (x', y')      -> (x +. y) /. 2.0\n| Times (x', y')\t-> x *. y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Sine e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (x', y')      -> (x +. y) /. 2.0\n| Times (x', y')\t-> x *. y"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)), 1.0, 1.0)", "bad": "let _ = eval (Sine(Average(VarX,VarY)), 0.5, 0.5)", "annotated": "let _ = eval (Sine(Average(VarX,VarY)), 0.5, 0.5)"}
{"fix": "let rec eval (e,x,y) = match e with\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (x', y')      -> (x +. y) /. 2.0\n| Times   (x', y')\t-> x *. y", "bad": "let _ = eval (Cosine(Average(VarX,VarY)), 0.0, 0.0)", "annotated": "let _ = eval (Cosine(Average(VarX,VarY)), 0.0, 0.0)"}
{"fix": "let _ = eval (Thresh(VarX,VarY,Sine(VarY),Cosine(VarX)), 1.0, 2.0)", "bad": "let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cos(VarY), 1.0, 2.0))", "annotated": "let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cos(VarY), 1.0, 2.0))"}
{"fix": "let _ = eval (Thresh(VarX,VarY,Sine(VarY),Cosine(VarX)), 1.0, 2.0)", "bad": "let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cos(VarY)), 1.0, 2.0)", "annotated": "let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cos(VarY)), 1.0, 2.0)"}
{"fix": "let _ = eval (Thresh(VarX,VarY,Sine(VarY),Cosine(VarX)), 1.0, 2.0)", "bad": "let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cosine(VarY)), 1.0, 2.0)", "annotated": "let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cosine(VarY)), 1.0, 2.0)"}
{"fix": "let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cosine(VarX)), 0.5, 1.0)", "bad": ")", "annotated": ")"}
{"fix": "let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cosine(VarX)), 0.5, 1.0)", "bad": "let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cosine(VarX)), 1.0, 0.5)", "annotated": "let _ = eval (Thresh(VarX,VarY,Sine(VarX),Cosine(VarX)), 1.0, 0.5)"}
{"fix": "let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")", "bad": "let _ = eval (sampleExpr1,0.5,0.2)", "annotated": "let _ = eval (sampleExpr1,0.5,0.2)"}
{"fix": "let _ = eval (Cosine(Average),0.5,0.2)", "bad": "let _ = eval (Sine(VarX),0.5,0.0)", "annotated": "let _ = eval (Sine(VarX),0.5,0.0)"}
{"fix": "let temp1 = FunckyCube(SquareRoot(VarY),SquareRoot(VarX),SquareRoot(VarY))", "bad": "let _ = exprToString FunckyCube(SquareRoot(VarY),SquareRoot(VarX),SquareRoot(VarY))", "annotated": "let _ = exprToString FunckyCube(SquareRoot(VarY),SquareRoot(VarX),SquareRoot(VarY))"}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = match e with\n| VarX         -> \"x\"\n| VarY         -> \"y\"\n| Sine e'      -> \"sin(pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos(pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^exprToString e1^\"+\"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\"*\"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^\nexprToString e3^\":\"^exprToString e4^\")\"\n| SquareRoot e'\t\t  -> \"sqrt(\"^exprToString e'^\")\"\n| FunckyRoot (e1,e2,e3)   -> \n\"sqrt(sqrt(\"^exprToString e1^\")+sqrt(\"^exprToString e2^\")+sqrt(\"^exprToString e3^\"))\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX         -> \"x\"\n| VarY         -> \"y\"\n| Sine e'      -> \"sin(pi*\"^exprToString e'^\")\"\n| Cosine e'    -> \"cos(pi*\"^exprToString e'^\")\"\n| Average (e1, e2)  -> \"((\"^exprToString e1^\"+\"^exprToString e2^\"/2)\"\n| Times   (e1, e2)  -> (exprToString e1)^\"*\"^exprToString e2\n| Thresh (e1, e2, e3, e4)    ->\n\"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^\nexprToString e3^\":\"^exprToString e4^\")\"\n| SquareRoot e'\t\t  -> \"sqrt(\"^exprToString e'^\")\"\n| FunckyRoot (e1,e2,e3)   -> \n\"sqrt(sqrt(\"^exprToString e1^\")+sqrt(\"^exprToString e2^\")+sqrt(\"^exprToString e3^\"))\""}
{"fix": "let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,7) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareRoot(build(rand, depth-1))", "bad": "let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,8) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareRoot(build(rand, depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,8) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareRoot(build(rand, depth-1))"}
{"fix": "let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,7) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareRoot(build(rand, depth-1))\n| 8 -> buildFunckySine(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "bad": "let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,7) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareRoot(build(rand, depth-1))\n| 8 -> buildFunckySine(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,7) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareRoot(build(rand, depth-1))\n| 8 -> buildFunckySine(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))"}
{"fix": "let makeRand (seed1, seed2) = \nlet seed = (Array.of_list [seed1;seed2]) in\nlet s = Random.State.make seed in\n(fun (x,y) -> (x + (Random.State.int s (y-x))))", "bad": "let rec build (rand, depth) =\nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,7) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareCosine(build(rand, depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nif depth = 0\nthen \nlet num = rand(0,1) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet num = rand(0,7) in\nmatch num with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\n| 7 -> buildSquareCosine(build(rand, depth-1))"}
{"fix": "let sqsum xs = \nlet f a x = a ** x in\nlet base = 0.0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = \nmatch x with \n| []    -> a\n| h::t  -> f (a + h**2) t in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = \nmatch x with \n| []    -> a\n| h::t  -> f (a + h**2) t in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a ** x in\nlet base = 0.0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a ** x in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a ** x in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let _ = sqsum [(-1);(-2)]", "bad": "let _ = sqsum [(-1);(-2)e]", "annotated": "let _ = sqsum [(-1);(-2)e]"}
{"fix": "let pipe fs = \nlet f a x = \nmatch x with \n| a   -> fun x -> x\n| h::t -> h\nin\n\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = \nmatch x with \n| a   -> fun x -> x\n| h::t -> h\nin\n\nlet base = [] in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = \nmatch x with \n| a   -> fun x -> x\n| h::t -> h\nin\n\nlet base = [] in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = \nmatch x with \n| []   -> a\n| h::t -> h\nin\n\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = \nmatch x with \n| []   -> b\n| h::t -> h\nin\n\nlet base = (fun x -> x) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = \nmatch x with \n| []   -> b\n| h::t -> h\nin\n\nlet base = (fun x -> x) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = 'a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = 'a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = \nmatch x with \n| [] -> a \n| h::t -> t\nin\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = \nmatch x with \n| [] -> a \n| h::t -> t\nin\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = [] in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun xs -> x (a xs) in  (* a fun that takes xs as input\nfor fun 'a' and take that output\nas input for fun 'x' *)\nlet base = (fun b -> b) in (* a fun that takes 'b as input, and \nreturn 'b as output *)\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun xs -> x (a xs) in  (* a fun that takes xs as input\nfor fun 'a' and take that output\nas input for fun 'x' *)\nlet base = (fun 'b -> b') in (* a fun that takes 'b as input, and \nreturn 'b as output *)\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun xs -> x (a xs) in  (* a fun that takes xs as input\nfor fun 'a' and take that output\nas input for fun 'x' *)\nlet base = (fun 'b -> b') in (* a fun that takes 'b as input, and \nreturn 'b as output *)\nList.fold_left f base fs"}
{"fix": "let _ = stringOfList (fun x -> string_of_int (x+1)) [1;2;3;4]", "bad": "let _ = stringOfList (fun x -> x+1) [1;2;3;4]", "annotated": "let _ = stringOfList (fun x -> x+1) [1;2;3;4]"}
{"fix": "let _ = stringOfList (fun x -> string_of_int (x+1)) [1;2;3;4]", "bad": "let _ = stringOfList (fun x -> int_of_string x+1) [1;2;3;4]", "annotated": "let _ = stringOfList (fun x -> int_of_string x+1) [1;2;3;4]"}
{"fix": "let _ = stringOfList (fun x -> string_of_int (x+1)) [1;2;3;4]", "bad": "let _ = stringOfList (fun x -> string_of_int x+1) [1;2;3;4]", "annotated": "let _ = stringOfList (fun x -> string_of_int x+1) [1;2;3;4]"}
{"fix": "let rec clone x n = \nlet f a x = List.append a x in\nlet base = [] in\nList.fold_right f x base", "bad": "let rec clone x n = \nlet f a x = List.append a x in\nlet base = [] in\nList.fold_right f x b", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nlet f a x = List.append a x in\nlet base = [] in\nList.fold_right f x b"}
{"fix": "let rec clone x n = \nlet aux acc n = \nif n  <= 0\nthen acc\nelse clone (List.append x acc) (n-1)\nin\naux [] n", "bad": "let _ = clone 3 5", "annotated": "let _ = clone 3 5"}
{"fix": "let rec clone x n = \nlet aux acc n = \nif n  <= 0\nthen acc\nelse clone (List.append x acc) (n-1)\nin\naux [] n", "bad": "let _ = clone \"foo\" 2", "annotated": "let _ = clone \"foo\" 2"}
{"fix": "let rec clone x n = \nlet aux acc n = \nif n  <= 0\nthen acc\nelse clone (List.append x acc) (n-1)\nin\naux [] n", "bad": "let _ = clone clone (-3)", "annotated": "let _ = clone clone (-3)"}
{"fix": "let rec clone x n = \nlet aux acc n = \nif n  <= 0\nthen acc\nelse clone (List.append acc x) (n-1)\nin\naux [] n", "bad": "let _ = clone 3 5", "annotated": "let _ = clone 3 5"}
{"fix": "let rec clone x n = \nlet aux acc n = \nif n  <= 0\nthen acc\nelse clone (List.append acc x) (n-1)\nin\naux [] n", "bad": "let _ = clone \"foo\" 2", "annotated": "let _ = clone \"foo\" 2"}
{"fix": "let rec clone x n = \nlet aux acc n = \nif n  <= 0\nthen acc\nelse clone (List.append x acc ) (n-1)\nin\naux [] n", "bad": "let rec clone x n = \nlet aux acc n = \nif n  <= 0\nthen acc\nelse clone (List.append [x] acc ) (n-1)\nin\naux [] n", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nlet aux acc n = \nif n  <= 0\nthen acc\nelse clone (List.append [x] acc ) (n-1)\nin\naux [] n"}
{"fix": "let rec clone x n = \nlet rec aux acc n = \nif n  <= 0\nthen acc\nelse aux (List.append [x] acc ) (n-1)\nin\naux [] n", "bad": "let rec clone x n = \nlet aux acc n = \nif n  <= 0\nthen acc\nelse clone (List.append [x] acc ) (n-1)\nin\naux [] n", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nlet aux acc n = \nif n  <= 0\nthen acc\nelse clone (List.append [x] acc ) (n-1)\nin\naux [] n"}
{"fix": "let rec clone x n = \nlet rec aux acc n = \nif n  <= 0\nthen acc\nelse aux (List.append [x] acc ) (n-1)\nin\naux [] n", "bad": "let rec clone x n = \nlet aux acc n = \nif n  <= 0\nthen acc\nelse aux (List.append [x] acc ) (n-1)\nin\naux [] n", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nlet aux acc n = \nif n  <= 0\nthen acc\nelse aux (List.append [x] acc ) (n-1)\nin\naux [] n"}
{"fix": "let _ = clone 2 (-1)", "bad": "let _ = clone 2 -1", "annotated": "let _ = clone 2 -1"}
{"fix": "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nif l1 < l2\nthen ((List.append (clone 0 (len2-len1)) l1), l2)\nelse (l1, (List.append (clone 0 (len1-len2)) l2))", "bad": "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nif l1 < l2\nthen ((List.append (clone 0 (len2-len1)) l1), l2)\nelse (l1, (List.append (clone 0 (len1-len2) l2)))", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nif l1 < l2\nthen ((List.append (clone 0 (len2-len1)) l1), l2)\nelse (l1, (List.append (clone 0 (len1-len2) l2)))"}
{"fix": "let _ = clone 4 (-12)", "bad": "let _ = List.append((clone 0 3) [1;2;3])", "annotated": "let _ = List.append((clone 0 3) [1;2;3])"}
{"fix": "let rec removeZero l = \nmatch l with\n| []   -> []\n| h::t ->\nif h == 0\nthen removeZero t\nelse l", "bad": "let bigMul l1 l2 = \nlet f a x =  \nlet (l, i) = x in\nlet (m, s) = a in\nlet result = bigAdd s ((mulByDigit i l)*m) in\n(m*10, result)\nin\nlet base = (1, []) in\nlet args = \nlet rec helper acc l1 l2 = \nmatch l2 with\n| []   -> acc\n| h::t -> helper (List.append [(l1,h)] acc) l1 t in\nhelper [] l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x =  \nlet (l, i) = x in\nlet (m, s) = a in\nlet result = bigAdd s ((mulByDigit i l)*m) in\n(m*10, result)\nin\nlet base = (1, []) in\nlet args = \nlet rec helper acc l1 l2 = \nmatch l2 with\n| []   -> acc\n| h::t -> helper (List.append [(l1,h)] acc) l1 t in\nhelper [] l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "bad": "let bigMul l1 l2 = \nlet f a x =  \nlet (l, i) = x in\nlet (m, s) = a in\nlet result = bigAdd s (List.append (mulByDigit i l) (clone 0 m)) in\n(m*10, result)\nin\nlet base = (1, []) in\nlet args = \nlet rec helper acc l1 l2 = \nmatch l2 with\n| []   -> acc\n| h::t -> helper (List.append [(l1,h)] acc) l1 t in\nhelper [] l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x =  \nlet (l, i) = x in\nlet (m, s) = a in\nlet result = bigAdd s (List.append (mulByDigit i l) (clone 0 m)) in\n(m*10, result)\nin\nlet base = (1, []) in\nlet args = \nlet rec helper acc l1 l2 = \nmatch l2 with\n| []   -> acc\n| h::t -> helper (List.append [(l1,h)] acc) l1 t in\nhelper [] l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| h::t -> if h = k then h else assoc(d,k,t)", "bad": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| h::t -> if h = k then return h else assoc(d,k,t)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| h::t -> if h = k then return h else assoc(d,k,t)"}
{"fix": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| h::t -> if h = k then h else assoc(d,k,t)", "bad": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| h::t -> if h = k then h else assoc(d,k,t)", "bad": "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| (ki,vi)::t -> if ki = k then vi else assoc(d,k,t)", "bad": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| (ki,vi)::t -> if ki = k then vi else assoc(d,k,t)", "bad": "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let buildOp2(a,b,a_less,b_less)    = Op2(a,b,a_less)", "bad": "let buildOp2()                     = Op2(e1,e2,e3)", "annotated": "let build: ((int * int -> int) * int) -> expr = fun Op2()                      ->  Op2(e1,e2,e3)"}
{"fix": "let buildOp2(a,b,a_less,b_less)    = Op2(a,b,a_less)", "bad": "let buildOp2(a,b,a_less,b_less)    = Op2(a,b,a_less,b_less)", "annotated": "let build: ((int * int -> int) * int) -> expr = fun Op2(a,b,a_less,b_less)     ->  Op2(a,b,a_less,b_less)"}
{"fix": "let rec build (rand, depth) = (*failwith \"to be implemented\" *) if depth = -1\nthen \nlet randNum = rand(1,2) in\nlet randNum2 = rand(3,4) in\nif (randNum = 1 && randNum2 = 3) then buildSine(buildOp1(buildX())) else\nif (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(  build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )", "bad": "let rec build (rand, depth) = (*failwith \"to be implemented\" *)\nlet randNum = rand(1,2) in\nlet randNum2 = rand(3,4) in\nif (randNum = 1 && randNum2 = 3) then buildSine(buildOp1(buildX())) else\nif (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(buildX(),buildY(),buildX())) else\nif (randNum = 2 && randNum2 = 3) then buildCosine(buildOp1(buildX())) else\nbuildCosine(buildOp2(buildY(),buildX(),buildY()))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  (*failwith \"to be implemented\" *)\nlet randNum = rand(1,2) in\nlet randNum2 = rand(3,4) in\nif (randNum = 1 && randNum2 = 3) then buildSine(buildOp1(buildX())) else\nif (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(buildX(),buildY(),buildX())) else\nif (randNum = 2 && randNum2 = 3) then buildCosine(buildOp1(buildX())) else\nbuildCosine(buildOp2(buildY(),buildX(),buildY()))"}
{"fix": "let rec build (rand, depth) = (*failwith \"to be implemented\" *) if depth > -1\nthen \nlet randNum = rand(1,2) in\nlet randNum2 = rand(3,4) in\nif (randNum = 1 && randNum2 = 3) then buildX() else\nif (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(  build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )", "bad": "let rec build (rand, depth) = (*failwith \"to be implemented\" *) if depth = -1\nthen \nlet randNum = rand(1,2) in\nlet randNum2 = rand(3,4) in\nif (randNum = 1 && randNum2 = 3) then buildX() else\nif (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(  build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = (*failwith \"to be implemented\" *) if depth  ->  -1\nthen \nlet randNum = rand(1,2) in\nlet randNum2 = rand(3,4) in\nif (randNum = 1 && randNum2 = 3) then buildX() else\nif (randNum = 1 && randNum2 = 4) then buildSine(buildOp2(  build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )"}
{"fix": "let rec build (rand, depth) = \nif depth = 0\nthen \nbuildSine(buildX())\nelse\nlet randNum = rand(1,2) in\nlet randNum2 = rand(1,2) in\nlet randNum3 = rand(1,2) in\nmatch (randNum, randNum2) with\n| (1,1) -> buildSine(build(rand, depth -1))\n| (2,2) -> buildCosine(build(rand, depth - 1))\n| _     -> match randNum3 with\n| 1 -> buildSine(buildOp2(  build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )\n| 2 -> buildCosine(buildOp2(build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )", "bad": "let rec build (rand, depth) = \nif depth = 0\nthen \nbuildSine(buildX())\nelse\nlet randNum = rand(1,2) in\nlet randNum2 = rand(1,2) in\nlet randNum3 = rand(1,2) in\nmatch (randNum, randNum2) with\n| (1,1) -> buildSine(buildX())\n| (2,2) -> buildCosine(buildX())\n| _     -> match randNum3 with\n| 1 -> buildSine(buildOp2(  build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )\n| 2 -> buildCosine(buildOp2(build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0\nthen \nbuildSine(buildX())\nelse\nlet randNum = rand(1,2) in\nlet randNum2 = rand(1,2) in\nlet randNum3 = rand(1,2) in\nmatch (randNum, randNum2) with\n| (1,1) -> buildSine(buildX())\n| (2,2) -> buildCosine(buildX())\n| _     -> match randNum3 with\n| 1 -> buildSine(buildOp2(  build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )\n| 2 -> buildCosine(buildOp2(build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| h::t -> let(s, x) = h in\nif (s = k) then x else assoc(d,k,t)", "bad": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| h::t -> let(s, x) = h\nif s = k then x else assoc(d,k,t)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  \nmatch l with \n| [] -> d\n| h::t -> let(s, x) = h\nif s = k then x else assoc(d,k,t)"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| h::t -> let(s, x) = h in\nif (s = k) then x else assoc(d,k,t)", "bad": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| h::t -> let(s, x) = h in\nif (s = k) then x else assoc(d,k,t)", "bad": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| h::t -> let(s, x) = h\nif (s = k) then x else assoc(d,k,t)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  \nmatch l with \n| [] -> d\n| h::t -> let(s, x) = h\nif (s = k) then x else assoc(d,k,t)"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| h::t -> let(s, x) = h in\nif (s = k) then x else assoc(d,k,t)", "bad": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let fixpoint (f,b) = \nlet f x = let xx = f(x) in (xx, xx = x) in \nwwhile (f,b)", "bad": "let fixpoint (f,b) = wwhile (((*failwith \"to be written\"*)fun x -> f(x), x = f(x)),b)\n\n(* uncomment after implementing fixpoint *)\n*\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (((*failwith \"to be written\"*)fun x -> f(x), x  ->  f(x)),b)\n\n(* uncomment after implementing fixpoint *)\n*\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = \nlet f x = let xx = f(x) in (xx, xx = x) in \nwwhile (f,b)", "bad": "let fixpoint (f,b) = wwhile ((let f x = let xx = f(x) in (xx, xx = x)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f x = let xx = f(x) in (xx, xx  ->  x)),b)"}
{"fix": "let fixpoint (f,b) = \nlet f x = let xx = f(x) in (xx, xx = x) in \nwwhile (f,b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nlet g x = let xx = f(x) in (xx, xx = x) in \nwwhile (g,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet g x = let xx = f(x) in (xx, xx = x) in \nwwhile (g,b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx = x)\nwwhile (g,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet g x = let xx = (f x) in (xx, xx = x)\nwwhile (g,b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx = x) in\nwwhile (g,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet g x = let xx = (f x) in (xx, xx = x) in\nwwhile (g,b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx != x) in\nwwhile (g,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet g x = let xx = (f x) in (xx, xx != x) in\nwwhile (g,b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y \n| Sine a -> sin(pi *. eval(a))\n| Cosine (a) -> cos(pi *. eval(a))\n| Average (a, b) -> ((eval(a) +. eval(b)) / 2)\n| Times (a, b) -> eval(a) *. eval(b)\n| Thresh (a, b, c, d) -> if(eval(a) < eval(b)) then  eval(c) else eval(d)", "bad": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y \n| Sine (a) -> sin(pi *. eval(a))\n| Cosine (a) -> cos(pi *. eval(a))\n| Average (a, b) -> (((eval(a) +. eval(b)) / 2)\n| Times (a, b) -> eval(a) *. eval(b)\n| Thresh (a, b, c, d) -> if(eval(a) < eval(b)) then  eval(c) else eval(d)\n(*failwith \"to be written\"*)\n\n\n(* uncomment after implementing eval*)\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with \n| VarX -> x\n| VarY -> y \n| Sine (a) -> sin(pi *. eval(a))\n| Cosine (a) -> cos(pi *. eval(a))\n| Average (a, b) -> (((eval(a) +. eval(b)) / 2)\n| Times (a, b) -> eval(a) *. eval(b)\n| Thresh (a, b, c, d) -> if(eval(a) < eval(b)) then  eval(c) else eval(d)\n(*failwith \"to be written\"*)\n\n\n(* uncomment after implementing eval*)\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)"}
{"fix": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y \n| Sine a -> sin(pi *. eval(a))\n| Cosine (a) -> cos(pi *. eval(a))\n| Average (a, b) -> ((eval(a) +. eval(b)) / 2)\n| Times (a, b) -> eval(a) *. eval(b)\n| Thresh (a, b, c, d) -> if(eval(a) < eval(b)) then  eval(c) else eval(d)", "bad": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y \n| Sine (a) -> sin(pi *. eval(a))\n| Cosine (a) -> cos(pi *. eval(a))\n| Average (a, b) -> ((eval(a) +. eval(b)) / 2)\n| Times (a, b) -> eval(a) *. eval(b)\n| Thresh (a, b, c, d) -> if(eval(a) < eval(b)) then  eval(c) else eval(d)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with \n| VarX -> x\n| VarY -> y \n| Sine (a) -> sin(pi *. eval(a))\n| Cosine (a) -> cos(pi *. eval(a))\n| Average (a, b) -> ((eval(a) +. eval(b)) / 2)\n| Times (a, b) -> eval(a) *. eval(b)\n| Thresh (a, b, c, d) -> if(eval(a) < eval(b)) then  eval(c) else eval(d)"}
{"fix": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y \n| Sine a -> sin(pi *. eval(a))\n| Cosine (a) -> cos(pi *. eval(a))\n| Average (a, b) -> ((eval(a) +. eval(b)) / 2)\n| Times (a, b) -> eval(a) *. eval(b)\n| Thresh (a, b, c, d) -> if(eval(a) < eval(b)) then  eval(c) else eval(d)", "bad": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)"}
{"fix": "let g1 () = failwith \"to be implemented\"", "bad": "let rec build (rand, depth) = \nif(depth = 0) then if(rand(0, 2) < 1) then buildX() else buildY() else let x = rand(0, 5) in\nif( x = 0) then buildSine(build(rand, (depth - 1))) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1))) else if( x = 4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif(depth = 0) then if(rand(0, 2) < 1) then build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  rand(0, 5) in\nif( x = 0) then build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))"}
{"fix": "let g1 () = failwith \"to be implemented\"", "bad": "let rec build (rand, depth) = \nif(depth = 0) then if(rand(0, 2) < 1) then buildX() else buildY() else let x = rand(0, 5) in\nif( x = 0) then buildSine(build(rand, (depth - 1))) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1))) else if( x = 4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif(depth = 0) then if(rand(0, 2) < 1) then build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  rand(0, 5) in\nif( x = 0) then build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))"}
{"fix": "let g1 () = failwith \"to be implemented\"", "bad": "let rec build (rand, depth) = \nif(depth = 0) then if(rand(0, 2) < 1) then buildX() else buildY() else let x = rand(0, 5) in\nif( x = 0) then buildSine(build(rand, (depth - 1))) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1)))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif(depth = 0) then if(rand(0, 2) < 1) then build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  rand(0, 5) in\nif( x = 0) then build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1)))"}
{"fix": "let g1 () = failwith \"to be implemented\"", "bad": "let rec build (rand, depth) = \nif(depth = 0) then if(rand(0, 2) < 1) then buildX() else buildY() else let x = rand(0, 5) in\n(*if( x = 0) then buildSine(build(rand, (depth - 1))) else if( x = 1) then buildCosine(build(rand, (depth -1))) else if( x = 2) then buildAverage(build(rand, (depth -1)), build(rand, (depth -1))) else if (x = 3) then buildTimes(build(rand, (depth -1)), build(rand, (depth -1))) else if( x = 4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))*)\nmatch x with\n| 0 -> buildSine(build(rand, (depth - 1)))\n| 1 -> buildCosine(build(rand, (depth -1)))\n| 2 -> buildAverage(build(rand, (depth -1)), build(rand, (depth -1)))\n| 3 -> buildTimes(build(rand, (depth -1)), build(rand, (depth -1)))\n| 4 -> buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif(depth = 0) then if(rand(0, 2) < 1) then build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  rand(0, 5) in\n(*if( x = 0) then build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  4) then buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))*)\nmatch x with\n| 0 -> buildSine(build(rand, (depth - 1)))\n| 1 -> buildCosine(build(rand, (depth -1)))\n| 2 -> buildAverage(build(rand, (depth -1)), build(rand, (depth -1)))\n| 3 -> buildTimes(build(rand, (depth -1)), build(rand, (depth -1)))\n| 4 -> buildThresh(build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)), build(rand, (depth -1)))"}
{"fix": "let _ = sumList []", "bad": "let _ = sumList 1", "annotated": "let _ = sumList 1"}
{"fix": "let rec additivePersAndRoot xs pers =\nlet theSum = sumList xs in\nif theSum < 10 then (pers, theSum)\nelse additivePersAndRoot (digits theSum) (pers + 1)", "bad": "let rec additivePersAndRoot xs pers =\nlet theSum = sumList xs;\nlet nextArr = digits theSum in \nif (sumList xs) < 10 then (pers, theSum)\nelse additivePersAndRoot(nextArr (pers + 1))", "annotated": "let rec additivePersAndRoot xs pers =\nlet theSum = sumList xs;\nlet nextArr = digits theSum in \nif (sumList xs) < 10 then (pers, theSum)\nelse additivePersAndRoot(nextArr (pers + 1))"}
{"fix": "let rec additivePersAndRoot xs pers =\nlet theSum = sumList xs in\nif theSum < 10 then (pers, theSum)\nelse additivePersAndRoot (digits theSum) (pers + 1)", "bad": "let _ = additivePersAndRoot [1, 1] 0", "annotated": "let _ = additivePersAndRoot [1, 1] 0"}
{"fix": "let rec additivePersAndRoot xs pers =\nlet theSum = sumList xs in\nif theSum < 10 then (pers, theSum)\nelse additivePersAndRoot (digits theSum) (pers + 1)", "bad": "let rec additivePersAndRoot xs pers =\nlet theSum = sumList xs", "annotated": "let rec additivePersAndRoot xs pers =\nlet theSum = sumList xs"}
{"fix": "let rec additivePersAndRoot xs pers =\nlet theSum = sumList xs in\nif theSum < 10 then (pers, theSum)\nelse additivePersAndRoot (digits theSum) (pers + 1)", "bad": "let nextArr = digits theSum in \nif (sumList xs) < 10 then (pers, theSum)\nelse additivePersAndRoot(nextArr (pers + 1))", "annotated": "let nextArr = digits theSum in \nif (sumList xs) < 10 then (pers, theSum)\nelse additivePersAndRoot(nextArr (pers + 1))"}
{"fix": "let rec additivePersAndRoot xs pers =\nlet theSum = sumList xs in\nif theSum < 10 then (pers, theSum)\nelse additivePersAndRoot (digits theSum) (pers + 1)", "bad": "let rec additivePersAndRoot xs pers =\nlet theSum = sumList xs;\nlet nextArr = digits theSum in \nif (sumList xs) < 10 then (pers, theSum)\nelse additivePersAndRoot(nextArr (pers + 1))", "annotated": "let rec additivePersAndRoot xs pers =\nlet theSum = sumList xs;\nlet nextArr = digits theSum in \nif (sumList xs) < 10 then (pers, theSum)\nelse additivePersAndRoot(nextArr (pers + 1))"}
{"fix": "let rec additivePersAndRoot xs pers =\nlet theSum = sumList xs in\nif theSum < 10 then (pers, theSum)\nelse additivePersAndRoot (digits theSum) (pers + 1)", "bad": "let rec additivePersAndRoot xs pers =\nlet theSum = sumList xs in\nif theSum < 10 then (pers, theSum)\nelse additivePersAndRoot((digits theSum) (pers + 1))", "annotated": "let rec additivePersAndRoot xs pers =\nlet theSum = sumList xs in\nif theSum < 10 then (pers, theSum)\nelse additivePersAndRoot((digits theSum) (pers + 1))"}
{"fix": "let rec listReverse l = \nmatch l with\n[] -> []\n| r::h ->\n(listReverse h) @ [r]", "bad": "let rec listReverse l = \nmatch l with\n[] -> []\n| r:h ->\n(listReverse h) @ [r]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n[] -> []\n| r:h ->\n(listReverse h) @ [r]"}
{"fix": "let rec listReverse l = \nmatch l with\n[] -> []\n| r::h ->\n(listReverse h) @ [r]", "bad": "let rec listReverse l = \nmatch l with\n[] -> []\n| r:h ->\n(listReverse h) @ [r]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n[] -> []\n| r:h ->\n(listReverse h) @ [r]"}
{"fix": "let rec lasts w =\nlet l::h = w in\nmatch h with\n[] -> l\n| r::h ->\nlasts h", "bad": "let palindrome w = \nlet ex = explode w in\nex[0] && ex[", "annotated": "let palindrome : string -> bool = fun  w  ->  \nlet ex = explode w in\nex[0] && ex["}
{"fix": "let rec lasts w =\nlet l::h = w in\nmatch h with\n[] -> l\n| r::h ->\nlasts h", "bad": "end", "annotated": "end"}
{"fix": "let rec lasts w =\nlet l::h = w in\nmatch h with\n[] -> l\n| r::h ->\nlasts h", "bad": "]", "annotated": "]"}
{"fix": "let rec lasts w =\nlet l::h = w in\nmatch h with\n[] -> l\n| r::h ->\nlasts h", "bad": "let palindrome w = \nlet ex = explode w in\nex[0] && ex[_end]", "annotated": "let palindrome : string -> bool = fun  w  ->  \nlet ex = explode w in\nex[0] && ex[_end]"}
{"fix": "let palindrome w = \nlet ex = explode w in\nlet revex = listReverse ex in\nex = revex", "bad": "let palindrome w = \nlet ex = explode w in\nlet revex = listReverese ex in\nex = revex", "annotated": "let palindrome : string -> bool = fun  w  ->  \nlet ex = explode w in\nlet revex = listReverese ex in\nex = revex"}
{"fix": "let palindrome w = \nlet ex = explode w in\nlet revex = listReverse ex in\nex = revex", "bad": "let palindrome w = \nlet ex = explode w in\nlet revex = listReverese ex in\nex = revex", "annotated": "let palindrome : string -> bool = fun  w  ->  \nlet ex = explode w in\nlet revex = listReverese ex in\nex = revex"}
{"fix": "let rec digitsOfInt n =\nif n <= 0 then []\nelse \ndigitsOfInt (n / 10) @ (n mod 10)", "bad": "let rec digitsOfInt n =\nif n <= 0 then []\nelse \nlet next_tail = digitsOfInt (n / 10) in\nmatch next_tail with\nx::xs -> \nxs @ [x :: (n mod 10)]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n <= 0 then []\nelse \nlet next_tail = digitsOfInt (n / 10) in\nmatch next_tail with\nx::xs -> \nxs @ [x :: (n mod 10)]"}
{"fix": "let rec digitsOfInt n =\nif n <= 0 then []\nelse (digitsOfInt (n / 10)) @ [n mod 10]", "bad": "let rec digitsOfInt n =\nif n <= 0 then []\nelse (digitsOfInt (n / 10)) :: (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n <= 0 then []\nelse (digitsOfInt (n / 10)) :: (n mod 10)"}
{"fix": "let _ = additivePersistence (-9876)", "bad": "let _ = additivePersistence -9860", "annotated": "let _ = additivePersistence -9860"}
{"fix": "let _ = additivePersistence (abs (-9876))", "bad": "let _ = additivePersistence abs (-9876)", "annotated": "let _ = additivePersistence abs (-9876)"}
{"fix": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "bad": "let rec assoc (d,k,l) = \nmatch l with\n| (ki, vi)::tl  -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _\t\t-> d", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  \nmatch l with\n| (ki, vi)::tl  -> \nif ki = k then\nvi\nelse\nassoc (d,k,tl)\n| _\t\t-> d"}
{"fix": "let _ = assoc (-1,123, [(123, 1)])", "bad": "let _ = assoc (-1,\"d\", [(\"d\", 1)])", "annotated": "let _ = assoc (-1,\"d\", [(\"d\", 1)])"}
{"fix": "let _ = assoc ([], 123, [(123, \"sad\"); (321, \"happy\")])", "bad": "let _ = assoc (\"null\",123, [(123, \"sad\"; (321, \"happy\")])", "annotated": "let _ = assoc (\"null\",123, [(123, \"sad\"; (321, \"happy\")])"}
{"fix": "let _ = assoc ([], 123, [(123, \"sad\"); (321, \"happy\")])", "bad": "let _ = assoc (\"null\", 123, [(123, \"sad\"); (321, \"happy\")])", "annotated": "let _ = assoc (\"null\", 123, [(123, \"sad\"); (321, \"happy\")])"}
{"fix": "let _ = assoc ('c', 123, [(123, \"sad\"); (321, \"happy\")])", "bad": "let _ = assoc (\"null\", 123, [(123, \"sad\"); (321, \"happy\")])", "annotated": "let _ = assoc (\"null\", 123, [(123, \"sad\"); (321, \"happy\")])"}
{"fix": "let long_list = \nlet rec assemble n l = \nif n < 10000000 then\nassemble (n+1) ((string_of_int(n), n) :: l)\nelse\nl\nin\nassemble 1 []", "bad": "let _ = assoc (\"null\", 123, [(123, \"sad\"); (321, \"happy\")])", "annotated": "let _ = assoc (\"null\", 123, [(123, \"sad\"); (321, \"happy\")])"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile ((f),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((f),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((f b),b)", "bad": "let fixpoint (f,b) = wwhile ((f (=)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((f ( -> )),b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile ((let g h x = let xx = h x in (xx, x != xx) in g f),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g h x = let xx = h x in (xx, x ! ->  xx) in g f),b)"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> if (eval(e1, x, y) < eval(e2, x, y)) then eval(e3, x, y) else eval(e4, x, y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> if (eval(e1, x, y) < eval(e2, x, y)) then eval(e3, x, y) else eval(e4, x, y)"}
{"fix": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| _ -> randX()", "bad": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildAverage(first_forced, build(rand, depth - 1), build(rand, depth - 1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildAverage(first_forced, build(rand, depth - 1), build(rand, depth - 1))"}
{"fix": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| _ -> randX()", "bad": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1))"}
{"fix": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| _ -> randX()", "bad": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))"}
{"fix": "set _ = build(rand, 5)", "bad": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| _ -> randX()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| _ -> randX()"}
{"fix": "set _ = build(rand, 5)", "bad": "let rec build (rand, depth) = \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse buildY()   (* bin_rand = 2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| _ -> buildX()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth <= 0 then\nlet bin_rand = rand(1, 2) in\nif bin_rand = 1 then buildX()\nelse build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  2 *)\nelse \nlet exp_rand = rand(1, 5) in\nlet first_forced = build(rand, depth - 1) in\nmatch exp_rand with\n| 1 -> buildSine(first_forced)\n| 2 -> buildCosine(first_forced)\n| 3 -> buildAverage(first_forced, build(rand, depth - 1))\n| 4 -> buildTimes(first_forced, build(rand, depth - 1))\n| 5 -> buildThresh(first_forced, build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))\n| _ -> buildX()"}
{"fix": "let _ = build(makeRand, 5)", "bad": "let _ = build(rand, 5)", "annotated": "let _ = build(rand, 5)"}
{"fix": "let _ = build(makeRand, 5)", "bad": "let _ = build(makeRand, 5)", "annotated": "let _ = build(makeRand, 5)"}
{"fix": "let pi = 4.0 *. atan 1.0", "bad": "let buildAcossin(e1,e2)\t\t   = Acossin(e1,e2)", "annotated": "let build: ((int * int -> int) * int) -> expr = fun Acossin(e1,e2)\t\t    ->  Acossin(e1,e2)"}
{"fix": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)"}
{"fix": "let pipe fs = \nlet f a x = (+) (x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (+) (x a) in\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (+) (x a) in\nlet base = 0 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (+) (x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (+) (a x) in\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (+) (a x) in\nlet base = 0 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = a in\nlet base =  0 in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = (fun a -> a) in\nlet base =  (fun x -> x) in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = (fun a -> a) in\nlet base =  (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (fun a -> a) in\nlet base =  0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (fun a -> a) in\nlet base =  0 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base =  0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (fun r s -> a) in\nlet base =  (fun r s -> 0) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (fun r s -> a) in\nlet base =  (fun r s -> 0) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base =  0 in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base =  (fun x -> []) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base =  (fun) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base =  (fun) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base =  (fun x -> []) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base =  (fun n -> ) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base =  (fun n -> ) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base =  (fun n -> n) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base =  (fun x -> ) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base =  (fun x -> ) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base =  (fun n -> n) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base =  (fun -> y) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base =  (fun -> y) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base =  (fun n -> n) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base =  (fun y) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base =  (fun y) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base =  (fun n -> n) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base =  (fun n -> n) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base =  (fun n -> n) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (fun y -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (fun y -> x a) in\nlet base =  in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (fun y -> x a) in\nlet base =  in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (fun y -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (fun y -> x a) in\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (fun y -> x a) in\nlet base = 0 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (fun _ -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (fun -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (fun -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (fun _ -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (fun _ -> x a) in\nlet base = (fun _ -> _) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (fun _ -> x a) in\nlet base = (fun _ -> _) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (fun _ -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (fun _ -> x a) in\nlet base = [] in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (fun _ -> x a) in\nlet base = [] in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (fun _ -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (fun _ -> x a) in\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (fun _ -> x a) in\nlet base = 0 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (fun _ -> x) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (fun _ -> a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (fun _ -> a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (fun y -> x y) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = (let myfun = x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (let rec = x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (let rec = x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (let myfun = x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (let myfun = x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (let myfun = x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (let myfun = x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (let myfun _ = x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (let myfun _ = x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (let myfun = x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (let myfun = (x a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (let myfun = (x a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (let myfun = x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (let myfun x a = x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (let myfun x a = x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (let myfun = x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (let myfun x a -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (let myfun x a -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (let myfun = x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (let myfun = x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (let myfun = x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (let myfun = x a in myfun) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (let rec myfun = x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (let rec myfun = x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (a x) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (a x) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (fun y -> x) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (fun y -> (y a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (fun y -> (y a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (fun y -> x) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (fun y -> a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (fun y -> a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (fun _ -> (x a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (fun y -> x -> (x a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (fun y -> x -> (x a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (fun _ -> (x a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (fun _ x -> (x a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (fun _ x -> (x a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun _ -> 0) in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun _ -> 0) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (x a) in\nlet base = (fun) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun _ -> 0) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun _ -> base) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (x a) in\nlet base = (fun _ -> base) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun y -> y ) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun y -> y -> 0) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (x a) in\nlet base = (fun y -> y -> 0) in\nList.fold_left f base fs"}
{"fix": "let _ = pipe [] 3", "bad": "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3"}
{"fix": "let _ = pipe [] 3", "bad": "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3"}
{"fix": "let _ = pipe [] 3", "bad": "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = (x (x a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (x (a a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (x (a a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (x (x a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (x (a x)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (x (a x)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (x (a)) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (x (a)) in\nlet base = (fn y -> y) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (x (a)) in\nlet base = (fn y -> y) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = (x a) in\nlet base = (f) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun _ -> y) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (x a) in\nlet base = (fun _ -> y) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (x a) in\nlet base = (f) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (x a) in\nlet base = (f a) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (x a) in\nlet base = (f a) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)]", "annotated": "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)]"}
{"fix": "let pipe fs = \nlet f a x = (fun _ -> x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = (fun z -> a z) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (fun z -> z a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (fun z -> z a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x a in\nlet base = \"\" in\nlet l = [fun x -> x ^ sep] in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x a in\nlet base = \"\" in\nlet l = (^) sep in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x a in\nlet base = \"\" in\nlet l = (^) sep in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x a in\nlet base = \"\" in\nlet l = [fun x -> x ^ sep] in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x a in\nlet base = \"\" in\nlet l = fun x -> x ^ sep in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x a in\nlet base = \"\" in\nlet l = fun x -> x ^ sep in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base = \"\" in\nlet l = [fun x -> x ^ sep] in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base = \"\" in\nlet l = [fun x -> x ^ sep] in\nList.fold_left f base l"}
{"fix": "let stringOfList f l = \nmatch l with\n| []    -> \"[]\"\n| x::xs ->\nlet g a x = a ^ \"; \" ^ (f x) in\nlet base = f x in\nList.fold_left g base xs", "bad": "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "annotated": "let _ = stringOfList string_of_int [1;2;3;4;5;6]"}
{"fix": "let stringOfList f l = \nmatch l with\n| []    -> \"[]\"\n| x::xs ->\nlet g a x = a ^ \"; \" ^ (f x) in\nlet base = f x in\nList.fold_left g base xs", "bad": "let stringOfList f l = \nmatch l with\n| []    -> \"[]\"\n| x::xs ->\nlet g a x = a ^ \"; \" ^ (f x) in\nlet base = f x in\nList.fold_left f base xs", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \nmatch l with\n| []    -> \"[]\"\n| x::xs ->\nlet g a x = a ^ \"; \" ^ (f x) in\nlet base = f x in\nList.fold_left f base xs"}
{"fix": "let rec clone x n =\nlet rec clone_RT acc n =\nif n <= 0 then \nacc\nelse \nclone_RT (x::acc) (n-1)\nin\nclone_RT [] n", "bad": "let rec clone x n =\nlet rec clone_RT acc n =\nif n <= 0 then acc\nelse clone (x::acc) (n-1)\nin\nclone_RT [] n", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  -> \nlet rec clone : 'a -> int -> 'a list = fun  x n  -> \nif n <= 0 then acc\nelse clone (x::acc) (n-1)\nin\nclone_RT [] n"}
{"fix": "let rec clone x n =\nlet rec clone_RT acc n =\nif n <= 0 then \nacc\nelse \nclone_RT (x::acc) (n-1)\nin\nclone_RT [] n", "bad": "let rec clone x n =\nlet rec clone_RT acc n =\nif n <= 0 then \nacc\nelse \nclone (x::acc) (n-1)\nin\nclone_RT [] n", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  -> \nlet rec clone : 'a -> int -> 'a list = fun  x n  -> \nif n <= 0 then \nacc\nelse \nclone (x::acc) (n-1)\nin\nclone_RT [] n"}
{"fix": "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nlet diff = len1 - len2 in\nif diff < 0 then\n(List.append (clone 0 (-diff)) l1, l2)\nelse\n(List.append (clone 0 diff) l2, l1)", "bad": "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nlet diff = len1 - len2 in\nif diff < 0 then\nList.append (List.append ((clone 0 (-diff)), len1), len2)\nelse\nList.append (List.append (clone 0 (diff), len2), len1)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nlet diff = len1 - len2 in\nif diff < 0 then\nList.append (List.append ((clone 0 (-diff)), len1), len2)\nelse\nList.append (List.append (clone 0 (diff), len2), len1)"}
{"fix": "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nlet diff = len1 - len2 in\nif diff < 0 then\n(List.append (clone 0 (-diff)) l1, l2)\nelse\n(List.append (clone 0 diff) l2, l1)", "bad": "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nlet diff = len1 - len2 in\nif diff < 0 then\nList.append (List.append ((clone 0 (-diff)), len1), len2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nlet diff = len1 - len2 in\nif diff < 0 then\nList.append (List.append ((clone 0 (-diff)), len1), len2)"}
{"fix": "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nlet diff = len1 - len2 in\nif diff < 0 then\n(List.append (clone 0 (-diff)) l1, l2)\nelse\n(List.append (clone 0 diff) l2, l1)", "bad": ")\nelse\nList.append (List.append (clone 0 (diff), len2), len1)", "annotated": ")\nelse\nList.append (List.append (clone 0 (diff), len2), len1)"}
{"fix": "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nlet diff = len1 - len2 in\nif diff < 0 then\n(List.append (clone 0 (-diff)) l1, l2)\nelse\n(List.append (clone 0 diff) l2, l1)", "bad": "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nlet diff = len1 - len2 in\nif diff < 0 then\n(List.append (clone 0 (-diff), len1), len2)\nelse\n(List.append (clone 0 (diff), len2), len1)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nlet diff = len1 - len2 in\nif diff < 0 then\n(List.append (clone 0 (-diff), len1), len2)\nelse\n(List.append (clone 0 (diff), len2), len1)"}
{"fix": "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nlet diff = len1 - len2 in\nif diff < 0 then\n(List.append (clone 0 (-diff)) l1, l2)\nelse\n(List.append (clone 0 diff) l2, l1)", "bad": "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nlet diff = len1 - len2 in\nif diff < 0 then\n(List.append (clone 0 (-diff)) len1, len2)\nelse\n(List.append (clone 0 diff) len2, len1)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nlet diff = len1 - len2 in\nif diff < 0 then\n(List.append (clone 0 (-diff)) len1, len2)\nelse\n(List.append (clone 0 diff) len2, len1)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = ([0], [0]) in\nlet base = ([0], [0]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = 0 in\nlet base = 0 in\nlet args = (l1, l1) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = 0 in\nlet base = 0 in\nlet args = (l1, l1) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = ([0], [0]) in\nlet base = ([0], [0]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (1,2) in\nlet base = 0 in\nlet args = (l1, l1) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = (1,2) in\nlet base = 0 in\nlet args = (l1, l1) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = ([0], [0]) in\nlet base = ([0], [0]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (0, 0) in\nlet base = (0, 0) in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = (0, 0) in\nlet base = (0, 0) in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = ([0], [0]) in\nlet base = ([0], [0]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (0, 0) in\nlet base = (0, 0) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = (0, 0) in\nlet base = (0, 0) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (0, []) in\nlet base = (0, []) in\nlet args = (clone 0 (List.length l1)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = ([0], [0]) in\nlet base = ([0], [0]) in\nlet args = (l1, 2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = ([0], [0]) in\nlet base = ([0], [0]) in\nlet args = (l1, 2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (0, []) in\nlet base = (0, []) in\nlet args = (clone 0 (List.length l1)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = ([0], [0]) in\nlet base = ([0], [0]) in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = ([0], [0]) in\nlet base = ([0], [0]) in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (0, []) in\nlet base = (0, []) in\nlet args = (clone 0 (List.length l1)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = ([0], [0]) in\nlet base = (0, 0) in\nlet args = (0, clone 0 List.length l1) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = ([0], [0]) in\nlet base = (0, 0) in\nlet args = (0, clone 0 List.length l1) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (0, []) in\nlet base = (0, []) in\nlet args = (clone 0 (List.length l1)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = ([0], [0]) in\nlet base = (0, []) in\nlet args = (0, clone 0 List.length l1) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = ([0], [0]) in\nlet base = (0, []) in\nlet args = (0, clone 0 List.length l1) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (0, []) in\nlet base = (0, []) in\nlet args = (clone 0 (List.length l1)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (0, []) in\nlet base = (0, []) in\nlet args = (0, clone 0 List.length l1) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = (0, []) in\nlet base = (0, []) in\nlet args = (0, clone 0 List.length l1) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (0, []) in\nlet base = (0, []) in\nlet args = (clone 0 (List.length l1)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (0, []) in\nlet base = (0, []) in\nlet args = (0, clone 0 (List.length l1)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = (0, []) in\nlet base = (0, []) in\nlet args = (0, clone 0 (List.length l1)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \n(t, (h + x)::y)\nin\nlet base = (List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \nlet sum = h + x in\n(t, sum::y)", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \nlet sum = h + x in\n(t, sum::y)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \n(t, (h + x)::y)\nin\nlet base = (List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let base = (List.reverse l1, []) in\nlet args = List.reverse l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let base = (List.reverse l1, []) in\nlet args = List.reverse l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \n(t, (h + x)::y)\nin\nlet base = (List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \nlet sum = h + x in\n(t, sum::y)", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \nlet sum = h + x in\n(t, sum::y)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \n(t, (h + x)::y)\nin\nlet base = (List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let base = (List.reverse l1, []) in\nlet args = List.reverse l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let base = (List.reverse l1, []) in\nlet args = List.reverse l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \n(t, (h + x)::y)\nin\nlet base = (List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \nlet sum =  in\n(t, (h + x)::y) in\nlet base = (List.reverse l1, []) in\nlet args = List.reverse l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \nlet sum =  in\n(t, (h + x)::y) in\nlet base = (List.reverse l1, []) in\nlet args = List.reverse l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \n(t, (h + x)::y)\nin\nlet base = (List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \nlet sum = \n(t, (h + x)::y) in\nlet base = (List.reverse l1, []) in\nlet args = List.reverse l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \nlet sum = \n(t, (h + x)::y) in\nlet base = (List.reverse l1, []) in\nlet args = List.reverse l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \n(t, (h + x)::y)\nin\nlet base = (List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \nlet sum = \n(t, (h + x)::y) in\nlet base = (List.reverse l1, []) in\nlet args = List.reverse l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \nlet sum = \n(t, (h + x)::y) in\nlet base = (List.reverse l1, []) in\nlet args = List.reverse l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \n(t, (h + x)::y)\nin\nlet base = (List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \n(t, (h + x)::y)\nin\nlet base = (List.reverse l1, []) in\nlet args = List.reverse l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \n(t, (h + x)::y)\nin\nlet base = (List.reverse l1, []) in\nlet args = List.reverse l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \n(t, (h + x)::y)\nin\nlet base = (List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \n(t, (h + x)::y)\nin\nlet base = (List.rev l1, []) in\nlet args = List.reverse l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| ([], y) -> ([], y) \n| (h::t, y) -> \n(t, (h + x)::y)\nin\nlet base = (List.rev l1, []) in\nlet args = List.reverse l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([], _), y) -> (([], 0), y) \n| ((h::t, carry), y) -> \nlet sum = h + x in\n((t, sum / 10), (sum mod 10)::y)\nin\nlet base = ((List.rev l1, 0), []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([], _), y) -> (([], 0), y) \n| ((h::t, carry), y) -> \nlet sum = h + x in\n((t, sum / 10), (sum mod 10)::y)\nin\nlet base = ((List.rev l1, carry), []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| (([], _), y) -> (([], 0), y) \n| ((h::t, carry), y) -> \nlet sum = h + x in\n((t, sum / 10), (sum mod 10)::y)\nin\nlet base = ((List.rev l1, carry), []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([], _), y) -> (([], 0), y) \n| ((h::t, carry), y) -> \nlet sum = h + x + carry in\n((t, sum / 10), (sum mod 10)::y)\nin\nlet base = ((0::(List.rev l1), 0), []) in\nlet args = 0::(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([], _), y) -> (([], 0), y) \n| ((h::t, carry), y) -> \nlet sum = h + x + carry in\n((t, sum / 10), (sum mod 10)::y)\nin\nlet base = (0::(List.rev l1, 0), []) in\nlet args = 0::(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| (([], _), y) -> (([], 0), y) \n| ((h::t, carry), y) -> \nlet sum = h + x + carry in\n((t, sum / 10), (sum mod 10)::y)\nin\nlet base = (0::(List.rev l1, 0), []) in\nlet args = 0::(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([], _), y) -> (([], 0), y) \n| ((h::t, carry), y) -> \nlet sum = h + x + carry in\n((t, sum / 10), (sum mod 10)::y)\nin\nlet base = ((0::(List.rev l1), 0), []) in\nlet args = 0::(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([], _), y) -> (([], 0), y) \n| ((h::t, carry), y) -> \nlet sum = h + x + carry in\n((t, sum / 10), (sum mod 10)::y)\nin\nlet base = (0::(List.rev l1), 0), []", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| (([], _), y) -> (([], 0), y) \n| ((h::t, carry), y) -> \nlet sum = h + x + carry in\n((t, sum / 10), (sum mod 10)::y)\nin\nlet base = (0::(List.rev l1), 0), []"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([], _), y) -> (([], 0), y) \n| ((h::t, carry), y) -> \nlet sum = h + x + carry in\n((t, sum / 10), (sum mod 10)::y)\nin\nlet base = ((List.rev (0::l1), 0), []) in\nlet args = List.rev (0::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([], _), y) -> (([], 0), y) \n| ((h::t, carry), y) -> \nlet sum = h + x + carry in\n((t, sum / 10), (sum mod 10)::y)\nin\nlet base = ((List.rev 0::l1, 0), []) in\nlet args = List.rev 0::l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| (([], _), y) -> (([], 0), y) \n| ((h::t, carry), y) -> \nlet sum = h + x + carry in\n((t, sum / 10), (sum mod 10)::y)\nin\nlet base = ((List.rev 0::l1, 0), []) in\nlet args = List.rev 0::l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let _ = bigAdd [-1] [-2; -3]", "bad": "let _ = bigAdd [-1] [-2, -3]", "annotated": "let _ = bigAdd [-1] [-2, -3]"}
{"fix": "let rec mulByDigit i l = \nlet rec mulByDigit_RT i acc =\nif i = 1 then acc\nelse mulByDigit_RT (i-1) (bigAdd acc l)\nin\nmulByDigit_RT i []", "bad": "let rec mulByDigit i l = \nlet mulByDigit_RT i acc =\nif i = 1 then acc\nelse mulByDigit_RT (i-1) (bigAdd acc l)\nin\nmulByDigit_RT i []", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet mulByDigit : int -> int list -> int list  = fun  i l  -> \nif i = 1 then acc\nelse mulByDigit_RT (i-1) (bigAdd acc l)\nin\nmulByDigit_RT i []"}
{"fix": "let bigMul l1 l2 = \nlet f a x = match a with\n| (i, acc) -> \nlet digmul = mulByDigit (i * x) l2 in\n(i * 10, bigAdd digmul acc)\n| _ -> failwith \"wtf\" in\nlet base = (1, []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = match a with\n| (i, acc) -> ([], acc) \n| _ -> failwith \"wtf\" in\nlet base = (0, []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match a with\n| (i, acc) -> ([], acc) \n| _ -> failwith \"wtf\" in\nlet base = (0, []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let _ = sepConcat \"X\" [\"hello\"]", "bad": "let _ = sepConcat \"X\" [\"hello\"]\n\n\n(sepConcat \"; \")", "annotated": "let _ = sepConcat \"X\" [\"hello\"]\n\n\n(sepConcat \"; \")"}
{"fix": "let stringOfList f l = \n\"[\" ^ (stringOfList f (List.map f l)) ^ \"]\"", "bad": "let stringOfList f l = \n\"[\" ^ List map f (List.map f l) ^ \"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \n\"[\" ^ List map f (List.map f l) ^ \"]\""}
{"fix": "let stringOfList f l = \n\"[\" ^ (stringOfList f (List.map f l)) ^ \"]\"", "bad": "let stringOfList f l = \n\"[\" ^ stringOfList (List.map f l) ^ \"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \n\"[\" ^ stringOfList (List.map f l) ^ \"]\""}
{"fix": "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "bad": "sepConcat \"; \" [[1;0];[2];[3]]", "annotated": "sepConcat \"; \" [[1;0];[2];[3]]"}
{"fix": "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "bad": "List.map string_of_int [[1;0];[2];[3]]", "annotated": "List.map string_of_int [[1;0];[2];[3]]"}
{"fix": "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "bad": "sepConcat \"; \" [[1;0];[2];[3]]", "annotated": "sepConcat \"; \" [[1;0];[2];[3]]"}
{"fix": "let stringOfList f l = (List.map f l);", "bad": "let stringOfList f l = \"[\" ^ (List.map f l) ^ \"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\" ^ (List.map f l) ^ \"]\""}
{"fix": "let _ = bigMul [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9] []", "bad": "let _ = bigMul [1] [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9]", "annotated": "let _ = bigMul [1] [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9]"}
{"fix": "let _ = bigMul [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9] []", "bad": "let _ = bigMul [10] [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9]", "annotated": "let _ = bigMul [10] [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9]"}
{"fix": "let _ = bigMul [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9] []", "bad": "let _ = bigMul [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9] [10]", "annotated": "let _ = bigMul [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6;7;9;1;2;0;3;9] [10]"}
{"fix": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = mulByDigit 9 [9;9;9;9]", "annotated": "let _ = mulByDigit 9 [9;9;9;9]"}
{"fix": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet (i, acc) = a in\nlet digmul = mulByDigit (i * x) l2 in\n(i * 10, bigAdd digmul acc) in\nlet base = (1, []) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet (i, acc) = a in\nlet digmul = mulByDigit (i * x) l2 in\n(i * 10, bigAdd digmul acc) in\nlet base = (1, []) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "annotated": "let _ = bigMul [9;9;9;9] [9;9;9;9]"}
{"fix": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]", "annotated": "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]"}
{"fix": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigMul [1;2] [3;4]", "annotated": "let _ = bigMul [1;2] [3;4]"}
{"fix": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigMul [1;2;3] [9;9]", "annotated": "let _ = bigMul [1;2;3] [9;9]"}
{"fix": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigMul [4;1;3] [4;2;4;5;0;8;9]", "annotated": "let _ = bigMul [4;1;3] [4;2;4;5;0;8;9]"}
{"fix": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigMul [] [0]", "annotated": "let _ = bigMul [] [0]"}
{"fix": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigMul [0] []", "annotated": "let _ = bigMul [0] []"}
{"fix": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigMul [] []", "annotated": "let _ = bigMul [] []"}
{"fix": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigMul [1;2;3] [0]", "annotated": "let _ = bigMul [1;2;3] [0]"}
{"fix": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigMul [0] [2;3;4]", "annotated": "let _ = bigMul [0] [2;3;4]"}
{"fix": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigMul [1;9;4;5;2;3] []", "annotated": "let _ = bigMul [1;9;4;5;2;3] []"}
{"fix": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigMul [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6] []", "annotated": "let _ = bigMul [1;9;4;5;2;3;7;4;8;1;2;9;5;8;1;0;0;5;4;6] []"}
{"fix": "let rec digitsOfInt n = \nif n <= 0 then []\nelse n mod 10 :: digitsOfInt (n / 10)", "bad": "let rec digitsOfInt n myList = \nif (n <= 0)\nthen myList\nelse digitsOfInt (n/10)  (n mod 10 ::myList)\nmatch n with \n| 0 -> [0]\n| _ -> digitsOfInt n []", "annotated": "let rec digitsOfInt : int -> int list = fun  n myList  ->  \nif (n <= 0)\nthen myList\nelse digitsOfInt (n/10)  (n mod 10 ::myList)\nmatch n with \n| 0 -> [0]\n| _ -> digitsOfInt n []"}
{"fix": "let rec digitsOfInt n = \nif n <= 0 then []\nelse n mod 10 :: digitsOfInt (n / 10)", "bad": "let rec digitsOfInt n myList = match n with\n| n <= 0 -> []\n| _      -> n mod 10 :: digitsOfInt (n / 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n myList  ->  match n with\n| n <= 0 -> []\n| _      -> n mod 10 :: digitsOfInt (n / 10)"}
{"fix": "let rec digitsOfInt n = \nif n <= 0 then []\nelse n mod 10 :: digitsOfInt (n / 10)", "bad": "let rec digitsOfInt n = match n with\n| n <= 0 -> []\n| _      -> n mod 10 :: digitsOfInt (n / 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  match n with\n| n <= 0 -> []\n| _      -> n mod 10 :: digitsOfInt (n / 10)"}
{"fix": "let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num", "bad": "let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \nlet myList = digits n in\nlet num = sumList n in\nnum + additivePersistence num", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif (n < 10) \nthen 0\nelse \nlet myList = digits n in\nlet num = sumList n in\nnum + additivePersistence num"}
{"fix": "let rec additivePersistence n = \nif (n < 10) \nthen counter\nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num", "bad": "let rec additivePersistence n = \nif (n < 10) \nthen counter\nelse \nlet myList = digits n in\nlet num = sumList myList in\nlet counter = counter + 1 \nnum + additivePersistence num", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif (n < 10) \nthen counter\nelse \nlet myList = digits n in\nlet num = sumList myList in\nlet counter = counter + 1 \nnum + additivePersistence num"}
{"fix": "let rec additivePersistence n = \nif (n < 10) \nthen counter\nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num", "bad": "let rec additivePersistence n = \nif (n < 10) \nthen counter\nelse \nlet myList = digits n in\nlet num = sumList myList in\nlet counter = counter + 1", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif (n < 10) \nthen counter\nelse \nlet myList = digits n in\nlet num = sumList myList in\nlet counter = counter + 1"}
{"fix": "let rec additivePersistence n = \nif (n < 10) \nthen counter\nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num", "bad": "let rec additivePersistence n = \nif (n < 10) \nthen counter\nelse \nlet myList = digits n in\nlet num = sumList myList in\nlet counter = counter + 1", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif (n < 10) \nthen counter\nelse \nlet myList = digits n in\nlet num = sumList myList in\nlet counter = counter + 1"}
{"fix": "let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num", "bad": "let rec additivePersistence n = \nif (n < 10) \nthen counter\nelse \nlet myList = digits n in\nlet num = sumList myList in\nlet counter = 0 in\ncounter = counter + 1\nnum + additivePersistence num", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif (n < 10) \nthen counter\nelse \nlet myList = digits n in\nlet num = sumList myList in\nlet counter = 0 in\ncounter = counter + 1\nnum + additivePersistence num"}
{"fix": "let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num", "bad": "let rec additivePersistence n = \nif (n < 10) \nthen \nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif (n < 10) \nthen \nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num"}
{"fix": "let rec additivePersistence n = \nif (n < 10) \nthen []\nelse \nlet myList = digits n in\n(*let num = sumList myList in*)\nmyList", "bad": "let rec additivePersistence n = \nif (n < 10) \nthen []\nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif (n < 10) \nthen []\nelse \nlet myList = digits n in\nlet num = sumList myList in\nnum + additivePersistence num"}
{"fix": "let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \n1 + additivePersistence (sumList (digits n))", "bad": "let rec additivePersistence n = \nif (n < 10) \nthen 0\nelse \n1 + additivePersistence sumList (digits n)", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif (n < 10) \nthen 0\nelse \n1 + additivePersistence sumList (digits n)"}
{"fix": "let rec digitalRoot n = \nif (n < 10)\nthen n\nelse\nadditivePersistence ( sumList (digits n))", "bad": "let rec digitalRoot n = \nif (n < 10)\nthen digRoot = n\nelse\nadditivePersistence ( sumList (digits n))", "annotated": "let rec digitalRoot : int -> int = fun  n  ->  \nif (n < 10)\nthen digRoot = n\nelse\nadditivePersistence ( sumList (digits n))"}
{"fix": "let rec digitalRoot n = \nif (n < 10)\nthen n\nelse\nadditivePersistence ( sumList (digits n))", "bad": "let rec digitalRoot n = \nif (n < 10)\nthen root = n\nelse\nadditivePersistence ( sumList (digits n))", "annotated": "let rec digitalRoot : int -> int = fun  n  ->  \nif (n < 10)\nthen root = n\nelse\nadditivePersistence ( sumList (digits n))"}
{"fix": "let rec digitalRoot n = \nif (n < 10)\nthen n\nelse\nadditivePersistence ( sumList (digits n))", "bad": "let rec digitalRoot n = \nif (n < 10)\nthen root = n\nelse\nadditivePersistence ( sumList (digits n))", "annotated": "let rec digitalRoot : int -> int = fun  n  ->  \nif (n < 10)\nthen root = n\nelse\nadditivePersistence ( sumList (digits n))"}
{"fix": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> []", "bad": "let rec listReverse l = match l with \n| [] -> []\n| h::t ->", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with \n| [] -> []\n| h::t ->"}
{"fix": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> []", "bad": "let _ = \"a\" :: \"b\" :: \"c\"", "annotated": "let _ = \"a\" :: \"b\" :: \"c\""}
{"fix": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> []", "bad": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> 0", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with \n| [] -> []\n| h::t -> 0"}
{"fix": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> []", "bad": "let _ = \"a\" :: \"b\" :: \"c\"", "annotated": "let _ = \"a\" :: \"b\" :: \"c\""}
{"fix": "let rec listReverse l = match l with \n| [] -> []\n| h::[] -> l\n| h::t -> listReverse (append t [h] )", "bad": "let rec listReverse l = match l with \n| [] -> []\n| h::[] -> l\n| h::t -> listReverse ( append ( t [h] ) )", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with \n| [] -> []\n| h::[] -> l\n| h::t -> listReverse ( append ( t [h] ) )"}
{"fix": "let rec listReverse l = match l with \n| [] -> []\n| h::[] -> l\n| h::t -> listReverse (append t [h] )", "bad": "let rec listReverse l = match l with \n| [] -> []\n| h::[] -> l\n| h::t -> listReverse append ( t [h] )", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with \n| [] -> []\n| h::[] -> l\n| h::t -> listReverse append ( t [h] )"}
{"fix": "let rec listReverse l = match l with \n| [] -> []\n| h::[] -> l\n| h::t -> listReverse (append t [h] )", "bad": "let rec listReverse l = match l with \n| [] -> []\n| h::[] -> l\n| h::t -> listReverse (append ( t [h] ))", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with \n| [] -> []\n| h::[] -> l\n| h::t -> listReverse (append ( t [h] ))"}
{"fix": "let rec listReverse l = match l with \n| [] -> l\n| h::t -> listReverse (append t [h])", "bad": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> append ( t [h])", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with \n| [] -> []\n| h::t -> append ( t [h])"}
{"fix": "let rec listReverse l = match l with \n| [] -> l\n| h::t -> listReverse (append t [h])", "bad": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> append t [h]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with \n| [] -> []\n| h::t -> append t [h]"}
{"fix": "let rec listReverse l = match l with \n| [] -> l\n| h::t -> listReverse (append t [h])", "bad": "let _ = listReverse [1; 2; 3; 4]", "annotated": "let _ = listReverse [1; 2; 3; 4]"}
{"fix": "let rec listReverse l = match l with \n| [] -> l\n| h::t -> listReverse (append t [h])", "bad": "let rec listReverse l = match l with \n| [] -> []\n| h::t -> listReverse (append t [h])", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with \n| [] -> []\n| h::t -> listReverse (append t [h])"}
{"fix": "let rec listReverse l = match l with \n| [] -> l\n| h::t -> listReverse (append t [h])", "bad": "let _ = listReverse [1; 2; 3; 4]", "annotated": "let _ = listReverse [1; 2; 3; 4]"}
{"fix": "let rec listReverse l = match l with \n| [] -> l\n| h::t -> append t [h]", "bad": "let _ = listReverse [1; 2; 3; 4]", "annotated": "let _ = listReverse [1; 2; 3; 4]"}
{"fix": "let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlistReverse ([(n mod 10)] append digitsOfInt (n/10) )", "bad": "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]", "annotated": "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]"}
{"fix": "let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlistReverse ([(n mod 10)] append digitsOfInt (n/10) )", "bad": "let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlistReverse ([n mod 10] append digitsOfInt (n/10) )", "annotated": "let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlistReverse ([n mod 10] append digitsOfInt (n/10) )"}
{"fix": "let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlistReverse ([(n mod 10)] append digitsOfInt (n/10) )", "bad": "let _ = digitsOfInt 3124", "annotated": "let _ = digitsOfInt 3124"}
{"fix": "let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlistReverse (append [n mod 10] (digitsOfInt (n/10)) )", "bad": "let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlistReverse (append [n mod 10] digitsOfInt (n/10) )", "annotated": "let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlistReverse (append [n mod 10] digitsOfInt (n/10) )"}
{"fix": "let rec digitsOfInt n = \nif n <= 0 then []\nelse \nlistReverse (append [n mod 10] (digitsOfInt (n/10)) )", "bad": "let _ = digitsOfInt 3124", "annotated": "let _ = digitsOfInt 3124"}
{"fix": "let _ = palindrome \"a\"", "bad": "let palindrome w = match w with \n| \"\" -> true\n| _ -> \nlet myString = explode w in\nlet reverseString = listReverse myString in\nif myString = reverseString\nthen true\nelse false", "annotated": "let palindrome : string -> bool = fun  w  ->  match w with \n| \"\" -> true\n| _ -> \nlet myString = explode w in\nlet reverseString = listReverse myString in\nif myString = reverseString\nthen true\nelse false"}
{"fix": "let _ = palindrome \"a\"", "bad": "let _ = palindrome \"malayalam\"", "annotated": "let _ = palindrome \"malayalam\""}
{"fix": "let _ = palindrome \"a\"", "bad": "let _ = palindrome \"myxomatosis\"", "annotated": "let _ = palindrome \"myxomatosis\""}
{"fix": "let _ = palindrome \"a\"", "bad": "let _ = palindrome \"\"", "annotated": "let _ = palindrome \"\""}
{"fix": "let _ = palindrome \"a\"", "bad": "let _ = palindrome \"a\"", "annotated": "let _ = palindrome \"a\""}
{"fix": "let fixpoint (f,b) = wwhile ((fun x -> let b = (f x) in (b, b != x)),b)", "bad": "let fixpoint (f,b) = wwhile (fun x -> let b = (f x) in (b, b != x),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun x -> let b = (f x) in (b, b ! ->  x),b)"}
{"fix": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t  -> \"x\"\n| VarY\t\t  -> \"y\"\n| Sine(t)\t  -> (\"sin(pi*\"^(expr t)^\")\")\n| Cosine(t)\t  -> (\"cos(pi*\"^(expr t)^\")\")\n| Average(s, t) -> (\"((\"^(expr s)^\"+\"^(expr t)^\")/2)\" )\n| Times(s, t) -> ((expr s)^\"*\"^(expr t))\n| Thresh(s, t, u, v) -> (\"(\"^(expr s)^\"<\"^(expr t)^\"?\"^(expr u)^\":\"^(expr v)^\")\")", "bad": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t  -> \"x\"\n| VarY\t\t  -> \"y\"\n| Sine(t)\t  -> (\"sin(pi*\"^(expr t)^\")\")\n| Cosine(t)\t  -> (\"cos(pi*\"^(expr t)^\")\")\n| Average(s, t) -> (\"((\"^(ex s)^\"+\"^(ex t)^\")/2)\" )\n| Times(s, t) -> ((ex s)^\"*\"^(ex t))\n| Thresh(s, t, u, v) -> (\"(\"^(ex s)^\"<\"^(ex t)^\"?\"^(ex u)^\":\"^(ex v)^\")\")", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nlet expr = exprToString in\nmatch e with\n| VarX\t\t  -> \"x\"\n| VarY\t\t  -> \"y\"\n| Sine(t)\t  -> (\"sin(pi*\"^(expr t)^\")\")\n| Cosine(t)\t  -> (\"cos(pi*\"^(expr t)^\")\")\n| Average(s, t) -> (\"((\"^(ex s)^\"+\"^(ex t)^\")/2)\" )\n| Times(s, t) -> ((ex s)^\"*\"^(ex t))\n| Thresh(s, t, u, v) -> (\"(\"^(ex s)^\"<\"^(ex t)^\"?\"^(ex u)^\":\"^(ex v)^\")\")"}
{"fix": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t  -> \"x\"\n| VarY\t\t  -> \"y\"\n| Sine(t)\t  -> (\"sin(pi*\"^(expr t)^\")\")\n| Cosine(t)\t  -> (\"cos(pi*\"^(expr t)^\")\")\n| Average(s, t) -> (\"((\"^(expr s)^\"+\"^(expr t)^\")/2)\" )\n| Times(s, t) -> ((expr s)^\"*\"^(expr t))\n| Thresh(s, t, u, v) -> (\"(\"^(expr s)^\"<\"^(expr t)^\"?\"^(expr u)^\":\"^(expr v)^\")\")", "bad": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t  -> \"x\"\n| VarY\t\t  -> \"y\"\n| Sine(t)\t  -> (\"sin(pi*\"^(expr t)^\")\")\n| Cosine(t)\t  -> (\"cos(pi*\"^(expr t)^\")\")\n| Average(s, t) -> (\"((\"^(expr s)^\"+\"^(expr t)^\")/2)\" )\n| Times(s, t) -> ((ex s)^\"*\"^(expr t))\n| Thresh(s, t, u, v) -> (\"(\"^(expr s)^\"<\"^(expr t)^\"?\"^(expr u)^\":\"^(expr v)^\")\")", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nlet expr = exprToString in\nmatch e with\n| VarX\t\t  -> \"x\"\n| VarY\t\t  -> \"y\"\n| Sine(t)\t  -> (\"sin(pi*\"^(expr t)^\")\")\n| Cosine(t)\t  -> (\"cos(pi*\"^(expr t)^\")\")\n| Average(s, t) -> (\"((\"^(expr s)^\"+\"^(expr t)^\")/2)\" )\n| Times(s, t) -> ((ex s)^\"*\"^(expr t))\n| Thresh(s, t, u, v) -> (\"(\"^(expr s)^\"<\"^(expr t)^\"?\"^(expr u)^\":\"^(expr v)^\")\")"}
{"fix": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t      -> \"x\"\n| VarY\t\t      -> \"y\"\n| Sine a\t      -> (\"sin(pi*\"^(expr a)^\")\")\n| Cosine a\t      -> (\"cos(pi*\"^(expr a)^\")\")\n| Average (a, b)      -> (\"((\"^(expr a)^\"+\"^(expr b)^\")/2)\" )\n| Times (a, b)\t      -> ((expr a)^\"*\"^(expr b))\n| Thresh (a, b, c, d) -> (\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\")", "bad": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t      -> \"x\"\n| VarY\t\t      -> \"y\"\n| Sine a\t      -> (\"sin(pi*\"^(expr a)^\")\")\n| Cosine a\t      -> (\"cos(pi*\"^(expr a)^\")\")\n| Average a, b        -> (\"((\"^(expr a)^\"+\"^(expr b)^\")/2)\" )\n| Times a, b\t      -> ((expr a)^\"*\"^(expr b))\n| Thresh a, b, c, d   -> (\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\")", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nlet expr = exprToString in\nmatch e with\n| VarX\t\t      -> \"x\"\n| VarY\t\t      -> \"y\"\n| Sine a\t      -> (\"sin(pi*\"^(expr a)^\")\")\n| Cosine a\t      -> (\"cos(pi*\"^(expr a)^\")\")\n| Average a, b        -> (\"((\"^(expr a)^\"+\"^(expr b)^\")/2)\" )\n| Times a, b\t      -> ((expr a)^\"*\"^(expr b))\n| Thresh a, b, c, d   -> (\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\")"}
{"fix": "let rec wwhile (f,b) = \nmatch (f, b) with\n| (b', y) -> \nif y = false\nthen b'\nelse wwhile (f, b')", "bad": "let rec wwhile (f,b) = \nlet check = (f, b') in\nmatch check with\n| (b', y) -> \nif y = false\nthen b'\nelse wwhile (f, b')", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet check = (f, b') in\nmatch check with\n| (b', y) -> \nif y = false\nthen b'\nelse wwhile (f, b')"}
{"fix": "let rec wwhile (f,b) = \nmatch (f, b) with\n| (b', y) -> \nif y = false\nthen b'\nelse wwhile (f, b')", "bad": "let rec wwhile (f,b) = \nlet check = (f b') in\nmatch check with\n| (b', y) -> \nif y = false\nthen b'\nelse wwhile (f, b')", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet check = (f b') in\nmatch check with\n| (b', y) -> \nif y = false\nthen b'\nelse wwhile (f, b')"}
{"fix": "let rec wwhile (f,b) = \nmatch (f, b) with\n| (b', y) -> \nif y = false\nthen b'\nelse wwhile (f, b')", "bad": "let rec wwhile (f,b) = \nlet check = (f b') in\nmatch check with\n| (b', y) -> \nif y = false\nthen b'\nelse wwhile (f, b')", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet check = (f b') in\nmatch check with\n| (b', y) -> \nif y = false\nthen b'\nelse wwhile (f, b')"}
{"fix": "let rec wwhile (f,b) = \nmatch (f, b) with\n| (x, y) -> \nif y = false\nthen x\nelse wwhile (f, x)", "bad": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "annotated": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}
{"fix": "let rec wwhile (f,b) = \nlet check = (f b) in\nmatch check with\n| (x, y) -> \nif y = false\nthen x\nelse wwhile (f, x)", "bad": "let rec wwhile (f,b) = \nlet check = (f b) in\nmatch (f, b) with\n| (x, y) -> \nif y = false\nthen x\nelse wwhile (f, x)", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet check = (f b) in\nmatch (f, b) with\n| (x, y) -> \nif y = false\nthen x\nelse wwhile (f, x)"}
{"fix": "let fixpoint (f,b) = wwhile ((fun x ->\nlet b = (f x) in\n(b, b != x)),b)", "bad": "let fixpoint (f,b) = wwhile (fun x \nlet b = (f x) in\n(b, b != x),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (fun x \nlet b = (f x) in\n(b, b != x),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((fun x ->\nlet b = (f x) in\n(b, b != x)),b)", "bad": "let fixpoint (f,b) = wwhile (fun x ->\nlet b = (f x) in\n(b, b != x),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (fun x ->\nlet b = (f x) in\n(b, b != x),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((fun x ->\nlet b = (f x) in\n(b, b != x)),b)", "bad": "let fixpoint (f,b) = wwhile (fun x ->\nlet b = (f x) in\n(b, b != x),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (fun x ->\nlet b = (f x) in\n(b, b != x),b)"}
{"fix": "let _ = fixpoint (collatz, 48)", "bad": " _ = fixpoint (collatz, 3)", "annotated": " _ = fixpoint (collatz, 3)"}
{"fix": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t      -> \"x\"\n| VarY\t\t      -> \"y\"  \n| Sine a\t      -> \"sin(pi*\"^(expr a)^\")\"\n| Cosine a\t      -> \"cos(pi*\"^(expr a)^\")\"\n| Average (a, b)      -> \"((\"^(expr a)^\"+\"^(expr b)^\")/2)\"\n| Times (a, b)\t      -> (expr a)^\"*\"^(expr b)\n| Thresh (a, b, c, d) -> \n\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\"", "bad": "let rec exprToString e = \n(*let expr = exprToString in*)\nmatch e with\n| VarX\t\t      -> \"x\"\n| VarY\t\t      -> \"y\"  \n| Sine a\t      -> \"sin(pi*\"^(expr a)^\")\"\n| Cosine a\t      -> \"cos(pi*\"^(expr a)^\")\"\n| Average (a, b)      -> \"((\"^(expr a)^\"+\"^(expr b)^\")/2)\"\n| Times (a, b)\t      -> (expr a)^\"*\"^(expr b)\n| Thresh (a, b, c, d) -> \n\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \n(*let expr = exprToString in*)\nmatch e with\n| VarX\t\t      -> \"x\"\n| VarY\t\t      -> \"y\"  \n| Sine a\t      -> \"sin(pi*\"^(expr a)^\")\"\n| Cosine a\t      -> \"cos(pi*\"^(expr a)^\")\"\n| Average (a, b)      -> \"((\"^(expr a)^\"+\"^(expr b)^\")/2)\"\n| Times (a, b)\t      -> (expr a)^\"*\"^(expr b)\n| Thresh (a, b, c, d) -> \n\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\""}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": " _ = fixpoint (collatz, 9001)", "annotated": " _ = fixpoint (collatz, 9001)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": " _ = fixpoint (collatz, 9001)", "annotated": " _ = fixpoint (collatz, 9001)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": " g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": " g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let rec assoc (d,k,l) = \nif l = [] then d else\nmatch l with h::t ->\nmatch h with (a, b) ->\nif a = k then b\nelse assoc (d, k, t)", "bad": "let rec assoc (d,k,l) = \nmatch dkl with (d, k, l) ->\nif l = [] then d else\nmatchl", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  \nmatch dkl with (d, k, l) ->\nif l = [] then d else\nmatchl"}
{"fix": "let rec assoc (d,k,l) = \nif l = [] then d else\nmatch l with h::t ->\nmatch h with (a, b) ->\nif a = k then b\nelse assoc (d, k, t)", "bad": "with h::t ->\nmatch h with (a, b) ->\nif a = k then b\nelse assoc (d, k, t)", "annotated": "with h::t ->\nmatch h with (a, b) ->\nif a = k then b\nelse assoc (d, k, t)"}
{"fix": "let rec assoc (d,k,l) = \nif l = [] then d else\nmatch l with h::t ->\nmatch h with (a, b) ->\nif a = k then b\nelse assoc (d, k, t)", "bad": "let rec assoc (d,k,l) = \nif l = [] then d else\nmatchl", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  \nif l = [] then d else\nmatchl"}
{"fix": "let rec assoc (d,k,l) = \nif l = [] then d else\nmatch l with h::t ->\nmatch h with (a, b) ->\nif a = k then b\nelse assoc (d, k, t)", "bad": "with h::t ->\nmatch h with (a, b) ->\nif a = k then b\nelse assoc (d, k, t)", "annotated": "with h::t ->\nmatch h with (a, b) ->\nif a = k then b\nelse assoc (d, k, t)"}
{"fix": "let rec assoc (d,k,l) =\nmatch (d, k, l) with\n| (d, k, l) ->\nif l = [] \nthen d\nelse\nmatch l with h::t ->\nmatch h with (a, b) ->\nif a = k \nthen b\nelse assoc (d, k, t)", "bad": "let rec assoc (d,k,l) =\nmatch (d, k, l) with\n| [] -> 0\n| (d, k, l) ->\nif l = [] \nthen d\nelse\nmatch l with h::t ->\nmatch h with (a, b) ->\nif a = k \nthen b\nelse assoc (d, k, t)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  -> \nmatch (d, k, l) with\n| [] -> 0\n| (d, k, l) ->\nif l = [] \nthen d\nelse\nmatch l with h::t ->\nmatch h with (a, b) ->\nif a = k \nthen b\nelse assoc (d, k, t)"}
{"fix": "let rec wwhile (f,b) = \nlet check = (f b) in\nmatch check with\n| (x', y) -> \nif y = false\nthen x'\nelse wwhile (f, x')", "bad": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "annotated": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}
{"fix": "let rec build (rand, depth) = if depth > 0 then \n\nlet r = (rand (0, 5)) in \nlet d = (depth - 1) in \n\nmatch r with\n| 0 -> buildSine((build (rand, d)))\n| 1 -> buildCosine((build (rand, d)))\n| 2 -> buildAverage((build (rand, d)), (build (rand, d)))\n| 3 -> buildTimes((build (rand, d)), (build (rand, d)))\n| 4 -> buildThresh((build (rand, d)), (build (rand, d)), (build (rand, d)), (build (rand, d)))\n\nelse \n\nlet r = (rand (0, 2)) in \n\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let g1 () = build (2, 2)", "annotated": "let g1 () = build (2, 2)"}
{"fix": "let rec build (rand, depth) = if depth > 0 then \n\nlet r = (rand (0, 5)) in \nlet d = (depth - 1) in \n\nmatch r with\n| 0 -> buildSine((build (rand, d)))\n| 1 -> buildCosine((build (rand, d)))\n| 2 -> buildAverage((build (rand, d)), (build (rand, d)))\n| 3 -> buildTimes((build (rand, d)), (build (rand, d)))\n| 4 -> buildThresh((build (rand, d)), (build (rand, d)), (build (rand, d)), (build (rand, d)))\n\nelse \n\nlet r = (rand (0, 2)) in \n\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let g2 () = build (2, 5)", "annotated": "let g2 () = build (2, 5)"}
{"fix": "let rec build (rand, depth) = if depth > 0 then \n\nlet r = (rand (0, 5)) in \nlet d = (depth - 1) in \n\nmatch r with\n| 0 -> buildSine((build (rand, d)))\n| 1 -> buildCosine((build (rand, d)))\n| 2 -> buildAverage((build (rand, d)), (build (rand, d)))\n| 3 -> buildTimes((build (rand, d)), (build (rand, d)))\n| 4 -> buildThresh((build (rand, d)), (build (rand, d)), (build (rand, d)), (build (rand, d)))\n\nelse \n\nlet r = (rand (0, 2)) in \n\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let g1 () = build (rand(0, 5), 2)", "annotated": "let g1 () = build (rand(0, 5), 2)"}
{"fix": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n(eval(a, x, y) *. eval(a, x, y)) +. (eval(b, x, y) *. eval(c, x, y))\n| Tan a -> sin (pi *. eval(a, x, y)) /. cos (pi *. eval(a, x, y))", "bad": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n(eval(a, x, y) *. eval(a, x, y)) + (eval(b, x, y) *. eval(c, x, y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n(eval(a, x, y) *. eval(a, x, y)) + (eval(b, x, y) *. eval(c, x, y))"}
{"fix": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n(eval(a, x, y) *. eval(a, x, y)) +. (eval(b, x, y) *. eval(c, x, y))\n| Tan a -> sin (pi *. eval(a, x, y)) /. cos (pi *. eval(a, x, y))", "bad": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n(eval(a, x, y) * eval(a, x, y)) + (eval(b, x, y) *. eval(c, x, y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n(eval(a, x, y) * eval(a, x, y)) + (eval(b, x, y) *. eval(c, x, y))"}
{"fix": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n(eval(a, x, y) *. eval(a, x, y)) +. (eval(b, x, y) *. eval(c, x, y))\n| Tan a -> sin (pi *. eval(a, x, y)) /. cos (pi *. eval(a, x, y))", "bad": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n(eval(a, x, y) *. eval(a, x, y)) +. (eval(b, x, y) *. eval(c, x, y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n(eval(a, x, y) *. eval(a, x, y)) +. (eval(b, x, y) *. eval(c, x, y))"}
{"fix": "let rec build (rand, depth) = \nif depth < 0 \nthen \nlet r = (rand (0, 2)) in \nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\nelse \nlet d = depth - 1 in \nmatch rand(0, 7) with\n| 0 -> buildSine(build (rand, d))\n| 1 -> buildCosine(build (rand, d))\n| 2 -> buildAverage(build (rand, d), build (rand, d))\n| 3 -> buildTimes(build (rand, d), build (rand, d))\n| 4 -> buildThresh(build (rand, d),\nbuild (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| 5 -> buildPoly(build (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| 6 -> buildTan( build (rand, d))\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up \"", "bad": "let rec build (rand, depth) = \nif depth < 0 \nthen \nlet r = (rand (0, 2)) in \nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\nelse \nlet d = depth - 1 in \nmatch rand(0, 7) with\n| 0 -> buildSine(build (rand, d))\n| 1 -> buildCosine(build (rand, d))\n| 2 -> buildAverage(build (rand, d), build (rand, d))\n| 3 -> buildTimes(build (rand, d), build (rand, d))\n| 4 -> buildThresh(build (rand, d),\nbuild (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| 5 -> buildPoly(build (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| 6 -> buildTan( build (rand, d))\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up \"", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth < 0 \nthen \nlet r = (rand (0, 2)) in \nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\nelse \nlet d = depth - 1 in \nmatch rand(0, 7) with\n| 0 -> buildSine(build (rand, d))\n| 1 -> buildCosine(build (rand, d))\n| 2 -> buildAverage(build (rand, d), build (rand, d))\n| 3 -> buildTimes(build (rand, d), build (rand, d))\n| 4 -> buildThresh(build (rand, d),\nbuild (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| 5 -> buildPoly(build (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| 6 -> buildTan( build (rand, d))\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up \""}
{"fix": "let pipe fs = \nlet f a x = fun b -> x(a b) in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun b -> x(a y) in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun b -> x(a y) in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun b -> x(a b) in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = fun b -> x(a b) in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun b -> x(a b) in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "bad": "let stringOfList f l = \"[\" ^ (sep \"; \" (List.map f l)) & \"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\" ^ (sep \"; \" (List.map f l)) & \"]\""}
{"fix": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "bad": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) & \"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\" ^ (sepConcat \"; \" (List.map f l)) & \"]\""}
{"fix": "let padZero l1 l2 = \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (l1, l2)\nelse if a < b\nthen (clone 0 (b - a) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)", "bad": "let padZero l1 l2 = \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (a, b)\nelse if a < b\nthen (clone 0 (a - b) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (a, b)\nelse if a < b\nthen (clone 0 (a - b) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)"}
{"fix": "let padZero l1 l2 = \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (l1, l2)\nelse if a < b\nthen (clone 0 (b - a) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)", "bad": "let padZero l1 l2 = \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (a, b)\nelse if a < b\nthen ((clone 0 (a - b) @ l1), l2)\nelse (l1, clone 0 (a - b) @ l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (a, b)\nelse if a < b\nthen ((clone 0 (a - b) @ l1), l2)\nelse (l1, clone 0 (a - b) @ l2)"}
{"fix": "let padZero l1 l2 = \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (l1, l2)\nelse if a < b\nthen (clone 0 (b - a) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)", "bad": "let padZero l1 l2 = \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (a, b)\nelse if a < b\nthen (clone 0 (b - a) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (a, b)\nelse if a < b\nthen (clone 0 (b - a) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)"}
{"fix": "let padZero l1 l2 = \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (l1, l2)\nelse if a < b\nthen (clone 0 (b - a) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)", "bad": "let padZero l1 l2 = \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (a, b)\nelse if a < b\nthen (clone 0 (b - a) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (a, b)\nelse if a < b\nthen (clone 0 (b - a) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (x1, x2) = x in\nlet res = x1 + x2 + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 :: [])\n| h::t -> (newCarry, newCarry :: res mod 10 :: t) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet c = fst x + snd x in\nmatch a with\n| h::t -> (h+c)/10::(h+c mod 10) :: t\n| _ -> (c/10)::[c mod 10] in\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet c = fst x + snd x in\nmatch a with\n| h::t -> (h+c)/10::(h+c mod 10) :: t\n| _ -> (c/10)::[c mod 10] in\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (x1, x2) = x in\nlet res = x1 + x2 + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 :: [])\n| h::t -> (newCarry, newCarry :: res mod 10 :: t) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (x1, x2) = x in\nlet res = x1 + x2 + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry : res mod 10 : [])\n|h::t -> (newCarry, newCarry :: res mod 10 :: t) in\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (x1, x2) = x in\nlet res = x1 + x2 + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry : res mod 10 : [])\n|h::t -> (newCarry, newCarry :: res mod 10 :: t) in\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (x1, x2) = x in\nlet res = x1 + x2 + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 :: [])\n| h::t -> (newCarry, newCarry :: res mod 10 :: t) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (x1, x2) = x in\nlet res = x1 + x2 + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 : [])\n|h::t -> (newCarry, newCarry :: res mod 10 :: t) in\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (x1, x2) = x in\nlet res = x1 + x2 + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 : [])\n|h::t -> (newCarry, newCarry :: res mod 10 :: t) in\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (x1, x2) = x in\nlet res = x1 + x2 + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 :: [])\n| h::t -> (newCarry, newCarry :: res mod 10 :: t) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (x1, x2) = x in\nlet res = x1 + x2 + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 :: [])\n|h::t -> (newCarry, newCarry :: res mod 10 :: t) in\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (x1, x2) = x in\nlet res = x1 + x2 + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 :: [])\n|h::t -> (newCarry, newCarry :: res mod 10 :: t) in\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (x1, x2) = x in\nlet res = x1 + x2 + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 :: [])\n| h::t -> (newCarry, newCarry :: res mod 10 :: t) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (x1, x2) = x in\nlet res = x1 + x2 + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 :: [])\n| h::t -> (newCarry, newCarry :: res mod 10 :: t) \nin\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (x1, x2) = x in\nlet res = x1 + x2 + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 :: [])\n| h::t -> (newCarry, newCarry :: res mod 10 :: t) \nin\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (x1, x2) = x in\nlet res = x1 + x2 + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 :: [])\n| h::t -> (newCarry, newCarry :: res mod 10 :: t) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (x1, x2) = x in\nlet res = x1 + x2 + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 :: [])\n| h::t -> (newCarry, newCarry :: res mod 10 :: t) \nin\nlet base = [] in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (x1, x2) = x in\nlet res = x1 + x2 + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 :: [])\n| h::t -> (newCarry, newCarry :: res mod 10 :: t) \nin\nlet base = [] in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if List.length l1 < List.length l2\nthen (clone 0 (List.length l2 - List.length l1)) @ l1, l2\nelse l1, (clone 0 (List.length l1 - List.length l2)) @ l2", "bad": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if List.length l1 < List.length l2\nthen clone 0 (List.length l2 - List.length l1) @ l1, l2\nelse l1, clone 0 (List.length l1 - List.length l2 @ l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if List.length l1 < List.length l2\nthen clone 0 (List.length l2 - List.length l1) @ l1, l2\nelse l1, clone 0 (List.length l1 - List.length l2 @ l2)"}
{"fix": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if List.length l1 < List.length l2\nthen (clone 0 (List.length l2 - List.length l1)) @ l1, l2\nelse l1, (clone 0 (List.length l1 - List.length l2)) @ l2", "bad": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if List.length l1 < List.length l2\nthen (clone 0 (List.length l2 - List.length l1) @ l1, l2)\nelse l1, clone 0 (List.length l1 - List.length l2 @ l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if List.length l1 < List.length l2\nthen (clone 0 (List.length l2 - List.length l1) @ l1, l2)\nelse l1, clone 0 (List.length l1 - List.length l2 @ l2)"}
{"fix": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if List.length l1 < List.length l2\nthen (clone 0 (List.length l2 - List.length l1)) @ l1, l2\nelse l1, (clone 0 (List.length l1 - List.length l2)) @ l2", "bad": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if List.length l1 < List.length l2\nthen (clone 0 (List.length l2 - List.length l1)) @ l1, l2\nelse l1, clone 0 (List.length l1 - List.length l2 @ l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if List.length l1 < List.length l2\nthen (clone 0 (List.length l2 - List.length l1)) @ l1, l2\nelse l1, clone 0 (List.length l1 - List.length l2 @ l2)"}
{"fix": "let bigMul l1 l2 = \nlet f a x = let (b, c) = a in\nlet (_, d) = x in\nlet res = bigAdd (mulByDigit d l1 @ clone 0 b) c in\n(b + 1, res)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = let a = (b, c)  in\nlet x = (_, d) in\nlet y = bigAdd (mulByDigit d l1 @ clone c b) c in\n(b + 1, c)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let a = (b, c)  in\nlet x = (_, d) in\nlet y = bigAdd (mulByDigit d l1 @ clone c b) c in\n(b + 1, c)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = let (b, c) = a in\nlet (_, d) = x in\nlet res = bigAdd (mulByDigit d l1 @ clone 0 b) c in\n(b + 1, res)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = let a = (b, c)  in\nlet  (_, d) = x in\nlet y = bigAdd (mulByDigit d l1 @ clone c b) c in\n(b + 1, c)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let a = (b, c)  in\nlet  (_, d) = x in\nlet y = bigAdd (mulByDigit d l1 @ clone c b) c in\n(b + 1, c)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = let (b, c) = a in\nlet (_, d) = x in\nlet res = bigAdd (mulByDigit d l1 @ clone 0 b) c in\n(b + 1, res)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = let (b, c) = a in\nlet  (_, d) = x in\nlet y = bigAdd (mulByDigit d l1 @ clone c b) c in\n(b + 1, c)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (b, c) = a in\nlet  (_, d) = x in\nlet y = bigAdd (mulByDigit d l1 @ clone c b) c in\n(b + 1, c)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = let (b, c) = a in\nlet (_, d) = x in\nlet e = bigAdd (mulByDigit d l1 @ clone 0 b) c in\n(b + 1, e)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = let a = (b, c) in\nlet x = (_, d) in\nlet e = bigAdd (mulByDigit d l1 @ clone 0 b) c in\n(b + 1, e)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let a = (b, c) in\nlet x = (_, d) in\nlet e = bigAdd (mulByDigit d l1 @ clone 0 b) c in\n(b + 1, e)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (b, c) = x in\nlet res = b + c + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 :: [])\n| h::t -> (newCarry, newCarry :: res mod 10 :: t) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (b, c) = x in\nlet res = x + x + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 :: [])\n| h::t -> (newCarry, newCarry :: res mod 10 :: t) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (b, c) = x in\nlet res = x + x + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 :: [])\n| h::t -> (newCarry, newCarry :: res mod 10 :: t) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (addC, resOfAdd) = a in\nlet (i1, i2) = x in\nlet result = i1 + i2 + addC in\nlet nextCarry = result / 10 in\nmatch resOfAdd with \n| [] -> (nextCarry, [nextCarry] @ [result mod 10] @ [])\n| h::t -> (nextCarry, [nextCarry] @ [result mod 10] @ t) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (addC, resOfAdd) = a in\nlet (i1, i2) = x in\nlet result = i1 + i2 + addC in\nlet nextCarry = result / 10 in\nmatch resOfAdd with \n| [] -> (nextCarry, nextCarry @ [result mod 10] @ [])\n| h::t -> (nextCarry, nextCarry @ [result mod 10] @ t) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (addC, resOfAdd) = a in\nlet (i1, i2) = x in\nlet result = i1 + i2 + addC in\nlet nextCarry = result / 10 in\nmatch resOfAdd with \n| [] -> (nextCarry, nextCarry @ [result mod 10] @ [])\n| h::t -> (nextCarry, nextCarry @ [result mod 10] @ t) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigMul l1 l2 = \nlet f a x = let (b, c) = a in\nlet (_, d) = x in\nlet e = bigAdd (mulByDigit d l1 @ clone 0 b) c in\n(b + 1, e)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = let (b, c) = a in\nlet (_, d) = x in\nlet e = bigAdd (mulByDigit d l1 @ clone 0 b) c in\n(b + 1, e)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) List.rev l2  in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (b, c) = a in\nlet (_, d) = x in\nlet e = bigAdd (mulByDigit d l1 @ clone 0 b) c in\n(b + 1, e)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) List.rev l2  in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let rec sumList xs = match xs with\n[] ->0\n| h::t -> h + t", "bad": "let rec sumList xs = function [] -> int", "annotated": "let rec sumList : int list -> int = fun  xs  ->  function [] -> int"}
{"fix": "let rec sumList xs = match xs with\n[] ->0\n| h::t -> h + t", "bad": "let rec sumList xs = \n[] -> 0\n| h::t -> h + t", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \n[] -> 0\n| h::t -> h + t"}
{"fix": "let rec sumList xs = match xs with\n[] ->0\n| h::t -> h + t", "bad": "let rec sumList xs = [] -> 0\n| h::t -> h + t", "annotated": "let rec sumList : int list -> int = fun  xs  ->  [] -> 0\n| h::t -> h + t"}
{"fix": "let rec sumList xs = match xs with\n[] ->0\n| h::t -> h + t", "bad": "let rec sumList xs = [] -> 0\n| h::t -> h + t", "annotated": "let rec sumList : int list -> int = fun  xs  ->  [] -> 0\n| h::t -> h + t"}
{"fix": "let rec sumList xs = \nList.fold_left (+) xs", "bad": "let rec sumList xs = match xs with\n[] ->0\n| h::t -> h + t in xs", "annotated": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n[] ->0\n| h::t -> h + t in xs"}
{"fix": "let rec sumList xs = \nList.fold_left (+) xs", "bad": "let rec sumList xs = function (*failwith \"TBD:sumList\"*)\nList.fold_left (+) xs", "annotated": "let rec sumList : int list -> int = fun  xs  ->  function (*failwith \"TBD:sumList\"*)\nList.fold_left (+) xs"}
{"fix": "let rec sumList xs = match xs with\n[] -> 0", "bad": "let rec sumList xs = match xs with\n| [] -> 0\n| x :: xs -> List.fold_left x + xs", "annotated": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n| [] -> 0\n| x :: xs -> List.fold_left x + xs"}
{"fix": "let rec sumList xs = match xs with\n[] -> 0\n| h::t -> 1", "bad": "let rec sumList xs = match xs with\n[] -> 0\n| h::t -> h + sum t", "annotated": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n[] -> 0\n| h::t -> h + sum t"}
{"fix": "let rec sumList xs = match xs with\n[] -> 0\n| h::t -> 1", "bad": "let rec sumList xs = match xs with\n[] -> 0\n| h::t in xs -> h + sum t", "annotated": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n[] -> 0\n| h::t in xs -> h + sum t"}
{"fix": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "bad": "let rec sumList xs = match xs with\n[] -> int\n| h::t -> 1", "annotated": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n[] -> int\n| h::t -> 1"}
{"fix": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "bad": "let rec sumList xs = \n[] -> res + 0\n| x :: xs -> x + sumList xs", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \n[] -> res + 0\n| x :: xs -> x + sumList xs"}
{"fix": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "bad": "let rec sumList xs = \n[] -> 0\n| x :: xs -> x + sumList xs", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \n[] -> 0\n| x :: xs -> x + sumList xs"}
{"fix": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "bad": "let rec sumList xs = \n[] -> 0\n| x :: xs -> x + sumList xs", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \n[] -> 0\n| x :: xs -> x + sumList xs"}
{"fix": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "bad": "let rec sumList xs = \n[] -> 0\n| x :: xs -> x + sumList xs", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \n[] -> 0\n| x :: xs -> x + sumList xs"}
{"fix": "let rec digitsOfInt n = match n with\n0 -> []\n| n -> n / 10 :: digitsOfInt n", "bad": "let rec digitsOfInt n = match n with\n0 -> []\n| n -> n / 10 ::[] digitsOfInt n", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  match n with\n0 -> []\n| n -> n / 10 ::[] digitsOfInt n"}
{"fix": "let rec digitsOfInt n =\nif n < 0 then []\nelse match n /10 with\n0 -> [0]\n| _ -> digitsOfInt n", "bad": "let rec digitsOfInt n =\nif n < 0 then -> []\nelse n -> n / 10 ::[] digitsOfInt n", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then -> []\nelse n -> n / 10 ::[] digitsOfInt n"}
{"fix": "let rec digitsOfInt n =\nif n < 0 then []\nelse match n /10 with\n0 -> [0]\n| _ -> digitsOfInt n", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse n / 10 ::[] digitsOfInt n", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse n / 10 ::[] digitsOfInt n"}
{"fix": "let rec digitsOfInt n =\nif n < 0 then []\nelse match n /10 with\n0 -> [0]\n| _ -> digitsOfInt n", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse match n /10 with\n0 -> [0]\n| _ -> digitsOfIn n []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse match n /10 with\n0 -> [0]\n| _ -> digitsOfIn n []"}
{"fix": "let rec digitsOfInt n =\nif n < 0 then []\nelse match n /10 with\n0 -> [0]\n| _ -> digitsOfInt n", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse match n /10 with\n0 -> [0]\n| _ -> digitsOfInt n []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse match n /10 with\n0 -> [0]\n| _ -> digitsOfInt n []"}
{"fix": "let _ = digitsOfInt (-1)", "bad": "let _ = digitsOfInt 0", "annotated": "let _ = digitsOfInt 0"}
{"fix": "let _ = digitsOfInt 0", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse match (n mod 10) with\n_ -> _::[] digitsOfInt (n / 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse match (n mod 10) with\n_ -> _::[] digitsOfInt (n / 10)"}
{"fix": "let _ = digitsOfInt 0", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse match (n mod 10) with\n_ -> digitsOfInt (n/10)::[]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse match (n mod 10) with\n_ -> digitsOfInt (n/10)::[]"}
{"fix": "let _ = digitsOfInt 0", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse match (n mod 10) with\n_ -> digitsOfInt (n/10) ::[]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse match (n mod 10) with\n_ -> digitsOfInt (n/10) ::[]"}
{"fix": "let _ = digitsOfInt 0", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitOfInt (n/10) :: []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse digitOfInt (n/10) :: []"}
{"fix": "let _ = digitsOfInt 0", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n/10) :: []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse digitsOfInt (n/10) :: []"}
{"fix": "let _ = digitsOfInt 0", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n/10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse digitsOfInt (n/10)"}
{"fix": "let _ = digitsOfInt 0", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec loop n x = match n with\n0 -> [0]\n| _ -> loop (n/10) (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse let rec loop n x = match n with\n0 -> [0]\n| _ -> loop (n/10) (n mod 10)"}
{"fix": "let _ = digitsOfInt 0", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec loop n x = \nif n = 0 then x\nelse\n(n mod 10)::x\nmatch n with \n0 -> [0]\n| x -> loop n []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse let rec loop n x = \nif n = 0 then x\nelse\n(n mod 10)::x\nmatch n with \n0 -> [0]\n| x -> loop n []"}
{"fix": "let _ = digitsOfInt 0", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec loop n x = \nif n = 0 then x\nelse loop (n/10) (n mod 10::x) in match n with\n0 -> [0]\n| _ -> loop n []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse let rec loop n x = \nif n = 0 then x\nelse loop (n/10) (n mod 10::x) in match n with\n0 -> [0]\n| _ -> loop n []"}
{"fix": "let _ = sumList [1; 3; 5; 7; 9; 11]", "bad": "let _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(* `digitsOfInt n` should return `[]` if `n` is not positive,\nand otherwise returns the list of digits of `n` in the \norder in which they appear in `n`. *)\n\n(* digitsOfInt : int -> int list  *)\n(1 mod 10 ::4)", "annotated": "let _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(* `digitsOfInt n` should return `[]` if `n` is not positive,\nand otherwise returns the list of digits of `n` in the \norder in which they appear in `n`. *)\n\n(* digitsOfInt : int -> int list  *)\n(1 mod 10 ::4)"}
{"fix": "let _ = sumList [1; 3; 5; 7; 9; 11]", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse let rec loop n x = \nif n = 0 then x\nelse match n with\n0 -> [0]\n| _ -> loop (n/10) (n mod 10::[])", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse let rec loop n x = \nif n = 0 then x\nelse match n with\n0 -> [0]\n| _ -> loop (n/10) (n mod 10::[])"}
{"fix": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec addPersist n x =\nif n = 0 then x\nelse addPersist (n/10 + n mod 10) (1+x) in match n with \n0 -> 0\n| _ -> 1", "bad": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec addPersist n x =\nif n = 0 then x\nelse addPersist (n/10 + n mod 10) x in match n with\n0 -> 0\n_ -> x + 1", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif n = 0 then 0\nelse let rec addPersist n x =\nif n = 0 then x\nelse addPersist (n/10 + n mod 10) x in match n with\n0 -> 0\n_ -> x + 1"}
{"fix": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec addPersist n x =\nif n = 0 then x\nelse addPersist (n/10 + n mod 10) (1+x) in match n with \n0 -> 0\n| _ -> 1", "bad": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec addPersist n x =\nif n = 0 then x\nelse addPersist (n/10 + n mod 10) (1+x) in match n with \n0 -> 0\n_ -> 1", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif n = 0 then 0\nelse let rec addPersist n x =\nif n = 0 then x\nelse addPersist (n/10 + n mod 10) (1+x) in match n with \n0 -> 0\n_ -> 1"}
{"fix": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec addPersist n x =\nif n = 0 then x\nelse addPersist (n/10 + n mod 10) (1+x) in match n with \n0 -> 0\n| _ -> 1", "bad": "let rec additivePersistence n = \nif n = 0 then 0\nelse let rec addPersist n x =\nif n = 0 then x\nelse addPersist (n/10 + n mod 10) (1+x) in match n with \n0 -> 0\n| _ -> 1", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif n = 0 then 0\nelse let rec addPersist n x =\nif n = 0 then x\nelse addPersist (n/10 + n mod 10) (1+x) in match n with \n0 -> 0\n| _ -> 1"}
{"fix": "let _ = additivePersistence 12", "bad": "let _ additivePersistence 0", "annotated": "let _ additivePersistence 0"}
{"fix": "let _ = additivePersistence 12", "bad": "let _ = additivePersistence 0", "annotated": "let _ = additivePersistence 0"}
{"fix": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "bad": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n = 0 then m\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> m\n| - -> r_digitalRoot n 0", "annotated": "let rec digitalRoot : int -> int = fun  n  ->  \nif n = 0 then 0\nelse let rec r_digitalRoot : int -> int = fun  n  ->  \nif n = 0 then m\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> m\n| - -> r_digitalRoot n 0"}
{"fix": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "bad": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n = 0 then m\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> m\n| _ -> r_digitalRoot n 0", "annotated": "let rec digitalRoot : int -> int = fun  n  ->  \nif n = 0 then 0\nelse let rec r_digitalRoot : int -> int = fun  n  ->  \nif n = 0 then m\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> m\n| _ -> r_digitalRoot n 0"}
{"fix": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "bad": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n = 0 then m\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> r_digital root m 0\n| _ -> r_digitalRoot n 0", "annotated": "let rec digitalRoot : int -> int = fun  n  ->  \nif n = 0 then 0\nelse let rec r_digitalRoot : int -> int = fun  n  ->  \nif n = 0 then m\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> r_digital root m 0\n| _ -> r_digitalRoot n 0"}
{"fix": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "bad": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n = 0 then m\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> r_digitalRoot m 0\n| _ -> r_digitalRoot n 0", "annotated": "let rec digitalRoot : int -> int = fun  n  ->  \nif n = 0 then 0\nelse let rec r_digitalRoot : int -> int = fun  n  ->  \nif n = 0 then m\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> r_digitalRoot m 0\n| _ -> r_digitalRoot n 0"}
{"fix": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "bad": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n < then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 0\n| _ -> r_digitalRoot n m", "annotated": "let rec digitalRoot : int -> int = fun  n  ->  \nif n = 0 then 0\nelse let rec r_digitalRoot : int -> int = fun  n  ->  \nif n < then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 0\n| _ -> r_digitalRoot n m"}
{"fix": "let rec sumList xs = match xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "bad": "let rec digitalRoot n = \nif n = 0 then 0\nelse let rec r_digitalRoot n m = \nif n < 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 0\n| _ -> r_digitalRoot n m", "annotated": "let rec digitalRoot : int -> int = fun  n  ->  \nif n = 0 then 0\nelse let rec r_digitalRoot : int -> int = fun  n  ->  \nif n < 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 0\n| _ -> r_digitalRoot n m"}
{"fix": "let _ = digitalRoot 0", "bad": "let rec digitalRoot n = \nif n <= 9 then n\nelse let rec r_digitalRoot n m = \nif n <= 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 123\n| _ -> r_digitalRoot n (-1)", "annotated": "let rec digitalRoot : int -> int = fun  n  ->  \nif n <= 9 then n\nelse let rec r_digitalRoot : int -> int = fun  n  ->  \nif n <= 9 then n\nelse r_digitalRoot (n/10) (n mod 10 + m) in match n with\n0 -> 123\n| _ -> r_digitalRoot n (-1)"}
{"fix": "let rec sumList xs = \nmatch xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "bad": "let rec listReverse l =\nif l = [] then []\nelse let rec r_listReverse l x = match l with\n[] -> []\n| h::t -> r_listReverse t []::h", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nif l = [] then []\nelse let rec r_listReverse : 'a list -> 'a list = fun  l  ->  match l with\n[] -> []\n| h::t -> r_listReverse t []::h"}
{"fix": "let rec sumList xs = \nmatch xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "bad": "let rec listReverse l =\nif l = [] then []\nelse let rec r_listReverse l x = match l with\n[] -> []\n| h::t -> r_listReverse t h::[]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nif l = [] then []\nelse let rec r_listReverse : 'a list -> 'a list = fun  l  ->  match l with\n[] -> []\n| h::t -> r_listReverse t h::[]"}
{"fix": "let rec sumList xs = \nmatch xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "bad": "let rec listReverse l = match l with\n[] -> []\n| h::t -> listReverse t ::h", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n[] -> []\n| h::t -> listReverse t ::h"}
{"fix": "let rec sumList xs = \nmatch xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "bad": "let rec listReverse l = \nmatch l with\n[] -> []\n| h::t -> listReverse t @ h", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n[] -> []\n| h::t -> listReverse t @ h"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l = \nmatch l with\n[] -> []\n| h::t -> listReverse t @ h::[]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n[] -> []\n| h::t -> listReverse t @ h::[]"}
{"fix": "let _ = digitsOfInt 0", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nmatch n with \n0 -> [0]\n| _ -> digitsOfInt (n / 10) @ (n mod 10)::[]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse\nmatch n with \n0 -> [0]\n| _ -> digitsOfInt (n / 10) @ (n mod 10)::[]"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse let rec r_digitsOfInt n x = \nif n = 0 then x\nelse r_digitsOfInt (n / 10) (n mod 10 :: [])", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse digitsOfInt (n / 10) @ (n mod 10)::[]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse if n = 0 then []\nelse digitsOfInt (n / 10) @ (n mod 10)::[]"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse digitsOfInt (n / 10) @ (n mod 10)::[] \nin match n with \n0 -> [0]\n| _ -> digitsOfInt n @ []", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then []\nelse digitsOfInt (n / 10) @ (n mod 10)::[]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse if n = 0 then []\nelse digitsOfInt (n / 10) @ (n mod 10)::[]"}
{"fix": "let rec sumList xs = \nmatch xs with \n[] -> 0\n| h::t -> h + sumList t", "bad": "let palindrome w = \nlet orig_Esplode = esplode w and\nlet reverse_Esplode = explode reverseList w", "annotated": "let palindrome : string -> bool = fun  w  ->  \nlet orig_Esplode = esplode w and\nlet reverse_Esplode = explode reverseList w"}
{"fix": "let rec sumList xs = \nmatch xs with \n[] -> 0\n| h::t -> h + sumList t", "bad": "let palindrome w = \norig_Esplode = esplode w", "annotated": "let palindrome : string -> bool = fun  w  ->  \norig_Esplode = esplode w"}
{"fix": "let rec sumList xs = \nmatch xs with \n[] -> 0\n| h::t -> h + sumList t", "bad": "let palindrome w = \nif w = [] then true\nelse\nlet orig_Esplode = esplode w and\nlet reverse_Esplode = explode reverseList w in \nlet rec r_palindrome orig_Esplode revserse_Esplode = \nlet h1 = h::orig_Esplode \nand h2 = h::reverse_Esplode\nif h1 = h2 then r_panlindrome orig_Esplode reverse_Esplode\nelse false", "annotated": "let palindrome : string -> bool = fun  w  ->  \nif w = [] then true\nelse\nlet orig_Esplode = esplode w and\nlet reverse_Esplode = explode reverseList w in \nlet rec r_palindrome : string -> bool = fun  w  ->  \nlet h1 = h::orig_Esplode \nand h2 = h::reverse_Esplode\nif h1 = h2 then r_panlindrome orig_Esplode reverse_Esplode\nelse false"}
{"fix": "let rec sumList xs = \nmatch xs with \n[] -> 0\n| h::t -> h + sumList t", "bad": "let palindrome w = \nif w = [] then true\nelse\nlet rec r_palindrome esplode w esplode reverseList w = true", "annotated": "let palindrome : string -> bool = fun  w  ->  \nif w = [] then true\nelse\nlet rec r_palindrome : string -> bool = fun  w  ->  true"}
{"fix": "let rec sumList xs = \nmatch xs with \n[] -> 0\n| h::t -> h + sumList t", "bad": "let palindrome w = \nif w = [] then true", "annotated": "let palindrome : string -> bool = fun  w  ->  \nif w = [] then true"}
{"fix": "let rec sumList xs = \nmatch xs with \n[] -> 0\n| h::t -> h + sumList t", "bad": "let palindrome w = match w with\n[] -> true\n| _ -> false", "annotated": "let palindrome : string -> bool = fun  w  ->  match w with\n[] -> true\n| _ -> false"}
{"fix": "let _ = digitsOfInt 0", "bad": "let rec digitsOfInt n = \nmatch n with\n| [] -> []\n| 0 -> [0]\n| _ -> digitsOfInt (n / 10) @ (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nmatch n with\n| [] -> []\n| 0 -> [0]\n| _ -> digitsOfInt (n / 10) @ (n mod 10)"}
{"fix": "let _ = digitsOfInt 0", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nmatch n with \n| 0 -> [0]\n| _ -> digitsOfInt (n / 10) @ (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse\nmatch n with \n| 0 -> [0]\n| _ -> digitsOfInt (n / 10) @ (n mod 10)"}
{"fix": "let _ = digitsOfInt 0", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nmatch n with \n| 0 -> [0]\n| _ -> digitsOfInt (n / 10) :: (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse\nmatch n with \n| 0 -> [0]\n| _ -> digitsOfInt (n / 10) :: (n mod 10)"}
{"fix": "let _ = digitsOfInt 0", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nmatch n with \n| 0 -> [0]\n| _ -> digitsOfInt (n / 10) :: (n mod 10 ::[])", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse\nmatch n with \n| 0 -> [0]\n| _ -> digitsOfInt (n / 10) :: (n mod 10 ::[])"}
{"fix": "let _ = digitsOfInt 0", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nmatch n with \n| 0 -> [0]\n| _ -> digitsOfInt (n / 10) @ (n mod 10 ::[])", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse\nmatch n with \n| 0 -> [0]\n| _ -> digitsOfInt (n / 10) @ (n mod 10 ::[])"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with \n| 0 -> [0]\n| _ -> \nif (n /10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])\nelse []", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with \n| 0 -> [0]\n| _ -> \nif (n /10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])\nelse []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse match n with \n| 0 -> [0]\n| _ -> \nif (n /10) != 0 then digitsOfInt (n / 10) @ (n mod 10 ::[])\nelse []"}
{"fix": "let _ = additivePersistence 0", "bad": "let rec additivePersistence n = \nif sumList (digitsOfInt n) < 9 then 0\nelse 1 + additivePersistence sumList n", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif sumList (digitsOfInt n) < 9 then 0\nelse 1 + additivePersistence sumList n"}
{"fix": "let _ = additivePersistence 0", "bad": "let rec additivePersistence n = \nif sumList (digitsOfInt n) < 9 then 0\nelse 1 + additivePersistence (sumList n)", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif sumList (digitsOfInt n) < 9 then 0\nelse 1 + additivePersistence (sumList n)"}
{"fix": "let _ = additivePersistence 0", "bad": "let rec additivePersistence n = \nif sumList (digitsOfInt n) < 9 then 0\nelse 1 + additivePersistence (sumList (digitsOfInt n))", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif sumList (digitsOfInt n) < 9 then 0\nelse 1 + additivePersistence (sumList (digitsOfInt n))"}
{"fix": "let _ = digitalRoot 0", "bad": "let rec digitalRoot n = \nif n <= 9 then n\nelse if sumList (digitsOfInt n) < 9 then sumList (digitsOfInt n)\nelse digitalRoot (sumList (digitsOfInt n))", "annotated": "let rec digitalRoot : int -> int = fun  n  ->  \nif n <= 9 then n\nelse if sumList (digitsOfInt n) < 9 then sumList (digitsOfInt n)\nelse digitalRoot (sumList (digitsOfInt n))"}
{"fix": "let palindrome w = \nmatch w with \n| [] -> true\n| _  -> \nlet ex = esplode w in \nlet rec r_palindrome ex = match ex with\n| [] -> true\n| h1::t1 -> false", "bad": "let palindrome w = \nmatch w with \n| [] -> true\n| _  -> \nlet rec r_palindrome w = \nmatch w with\n| [] -> true\n| h1::t1 -> \nmatch reverseList t1 with\n| h2::t2 ->\nif h1 = h2 then r_palindrome t2\nelse false", "annotated": "let palindrome : string -> bool = fun  w  ->  \nmatch w with \n| [] -> true\n| _  -> \nlet rec r_palindrome : string -> bool = fun  w  ->  \nmatch w with\n| [] -> true\n| h1::t1 -> \nmatch reverseList t1 with\n| h2::t2 ->\nif h1 = h2 then r_palindrome t2\nelse false"}
{"fix": "let palindrome w = \nmatch w with \n| [] -> true\n| _  -> \nlet ex = esplode w in \nlet rec r_palindrome ex = match ex with\n| [] -> true\n| h1::t1 -> false", "bad": "let palindrome w = \nmatch w with \n| [] -> true\n| _  -> \nlet rec r_palindrome w = \nmatch w with\n| [] -> true\n| h1::t1 -> \nmatch reverseList t1 with\n| h2::t2 ->\nif h1 = h2 then r_palindrome t2\nelse false\n| _ -> false", "annotated": "let palindrome : string -> bool = fun  w  ->  \nmatch w with \n| [] -> true\n| _  -> \nlet rec r_palindrome : string -> bool = fun  w  ->  \nmatch w with\n| [] -> true\n| h1::t1 -> \nmatch reverseList t1 with\n| h2::t2 ->\nif h1 = h2 then r_palindrome t2\nelse false\n| _ -> false"}
{"fix": "let palindrome w = \nmatch w with \n| [] -> true\n| _  -> \nlet ex = esplode w in \nlet rec r_palindrome ex = match ex with\n| [] -> true\n| h1::t1 -> false", "bad": "let palindrome w = \nmatch w with \n| [] -> true\n| _  -> \nlet ex = esplode w in \nlet rec r_palindrome ex = match ex with\n| [] -> true\n| h1::t1 -> \nmatch reverseList t1 with\n| [] -> true\n| h2::t2 ->\nif h1 = h2 then r_palindrome t2\nelse false", "annotated": "let palindrome : string -> bool = fun  w  ->  \nmatch w with \n| [] -> true\n| _  -> \nlet ex = esplode w in \nlet rec r_palindrome : string -> bool = fun  w  ->  match ex with\n| [] -> true\n| h1::t1 -> \nmatch reverseList t1 with\n| [] -> true\n| h2::t2 ->\nif h1 = h2 then r_palindrome t2\nelse false"}
{"fix": "let palindrome w = \nmatch w with \n| [] -> true\n| _  -> \nlet ex = esplode w in \nlet rec r_palindrome ex = match ex with\n| [] -> true\n| h1::t1 -> false", "bad": "let palindrome w = \nmatch w with \n| [] -> true\n| _  -> false", "annotated": "let palindrome : string -> bool = fun  w  ->  \nmatch w with \n| [] -> true\n| _  -> false"}
{"fix": "let _ = palindrome \"malayalam\"", "bad": "let palindrome w = \nlet ex = esplode w in\nlet rev_ex = reverseList ex in\nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false", "annotated": "let palindrome : string -> bool = fun  w  ->  \nlet ex = esplode w in\nlet rev_ex = reverseList ex in\nlet rec r_palindrome : string -> bool = fun  w  ->  match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false"}
{"fix": "let _ = palindrome \"malayalam\"", "bad": "let palindrome w = \nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false in\nlet ex = esplode w in\nlet rev_ex = reverseList ex", "annotated": "let palindrome : string -> bool = fun  w  ->  \nlet rec r_palindrome : string -> bool = fun  w  ->  match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false in\nlet ex = esplode w in\nlet rev_ex = reverseList ex"}
{"fix": "let _ = palindrome \"malayalam\"", "bad": "let palindrome w = \nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false in\nlet rev_ex = reverseList ex in \nlet ex = esplode w", "annotated": "let palindrome : string -> bool = fun  w  ->  \nlet rec r_palindrome : string -> bool = fun  w  ->  match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false in\nlet rev_ex = reverseList ex in \nlet ex = esplode w"}
{"fix": "let _ = palindrome \"malayalam\"", "bad": "let palindrome w = \nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false in\nr_palindrome (esplode w) (reverseList (esplode w))", "annotated": "let palindrome : string -> bool = fun  w  ->  \nlet rec r_palindrome : string -> bool = fun  w  ->  match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false in\nr_palindrome (esplode w) (reverseList (esplode w))"}
{"fix": "let _ = palindrome \"malayalam\"", "bad": "let palindrome w = \nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false in\nr_palindrome (esplode w) (reverseList (explode w))", "annotated": "let palindrome : string -> bool = fun  w  ->  \nlet rec r_palindrome : string -> bool = fun  w  ->  match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false in\nr_palindrome (esplode w) (reverseList (explode w))"}
{"fix": "let _ = palindrome \"malayalam\"", "bad": "let palindrome w = \nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false in\nr_palindrome (explode w) (reverseList (explode w))", "annotated": "let palindrome : string -> bool = fun  w  ->  \nlet rec r_palindrome : string -> bool = fun  w  ->  match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false in\nr_palindrome (explode w) (reverseList (explode w))"}
{"fix": "let _ = palindrome \"malayalam\"", "bad": "let palindrome w = \nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false \nin\nr_palindrome (explode w) (reverseList (explode w))", "annotated": "let palindrome : string -> bool = fun  w  ->  \nlet rec r_palindrome : string -> bool = fun  w  ->  match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false \nin\nr_palindrome (explode w) (reverseList (explode w))"}
{"fix": "let _ = palindrome \"malayalam\"", "bad": "let palindrome w = \nlet rec r_palindrome ex rev_ex = match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false \nin\nr_palindrome (explode w) (listReverse (explode w))", "annotated": "let palindrome : string -> bool = fun  w  ->  \nlet rec r_palindrome : string -> bool = fun  w  ->  match (ex, rev_ex) with\n| ([],[]) -> true\n| (h1::t1, h2::t2) ->\nif h1 = h2 then r_palindrome t1 t2\nelse false\n| (ex, rev_ex) -> false \nin\nr_palindrome (explode w) (listReverse (explode w))"}
{"fix": "let _ = listReverse []", "bad": "let rec listReverse l = \nmatch l with\n| [] -> []\n| h::t -> append (listReverse t) [h]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> []\n| h::t -> append (listReverse t) [h]"}
{"fix": "let rec assoc (d,k,l) = match l with \n| []   -> d\n| h::t -> match h with\n| (k1,v1) -> if k = k1 then v1\nelse assoc (d,k,t)", "bad": "let rec assoc (d,k,l) = match l with \n| []   -> d\n| h::t -> match h with\n| (k1,v1) -> if k = k1 then \nelse assoc (d,k,t)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with \n| []   -> d\n| h::t -> match h with\n| (k1,v1) -> if k = k1 then \nelse assoc (d,k,t)"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen \nthen helper (seen, t) \nelse helper (h::seen, t) in\nlet rest' = helper (seen', t) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = if List.mem (h, seen) then helper (h::seen, t) in\nlet rest' = helper (seen', t) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = if List.mem (h, seen) then helper (h::seen, t) in\nlet rest' = helper (seen', t) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen \nthen helper (seen, t) \nelse helper (h::seen, t) in\nlet rest' = helper (seen', t) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = if List.mem h seen", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = if List.mem h seen"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen \nthen helper (seen, t) \nelse helper (h::seen, t) in\nlet rest' = helper (seen', t) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": ") then helper (h::seen, t) in\nlet rest' = helper (seen', t) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": ") then helper (h::seen, t) in\nlet rest' = helper (seen', t) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen \nthen helper (seen, t) \nelse helper (h::seen, t) in\nlet rest' = helper (seen', t) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = if List.mem h seen then helper (h::seen, t) in\nlet rest' = helper (seen', t) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = if List.mem h seen then helper (h::seen, t) in\nlet rest' = helper (seen', t) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then\nseen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then\nseen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then\nseen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen\nelse seen in \nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen\nelse seen in \nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then h::seen", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then h::seen"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen\nelse seen in \nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen\nelse seen", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen\nelse seen"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen\nelse seen in \nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then seen\nelse seen in \nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let _ = removeDuplicates [1,1,2]", "annotated": "let _ = removeDuplicates [1,1,2]"}
{"fix": "let _ = removeDuplicates [1,1,2]", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then h::seen\nelse seen", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then h::seen\nelse seen"}
{"fix": "let _ = removeDuplicates [1,1,2]", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen \nthen h::seen\nelse seen", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen \nthen h::seen\nelse seen"}
{"fix": "let _ = removeDuplicates [1,1,2]", "bad": "let rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let _ = removeDuplicates [1,1,2]", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = seen", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = seen"}
{"fix": "let _ = removeDuplicates [1,1,2]", "bad": "let rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let _ = removeDuplicates [1,1,2]", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = seen", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = seen"}
{"fix": "let _ = removeDuplicates [1,1,2]", "bad": "let rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let _ = removeDuplicates [1,1,2]", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let _ = removeDuplicates [1,1,2]", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen \nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen \nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let f x = \nlet xx = x*x*x in (xx,xx<100)", "bad": "let rec wwhile (f,b) =\nlet (b', c') = f b in \nmatch c' with\n| False -> b'\n| True  -> while (f, b')", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> \nlet (b', c') = f b in \nmatch c' with\n| False -> b'\n| True  -> while (f, b')"}
{"fix": "let f x = \nlet xx = x*x*x in (xx,xx<100)", "bad": "let rec wwhile (f,b) =\nlet (b', c') = f b in \nmatch c' with\n| False -> b'\n| True  -> wwhile (f, b')", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> \nlet (b', c') = f b in \nmatch c' with\n| False -> b'\n| True  -> wwhile (f, b')"}
{"fix": "let f x = \nlet xx = x*x*x in (xx,xx<100)", "bad": "let rec wwhile (f,b) =\nlet (b', c') = f b in \nmatch c' with\n| false -> b'\n| true  -> wwhile (f, b')", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> \nlet (b', c') = f b in \nmatch c' with\n| false -> b'\n| true  -> wwhile (f, b')"}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = match e with\n| VarX                       -> \"x\"\n| VarY                       -> \"y\"\n| Sine  (ex)                 -> \"sin (pi*)\" ^ exprToString ex ^ \")\"\n| Cosine  (ex)               -> \"cos (pi*)\" ^ exprToString ex ^ \")\"\n| Average (ex1, ex2)         -> \"((\" ^ exprToSring ex1 ^ \" + \" ^ exprToString ex2 ^ \")/2)\" \n| Times (ex1, ex2)           -> exprToString expr1 ^ \" * \" ^ exprToString expr2\n| Thresh (ex1, ex2, ex3, ex4) -> \"(\" ^ exprToString expr1 ^ \"<\" ^ exprToString expr2 ^ \" ? \" ^ exprToString expr3 ^ \" : \" ^ exprToString expr4 ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX                       -> \"x\"\n| VarY                       -> \"y\"\n| Sine  (ex)                 -> \"sin (pi*)\" ^ exprToString ex ^ \")\"\n| Cosine  (ex)               -> \"cos (pi*)\" ^ exprToString ex ^ \")\"\n| Average (ex1, ex2)         -> \"((\" ^ exprToSring ex1 ^ \" + \" ^ exprToString ex2 ^ \")/2)\" \n| Times (ex1, ex2)           -> exprToString expr1 ^ \" * \" ^ exprToString expr2\n| Thresh (ex1, ex2, ex3, ex4) -> \"(\" ^ exprToString expr1 ^ \"<\" ^ exprToString expr2 ^ \" ? \" ^ exprToString expr3 ^ \" : \" ^ exprToString expr4 ^ \")\""}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = match e with\n| VarX                       -> \"x\"\n| VarY                       -> \"y\"\n| Sine  (ex)                 -> \"sin (pi*)\" ^ exprToString ex ^ \")\"\n| Cosine  (ex)               -> \"cos (pi*)\" ^ exprToString ex ^ \")\"\n| Average (ex1, ex2)         -> \"((\" ^ exprToString ex1 ^ \" + \" ^ exprToString ex2 ^ \")/2)\" \n| Times (ex1, ex2)           -> exprToString expr1 ^ \" * \" ^ exprToString expr2\n| Thresh (ex1, ex2, ex3, ex4) -> \"(\" ^ exprToString expr1 ^ \"<\" ^ exprToString expr2 ^ \" ? \" ^ exprToString expr3 ^ \" : \" ^ exprToString expr4 ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX                       -> \"x\"\n| VarY                       -> \"y\"\n| Sine  (ex)                 -> \"sin (pi*)\" ^ exprToString ex ^ \")\"\n| Cosine  (ex)               -> \"cos (pi*)\" ^ exprToString ex ^ \")\"\n| Average (ex1, ex2)         -> \"((\" ^ exprToString ex1 ^ \" + \" ^ exprToString ex2 ^ \")/2)\" \n| Times (ex1, ex2)           -> exprToString expr1 ^ \" * \" ^ exprToString expr2\n| Thresh (ex1, ex2, ex3, ex4) -> \"(\" ^ exprToString expr1 ^ \"<\" ^ exprToString expr2 ^ \" ? \" ^ exprToString expr3 ^ \" : \" ^ exprToString expr4 ^ \")\""}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = match e with\n| VarX                       -> \"x\"\n| VarY                       -> \"y\"\n| Sine  (ex)                 -> \"sin (pi*)\" ^ exprToString ex ^ \")\"\n| Cosine  (ex)               -> \"cos (pi*)\" ^ exprToString ex ^ \")\"\n| Average (ex1, ex2)         -> \"((\" ^ exprToString ex1 ^ \" + \" ^ exprToString ex2 ^ \")/2)\" \n| Times (ex1, ex2)           -> exprToString ex1 ^ \" * \" ^ exprToString ex2\n| Thresh (ex1, ex2, ex3, ex4) -> \"(\" ^ exprToString expr1 ^ \"<\" ^ exprToString expr2 ^ \" ? \" ^ exprToString expr3 ^ \" : \" ^ exprToString expr4 ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX                       -> \"x\"\n| VarY                       -> \"y\"\n| Sine  (ex)                 -> \"sin (pi*)\" ^ exprToString ex ^ \")\"\n| Cosine  (ex)               -> \"cos (pi*)\" ^ exprToString ex ^ \")\"\n| Average (ex1, ex2)         -> \"((\" ^ exprToString ex1 ^ \" + \" ^ exprToString ex2 ^ \")/2)\" \n| Times (ex1, ex2)           -> exprToString ex1 ^ \" * \" ^ exprToString ex2\n| Thresh (ex1, ex2, ex3, ex4) -> \"(\" ^ exprToString expr1 ^ \"<\" ^ exprToString expr2 ^ \" ? \" ^ exprToString expr3 ^ \" : \" ^ exprToString expr4 ^ \")\""}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = match e with\n| VarX                       -> \"x\"\n| VarY                       -> \"y\"\n| Sine  (ex)                 -> \"sin (pi*)\" ^ exprToString ex ^ \")\"\n| Cosine  (ex)               -> \"cos (pi*)\" ^ exprToString ex ^ \")\"\n| Average (ex1, ex2)         -> \"((\" ^ exprToString ex1 ^ \" + \" ^ exprToString ex2 ^ \")/2)\" \n| Times (ex1, ex2)           -> exprToString ex1 ^ \" * \" ^ exprToString ex2\n| Thresh (ex1, ex2, ex3, ex4) -> \"(\" ^ exprToString ex1 ^ \"<\" ^ exprToString ex2 ^ \" ? \" ^ exprToString ex3 ^ \" : \" ^ exprToString ex4 ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX                       -> \"x\"\n| VarY                       -> \"y\"\n| Sine  (ex)                 -> \"sin (pi*)\" ^ exprToString ex ^ \")\"\n| Cosine  (ex)               -> \"cos (pi*)\" ^ exprToString ex ^ \")\"\n| Average (ex1, ex2)         -> \"((\" ^ exprToString ex1 ^ \" + \" ^ exprToString ex2 ^ \")/2)\" \n| Times (ex1, ex2)           -> exprToString ex1 ^ \" * \" ^ exprToString ex2\n| Thresh (ex1, ex2, ex3, ex4) -> \"(\" ^ exprToString ex1 ^ \"<\" ^ exprToString ex2 ^ \" ? \" ^ exprToString ex3 ^ \" : \" ^ exprToString ex4 ^ \")\""}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex) -> sin(pi * (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi * eval (ex,x,y))\n| Average (ex1, ex2) -> (eval (ex1,x,y) + eval (ex2,x,y) )/ 2\n| Times (ex1, ex2) -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1, ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex) -> sin(pi * (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi * eval (ex,x,y))\n| Average (ex1, ex2) -> (eval (ex1,x,y) + eval (ex2,x,y) )/ 2\n| Times (ex1, ex2) -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1, ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> let ex1 = eval(ex,x,y) in sin(pi * ex1)\n| Cosine (ex) -> cos(pi * eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y) )/ 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> let ex1 = eval(ex,x,y) in sin(pi * ex1)\n| Cosine (ex) -> cos(pi * eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y) )/ 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi * (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi * eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y)) / 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi * (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi * eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y)) / 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y)) / 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y)) / 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y)) / 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) + eval (ex2,x,y)) / 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) / 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) / 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) /. 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) /. 2\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) / 2.\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) / 2.\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) /. 2.\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) /. 2.\n| Times (ex1,ex2)   -> eval (ex1,x,y) * eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) /. 2.\n| Times (ex1,ex2)   -> eval (ex1,x,y) *. eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine (ex)   -> sin(pi *. (eval (ex,x,y)))\n| Cosine (ex) -> cos(pi *. eval (ex,x,y))\n| Average (ex1,ex2) -> (eval (ex1,x,y) +. eval (ex2,x,y)) /. 2.\n| Times (ex1,ex2)   -> eval (ex1,x,y) *. eval (ex2,x,y)\n| Thresh (ex1,ex2, ex3, ex4) -> if eval (ex1,x,y) < eval (ex2,x,y) then eval (ex3,x,y) else eval (ex4,x,y)"}
{"fix": "let rec build (rand, depth) = \nif depth = 0 then \nlet x = rand(0,1) in\nmatch x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand (0,4) in match r with\n| 0 -> buildSine(build (rand, depth-1))\n| 1 -> buildCosine( build (rand, depth-1))\n| 2 -> buildAverage( build (rand, depth -1), build (rand, depth -1))\n| 3 -> buildTimes( build (rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build (rand, depth-1),build (rand, depth-1),build (rand, depth-1),build (rand, depth-1))", "bad": "let rec build (rand, depth) = \nif depth = 0 then \nlet x = rand(0,1) in\nmatch x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand (1,5) in match r with\n| 1 -> buildSine(build (rand, depth-1))\n| 2 -> buildCosine( build (rand, depth-1))\n| 3 -> buildAverage( build (rand, depth -1), build (rand, depth -1))\n| 4 -> buildTimes( build (rand, depth-1), build(rand, depth-1))\n| 5 -> buildTresh(build (rand, depth-1),build (rand, depth-1),build (rand, depth-1),build (rand, depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0 then \nlet x = rand(0,1) in\nmatch x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand (1,5) in match r with\n| 1 -> buildSine(build (rand, depth-1))\n| 2 -> buildCosine( build (rand, depth-1))\n| 3 -> buildAverage( build (rand, depth -1), build (rand, depth -1))\n| 4 -> buildTimes( build (rand, depth-1), build(rand, depth-1))\n| 5 -> buildTresh(build (rand, depth-1),build (rand, depth-1),build (rand, depth-1),build (rand, depth-1))"}
{"fix": "let rec build (rand, depth) = \nif depth = 0 then \nlet x = rand(0,1) in\nmatch x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand (0,4) in match r with\n| 0 -> buildSine(build (rand, depth-1))\n| 1 -> buildCosine( build (rand, depth-1))\n| 2 -> buildAverage( build (rand, depth -1), build (rand, depth -1))\n| 3 -> buildTimes( build (rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build (rand, depth-1),build (rand, depth-1),build (rand, depth-1),build (rand, depth-1))", "bad": "let rec build (rand, depth) = \nif depth = 0 then \nlet x = rand(0,1) in\nmatch x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand (1,5) in match r with\n| 1 -> buildSine(build (rand, depth-1))\n| 2 -> buildCosine( build (rand, depth-1))\n| 3 -> buildAverage( build (rand, depth -1), build (rand, depth -1))\n| 4 -> buildTimes( build (rand, depth-1), build(rand, depth-1))\n| 5 -> buildThresh(build (rand, depth-1),build (rand, depth-1),build (rand, depth-1),build (rand, depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0 then \nlet x = rand(0,1) in\nmatch x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand (1,5) in match r with\n| 1 -> buildSine(build (rand, depth-1))\n| 2 -> buildCosine( build (rand, depth-1))\n| 3 -> buildAverage( build (rand, depth -1), build (rand, depth -1))\n| 4 -> buildTimes( build (rand, depth-1), build(rand, depth-1))\n| 5 -> buildThresh(build (rand, depth-1),build (rand, depth-1),build (rand, depth-1),build (rand, depth-1))"}
{"fix": "assoc\n(-1, \"bob\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "bad": "assoc\n(-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "assoc\n(-1, \"william\", [(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let rec assoc (d,k,l) = match l with \n| []   -> d\n| h::t -> match h with\n| (k1,v1) -> \nif k = k1 then v1\nelse assoc (d,k,t)", "bad": "let rec build (rand, depth) = \nif depth = 0 then \nlet x = rand(0,1) in\nmatch x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand (0,4) in match r with\n| 0 -> buildSine(build (rand, depth-1))\n| 1 -> buildCosine( build (rand, depth-1))\n| 2 -> buildAverage( build (rand, depth -1), build (rand, depth -1))\n| 3 -> buildTimes( build (rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build (rand, depth-1),build (rand, depth-1),build (rand, depth-1),build (rand, depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0 then \nlet x = rand(0,1) in\nmatch x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand (0,4) in match r with\n| 0 -> buildSine(build (rand, depth-1))\n| 1 -> buildCosine( build (rand, depth-1))\n| 2 -> buildAverage( build (rand, depth -1), build (rand, depth -1))\n| 3 -> buildTimes( build (rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build (rand, depth-1),build (rand, depth-1),build (rand, depth-1),build (rand, depth-1))"}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = match e with\n| VarX                      -> \"x\"\n| VarY                      -> \"y\"\n| Sine (e)                 -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine (e)               -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, e2)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\" \n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| NewExprA (e1,e2) -> \"(\" ^ exprToString e1 ^ \">\" ^exprToString e2 ^ \"?\" exprToString e1 ^ \":\" exprToString e2\n| NewExprB (e1,e2,e3) -> \"(\" exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"+\" ^ exprToString ex ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX                      -> \"x\"\n| VarY                      -> \"y\"\n| Sine (e)                 -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine (e)               -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, e2)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\" \n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| NewExprA (e1,e2) -> \"(\" ^ exprToString e1 ^ \">\" ^exprToString e2 ^ \"?\" exprToString e1 ^ \":\" exprToString e2\n| NewExprB (e1,e2,e3) -> \"(\" exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"+\" ^ exprToString ex ^ \")\""}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = match e with\n| VarX                      -> \"x\"\n| VarY                      -> \"y\"\n| Sine (e)                 -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine (e)               -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, e2)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\" \n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| NewExprA (e1,e2) -> \"(\" ^ exprToString e1 ^ \">\" ^exprToString e2 ^ \"?\" ^ exprToString e1 ^ \":\" exprToString e2\n| NewExprB (e1,e2,e3) -> \"(\" exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"+\" ^ exprToString ex ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX                      -> \"x\"\n| VarY                      -> \"y\"\n| Sine (e)                 -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine (e)               -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, e2)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\" \n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| NewExprA (e1,e2) -> \"(\" ^ exprToString e1 ^ \">\" ^exprToString e2 ^ \"?\" ^ exprToString e1 ^ \":\" exprToString e2\n| NewExprB (e1,e2,e3) -> \"(\" exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"+\" ^ exprToString ex ^ \")\""}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = match e with\n| VarX                      -> \"x\"\n| VarY                      -> \"y\"\n| Sine (e)                 -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine (e)               -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, e2)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\" \n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| NewExprA (e1,e2) -> \"(\" ^ exprToString e1 ^ \">\" ^exprToString e2 ^ \"?\" ^ exprToString e1 ^ \":\" ^ exprToString e2\n| NewExprB (e1,e2,e3) -> \"(\" exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"+\" ^ exprToString ex ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX                      -> \"x\"\n| VarY                      -> \"y\"\n| Sine (e)                 -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine (e)               -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, e2)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\" \n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| NewExprA (e1,e2) -> \"(\" ^ exprToString e1 ^ \">\" ^exprToString e2 ^ \"?\" ^ exprToString e1 ^ \":\" ^ exprToString e2\n| NewExprB (e1,e2,e3) -> \"(\" exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"+\" ^ exprToString ex ^ \")\""}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = match e with\n| VarX                      -> \"x\"\n| VarY                      -> \"y\"\n| Sine (e)                 -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine (e)               -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, e2)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\" \n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| NewExprA (e1,e2) -> \"(\" ^ exprToString e1 ^ \">\" ^exprToString e2 ^ \"?\" ^ exprToString e1 ^ \":\" ^ exprToString e2\n| NewExprB (e1,e2,e3) -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"+\" ^ exprToString ex ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX                      -> \"x\"\n| VarY                      -> \"y\"\n| Sine (e)                 -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine (e)               -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, e2)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\" \n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| NewExprA (e1,e2) -> \"(\" ^ exprToString e1 ^ \">\" ^exprToString e2 ^ \"?\" ^ exprToString e1 ^ \":\" ^ exprToString e2\n| NewExprB (e1,e2,e3) -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"+\" ^ exprToString ex ^ \")\""}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = match e with\n| VarX                      -> \"x\"\n| VarY                      -> \"y\"\n| Sine (e)                 -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine (e)               -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, e2)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\" \n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| NewExprA (e1,e2) -> \"(\" ^ exprToString e1 ^ \">\" ^exprToString e2 ^ \"?\" ^ exprToString e1 ^ \":\" ^ exprToString e2\n| NewExprB (e1,e2,e3) -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"+\" ^ exprToString e3 ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX                      -> \"x\"\n| VarY                      -> \"y\"\n| Sine (e)                 -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine (e)               -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, e2)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\" \n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| NewExprA (e1,e2) -> \"(\" ^ exprToString e1 ^ \">\" ^exprToString e2 ^ \"?\" ^ exprToString e1 ^ \":\" ^ exprToString e2\n| NewExprB (e1,e2,e3) -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"+\" ^ exprToString e3 ^ \")\""}
{"fix": "let rec exprToString e = match e with\n| VarX                      -> \"x\"\n| VarY                      -> \"y\"\n| Sine (e)                 -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine (e)               -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1, e2)        -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\" \n| Times (e1, e2)          -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| NewExprA (e1,e2) -> \"(\" ^ exprToString e1 ^ \">\" ^exprToString e2 ^ \"?\" ^ exprToString e1 ^ \":\" ^ exprToString e2 ^ \")\"s\n| NewExprB (e1,e2,e3) -> \"(\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"+\" ^ exprToString e3 ^ \")\"", "bad": "let _ = exprToString (NewExprA(VarX,VarY))", "annotated": "let _ = exprToString (NewExprA(VarX,VarY))"}
{"fix": "let _ = eval (NewExprA(VarX, VarY), -1., 1.)", "bad": "let _ = eval (NewExprA(VarX, VarY), 1., -1.)", "annotated": "let _ = eval (NewExprA(VarX, VarY), 1., -1.)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (e)   -> sin(pi *. (eval (e,x,y)))\n| Cosine (e) -> cos(pi *. eval (e,x,y))\n| Average (e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\n| Times (e1,e2)   -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2, e3, e4) -> if eval (e1,x,y) < eval (e2,x,y) then eval (e3,x,y) else eval (e4,x,y)\n| NewExprA (e1,e2) -> if eval(e1,x,y) > eval(e2,x,y) then eval (e1,x,y) else eval(e2,x,y)\n| NewExprB (e1,e2,e3) -> eval(e1,x,y) +. eval(e2,x,y) -. eval(e3,x,y)", "bad": "let _ = eval (NewExprB(VarX, VarY, VarX), -1.,-1.,-1.)", "annotated": "let _ = eval (NewExprB(VarX, VarY, VarX), -1.,-1.,-1.)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine (e)   -> sin(pi *. (eval (e,x,y)))\n| Cosine (e) -> cos(pi *. eval (e,x,y))\n| Average (e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\n| Times (e1,e2)   -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2, e3, e4) -> if eval (e1,x,y) < eval (e2,x,y) then eval (e3,x,y) else eval (e4,x,y)\n| NewExprA (e1,e2) -> if eval(e1,x,y) > eval(e2,x,y) then eval (e1,x,y) else eval(e2,x,y)\n| NewExprB (e1,e2,e3) -> eval(e1,x,y) +. eval(e2,x,y) -. eval(e3,x,y)", "bad": "let _ = eval (NewExprB(VarX, VarY, VarX), -1.,-1.)", "annotated": "let _ = eval (NewExprB(VarX, VarY, VarX), -1.,-1.)"}
{"fix": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = sqsum []", "annotated": "let _ = sqsum []"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = fun y -> y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = f a in\nlet base = x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = f a in\nlet base = x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = fun y -> y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = fun y -> y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = [] in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = [] in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = fun y -> y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a - x in\nlet base = fun y -> y in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a - x in\nlet base = fun y -> y in\nList.fold_left f base fs"}
{"fix": "let _ = pipe [] 3", "bad": "let pipe fs = \nlet f a x = a -> x in\nlet base =  y in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a -> x in\nlet base =  y in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun f a -> f x in\nlet base = fun y -> y in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun f a -> x in\nlet base = fun y -> y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun f x -> f a in\nlet base = fun y -> y in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun f x -> f a in\nlet base = fun y -> y in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun f x -> fun f a -> f a x in\nlet base = fun y -> y in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = fun f x -> fun f a -> f a x in\nlet base = fun y -> y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun f x -> f a in\nlet base = fun y -> y in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun f x -> f a in\nlet base = fun y -> y in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun f x -> fun f a -> f a x in\nlet base = fun y -> y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun f a -> fun f x -> f z in\nlet base = fun y -> fun y in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun f a -> fun f x -> f z in\nlet base = fun y -> fun y in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun f x -> fun f a -> f a x in\nlet base = fun y -> y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun f a -> fun f x -> f z in\nlet base = fun y in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun f a -> fun f x -> f z in\nlet base = fun y in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun f x -> fun f a -> f a x in\nlet base = fun y -> y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun f a -> fun f x -> f z in\nlet base = fun y -> z in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun f a -> fun f x -> f z in\nlet base = fun y -> z in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun f x -> fun f a -> f a x in\nlet base = fun y -> y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun f a -> fun f x -> f w in\nlet base = fun y -> z in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun f a -> fun f x -> f w in\nlet base = fun y -> z in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun f x -> fun f a -> f a x in\nlet base = fun y -> y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun f a -> fun f x  in\nlet base = fun y -> z in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun f a -> fun f x  in\nlet base = fun y -> z in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun f x -> fun f a -> f a x in\nlet base = fun y -> y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun f a -> fun f x in\nlet base = fun y -> z in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun f a -> fun f x in\nlet base = fun y -> z in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun f x -> fun f a -> f a x in\nlet base = fun y -> y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun f x -> fun f a in\nlet base = fun y -> z in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun f x -> fun f a in\nlet base = fun y -> z in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun f x -> fun f a -> f a x in\nlet base = fun y -> y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun f x -> fun f a -> fun f a x in\nlet base = fun y -> y in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun f x -> fun f a -> fun f a x in\nlet base = fun y -> y in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun z -> x (a z) in\nlet base = fun z -> z in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = fun z -> x (a z) in\nlet base = fun z -> z in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun f x -> fun f a -> f a x in\nlet base = fun y z-> z in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun f x -> fun f a -> f a x in\nlet base = fun y z-> z in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun z -> x (a z) in\nlet base = fun z -> z in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun f x -> f (x a) in\nlet base = fun z -> z in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun f x -> f (x a) in\nlet base = fun z -> z in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun z -> x (a z) in\nlet base = fun z -> z in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun z -> f (x a) in\nlet base = fun z -> z in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun z -> f (x a) in\nlet base = fun z -> z in\nList.fold_left f base fs"}
{"fix": "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = h in\nlet l = \"\" in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = h in\nlet l = \"\" in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a x in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a x in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep in\nlet base = h ^ sep in\nlet l = h in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep in\nlet base = h ^ sep in\nlet l = h in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l", "bad": "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "annotated": "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = sl in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = \"\" in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = \"\" in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = sep in\nlet l = sl in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = t in\nlet l = sl in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = t in\nlet l = sl in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sep ^ a in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sep ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base ", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sep ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base "}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep ^ a in\nlet base = sep in\nlet l = sl in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep ^ a in\nlet base = a in\nlet l = sl in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep ^ a in\nlet base = a in\nlet l = sl in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ sep ^ a in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ sep ^ a in\nlet base =  in\nlet l = sl in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ sep ^ a in\nlet base =  in\nlet l = sl in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = [] in\nlet l = sl in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = [] in\nlet l = sl in\nList.fold_left f base l"}
{"fix": "let stringOfList f l = List.map sepConcat l", "bad": "let stringOfList f l = List.map \"[\" ^ sepConcat l ^ \"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map \"[\" ^ sepConcat l ^ \"]\""}
{"fix": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let stringOfList f l = List.map sepConcat \"\" l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map sepConcat \"\" l"}
{"fix": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let stringOfList f l = List.map f (sepConcat \"\" l)", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map f (sepConcat \"\" l)"}
{"fix": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let stringOfList f l = List.map f (sepConcat l)", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map f (sepConcat l)"}
{"fix": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let stringOfList f l = List.map f (sepConcat \"\" l)", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map f (sepConcat \"\" l)"}
{"fix": "let stringOfList f l = (List.map f l)", "bad": "let stringOfList f l = sepConcat (List.map f l)", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat (List.map f l)"}
{"fix": "let rec clone x n = \nif n <= 0 then []\nelse\nclone (x) (n-1)", "bad": "let rec clone x n = \nif x <= 0 then []\nelse\nclone x::[] (n-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif x <= 0 then []\nelse\nclone x::[] (n-1)"}
{"fix": "let rec clone x n = \nif n <= 0 then []\nelse\nclone (x) (n-1)", "bad": "let rec clone x n = \nif x <= 0 then []\nelse\nclone (x::[]) (n-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif x <= 0 then []\nelse\nclone (x::[]) (n-1)"}
{"fix": "let rec clone x n = \nif n <= 0 then []\nelse\nclone (x) (n-1)", "bad": "let rec clone x n = \nif n <= 0 then []\nelse\nclone (x::[]) (n-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif n <= 0 then []\nelse\nclone (x::[]) (n-1)"}
{"fix": "let rec clone x n = \nif n <= 0 then []\nelse\nclone (x) (n-1)", "bad": "let rec clone x n = \nif n <= 0 then x\nelse\nclone (x::[]) (n-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif n <= 0 then x\nelse\nclone (x::[]) (n-1)"}
{"fix": "let rec clone x n = \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> h::clone t (n-1)", "bad": "let rec clone x n = \nif n <= 0 then []\nelse\nclone (x) (n-1)\nin clone [] n", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif n <= 0 then []\nelse\nclone (x) (n-1)\nin clone [] n"}
{"fix": "let rec clone x n = \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> h::clone t (n-1)", "bad": "let rec clone x n = \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> clone h::x (n-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> clone h::x (n-1)"}
{"fix": "let rec clone x n = \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> h :: clone t (n-1)", "bad": "let _ = clone 3 5", "annotated": "let _ = clone 3 5"}
{"fix": "let rec clone x n = \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> h :: clone t (n-1)", "bad": "let rec clone x n = \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> clone t (n-1) :: h", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> clone t (n-1) :: h"}
{"fix": "let rec clone x n = \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> h :: clone t (n-1)", "bad": "let rec clone x n = \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> clone t (n-1) :: h ::[]", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> clone t (n-1) :: h ::[]"}
{"fix": "let rec clone x n = \nif n <= 0 then []\nelse x :: clone x (n-1)", "bad": "let _ = clone 3 5", "annotated": "let _ = clone 3 5"}
{"fix": "let rec clone x n = \nif n <= 0 then []\nelse x :: clone x (n-1)", "bad": "let rec clone x n = ", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  "}
{"fix": "let padZero l1 l2 = \nlet l = List.length l1 - List.length l2 in\nif l < 0 then ((clone 0 ((-1)*l) @ l2), l2)\nelse (l1, clone 0 l @ l2)", "bad": "let padZero l1 l2 = \nlet l = List.length l1 - List.length l2 in\nif l < 0 then ((clone 0 ((-1)*l) @ l2), l2)\nelse (l1, clone 0 l :: l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet l = List.length l1 - List.length l2 in\nif l < 0 then ((clone 0 ((-1)*l) @ l2), l2)\nelse (l1, clone 0 l :: l2)"}
{"fix": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let padZero l1 l2 = \nlet l = List.length l1 - List.length l2 in\nif l < 0 then ((clone 0 ((-1)*l) @ l1), l2)\nelse (l1, clone 0 l @ l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet l = List.length l1 - List.length l2 in\nif l < 0 then ((clone 0 ((-1)*l) @ l1), l2)\nelse (l1, clone 0 l @ l2)"}
{"fix": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x + a in\nlet base = 0 in\nlet args = x mod 10 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = x + a in\nlet base = 0 in\nlet args = x mod 10 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x + a in\nlet base = 0 in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = x + a in\nlet base = 0 in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let _ = bigAdd [9;9] [1;0;0;2]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a mod 10 :: []\n| h::t -> (a+h) mod 10 :: t in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a mod 10 :: []\n| h::t -> (a+h) mod 10 :: t in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let _ = bigAdd [9;9] [1;0;0;2]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a mod 10\n| h::t -> (a+h) mod 10 in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a mod 10\n| h::t -> (a+h) mod 10 in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let _ = bigAdd [9;9] [1;0;0;2]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a mod 10 :: []\n| h::t -> (a+h) mod 10 :: [] in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a mod 10 :: []\n| h::t -> (a+h) mod 10 :: [] in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let _ = bigAdd [9;9] [1;0;0;2]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a mod 10 :: []\n| h::t -> (a+h) mod 10 :: (a+h)/10 in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a mod 10 :: []\n| h::t -> (a+h) mod 10 :: (a+h)/10 in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let _ = bigAdd [9;9] [1;0;0;2]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a mod 10 :: []\n| h::t -> (a+h) mod 10 :: (a+h)/10 in\nlet base = (0,0) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a mod 10 :: []\n| h::t -> (a+h) mod 10 :: (a+h)/10 in\nlet base = (0,0) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let _ = bigAdd [9;9] [1;0;0;2]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a mod 10\n| h::t -> (a+h) mod 10 in\nlet base = (0,0) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a mod 10\n| h::t -> (a+h) mod 10 in\nlet base = (0,0) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let _ = bigAdd [9;9] [1;0;0;2]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a mod 10\n| h::t -> (a+h) mod 10 in\nlet base = [] in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a mod 10\n| h::t -> (a+h) mod 10 in\nlet base = [] in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let _ = bigAdd [9;9] [1;0;0;2]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a mod 10\n| h::t -> (a+h) mod 10 in\nlet base = [0] in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a mod 10\n| h::t -> (a+h) mod 10 in\nlet base = [0] in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let _ = bigAdd [9;9] [1;0;0;2]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (c,d) -> c in macth x", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| (c,d) -> c in macth x"}
{"fix": "let _ = bigAdd [9;9] [1;0;0;2]", "bad": "with\n| (add1, add2) -> ((c + add1 + add2) mod 10, (c + add1 + add2))", "annotated": "with\n| (add1, add2) -> ((c + add1 + add2) mod 10, (c + add1 + add2))"}
{"fix": "let _ = bigAdd [9;9] [1;0;0;2]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (x,y) -> x in macth x", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| (x,y) -> x in macth x"}
{"fix": "let _ = bigAdd [9;9] [1;0;0;2]", "bad": "with\n| (add1, add2) -> ((x + add1 + add2) mod 10, (x + add1 + add2))", "annotated": "with\n| (add1, add2) -> ((x + add1 + add2) mod 10, (x + add1 + add2))"}
{"fix": "let _ = bigAdd [9;9] [1;0;0;2]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (x,y) -> x in match x with\n| (add1, add2) -> ((x + add1 + add2) mod 10, (x + add1 + add2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| (x,y) -> x in match x with\n| (add1, add2) -> ((x + add1 + add2) mod 10, (x + add1 + add2))"}
{"fix": "let _ = bigAdd [9;9] [1;0;0;2]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (x,y) -> x in match x with\n| (add1, add2) -> (x + add1 + add2) mod 10", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| (x,y) -> x in match x with\n| (add1, add2) -> (x + add1 + add2) mod 10"}
{"fix": "let _ = bigAdd [9;9] [1;0;0;2]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet carry = match a with\n| (x,y) -> x in \nmatch x with\n| (add1, add2) -> \nlet new_carry = (carry + add1 + add2) / 10 in\nlet digit = (carry + add1 + add2) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet carry = match a with\n| (x,y) -> x in \nmatch x with\n| (add1, add2) -> \nlet new_carry = (carry + add1 + add2) / 10 in\nlet digit = (carry + add1 + add2) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let _ = bigAdd [9;9] [1;0;0;2]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n| (add1, add2) -> ((add1 + add2 + a)/ 10, ((add1 + add2 + a) mod 10)::reest)  in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n| (add1, add2) -> ((add1 + add2 + a)/ 10, ((add1 + add2 + a) mod 10)::reest)  in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let _ = bigAdd [9;9] [1;0;0;2]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n| (add1, add2) -> ((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::reest)  in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n| (add1, add2) -> ((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::reest)  in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let _ = bigAdd [9;9] [1;0;0;2]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n| (add1, add2) -> ((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)  in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n| (add1, add2) -> ((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)  in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let _ = removeZero [0;0;0;0]", "bad": "let _ = removeZero [\n\n\nlet bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n\n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)  in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let _ = removeZero [\n\n\nlet bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n\n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)  in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let _ = removeZero [0;0;0;0]", "bad": "let _ = removeZero [\n\n\nlet bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n\n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)  in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let _ = removeZero [\n\n\nlet bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n\n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)  in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let _ = removeZero [0;0;0;0]", "bad": "let _ = bigAdd [9;9] [9;9]", "annotated": "let _ = bigAdd [9;9] [9;9]"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)\n| (_,_) -> ((carry/10), (carry mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest)\n| (_,_) -> ((carry/10), (carry mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let _ = removeZero [0;0;0;0]", "bad": "let _ = removeZero [9;9]", "annotated": "let _ = removeZero [9;9]"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nif x = [] then a\nelse\nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n| (_,_) -> (carry::rest)\n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = match a with\n| (carry, rest) -> match x with \n| (_,_) -> (carry::rest)\n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nif x = [] then a\nelse\nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nif x = () then a\nelse\nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nif x = () then a\nelse\nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nlet carry = \nmatch a with\n| (x,y) -> x in\nmatch x with \n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nif x = (Nil,Nil) then a\nelse\nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nif x = (Nil,Nil) then a\nelse\nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nlet carry = \nmatch a with\n| (x,y) -> x in\nmatch x with \n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nif x = (,) then a\nelse\nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nif x = (,) then a\nelse\nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nlet carry = \nmatch a with\n| (x,y) -> x in\nmatch x with \n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \nif List.length rest = List.length l1 || List.length rest = List.length l2 then\n(0, carry::rest)\nelse\n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \nif List.length rest = List.length l1 or List.length rest = List.length l2 then\ncarry::rest\nelse\n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \nif List.length rest = List.length l1 or List.length rest = List.length l2 then\ncarry::rest\nelse\n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \nif List.length rest = List.length l1 || List.length rest = List.length l2 then\n(0, carry::rest)\nelse\n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \nif List.length rest = List.length l1 or List.length rest = List.length l2 then\n(0, carry::rest)\nelse\n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) -> \nif List.length rest = List.length l1 or List.length rest = List.length l2 then\n(0, carry::rest)\nelse\n((add1 + add2 + carry)/ 10, ((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let _ = bigAdd [9;9] [9;9]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> \nif List.length rest >= List.length l1 || \nList.length rest >= List.length l2 \nthen\n(0, carry::rest)\nelse match x with \n| (add1, add2) ->\n((add1 + add2 + carry)/ 10, \n((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> \nif List.length rest >= List.length l1 || \nList.length rest >= List.length l2 \nthen\n(0, carry::rest)\nelse match x with \n| (add1, add2) ->\n((add1 + add2 + carry)/ 10, \n((add1 + add2 + carry) mod 10)::rest) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let _ = bigAdd [9;9] [9;9]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) ->\n((add1 + add2 + carry)/ 10, \n((add1 + add2 + carry) mod 10)::rest) in\nif List.length rest >= List.length l1 || \nList.length rest >= List.length l2 \nthen\n(0, ((add1 + add2 + carry)/ 10,)::rest)in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) ->\n((add1 + add2 + carry)/ 10, \n((add1 + add2 + carry) mod 10)::rest) in\nif List.length rest >= List.length l1 || \nList.length rest >= List.length l2 \nthen\n(0, ((add1 + add2 + carry)/ 10,)::rest)in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let _ = bigAdd [9;9] [9;9]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) ->\n((add1 + add2 + carry)/ 10, \n((add1 + add2 + carry) mod 10)::rest) in\nif List.length rest >= List.length l1 || \nList.length rest >= List.length l2 \nthen\n(0, ((add1 + add2 + carry)/ 10)::rest)in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) ->\n((add1 + add2 + carry)/ 10, \n((add1 + add2 + carry) mod 10)::rest) in\nif List.length rest >= List.length l1 || \nList.length rest >= List.length l2 \nthen\n(0, ((add1 + add2 + carry)/ 10)::rest)in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let _ = bigAdd [9;9] [9;9]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) ->\nlet new_carry = (add1 + add2 + carry) / 10 in\nlet result = (add1 + add2 + carry) mod 10 :: rest in\nif(List.length result >= List.length l1 ||\nList.length result >= List.length l2) then\n(0, carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) ->\nlet new_carry = (add1 + add2 + carry) / 10 in\nlet result = (add1 + add2 + carry) mod 10 :: rest in\nif(List.length result >= List.length l1 ||\nList.length result >= List.length l2) then\n(0, carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with\n| (carry, rest) -> match x with \n| (add1, add2) ->\nlet new_carry = (add1 + add2 + carry) / 10 in\nlet result = (add1 + add2 + carry) mod 10 :: rest in\nif(List.length result >= List.length l1 ||\nList.length result >= List.length l2) && new_carry > 0 then\n(0, carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let _ = bigAdd [5;0] [5;0]", "annotated": "let _ = bigAdd [5;0] [5;0]"}
{"fix": "let rec mulByDigit i l = \nlet f a x = match a with\n| (carry, rest) -> \nlet new_carry = ((i * x) + carry) / 10 in\nlet result = (((i * x) + carry) mod 10) :: rest in\nif List.length result = List.length l && new_carry = 1 then\n(0, new_carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nList.fold_left f base (List.rev l)", "bad": "let rec mulByDigit i l = \nlet f a x = match a with\n| (carry, rest) -> match x with \n| (mul1, mul2) ->\nlet new_carry = ((mul1 * mul2) + carry) / 10 in\nlet result = (((mul1 * mul2) + carry) mod 10) :: rest in\nif(List.length result = List.length l1 ||\nList.length result = List.length l2) && new_carry = 1 then\n(0, new_carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nList.fold_left f base (List.rev l)", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet f a x = match a with\n| (carry, rest) -> match x with \n| (mul1, mul2) ->\nlet new_carry = ((mul1 * mul2) + carry) / 10 in\nlet result = (((mul1 * mul2) + carry) mod 10) :: rest in\nif(List.length result = List.length l1 ||\nList.length result = List.length l2) && new_carry = 1 then\n(0, new_carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nList.fold_left f base (List.rev l)"}
{"fix": "let rec mulByDigit i l = \nlet f a x = match a with\n| (carry, rest) -> \nlet new_carry = ((i * x) + carry) / 10 in\nlet result = (((i * x) + carry) mod 10) :: rest in\nif List.length result = List.length l && new_carry = 1 then\n(0, new_carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nList.fold_left f base (List.rev l)", "bad": "let rec mulByDigit i l = \nlet f a x = match a with\n| (carry, rest) -> match x with \n| (mul1, mul2) ->\nlet new_carry = ((mul1 * mul2) + carry) / 10 in\nlet result = (((mul1 * mul2) + carry) mod 10) :: rest in\nif(List.length result = List.length l) && new_carry = 1 then\n(0, new_carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nList.fold_left f base (List.rev l)", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet f a x = match a with\n| (carry, rest) -> match x with \n| (mul1, mul2) ->\nlet new_carry = ((mul1 * mul2) + carry) / 10 in\nlet result = (((mul1 * mul2) + carry) mod 10) :: rest in\nif(List.length result = List.length l) && new_carry = 1 then\n(0, new_carry::result)\nelse\n(new_carry, result) in\nlet base = (0,[]) in\nList.fold_left f base (List.rev l)"}
{"fix": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigMul l1 l2 = \nlet f a x = match a with\n| (index, rest) -> \nlet new_index = index + 1 in\nlet results = bigAdd rest ((mulByDigit x l1)@clone 0 index)", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match a with\n| (index, rest) -> \nlet new_index = index + 1 in\nlet results = bigAdd rest ((mulByDigit x l1)@clone 0 index)"}
{"fix": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "bad": ") in\n(new_index, result) in\nlet base = (0,[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": ") in\n(new_index, result) in\nlet base = (0,[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let _ = bigMul [1;5] [1;5]", "bad": "let _ = bigMul [1;5] [1;5]", "annotated": "let _ = bigMul [1;5] [1;5]"}
{"fix": "let rec sumList xs = \nmatch xs with\n[] -> 0\n| xs -> List.hd xs + (sumList (List.tl xs))", "bad": "let rec sumList xs = \nmatch xs with\n[] -> 0\n| xs -> List.hd xs + (sumList List.tl xs)", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n[] -> 0\n| xs -> List.hd xs + (sumList List.tl xs)"}
{"fix": "let rec sumList xs = \nmatch xs with\n[] -> 0\n| xs -> List.hd xs + (sumList (List.tl xs))", "bad": "let _ = sumList [1; 2; 3; 4]", "annotated": "let _ = sumList [1; 2; 3; 4]"}
{"fix": "let rec sumList xs = \nmatch xs with\n[] -> 0\n| xs -> List.hd xs + (sumList (List.tl xs))", "bad": "let _ = sumList [1; -2; 3; 5]", "annotated": "let _ = sumList [1; -2; 3; 5]"}
{"fix": "let rec sumList xs = \nmatch xs with\n[] -> 0\n| xs -> List.hd xs + (sumList (List.tl xs))", "bad": "let _ = sumList [1; 3; 5; 7; 9; 11]", "annotated": "let _ = sumList [1; 3; 5; 7; 9; 11]"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse  digitsOfInt (n/10) @ [n mod 10]", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse  digitsOfInt (n/10) @ n mod 10", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse  digitsOfInt (n/10) @ n mod 10"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse  digitsOfInt (n/10) @ [n mod 10]", "bad": "let _ = digitsOfInt 3124", "annotated": "let _ = digitsOfInt 3124"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse  digitsOfInt (n/10) @ [n mod 10]", "bad": "let _ = digitsOfInt 352663", "annotated": "let _ = digitsOfInt 352663"}
{"fix": "let rec additiveHelper n acc = \nif n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)\nelse acc", "bad": "let additivePersistence n =\nif n > 9 then additivePersistence (List.fold_left (+) (digitsOfInt n))\nelse n", "annotated": "let additivePersistence : int -> int = fun  n  -> \nif n > 9 then additivePersistence (List.fold_left (+) (digitsOfInt n))\nelse n"}
{"fix": "let rec additiveHelper n acc = \nif n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)\nelse acc", "bad": "let _ = additivePersistence 9876", "annotated": "let _ = additivePersistence 9876"}
{"fix": "let rec additiveHelper n acc = \nif n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)\nelse acc", "bad": "let additiveHelper n acc = \nif n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)\nelse acc", "annotated": "let additiveHelper n acc = \nif n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)\nelse acc"}
{"fix": "let rec additiveHelper n acc = \nif n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)\nelse acc", "bad": "let additivePersistence n = additiveHelper n 0", "annotated": "let additivePersistence : int -> int = fun  n  ->  additiveHelper n 0"}
{"fix": "let rec additiveHelper n acc = \nif n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)\nelse acc", "bad": "let _ = additivePersistence 9876", "annotated": "let _ = additivePersistence 9876"}
{"fix": "let rec additiveHelper n acc = \nif n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)\nelse acc", "bad": "let additiveHelper n acc = \nif n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)\nelse acc", "annotated": "let additiveHelper n acc = \nif n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)\nelse acc"}
{"fix": "let rec additiveHelper n acc = \nif n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)\nelse acc", "bad": "let additivePersistence n = additiveHelper n 0", "annotated": "let additivePersistence : int -> int = fun  n  ->  additiveHelper n 0"}
{"fix": "let rec additiveHelper n acc = \nif n > 9 then additiveHelper (sumList(digitsOfInt n)) (acc + 1)\nelse acc", "bad": "let _ = additivePersistence 9876", "annotated": "let _ = additivePersistence 9876"}
{"fix": "let rec assoc (d,k,l) = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc d k ls", "bad": "let rec assoc (d,k,l) = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else \n\n\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else \n\n\n\nlet _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let rec assoc (d,k,l) = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc d k ls", "bad": "let rec assoc (d,k,l) = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)"}
{"fix": "let rec assoc (d,k,l) = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc d k ls", "bad": "let rec assoc (d,k,l) = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)"}
{"fix": "let rec assoc (d,k,l) = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if lk = lk then lv else assoc (d,k,ls)", "bad": "let rec assoc (d,k,l) = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if lk = lk then lv else assoc d k ls", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if lk = lk then lv else assoc d k ls"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)", "bad": "let rec assoc (d,k,l) = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile2 (f, 2)", "bad": "let f x = let xx = x*x*x in (xx, xx < 100 in\nwwhile2 (f, 2)", "annotated": "let f x = let xx = x*x*x in (xx, xx < 100 in\nwwhile2 (f, 2)"}
{"fix": "let fixpoint (f,b) = wwhile ((f (f b)),b)", "bad": "let fixpoint (f,b) = wwhile ((fun (f b) -> if f b = b then b else f b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun (f b) -> if f b  ->  b then b else f b),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((f (f b)),b)", "bad": "let fixpoint (f,b) = wwhile ((fun -> if f b = b then b else f b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun -> if f b  ->  b then b else f b),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((f (f b)),b)", "bad": "let fixpoint (f,b) = wwhile ((fun (f b)-> if f b = b then b else f b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun (f b)-> if f b  ->  b then b else f b),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((f (f b)),b)", "bad": "let fixpoint (f,b) = wwhile ((fun (f, b)-> if f b = b then b else f b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun (f, b)-> if f b  ->  b then b else f b),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((fun f' -> if f b = b then (b,false) else (f b, true)),b)", "bad": "let fixpoint (f,b) = wwhile ((fun f' -> if f b != b then (b,true) else (f b, false)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun f' -> if f b ! ->  b then (b,true) else (f b, false)),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((fun f' -> if f b = b then (b,false) else (f b, true)),b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = wwhile ((fun rec f'-> if f b = b then (b,false) else (f b, true)),b)", "bad": "let fixpoint (f,b) = wwhile ((fun f'-> if f b = b then (b,false) else (f b, true)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun f'-> if f b  ->  b then (b,false) else (f b, true)),b)"}
{"fix": "let rec wwhile (f,b) = \nlet (b',c') = f b in match c' with\n| false -> b'\n|     _ -> wwhile (f, b')", "bad": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile2 (f, 2)", "annotated": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile2 (f, 2)"}
{"fix": "let rec wwhile (f,b) = \nlet (b',c') = f b in match c' with\n| false -> b'\n|     _ -> wwhile (f, b')", "bad": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile2 (f, 2)", "annotated": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile2 (f, 2)"}
{"fix": "let rec wwhile (f,b) = \nlet (b',c') = f b in match c' with\n| false -> b'\n|     _ -> wwhile (f, b')", "bad": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "annotated": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}
{"fix": "let rec wwhile (f,b) = \nlet (b',c') = f b in match c' with\n| false -> b'\n|     _ -> wwhile (f, b')", "bad": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "annotated": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)", "bad": "let fixpoint (f,b) = wwhile ((fun (f,b) -> if f b = b then (f b, false) else (f b, true)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun (f,b) -> if f b  ->  b then (f b, false) else (f b, true)),b)"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)", "bad": "let fixpoint (f,b) = wwhile ((fun (f,b) -> match b with | f b -> (f b, false) | _ -> (f b, true)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((fun (f,b) -> match b with | f b -> (f b, false) | _ -> (f b, true)),b)"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)", "bad": "let fixpoint (f,b) = wwhile ((fun (f,b) -> match b with | (f b) -> (f b, false) | _ -> (f b, true)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((fun (f,b) -> match b with | (f b) -> (f b, false) | _ -> (f b, true)),b)"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)", "bad": "let fixpoint (f,b) = wwhile ((fun (f,b) -> match b with | f b = b -> (f b, false) | _ -> (f b, true)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun (f,b) -> match b with | f b  ->  b -> (f b, false) | _ -> (f b, true)),b)"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)", "bad": "let fixpoint (f,b) = wwhile ((fun (f,b) -> match b with | (f b) = b -> (f b, false) | _ -> (f b, true)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun (f,b) -> match b with | (f b)  ->  b -> (f b, false) | _ -> (f b, true)),b)"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)", "bad": "let fixpoint (f,b) = wwhile ((fun (f,b) -> match f b with | b -> (f b, false) | _ -> (f b, true)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((fun (f,b) -> match f b with | b -> (f b, false) | _ -> (f b, true)),b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile ((fun a -> if b = (f b) then (b,false) else ((f b),true)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun a -> if b  ->  (f b) then (b,false) else ((f b),true)),b)"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w) < eval(t) then eval(u) else eval(z)\n| Times (t,u) -> eval(t) * eval(u)\n| Average (t,u) -> (eval(t) * eval(u)) / 2\n| Cosine t -> cos(pi * eval(t))\n| Sine t -> sin(pi * eval(t))\n| VarX -> x\n| VarY -> y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w) < eval(t) then eval(u) else eval(z)\n| Times (t,u) -> eval(t) * eval(u)\n| Average (t,u) -> (eval(t) * eval(u)) / 2\n| Cosine t -> cos(pi * eval(t))\n| Sine t -> sin(pi * eval(t))\n| VarX -> x\n| VarY -> y"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| Times (t,u) -> eval(t,x,y) * eval(u,x,y)\n| Average (t,u) -> (eval(t,x,y) * eval(u,x,y)) / 2\n| Cosine t -> cos(pi * eval(t,x,y))\n| Sine t -> sin(pi * eval(t,x,y))\n| VarX -> x\n| VarY -> y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| Times (t,u) -> eval(t,x,y) * eval(u,x,y)\n| Average (t,u) -> (eval(t,x,y) * eval(u,x,y)) / 2\n| Cosine t -> cos(pi * eval(t,x,y))\n| Sine t -> sin(pi * eval(t,x,y))\n| VarX -> x\n| VarY -> y"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| Times (t,u) -> eval(t,x,y) * eval(u,x,y)\n| Average (t,u) -> (eval(t,x,y) * eval(u,x,y)) / 2\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| Times (t,u) -> eval(t,x,y) * eval(u,x,y)\n| Average (t,u) -> (eval(t,x,y) * eval(u,x,y)) / 2\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| Times (t,u) -> eval(t,x,y) * eval(u,x,y)\n| Average (t,u) -> (eval(t,x,y) * eval(u,x,y)) / 2\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| Times (t,u) -> eval(t,x,y) * eval(u,x,y)\n| Average (t,u) -> (eval(t,x,y) * eval(u,x,y)) / 2\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "annotated": "let eval : expr * float * float -> float = fun _fn e (x,y)  ->  \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| Times (t,u) -> eval(t,x,y) *. eval(u,x,y)\n| Average (t,u) -> (eval(t,x,y) *. eval(u,x,y)) /. 2.0\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| Times (t,u) -> eval(t,x,y) *. eval(u,x,y)\n| Average (t,u) -> (eval(t,x,y) *. eval(u,x,y)) /. 2.0\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y"}
{"fix": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine(buildHelper(rand, max_depth, curr_depth + 1))\n| 4 -> buildAverage(buildHelper(rand, max_depth, curr_depth + 1), \nbuildHelper(rand, max_depth, curr_depth + 1))\n| 5 -> buildTimes(buildHelper(rand, max_depth, curr_depth + 1 ), \nbuildHelper(rand, max_depth, curr_depth + 1))\n| 6 -> buildThresh(buildHelper(rand, max_depth, curr_depth + 1),\nbuildHelper(rand, max_depth, curr_depth + 1),\nbuildHelper(rand, max_depth, curr_depth + 1),\nbuildHelper(rand, max_depth, curr_depth + 1))\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun Helper rand max_depth curr_depth  ->  \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine(buildHelper(rand, max_depth, curr_depth + 1))\n| 4 -> buildAverage(buildHelper(rand, max_depth, curr_depth + 1), \nbuildHelper(rand, max_depth, curr_depth + 1))\n| 5 -> buildTimes(buildHelper(rand, max_depth, curr_depth + 1 ), \nbuildHelper(rand, max_depth, curr_depth + 1))\n| 6 -> buildThresh(buildHelper(rand, max_depth, curr_depth + 1),\nbuildHelper(rand, max_depth, curr_depth + 1),\nbuildHelper(rand, max_depth, curr_depth + 1),\nbuildHelper(rand, max_depth, curr_depth + 1))\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"}
{"fix": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine(buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage(buildHelper rand max_depth (curr_depth + 1), \nbuildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun Helper rand max_depth curr_depth  ->  \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine(buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage(buildHelper rand max_depth (curr_depth + 1), \nbuildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))"}
{"fix": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": ")\nelse match rand(0,1) with\n| 0 -> buildX\n| 1 -> buildY", "annotated": ")\nelse match rand(0,1) with\n| 0 -> buildX\n| 1 -> buildY"}
{"fix": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine(buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage(buildHelper rand max_depth (curr_depth + 1), \nbuildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun Helper rand max_depth curr_depth  ->  \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine(buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage(buildHelper rand max_depth (curr_depth + 1), \nbuildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))"}
{"fix": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine(buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage(buildHelper rand max_depth (curr_depth + 1), \nbuildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun Helper rand max_depth curr_depth  ->  \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine(buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage(buildHelper rand max_depth (curr_depth + 1), \nbuildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))"}
{"fix": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": ")\nelse match rand(0,1) with\n| 0 -> buildX\n| 1 -> buildY", "annotated": ")\nelse match rand(0,1) with\n| 0 -> buildX\n| 1 -> buildY"}
{"fix": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine(buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage(buildHelper rand max_depth (curr_depth + 1), \nbuildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun Helper rand max_depth curr_depth  ->  \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine(buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage(buildHelper rand max_depth (curr_depth + 1), \nbuildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))"}
{"fix": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": ")\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": ")\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"}
{"fix": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun Helper rand max_depth curr_depth  ->  \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))"}
{"fix": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": ")\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": ")\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"}
{"fix": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX ()\n| 1 -> buildY ()\n| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun Helper rand max_depth curr_depth  ->  \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX ()\n| 1 -> buildY ()\n| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))"}
{"fix": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": ")\nelse match rand(0,1) with\n| 0 -> buildX ()\n| 1 -> buildY ()", "annotated": ")\nelse match rand(0,1) with\n| 0 -> buildX ()\n| 1 -> buildY ()"}
{"fix": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX \n| 1 -> buildY \n| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun Helper rand max_depth curr_depth  ->  \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX \n| 1 -> buildY \n| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))"}
{"fix": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": ")\nelse match rand(0,1) with\n| 0 -> buildX \n| 1 -> buildY", "annotated": ")\nelse match rand(0,1) with\n| 0 -> buildX \n| 1 -> buildY"}
{"fix": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> VarX\n| 1 -> VarY \n| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun Helper rand max_depth curr_depth  ->  \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> VarX\n| 1 -> VarY \n| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))"}
{"fix": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"}
{"fix": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,(depth - 1))\n| 3 -> buildCosine(build rand (depth - 1))\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,(depth - 1))\n| 3 -> buildCosine(build rand (depth - 1))\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"}
{"fix": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"}
{"fix": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()", "bad": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()"}
{"fix": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesMod (w,t,u) -> ((eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) (eval(u,x,y))))\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| Tan t -> tan(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y", "bad": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesMod (w,t,u) -> (eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) eval(u,x,y) )\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesMod (w,t,u) -> (eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) eval(u,x,y) )\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y"}
{"fix": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesMod (w,t,u) -> ((eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) (eval(u,x,y))))\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| Tan t -> tan(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y", "bad": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesMod (w,t,u) -> ((eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) eval(u,x,y)))\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesMod (w,t,u) -> ((eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) eval(u,x,y)))\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y"}
{"fix": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesMod (w,t,u) -> ((eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) (eval(u,x,y))))\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| Tan t -> tan(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y", "bad": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesMod (w,t,u) -> ((eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) (eval(u,x,y))))\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesMod (w,t,u) -> ((eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) (eval(u,x,y))))\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base =  0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| [] -> []\n| (x,y)::t -> ((x+y)/10)::((x+y)%10)", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| [] -> []\n| (x,y)::t -> ((x+y)/10)::((x+y)%10)"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base =  0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| [] -> []\n| (x,y)::t -> ((x+y)/10)::((x+y)%10)::t", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| [] -> []\n| (x,y)::t -> ((x+y)/10)::((x+y)%10)::t"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base =  0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| [] -> []\n| (x,y)::t -> ((x+y)/10)::((x+y)%10)::a", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| [] -> []\n| (x,y)::t -> ((x+y)/10)::((x+y)%10)::a"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base =  0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| [] -> []\n| (x,y)::t -> ((x+y)/10)::((x+y)%10) @ a", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| [] -> []\n| (x,y)::t -> ((x+y)/10)::((x+y)%10) @ a"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| [] -> []\n| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| [] -> []\n| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t\n| _ -> []", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t\n| _ -> []"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t\n| _ -> a", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t\n| _ -> a"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2) @ (0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2) @ (0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2) @ (0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| (x,y)::t -> ((x+y)/10)::((x+y) mod 10)::t\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2) @ (0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::t\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2) @ (0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::t\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2) @ (0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::t\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2) @ (0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::t\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2) @ (0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2) @ (0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2) @ (0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)::(0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)::(0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add l1 l2 = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)::(0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add l1 l2 = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)::(0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::a::((w+y) mod 10)\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)::(0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::a::((w+y) mod 10)\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)::(0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)::(0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)::(0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (*match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in *)\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = (*match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in *)\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (*match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in *)in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = (*match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in *)in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\"(*match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in *)in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\"(*match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in *)in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\"(*match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in *)in\nlet base = [] in\nlet args =  (0, List.rev ((List.combine l1 l2))) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\"(*match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in *)in\nlet base = [] in\nlet args =  (0, List.rev ((List.combine l1 l2))) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = [] in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = [] in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = [] in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = [] in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  List.rev( List.combine l1 l2 ) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = [] in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = [] in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  List.rev((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  List.rev((List.combine l1 l2) @ (0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  List.rev((List.combine l1 l2) @ (0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  List.rev((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  List.rev((List.combine l1 l2)::(0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  List.rev((List.combine l1 l2)::(0,0)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  List.rev((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = [(0,0)] in\nlet args =  List.rev((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = [(0,0)] in\nlet args =  List.rev((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  List.rev((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base =  in\nlet args =  List.rev((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base =  in\nlet args =  List.rev((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = failwith \"TBD\" in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = failwith \"TBD\" in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": ")::t\n| [] -> [] in\nlet base = (_, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": ")::t\n| [] -> [] in\nlet base = (_, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = failwith \"TBD\" in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = failwith \"TBD\" in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": ") @ t\n| [] -> [] in\nlet base = (_, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": ") @ t\n| [] -> [] in\nlet base = (_, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = failwith \"TBD\" in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = failwith \"TBD\" in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": ")\n| [] -> [] in\nlet base = (_, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": ")\n| [] -> [] in\nlet base = (_, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = failwith \"TBD\" in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t\n| [] -> [] \nin\nlet base = (_, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t\n| [] -> [] \nin\nlet base = (_, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = failwith \"TBD\" in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t\n| [] -> [] \nin\nlet base = (c, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t\n| [] -> [] \nin\nlet base = (c, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = failwith \"TBD\" in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10)::((w+y+z) mod 10)::t\n| [] -> [] \nin\nlet base = (c, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10)::((w+y+z) mod 10)::t\n| [] -> [] \nin\nlet base = (c, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = failwith \"TBD\" in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch x with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t\n| [] -> [] \nin\nlet base = (c, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch x with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t\n| [] -> [] \nin\nlet base = (c, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = failwith \"TBD\" in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t\n| [] -> [] \nin\nlet base = (c, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t\n| [] -> [] \nin\nlet base = (c, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = failwith \"TBD\" in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)\n| [] -> [] \nin\nlet base = (c, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)\n| [] -> [] \nin\nlet base = (c, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = failwith \"TBD\" in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)\n| [] -> (0,0)\nin\nlet base = (c, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)\n| [] -> (0,0)\nin\nlet base = (c, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = failwith \"TBD\" in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)\n| [] -> (0,0)\nin\nlet base = (_, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)\n| [] -> (0,0)\nin\nlet base = (_, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = failwith \"TBD\" in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)\n| [] -> (0,0)\nin\nlet base = (0, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)\n| [] -> (0,0)\nin\nlet base = (0, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = failwith \"TBD\" in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t\n| [] -> (0,0)\nin\nlet base = (0, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet z = (fst x + snd x) in \nmatch a with\n| (w,y)::t -> ((w+z+y)/10),((w+y+z) mod 10)::t\n| [] -> (0,0)\nin\nlet base = (0, 0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = failwith \"TBD\" in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| h::t -> ((h+z)/10)::((h+z) mod 10):: t \n| _ -> (z/10)::(z mod 10)in\nlet base = [] in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| h::t -> ((h+z)/10)::((h+z) mod 10):: t \n| _ -> (z/10)::(z mod 10)in\nlet base = [] in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = failwith \"TBD\" in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| h::t -> ((h+z)/10)::((h+z) mod 10):: t \n| _ -> ((z/10),[z mod 10])in\nlet base = [] in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| h::t -> ((h+z)/10)::((h+z) mod 10):: t \n| _ -> ((z/10),[z mod 10])in\nlet base = [] in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = failwith \"TBD\" in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| h::t -> ((h+z)/10)::((h+z) mod 10):: t \n| _ -> (z/10)::[z mod 10] in\nlet base = [] in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| h::t -> ((h+z)/10)::((h+z) mod 10):: t \n| _ -> (z/10)::[z mod 10] in\nlet base = [] in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = failwith \"TBD\" in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| h::t -> (((h+z)/10), ((h+z) mod 10)):: t \n| _ -> ((z/10),(z mod 10)) in\nlet base = [] in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| h::t -> (((h+z)/10), ((h+z) mod 10)):: t \n| _ -> ((z/10),(z mod 10)) in\nlet base = [] in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = failwith \"TBD\" in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| h::t -> (((h+z)/10), ((h+z) mod 10))::t \n| _ -> ((z/10),(z mod 10)) in\nlet base = [] in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| h::t -> (((h+z)/10), ((h+z) mod 10))::t \n| _ -> ((z/10),(z mod 10)) in\nlet base = [] in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = failwith \"TBD\" in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y)", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = failwith \"TBD\" in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y)\nin \nlet base = [] in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y)\nin \nlet base = [] in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,0) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0, _ ) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0, _ ) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0, l) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0, l) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = [] in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = [] in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\n| _ -> ( ((z)/10), [z mod 10])\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\n| _ -> ( ((w+z)/10), ((w+z) mod 10))\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\n| _ -> ( ((w+z)/10), ((w+z) mod 10))\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\n| _ -> ( ((z)/10), [z mod 10])\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\n| _ -> ( ((z)/10), ((z) mod 10))\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\n| _ -> ( ((z)/10), ((z) mod 10))\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) )in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) @ (0,0))in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) @ (0,0))in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) )in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2)::(0,0))in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2)::(0,0))in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) )in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2)::([0],[0]))in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2)::([0],[0]))in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w, [])   -> (w, (z/10)::(z mod 10))\n| (w, h::t) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) )in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = [] in\nlet args =  List.rev( (List.combine l1 l2) )in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = [] in\nlet args =  List.rev( (List.combine l1 l2) )in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,[]) -> ( ((w+z)/10), 0::((w+z)mod 10)::[])\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) )in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,[]) -> ( ((w+z)/10), 0::((w+z)mod 10)::y\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) )in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,[]) -> ( ((w+z)/10), 0::((w+z)mod 10)::y\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) )in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,[]) -> ( ((w+z)/10), 0::((w+z)mod 10)::[])\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) )in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,[]) -> ( ((w+z)/10), 0::((w+z)mod 10)::y)\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) )in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let z = (fst x + snd x) in match a with\n| (w,[]) -> ( ((w+z)/10), 0::((w+z)mod 10)::y)\n| (w,y) -> ( ((w+z)/10), ((w+z) mod 10)::y )\nin \nlet base = (0,[]) in\nlet args =  List.rev( (List.combine l1 l2) )in\nlet (_, res) = List.fold_left f base args in\nres\nin \nadd (padZero l1 l2)"}
{"fix": "let rec mulByDigit i l = \nlet l1 = List.rev l in\nlet l2 = [i] in\nlet mul (l1, l2) = \nlet f a x = let z = fst x * snd x in \nmatch a with\n| (w,y) -> (((w+z)/10), ((w+z) mod 10)::y)\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero(mul (padZero l1 l2))", "bad": "let rec mulByDigit i l = \nlet l1 = List.reverse l in\nlet l2 = [i] in\nlet mul (l1, l2) = \nlet f a x = let z = fst x * snd x in \nmatch a with\n| (w,y) -> (((w+z)/10), ((w+z) mod 10)::y)\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero(mul (padZero l1 l2))", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet l1 = List.reverse l in\nlet l2 = [i] in\nlet mul (l1, l2) = \nlet f a x = let z = fst x * snd x in \nmatch a with\n| (w,y) -> (((w+z)/10), ((w+z) mod 10)::y)\nin \nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero(mul (padZero l1 l2))"}
{"fix": "let rec mulByDigit i l = \nlet rec helper i l acc = match i with\n| 0 -> [0]\n| 1 -> l\n| _ -> helper (i-1) l (bigAdd acc l)\nin \nhelper i l [0]", "bad": "let rec mulByDigit i l = \nlet rec helper acc n lis = match n with\n| 1 -> lis + acc\n| _ -> helper (n - 1) (bigAdd l lis)", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet rec helper acc n lis = match n with\n| 1 -> lis + acc\n| _ -> helper (n - 1) (bigAdd l lis)"}
{"fix": "let rec mulByDigit i l = \nlet rec helper i l acc = match i with\n| 0 -> [0]\n| 1 -> l\n| _ -> helper (i-1) l (bigAdd acc l)\nin \nhelper i l [0]", "bad": "let rec mulByDigit i l = \nlet rec helper acc n lis = match n with\n| 1 -> lis + acc\n| _ -> helper (n - 1) (bigAdd l lis)\nin \nhelper [] i l", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet rec helper acc n lis = match n with\n| 1 -> lis + acc\n| _ -> helper (n - 1) (bigAdd l lis)\nin \nhelper [] i l"}
{"fix": "let rec mulByDigit i l = \nlet rec helper i l acc = match i with\n| 0 -> [0]\n| 1 -> l\n| _ -> helper (i-1) l (bigAdd acc l)\nin \nhelper i l [0]", "bad": "let rec mulByDigit i l = \nlet rec helper acc n lis = match n with\n| 1 -> lis + acc\n| _ -> helper (n - 1) (bigAdd l lis)\nin \nhelper [0] i l", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet rec helper acc n lis = match n with\n| 1 -> lis + acc\n| _ -> helper (n - 1) (bigAdd l lis)\nin \nhelper [0] i l"}
{"fix": "let rec mulByDigit i l = \nlet rec helper i l acc = match i with\n| 0 -> [0]\n| 1 -> l\n| _ -> helper (i-1) l (bigAdd acc l)\nin \nhelper i l [0]", "bad": "let rec mulByDigit i l = \nlet rec helper acc n lis = match n with\n| 1 -> bigAdd lis acc\n| _ -> helper (n - 1) (bigAdd l lis)\nin \nhelper [0] i l", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet rec helper acc n lis = match n with\n| 1 -> bigAdd lis acc\n| _ -> helper (n - 1) (bigAdd l lis)\nin \nhelper [0] i l"}
{"fix": "let rec mulByDigit i l = \nlet rec helper w y acc = match i with\n| 0 -> [0]\n| 1 -> l\n| _ -> helper (w-1) y (bigAdd acc y)\nin \nhelper i l [0]", "bad": "let rec mulByDigit i l = \nlet rec helper w y acc = match i with\n| 0 -> [0]\n| 1 -> l\n| _ -> helper (w-1) y (bigAdd acc y)\nin \nhelper i l [10", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet rec helper w y acc = match i with\n| 0 -> [0]\n| 1 -> l\n| _ -> helper (w-1) y (bigAdd acc y)\nin \nhelper i l [10"}
{"fix": "let rec mulByDigit i l = \nlet rec adder n li acc = match n with\n| 0 -> [0]\n| 1 -> bigAdd li acc\n| _ -> adder (n-1) li (bigAdd acc li) \nin \nadder i l [0]", "bad": "let _ = mulByDigit 0 [1;2;3]", "annotated": "let _ = mulByDigit 0 [1;2;3]"}
{"fix": "let _ = mulByDigit 999999999 [9;9;9;9]", "bad": "let _ = mulByDigit 5 [6;9;8;9]", "annotated": "let _ = mulByDigit 5 [6;9;8;9]"}
{"fix": "let _ = mulByDigit 999999999 [9;9;9;9]", "bad": "let _ = mulByDigit 3 [9;9;9;9]", "annotated": "let _ = mulByDigit 3 [9;9;9;9]"}
{"fix": "let _ = mulByDigit 999999999 [9;9;9;9]", "bad": "let _ = mulByDigit 0 [1;2;3]", "annotated": "let _ = mulByDigit 0 [1;2;3]"}
{"fix": "let _ = mulByDigit 999999999 [9;9;9;9]", "bad": "let _ = mulByDigit 9999999 [9;9;9;9;9;9;9;9;9;9;]", "annotated": "let _ = mulByDigit 9999999 [9;9;9;9;9;9;9;9;9;9;]"}
{"fix": "let bigMul l1 l2 = \nlet f a x = match a with\n| (w,y) -> ( w, bigAdd a (mulByDigit (clone x (List.length y)) l1)) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = let z = fst x * snd x in\nmatch a with\n| (w,y) -> ((w+z)/10), ((w+z) mod 10)::y", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let z = fst x * snd x in\nmatch a with\n| (w,y) -> ((w+z)/10), ((w+z) mod 10)::y"}
{"fix": "let bigMul l1 l2 = \nlet f a x = match a with\n| (w,y) -> ( w, bigAdd a (mulByDigit (clone x (List.length y)) l1)) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": ")\nin \nlet base = (0,[]) in\nlet args = failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": ")\nin \nlet base = (0,[]) in\nlet args = failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = match a with\n| (w,y) -> ( w, bigAdd a (mulByDigit (clone x (List.length y)) l1)) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = let z = fst x * snd x in\nmatch a with\n| (w,y) -> (((w+z)/10), ((w+z) mod 10)::y)\nin \nlet base = (0,[]) in\nlet args = failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let z = fst x * snd x in\nmatch a with\n| (w,y) -> (((w+z)/10), ((w+z) mod 10)::y)\nin \nlet base = (0,[]) in\nlet args = failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let rec bigCombiner l1 l2 acc = \nmatch l1 with\n| [] -> acc\n| h::t -> mulByDigit h l2", "bad": "let bigMul l1 l2 = \nlet f a x = match a with\n| (w,y) -> ( w, bigAdd y (mulByDigit (clone x (List.length y)) l1)) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match a with\n| (w,y) -> ( w, bigAdd y (mulByDigit (clone x (List.length y)) l1)) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let rec bigCombiner l1 l2 acc = \nmatch l1 with\n| [] -> acc\n| h::t -> mulByDigit h l2", "bad": "let bigMul l1 l2 = \nlet f a x = match a with\n| (w,y) -> ( w, bigAdd y (mulByDigit (x * (List.length y)) l1)) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match a with\n| (w,y) -> ( w, bigAdd y (mulByDigit (x * (List.length y)) l1)) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": ";;", "bad": "let bigMul l1 l2 = \nlet f a x = x in \nlet base = (0, []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = x in \nlet base = (0, []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let rec mulByTen n = match n with\n| 0 -> 0\n| 1 -> 10\n| _ -> 10 * (mulByTen (n-1))", "bad": "let bigMul l1 l2 = \nlet f a x =  x in \nlet base = (0, []) in\nlet args = ( List.rev l1 , List.rev l2 ) in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x =  x in \nlet base = (0, []) in\nlet args = ( List.rev l1 , List.rev l2 ) in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let _ = additivePersistence 9876", "bad": "let rec additivePersistence (a, n) = \nif n < 10\nthen (n, 0)\nelse let (a', n') = (additivePersistence (a+1, sumList(digits n)))", "annotated": "let rec additivePersistence : int -> int = fun  (a, n)  ->  \nif n < 10\nthen (n, 0)\nelse let (a', n') = (additivePersistence (a+1, sumList(digits n)))"}
{"fix": "let _ = additivePersistence 9876", "bad": "let rec additivePersistence (a, n) = \nif n < 10\nthen (n, 0)\nelse additivePersistence (a+1, sumList(digits n))", "annotated": "let rec additivePersistence : int -> int = fun  (a, n)  ->  \nif n < 10\nthen (n, 0)\nelse additivePersistence (a+1, sumList(digits n))"}
{"fix": "let _ = additivePersistence 9876", "bad": ")", "annotated": ")"}
{"fix": "let _ = additivePersistence 9876", "bad": "let rec additivePersistence (a, n) = \nif n < 10\nthen (n, 0)\nelse additivePersistence (a+1, sumList(digits n))", "annotated": "let rec additivePersistence : int -> int = fun  (a, n)  ->  \nif n < 10\nthen (n, 0)\nelse additivePersistence (a+1, sumList(digits n))"}
{"fix": "let _ = additivePersistence (0,9876)", "bad": "let rec additivePersistence (a, n) = \nif n < 10\nthen (a, n)\nelse additivePersistence (a+1, sumList(digits n))", "annotated": "let rec additivePersistence : int -> int = fun  (a, n)  ->  \nif n < 10\nthen (a, n)\nelse additivePersistence (a+1, sumList(digits n))"}
{"fix": "let rec sumList xs = match xs with\n[] -> 0\n| x :: xs -> x + sumList xs", "bad": "let _ = digitalRoot 9876", "annotated": "let _ = digitalRoot 9876"}
{"fix": "let rec additivePersistenceDigitalRoot (a, n) = \nif n < 10\nthen (a, n)\nelse additivePersistenceDigitalRoot (a+1, sumList(digits n))", "bad": "let rec additivePersistence (a, n) = \nlet intFun (a, n) = \nif n < 10\nthen (a, n)\nelse intFun (a+1, sumList(digits n))\nin (4,5)", "annotated": "let rec additivePersistence : int -> int = fun  (a, n)  ->  \nlet intFun (a, n) = \nif n < 10\nthen (a, n)\nelse intFun (a+1, sumList(digits n))\nin (4,5)"}
{"fix": "let _ = digitsOfInt 03124", "bad": "let _ = digitsOfInt o3124", "annotated": "let _ = digitsOfInt o3124"}
{"fix": "let palindrome (w, p) = \nif (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindrome (w, p + 1)", "bad": "let palindrome (w, p) = \nif (List.length w) > (2 * p) and ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindrome (w, p + 1)", "annotated": "let palindrome : string -> bool = fun  (w, p)  ->  \nif (List.length w) > (2 * p) and ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindrome (w, p + 1)"}
{"fix": "let rec palindromeA (w, p) = \nif (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindromeA (w, p + 1)", "bad": "let _ = palindrome (['a'], 0);\n\nlet palindrome w = failwith \"TBD\"", "annotated": "let _ = palindrome (['a'], 0);\n\nlet palindrome : string -> bool = fun  w  ->  failwith \"TBD\""}
{"fix": "let rec palindromeA (w, p) = \nif (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindromeA (w, p + 1)", "bad": "let palindromeA (w, p) = \nif (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindromeA (w, p + 1)", "annotated": "let palindrome : string -> bool = fun A (w, p)  ->  \nif (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindromeA (w, p + 1)"}
{"fix": "let rec palindromeA (w, p) = \nif (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindromeA (w, p + 1)", "bad": "let _ = palindromeA (['a'], 0)", "annotated": "let _ = palindromeA (['a'], 0)"}
{"fix": "let rec palindromeA (w, p) = \nif (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindromeA (w, p + 1)", "bad": "let palindromeA (w, p) = \nif (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindromeA (w, p + 1)", "annotated": "let palindrome : string -> bool = fun A (w, p)  ->  \nif (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindromeA (w, p + 1)"}
{"fix": "let rec palindromeA (w, p) = \nif (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindromeA (w, p + 1)", "bad": "let _ = palindromeA (['a'], 0)", "annotated": "let _ = palindromeA (['a'], 0)"}
{"fix": "let rec palindromeA (w, p) = \nif ((List.length w) > (2 * p)) && (((List.nth w p) = (List.nth w (List.length w - 1 - p))))\nthen true\nelse palindromeA (w, p + 1)", "bad": "let _ = palindromeA (['a','b', 'c'], 0)", "annotated": "let _ = palindromeA (['a','b', 'c'], 0)"}
{"fix": "let rec palindromeA (w, p) = \nif (List.length w) <= (2 * p)\nthen if ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse false\nelse palindromeA (w, p + 1)", "bad": "let rec palindromeA (w, p) = \nif (List.length w) <= (2 * p)\nif ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse false\nelse palindromeA (w, p + 1)", "annotated": "let rec palindrome : string -> bool = fun A (w, p)  ->  \nif (List.length w) <= (2 * p)\nif ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse false\nelse palindromeA (w, p + 1)"}
{"fix": "let fixpoint (f,b) =\nwwhile (if f b = b then (f b, false) else (f b, true),b)", "bad": "let fixpoint (f,b) =\nwwhile ((f, (f b) != b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile ((f, (f b) != b),b)"}
{"fix": "let fixpoint (f,b) =\nwwhile (if f b = b then (f b, false) else (f b, true),b)", "bad": "let fixpoint (f,b) =\nwwhile ((f, f b = b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile ((f, f b = b),b)"}
{"fix": "let fixpoint (f,b) =\nwwhile (if f b = b then (f b, false) else (f b, true),b)", "bad": "let fixpoint (f,b) =\nwwhile ((f, true),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile ((f, true),b)"}
{"fix": "let fixpoint (f,b) =\nwwhile (if f b = b then (f b, false) else (f b, true),b)", "bad": "let fixpoint (f,b) =\nwwhile ((failwith \"asd\", true),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile ((failwith \"asd\", true),b)"}
{"fix": "let fixpoint (f,b) =\nwwhile (if f b = b then (f b, false) else (f b, true),b)", "bad": "let fixpoint (f,b) =\nwwhile ((failwith \"asd\", failwith \"asd\"),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile ((failwith \"asd\", failwith \"asd\"),b)"}
{"fix": "let fixpoint (f,b) =\nwwhile (if f b = b then (f b, false) else (f b, true),b)", "bad": "let fixpoint (f,b) =\nwwhile ((failwith \"asd\", undefined),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile ((failwith \"asd\", undefined),b)"}
{"fix": "let fixpoint (f,b) =\nwwhile (if f b = b then (f b, false) else (f b, true),b)", "bad": "let fixpoint (f,b) =\nwwhile ((failwith \"Asd\"),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile ((failwith \"Asd\"),b)"}
{"fix": "let fixpoint (f,b) =\nwwhile ((if f b = b then (failwith \"asd\") else failwith \"asd\") ,b)", "bad": "let fixpoint (f,b) =\nwwhile (if f b = b then (f b, false) else failwith \"asd\" ,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (if f b = b then (f b, false) else failwith \"asd\" ,b)"}
{"fix": "let fixpoint (f,b) =\nwwhile ((if f b = b then (failwith \"asd\") else failwith \"asd\") ,b)", "bad": "let fixpoint (f,b) =\nwwhile ((if f b = b then (f b, false) else failwith \"asd\") ,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile ((if f b = b then (f b, false) else failwith \"asd\") ,b)"}
{"fix": "let fixpoint (f,b) =\nwwhile ((if f b = b then (failwith \"asd\") else failwith \"asd\") ,b)", "bad": "let fixpoint (f,b) =\nwwhile ((if f b = b then failwith \"asd\" else failwith \"asd\") ,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile ((if f b = b then failwith \"asd\" else failwith \"asd\") ,b)"}
{"fix": "let fixpoint (f,b) =\nwwhile ((if f b = b then (fun b''\n-> (f b, false)) else failwith \"asd\") ,b)", "bad": "let fixpoint (f,b) =\nwwhile ((if f b = b then (true, failwith \"asd\") else failwith \"asd\") ,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile ((if f b = b then (true, failwith \"asd\") else failwith \"asd\") ,b)"}
{"fix": "let fixpoint (f,b) =\nwwhile ((if f b = b then (fun b''\n-> (f b, false)) else failwith \"asd\") ,b)", "bad": "let fixpoint (f,b) =\nwwhile ((if f b = b then (b, failwith \"asd\") else failwith \"asd\") ,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile ((if f b = b then (b, failwith \"asd\") else failwith \"asd\") ,b)"}
{"fix": "let fixpoint (f,b) =\nwwhile ((if f b = b then (fun b''\n-> (f b, false)) else failwith \"asd\") ,b)", "bad": "let fixpoint (f,b) =\nwwhile ((if f b = b then (failwith \"Asd\", failwith \"asd\") else failwith \"asd\") ,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile ((if f b = b then (failwith \"Asd\", failwith \"asd\") else failwith \"asd\") ,b)"}
{"fix": "let fixpoint (f,b) =\nwwhile ((if f b = b then (fun b''\n-> (f b, false)) else failwith \"asd\") ,b)", "bad": "let fixpoint (f,b) =\nwwhile ((if f b = b then (fun b''\n-> (failwith \"Asd\", failwith \"asd\")) else failwith \"asd\") ,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile ((if f b = b then (fun b''\n-> (failwith \"Asd\", failwith \"asd\")) else failwith \"asd\") ,b)"}
{"fix": "let fixpoint (f,b) =\nwwhile ((if f b = b \nthen (fun b'' -> (f b, false)) \nelse (fun b'' -> (f b, true))), b)", "bad": "let fixpoint (f,b) =\nwwhile ((if f b = b \nthen (fun b''\n-> (f b, false)) \nelse (fun b'' -> (f b, true) ,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile ((if f b = b \nthen (fun b''\n-> (f b, false)) \nelse (fun b'' -> (f b, true) ,b)"}
{"fix": "let fixpoint (f,b) =\nwwhile ((if f b = b \nthen (fun b'' -> (f b, false)) \nelse (fun b'' -> (f b, true))), b)", "bad": "let fixpoint (f,b) =\nwwhile ((if f b = b \nthen (fun b''\n-> (f b, false)) \nelse (fun b'' -> (f b, true))) ,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile ((if f b = b \nthen (fun b''\n-> (f b, false)) \nelse (fun b'' -> (f b, true))) ,b)"}
{"fix": "let fixpoint (f,b) =\nwwhile ((fun b' -> if f b' = b' \nthen (f b', false)\nelse (f b', true)), b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) <. (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)", "bad": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi * eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) + (eval (i2, x, y))) / 2.0)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi * eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) + (eval (i2, x, y))) / 2.0)"}
{"fix": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) <. (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)", "bad": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) + (eval (i2, x, y))) / 2.0)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) + (eval (i2, x, y))) / 2.0)"}
{"fix": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) <. (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)", "bad": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) / 2.0)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) / 2.0)"}
{"fix": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) <. (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)", "bad": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)"}
{"fix": "let g1 () = failwith \"to be implemented\"", "bad": "let rec build (rand, depth) = \nlet r = rand (if depth = 0 then (6, 7) else (1, 5)) in\nmatch r with\n1 -> buildSine (build (rand, depth - 1))\n| 2 -> buildCosine (build (rand, depth - 1))\n| 3 -> buildAverage ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 4 -> buildTimes (build (rand, depth - 1)) (build (rand, depth - 1))\n| 5 -> buildThresh (build (rand, depth - 1)) (build (rand, depth - 1)) (build (rand, depth - 1)) (build (rand, depth - 1))\n| 6 -> VarX\n| 7 -> VarY", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet r = rand (if depth = 0 then (6, 7) else (1, 5)) in\nmatch r with\n1 -> buildSine (build (rand, depth - 1))\n| 2 -> buildCosine (build (rand, depth - 1))\n| 3 -> buildAverage ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 4 -> buildTimes (build (rand, depth - 1)) (build (rand, depth - 1))\n| 5 -> buildThresh (build (rand, depth - 1)) (build (rand, depth - 1)) (build (rand, depth - 1)) (build (rand, depth - 1))\n| 6 -> VarX\n| 7 -> VarY"}
{"fix": "let g1 () = failwith \"to be implemented\"", "bad": "let rec build (rand, depth) = \nlet r = rand (if depth = 0 then (6, 7) else (1, 5)) in\nmatch r with\n1 -> buildSine (build (rand, depth - 1))\n| 2 -> buildCosine (build (rand, depth - 1))\n| 3 -> buildAverage ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 4 -> buildTimes ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 5 -> buildThresh ((build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)))\n| 6 -> VarX\n| 7 -> VarY", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet r = rand (if depth = 0 then (6, 7) else (1, 5)) in\nmatch r with\n1 -> buildSine (build (rand, depth - 1))\n| 2 -> buildCosine (build (rand, depth - 1))\n| 3 -> buildAverage ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 4 -> buildTimes ((build (rand, depth - 1)), (build (rand, depth - 1)))\n| 5 -> buildThresh ((build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)), (build (rand, depth - 1)))\n| 6 -> VarX\n| 7 -> VarY"}
{"fix": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin let my_log = fun l' -> let l = (max 0.1 l') in (log l) /. (log 10.0)\nin\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)", "bad": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin let my_log = fun l' -> let l = (min 0.1 l') in (log l) / (log 10.0)\nin\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin let my_log = fun l' -> let l = (min 0.1 l') in (log l) / (log 10.0)\nin\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)"}
{"fix": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin let my_log = fun l' -> let l = (max 0.1 l') in (log l) /. (log 10.0)\nin\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)", "bad": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin let my_log = fun l' -> let l = (min 0.1 l') in (log l) /. (log 10.0)\nin\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> 2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0\n| SinLog (a',b',c) ->\nlet a = abs_float (eval (a', x, y))\nin let b = abs_float (eval (b', x, y))\nin let my_log = fun l' -> let l = (min 0.1 l') in (log l) /. (log 10.0)\nin\nif eval (c, x, y) < 0.0\nthen (my_log (a *. 100.0)) ** (sin (pi *. b *. 100.0)) -. 1.0\nelse -1.0 *. ((my_log (b *. 100.0)) ** (pi *. sin (a *. 100.0)) -. 1.0)"}
{"fix": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a\nin max' -1.0 (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> 1.0", "bad": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> max 1.0 (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> 1.0", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> max 1.0 (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> 1.0"}
{"fix": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a\nin max' -1.0 (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> 1.0", "bad": "let rec eval (e,x,y) = match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a\nin max' 1.0 (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> 1.0", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX -> x\n| VarY -> y\n| Sine i -> sin (pi *. eval (i, x, y))\n| Cosine i -> cos (pi *. eval (i, x, y))\n| Average (i1, i2) -> (((eval (i1, x, y)) +. (eval (i2, x, y))) /. 2.0)\n| Times (i1, i2) -> (eval (i1, x, y)) *. (eval (i2, x, y))\n| Thresh (i1, i2, i3, i4) -> \nif (eval (i1, x, y)) < (eval (i2, x, y)) \nthen eval (i3, x, y)\nelse eval (i4, x, y)\n| ECosSin (a,b) -> let max' = fun a b -> if a < b then b else a\nin max' 1.0 (min 1.0 (2.71 ** ((sin (pi *. eval (a, x, y))) +. (cos (pi *. eval(b, x, y))) -. 1.0) -. 1.0))\n| SinLog (a',b',c) -> 1.0"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun y -> y in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun y -> y in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun y -> y in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let _ = pipe [(fun x -> x)] 4", "bad": "let _ = pipe [(fun x -> x + 2)] 4", "annotated": "let _ = pipe [(fun x -> x + 2)] 4"}
{"fix": "let _ = pipe [(fun x -> x)] 4", "bad": "let _ = pipe [(fun x -> 2)] 4", "annotated": "let _ = pipe [(fun x -> 2)] 4"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun y -> y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = fun y -> y in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = fun y -> y in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun y -> y + 3 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fun y -> y _+ 3 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun y -> y _+ 3 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = a in\nlet base = fun y -> y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = 3 + a in\nlet base = fun y -> y in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = 3 + a in\nlet base = fun y -> y in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = a in\nlet base = fun y -> y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = 3 + a in\nlet base = fun y -> y in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = 3 + a in\nlet base = fun y -> y in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun y -> y in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x); (fun x -> x)] 4", "annotated": "let _ = pipe [(fun x -> x); (fun x -> x)] 4"}
{"fix": "let pipe fs = \nlet f a x = fun g -> (x a) g in\nlet base = fun g -> g in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun g -> g (x a) in\nlet base = fun g -> g in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun g -> g (x a) in\nlet base = fun g -> g in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun g -> (x a) g in\nlet base = fun g -> g in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun g -> (x a) g in\nlet base = fun g -> g in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun g -> (a x) g in\nlet base = fun g -> g in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun g -> (a x) g in\nlet base = fun g -> g in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun g -> (x a) g in\nlet base = fun g -> g in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun g -> g (a x)  in\nlet base = fun g -> g in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun g -> g (a x)  in\nlet base = fun g -> g in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun g -> (x a) g in\nlet base = fun g -> g in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun g -> g (x a)  in\nlet base = fun g -> g in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun g -> g (x a)  in\nlet base = fun g -> g in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun g -> (x a) g in\nlet base = fun g -> g in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun g -> (g x) a  in\nlet base = fun g -> g in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun g -> (g x) a  in\nlet base = fun g -> g in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun g -> (x a) g in\nlet base = fun g -> g in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun g -> (g a) x  in\nlet base = fun g -> g in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun g -> (g a) x  in\nlet base = fun g -> g in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun g -> (x a) g in\nlet base = fun g -> g in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun g -> (a x) g in\nlet base = fun g -> g in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun g -> (a x) g in\nlet base = fun g -> g in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun g -> x (a g) in\nlet base = fun g -> g in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ \"a\" in\nlet base = failwith \"\" in\nlet l = sl in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = ^ \"a\" in\nlet base = failwith \"\" in\nlet l = sl in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = ^ \"a\" in\nlet base = failwith \"\" in\nlet l = sl in\nList.fold_left f base l"}
{"fix": " h in\nlet l = t in\nList.fold_left f base l", "bad": "let stringOfList f l = sepConcat \"; \" (map f l)", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat \"; \" (map f l)"}
{"fix": "let rec clone x n = match n with\n| 0 -> []\n| _ -> x :: clone x (n - 1)", "bad": "let rec clone x n = match n with\n| 0 -> []\n| x :: clone x (n - 1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with\n| 0 -> []\n| x :: clone x (n - 1)"}
{"fix": "let padZero l1 l2 = \nlet ll1 = List.length l1\nin let ll2 = List.length l2\nin ((clone 0 (ll2 - ll1)) @ l1, (clone 0 (ll1 - ll2)) @ l2)", "bad": "let padZero l1 l2 = \nlet l1 = List.length l1\nin let l2 = List.length l2\nin ((clone 0 (l2 - l1)) @ l1, (clone 0 (l1 - l2)) @ l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet l1 = List.length l1\nin let l2 = List.length l2\nin ((clone 0 (l2 - l1)) @ l1, (clone 0 (l1 - l2)) @ l2)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) mod 10 :: ds) in\nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) mod 10) in\nlet base = (0, 1) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) mod 10) in\nlet base = (0, 1) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) mod 10 :: ds) in\nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) mod 10 :: ds) in\nlet base = (0, 1) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) mod 10 :: ds) in\nlet base = (0, 1) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) :: ds) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) :: ds) in\nlet base = (0, []) in\nlet args = List.reverse (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((c + x1 + x2) / 10, (c + x1 + x2) :: ds) in\nlet base = (0, []) in\nlet args = List.reverse (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = (2, ds @ [(c + x1 + x2)]) in\nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((2, ds @ [(c + x1 + x2)]) in\nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = ((2, ds @ [(c + x1 + x2)]) in\nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = if List.length ds = List.length l1 \nthen (0, (c + x1 + x2) / 10 :: (c + x1 + x2) mod 10 :: ds)\nelse ((c + x1 + x2) / 10, (c + x1 + x2) mod 10 :: ds) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = if List.length ds = List.length x1 \nthen (0, (c + x1 + x2) / 10 :: (c + x1 + x2) mod 10 :: ds)\nelse ((c + x1 + x2) / 10, (c + x1 + x2) mod 10 :: ds) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f (c, ds) (x1, x2) = if List.length ds = List.length x1 \nthen (0, (c + x1 + x2) / 10 :: (c + x1 + x2) mod 10 :: ds)\nelse ((c + x1 + x2) / 10, (c + x1 + x2) mod 10 :: ds) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigMul l1 l2 = \nlet f (indent, acc) x = (0 :: indent, (List.fold_left bigAdd [] (clone l2 x)) @ indent) in\nlet base = ([], []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f (indent, acc) x = (0 :: indent, (List.fold_left bigAdd 0 (clone l2 x)) @ indent) in\nlet base = ([], []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f (indent, acc) x = (0 :: indent, (List.fold_left bigAdd 0 (clone l2 x)) @ indent) in\nlet base = ([], []) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let rec sumList xs = failwith \"TBD:sumList\"", "bad": "val sumList : int list -> int", "annotated": "val sumList : int list -> int"}
{"fix": "let rec sumList xs = failwith \"TBD:sumList\"", "bad": "sumList : int list -> int", "annotated": "sumList : int list -> int"}
{"fix": "let rec sumList xs = failwith \"TBD:sumList\"", "bad": "sumList : int list -> int", "annotated": "sumList : int list -> int"}
{"fix": "let rec sumList xs = failwith \"TBD:sumList\"", "bad": "val sumList : int list -> int", "annotated": "val sumList : int list -> int"}
{"fix": "let rec sumList xs = failwith \"TBD:sumList\"", "bad": "val sumList : int list -> int", "annotated": "val sumList : int list -> int"}
{"fix": "let rec sumList xs = failwith \"TBD:sumList\"", "bad": "let sumList : int list -> int", "annotated": "let sumList : int list -> int"}
{"fix": "let rec sumList xs = failwith \"TBD:sumList\"", "bad": "let sumList : int list -> int", "annotated": "let sumList : int list -> int"}
{"fix": "let rec sumList xs = failwith \"TBD:sumList\"", "bad": "let sumList : int list -> int", "annotated": "let sumList : int list -> int"}
{"fix": "let rec sumList xs = failwith \"TBD:sumList\"", "bad": "sumList : int list -> int", "annotated": "sumList : int list -> int"}
{"fix": "let rec sumList xs = failwith \"TBD:sumList\"", "bad": "sumList : int list -> int", "annotated": "sumList : int list -> int"}
{"fix": "let rec sumList xs =\nmatch xs with\n| [] -> []\n| let sum  = sum + hd :: sumLists tl", "bad": "let rec sumList xs =\nmatch xs with\n| [] -> []\n| let sum in hd::tl -> sum = sum + hd :: sumLists tl", "annotated": "let rec sumList : int list -> int = fun  xs  -> \nmatch xs with\n| [] -> []\n| let sum in hd::tl -> sum = sum + hd :: sumLists tl"}
{"fix": "let rec sumList xs =\nmatch xs with\n| [] -> []\n| hd::tl -> hd + (sumList tl)", "bad": "let rec sumList xs =\nmatch xs with\n| [] -> []\n| hd::tl -> sum  = sum + hd :: sumLists tl", "annotated": "let rec sumList : int list -> int = fun  xs  -> \nmatch xs with\n| [] -> []\n| hd::tl -> sum  = sum + hd :: sumLists tl"}
{"fix": "let digitsOfInt n = \nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "bad": "let _ = digitsOfInt 352663", "annotated": "let _ = digitsOfInt 352663"}
{"fix": "let digitsOfInt n = \nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n acc", "bad": "let _ = digitsOfInt 345", "annotated": "let _ = digitsOfInt 345"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let digitsOfInt n = \nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n [7]", "annotated": "let digitsOfInt : int -> int list = fun  n  ->  \nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n [7]"}
{"fix": "let digitsOfInt n = \nlet rec loop n tlist =\nif n = 0 then tlist\nelse loop (n/10) (n mod 10::tlist) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n [7]", "bad": "let digitsOfInt n = \nlet rec loop n tlist =\nif n = 0 then tlist\nelse loop (n/10) (n mod 10::tlist)", "annotated": "let digitsOfInt : int -> int list = fun  n  ->  \nlet rec loop n tlist =\nif n = 0 then tlist\nelse loop (n/10) (n mod 10::tlist)"}
{"fix": "let rec assoc (d,k,l) =\nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\n(match hd with\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl)\nin\nahelper d k l", "bad": "let rec assoc (d,k,l) =\nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\nmatch hd with\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  -> \nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\nmatch hd with\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl"}
{"fix": "let rec assoc (d,k,l) =\nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\n(match hd with\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl)\nin\nahelper d k l", "bad": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let rec assoc (d,k,l) =\nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\n(match hd with\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl)\nin\nahelper d k l", "bad": "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let rec assoc (d,k,l) =\nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\n(match hd with\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl)\nin\nahelper d k l", "bad": "let rec assoc (d,k,l) =\nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\n(match hd with\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  -> \nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\n(match hd with\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl)"}
{"fix": "let rec assoc (d,k,l) =\nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\n(match hd with\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl)\nin\nahelper d k l", "bad": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let rec assoc (d,k,l) =\nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\n(match hd with\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl)\nin\nahelper d k l", "bad": "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let rec assoc (d,k,l) =\nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\n(match hd with\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl)\nin\nahelper d k l", "bad": "let rec assoc (d,k,l) =\nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\n(match hd with\n| () -> d\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  -> \nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\n(match hd with\n| () -> d\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl)"}
{"fix": "let rec assoc (d,k,l) =\nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\n(match hd with\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl)\nin\nahelper d k l", "bad": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen::h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen::h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "annotated": "let _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = (seen::h) in\nlet rest' = (t) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = (seen::h) in\nlet rest' = (t) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem tl 2 = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem tl hd = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem tl hd = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem tl 2 = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem tl 2 = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem tl 2 = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem h tl = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem tl hd = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem tl hd = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let rec wwhile (f,b) =\nlet rec wwhelper f b =\nlet (b', c') = f b in\nif (c' = false) then b'\nelse wwhelper f b'\nin wwhelper f b", "bad": "let rec wwhile (f,b) =\nlet rec wwhelper f b =\nlet (b', c') = f b;\nif (c' = false) then b'\nelse wwhelper f b'\nin wwhelper fb", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> \nlet rec wwhelper f b =\nlet (b', c') = f b;\nif (c' = false) then b'\nelse wwhelper f b'\nin wwhelper fb"}
{"fix": "let rec wwhile (f,b) =\nlet rec wwhelper f b =\nlet (b', c') = f b in\nif (c' = false) then b'\nelse wwhelper f b'\nin wwhelper f b", "bad": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "annotated": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}
{"fix": "let rec wwhile (f,b) =\nlet rec wwhelper f b =\nlet (b', c') = f b in\nif (c' = false) then b'\nelse wwhelper f b'\nin wwhelper f b", "bad": "let rec wwhile (f,b) =\nlet rec wwhelper f b =\nlet (b', c') = f b;\nif (c' = false) then b'\nelse wwhelper f b'\nin wwhelper f b", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> \nlet rec wwhelper f b =\nlet (b', c') = f b;\nif (c' = false) then b'\nelse wwhelper f b'\nin wwhelper f b"}
{"fix": "let rec wwhile (f,b) =\nlet rec wwhelper f b =\nlet (b', c') = f b in\nif (c' = false) then b'\nelse wwhelper f b'\nin wwhelper f b", "bad": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "annotated": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}
{"fix": "let rec exprToString e =\nlet rec eTShelper e expr =\nlet e::= x \n| y \n| sin (pi*e) \n| cos (pi*e) \n| ((e + e)/2) \n| e * e \n| (e<e ? e : e) in\nmatch e with\n| VarX -> expr ^ e\n| VarY -> expr ^ e\n| Sine -> expr ^ e\n| Cosine -> expr ^ e\n| Average  -> expr ^ e\n| Times    -> expr ^ e\n| Thresh   -> expr ^ e\nin\neTShelper e \"\"", "bad": "let rec exprToString e =\nlet rec eTShelper e expr =\nlet e::= x \n| y \n| sin (pi*e) \n| cos (pi*e) \n| ((e + e)/2) \n| e * e \n| (e<e ? e : e) in\nmatch e with\n| VarX -> expr ^ e\n| VarY -> expr ^ e\n| Sine -> expr ^ e\n| Cosine -> expr ^ e\n| Average  -> expr ^ e\n| Times    -> expr ^ e\n| Thresh   -> expr ^ e\nin\neTShelper e \"\"", "annotated": "let rec exprToString : expr -> string = fun  e  -> \nlet rec eTShelper e expr =\nlet e::= x \n| y \n| sin (pi*e) \n| cos (pi*e) \n| ((e + e)/2) \n| e * e \n| (e<e ? e : e) in\nmatch e with\n| VarX -> expr ^ e\n| VarY -> expr ^ e\n| Sine -> expr ^ e\n| Cosine -> expr ^ e\n| Average  -> expr ^ e\n| Times    -> expr ^ e\n| Thresh   -> expr ^ e\nin\neTShelper e \"\""}
{"fix": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> float x\n| VarY -> float y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\nin\nevalhelper e x y", "bad": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi * evalhelper p1)\n| Cosine(p1) -> evalhelper p1\nin\nevalhelper e x y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  -> \nlet rec eval : expr * float * float -> float = fun  (e,x,y)  -> \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi * evalhelper p1)\n| Cosine(p1) -> evalhelper p1\nin\nevalhelper e x y"}
{"fix": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> float x\n| VarY -> float y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\nin\nevalhelper e x y", "bad": "let _ = eval(Sine(Varx), 0.5, -0.5)", "annotated": "let _ = eval(Sine(Varx), 0.5, -0.5)"}
{"fix": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> float x\n| VarY -> float y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\nin\nevalhelper e x y", "bad": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. evalhelper p1)\n| Cosine(p1) -> evalhelper p1\nin\nevalhelper e x y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  -> \nlet rec eval : expr * float * float -> float = fun  (e,x,y)  -> \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. evalhelper p1)\n| Cosine(p1) -> evalhelper p1\nin\nevalhelper e x y"}
{"fix": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> float x\n| VarY -> float y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\nin\nevalhelper e x y", "bad": "let _ = eval(Sine(Varx), 0.5, -0.5)", "annotated": "let _ = eval(Sine(Varx), 0.5, -0.5)"}
{"fix": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> float x\n| VarY -> float y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\nin\nevalhelper e x y", "bad": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. float evalhelper p1)\n| Cosine(p1) -> evalhelper p1\nin\nevalhelper e x y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  -> \nlet rec eval : expr * float * float -> float = fun  (e,x,y)  -> \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. float evalhelper p1)\n| Cosine(p1) -> evalhelper p1\nin\nevalhelper e x y"}
{"fix": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> float x\n| VarY -> float y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\nin\nevalhelper e x y", "bad": "let _ = eval(Sine(Varx), 0.5, -0.5)", "annotated": "let _ = eval(Sine(Varx), 0.5, -0.5)"}
{"fix": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> float x\n| VarY -> float y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\nin\nevalhelper e x y", "bad": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. evalhelper p1)\n| Cosine(p1) -> cos(pi *. evalhelper p1)\nin\nevalhelper e x y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  -> \nlet rec eval : expr * float * float -> float = fun  (e,x,y)  -> \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. evalhelper p1)\n| Cosine(p1) -> cos(pi *. evalhelper p1)\nin\nevalhelper e x y"}
{"fix": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> float x\n| VarY -> float y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\nin\nevalhelper e x y", "bad": "let _ = eval(Sine(Varx), 0.5, -0.5)", "annotated": "let _ = eval(Sine(Varx), 0.5, -0.5)"}
{"fix": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> float x\n| VarY -> float y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\nin\nevalhelper e x y", "bad": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> float x\n| VarY -> float y\n| Sine(p1) -> sin(pi *. evalhelper p1)\n| Cosine(p1) -> cos(pi *. evalhelper p1)\nin\nevalhelper e x y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  -> \nlet rec eval : expr * float * float -> float = fun  (e,x,y)  -> \nmatch e with\n| VarX -> float x\n| VarY -> float y\n| Sine(p1) -> sin(pi *. evalhelper p1)\n| Cosine(p1) -> cos(pi *. evalhelper p1)\nin\nevalhelper e x y"}
{"fix": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> float x\n| VarY -> float y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\nin\nevalhelper e x y", "bad": "let _ = eval(Sine(Varx), 0.5, -0.5)", "annotated": "let _ = eval(Sine(Varx), 0.5, -0.5)"}
{"fix": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> float x\n| VarY -> float y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\nin\nevalhelper e x y", "bad": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> float x\n| VarY -> float y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1)\nin\nevalhelper e x y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  -> \nlet rec eval : expr * float * float -> float = fun  (e,x,y)  -> \nmatch e with\n| VarX -> float x\n| VarY -> float y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1)\nin\nevalhelper e x y"}
{"fix": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> float x\n| VarY -> float y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\nin\nevalhelper e x y", "bad": "let _ = eval(Sine(Varx), 0.5, -0.5)", "annotated": "let _ = eval(Sine(Varx), 0.5, -0.5)"}
{"fix": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\nin\nevalhelper e x y", "bad": "let _ = eval(Sine(VarX), 0.5, -0.5)", "annotated": "let _ = eval(Sine(VarX), 0.5, -0.5)"}
{"fix": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"Var\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ (buildhelper 0 (depth-1) expr) ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "bad": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"Var\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 depth-1 expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 depth-1 expr ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"Var\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 depth-1 expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 depth-1 expr ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\""}
{"fix": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"Var\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ (buildhelper 0 (depth-1) expr) ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "bad": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"Var\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 depth-1 expr ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"Var\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 depth-1 expr ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\""}
{"fix": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand 0 1 = 0) then \nexpr ^ \"((\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"+\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"*\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr)\n| 4 -> \nexpr ^ \"(\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"<\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"?\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \":\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "bad": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand 0 1 = 0) then \nexpr ^ \"((\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"+\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"*\" ^ (eTShelper p2 expr)\n| 4 -> \nexpr ^ \"(\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"<\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"?\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \":\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand 0 1 = 0) then \nexpr ^ \"((\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"+\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"*\" ^ (eTShelper p2 expr)\n| 4 -> \nexpr ^ \"(\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"<\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"?\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \":\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\""}
{"fix": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand 0 1 = 0) then \nexpr ^ \"((\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"+\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"*\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr)\n| 4 -> \nexpr ^ \"(\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"<\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"?\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \":\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "bad": "let _ = build (rand, 3)", "annotated": "let _ = build (rand, 3)"}
{"fix": "let g1 () = failwith \"to be implemented\"", "bad": "let _ = build (rand, 3)", "annotated": "let _ = build (rand, 3)"}
{"fix": "let rec build (rand, depth) = \n(*\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\n*)\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper 0 0 expr)\nelse buildCosine(buildhelper 0 0 expr)\n| 2 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 3 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 4 ->\nbuildThresh(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| _ ->\nbuildThresh(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nin\nbuildhelper (rand(1,4)) depth \"\"", "bad": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n(*\n| 0 ->\nif (rand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\n*)\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nbuildCosine(buildhelper 0 (depth-1) expr)\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\nin\nlet num = rand(1,4) in \nbuildhelper num depth \"\"", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nmatch num with\n(*\n| 0 ->\nif (rand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\n*)\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nbuildCosine(buildhelper 0 (depth-1) expr)\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\nin\nlet num = rand(1,4) in \nbuildhelper num depth \"\""}
{"fix": "let rec build (rand, depth) = \n(*\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\n*)\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper 0 0 expr)\nelse buildCosine(buildhelper 0 0 expr)\n| 2 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 3 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 4 ->\nbuildThresh(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| _ ->\nbuildThresh(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nin\nbuildhelper (rand(1,4)) depth \"\"", "bad": "let rec build (rand, depth) = \n(*\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\n*)\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper (depth-1) (depth-1) expr)\nelse buildCosine(buildhelper 0 (depth-1) (depth-1) expr)\n| (2 || 3) ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| (4 || _) ->\nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nin\nbuildhelper (rand(1,4)) depth \"\"", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \n(*\nlet rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\n*)\nlet rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper (depth-1) (depth-1) expr)\nelse buildCosine(buildhelper 0 (depth-1) (depth-1) expr)\n| (2 || 3) ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| (4 || _) ->\nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nin\nbuildhelper (rand(1,4)) depth \"\""}
{"fix": "let rec build (rand, depth) = \n(*\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\n*)\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper 0 0 expr)\nelse buildCosine(buildhelper 0 0 expr)\n| 2 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 3 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 4 ->\nbuildThresh(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| _ ->\nbuildThresh(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nin\nbuildhelper (rand(1,4)) depth \"\"", "bad": "let rec build (rand, depth) = \n(*\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\n*)\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper (depth-1) (depth-1) expr)\nelse buildCosine(buildhelper 0 (depth-1) (depth-1) expr)\n| 2 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 3 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 4 ->\nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| _ ->\nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nin\nbuildhelper (rand(1,4)) depth \"\"", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \n(*\nlet rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\n*)\nlet rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper (depth-1) (depth-1) expr)\nelse buildCosine(buildhelper 0 (depth-1) (depth-1) expr)\n| 2 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 3 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 4 ->\nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| _ ->\nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nin\nbuildhelper (rand(1,4)) depth \"\""}
{"fix": "let rec build (rand, depth) = \n(*\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\n*)\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper 0 0 expr)\nelse buildCosine(buildhelper 0 0 expr)\n| 2 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 3 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 4 ->\nbuildThresh(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| _ ->\nbuildThresh(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nin\nbuildhelper (rand(1,4)) depth \"\"", "bad": "let rec build (rand, depth) = \n(*\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\n*)\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper 0 0 expr)\nelse buildCosine(buildhelper 0 0 expr)\n| 2 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 3 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 4 ->\nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| _ ->\nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nin\nbuildhelper (rand(1,4)) depth \"\"", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \n(*\nlet rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\n*)\nlet rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper 0 0 expr)\nelse buildCosine(buildhelper 0 0 expr)\n| 2 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 3 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 4 ->\nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| _ ->\nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nin\nbuildhelper (rand(1,4)) depth \"\""}
{"fix": "let fixpoint (f,b) = wwhile((let k x = f x = x in k b), b)", "bad": "let fixpoint (f,b) = wwhile((let k x = f x != x in k b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let k x = f x ! ->  x in k b), b)"}
{"fix": "let fixpoint (f,b) = wwhile((let k x = f x = x in k b), b)", "bad": "let fixpoint (f,b) = wwhile((let k x = f x != b in k b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let k x = f x ! ->  b in k b), b)"}
{"fix": "let fixpoint (f,b) = wwhile((let k x = f x = x in f), b)", "bad": "let fixpoint (f,b) = wwhile((fun k x -> f x = x), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((fun k x -> f x  ->  x), b)"}
{"fix": "let fixpoint (f,b) = wwhile((let k x = f x = x in f), b)", "bad": "let fixpoint (f,b) = wwhile((let k x = f x = x", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let k x = f x  ->  x"}
{"fix": "let fixpoint (f,b) = wwhile((let k x = f x = x in f), b)", "bad": "), b)", "annotated": "), b)"}
{"fix": "let fixpoint (f,b) = wwhile((let k x = f x = x in f), b)", "bad": "let fixpoint (f,b) = wwhile((let k x = f x = x;), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let k x = f x  ->  x;), b)"}
{"fix": "let fixpoint (f,b) = wwhile((let k x = f x = x in f), b)", "bad": "let fixpoint (f,b) = wwhile((let k x = f x = x in k b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let k x = f x  ->  x in k b), b)"}
{"fix": "let fixpoint (f,b) = wwhile((let k x = f x = x in f), b)", "bad": "let fixpoint (f,b) = wwhile((let k x = f x != x in k b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let k x = f x ! ->  x in k b), b)"}
{"fix": "let fixpoint (f,b) = wwhile((let k x = f x = x in f), b)", "bad": "let fixpoint (f,b) = wwhile((let k x = f x in (x, x=b)), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let k x = f x in (x, x -> b)), b)"}
{"fix": "let fixpoint (f,b) = wwhile((let k x = f x in (b, (k b)!=b)), b)", "bad": "let fixpoint (f,b) = wwhile({let k x = f x in (b, k b!=b)), b", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile({let k x = f x in (b, k b! -> b)), b"}
{"fix": "let fixpoint (f,b) = wwhile((let k x = f x in (b, (k b)!=b)), b)", "bad": "let fixpoint (f,b) = wwhile({let k x = f x in (b, (k b)!=b)), b", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile({let k x = f x in (b, (k b)! -> b)), b"}
{"fix": "let fixpoint (f,b) = wwhile((let k x = f x in (b, (k b)!=b)), b)", "bad": ")", "annotated": ")"}
{"fix": "let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)", "bad": "let fixpoint (f,b) = wwhile((let k x = f x in (b, b!=b)), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let k x = f x in (b, b! -> b)), b)"}
{"fix": "let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)", "bad": "let fixpoint (f,b) = wwhile(let k x = f x in (b, b!=b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let k x = f x in (b, b! -> b), b)"}
{"fix": "let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)", "bad": "let fixpoint (f,b) = wwhile(let k x = f x = y in (x, y!=x), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let k x = f x = y in (x, y! -> x), b)"}
{"fix": "let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)", "bad": "let fixpoint (f,b) = wwhile(let k x = f x = x in (x, x!=x), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let k x = f x = x in (x, x! -> x), b)"}
{"fix": "let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)", "bad": "let fixpoint (f,b) = wwhile(let k x = let y = f x in (x, y!=x), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let k x = let y = f x in (x, y! -> x), b)"}
{"fix": "let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)", "bad": "let fixpoint (f,b) = wwhile(let k x = let y = f x in f x in (x, y!=x), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let k x = let y = f x in f x in (x, y! -> x), b)"}
{"fix": "let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)", "bad": "let fixpoint (f,b) = wwhile(let f x = let xx = x*x*x in (xx, xx < 100), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let f x = let xx  ->  x*x*x in (xx, xx < 100), b)"}
{"fix": "let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)", "bad": "let fixpoint (f,b) = wwhile(let g x = f x in (x, x<100), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x  ->  f x in (x, x<100), b)"}
{"fix": "let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)", "bad": "let fixpoint (f,b) = wwhile(let g x = f x in (g x, x<100), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x  ->  f x in (g x, x<100), b)"}
{"fix": "let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)", "bad": "let fixpoint (f,b) = wwhile(let g x = f x in g x in (x, x<100), b", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x  ->  f x in g x in (x, x<100), b"}
{"fix": "let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)", "bad": ")", "annotated": ")"}
{"fix": "let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)", "bad": "let fixpoint (f,b) = wwhile(let g x = f x in g b in (x, x<100), b", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x  ->  f x in g b in (x, x<100), b"}
{"fix": "let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)", "bad": ")", "annotated": ")"}
{"fix": "let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)", "bad": "let fixpoint (f,b) = wwhile((let g x = f x in g b in (x, x<100)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x  ->  f x in g b in (x, x<100)"}
{"fix": "let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)", "bad": "), b", "annotated": "), b"}
{"fix": "let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)", "bad": "let fixpoint (f,b) = wwhile(let g x = (f x) in g b in (x, x<100), b", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x  ->  (f x) in g b in (x, x<100), b"}
{"fix": "let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)", "bad": ")", "annotated": ")"}
{"fix": "let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)", "bad": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "annotated": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile(let g x = (f x) in g b, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x  ->  (f x) in g b, b)"}
{"fix": "let fixpoint (f,b) = wwhile(let g x = f x in g b, b)", "bad": "let fixpoint (f,b) = wwhile(let g x = f x in g b != x, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x = f x in g b ! ->  x, b)"}
{"fix": "let fixpoint (f,b) = wwhile(let g x = f x in g b, b)", "bad": "let fixpoint (f,b) = wwhile(let g x = f x in g b != b, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x = f x in g b ! ->  b, b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile(let g x = f x in (g b, (g b)!= b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let g x = f x in (g b, (g b)! ->  b), b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile(let xx = x*x*x in (xx, xx < 100), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let xx  ->  x*x*x in (xx, xx < 100), b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile(let xx = b*b*b in (xx, xx < 100), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let xx  ->  b*b*b in (xx, xx < 100), b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile(let f x = let xx = x*x*x in (xx, xx < 100), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile(let f x = let xx  ->  x*x*x in (xx, xx < 100), b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile((let g x = f x in f), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x  ->  f x in f), b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile((let g f x = let y = f x in (y,y != x)), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g f x = let y = f x in (y,y ! ->  x)), b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile((let y = let g f x = f x in (y,y != x)), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let y = let g f x = f x in (y,y ! ->  x)), b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile((let g x = f x != x in (y,y != x)), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x = f x != x in (y,y ! ->  x)), b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile((let g x = f x in (x, x!=x)), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x = f x in (x, x! -> x)), b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile((let g x = f x !=x), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x = f x ! -> x), b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile((let g x = f x !=x in g b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x = f x ! -> x in g b), b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile((let g x = f x in g b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x  ->  f x in g b), b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x = let xx = f x in (xx, xx! -> b) in g b), b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x = let xx = f x in (xx, xx! -> b) in g), b)"}
{"fix": "let fixpoint (f,b) = wwhile((let g b = let xx = f x in (xx, xx!=b) in g), b)", "bad": "let fixpoint (f,b) = wwhile((let g x = let xx = f x in (b, xx!=b) in g), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x = let xx = f x in (b, xx! -> b) in g), b)"}
{"fix": "let fixpoint (f,b) = wwhile((let g b = let xx = f x in (xx, xx!=b) in g), b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = wwhile((let g x = let xx = f xx in (xx, xx!=b) in g), b)", "bad": "let fixpoint (f,b) = wwhile((let g x = let xx = f b in (xx, xx!=b) in g), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x = let xx = f b in (xx, xx! -> b) in g), b)"}
{"fix": "let fixpoint (f,b) = wwhile((let g x = let xx = f xx in (xx, xx!=b) in g), b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g b), b)", "bad": "let fixpoint (f,b) = wwhile((let g xx = let xx = f x in (xx, xx!=b) in g), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g xx = let xx = f x in (xx, xx! -> b) in g), b)"}
{"fix": "let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g b), b)", "bad": "let fixpoint (f,b) = wwhile((let g x = xx = f x in (xx, xx!=b) in g", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x = xx = f x in (xx, xx! -> b) in g"}
{"fix": "let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g b), b)", "bad": "let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x = let xx = f x in (xx, xx! -> b) in g), b)"}
{"fix": "let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g b), b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=b) in inwwhile), b)", "bad": "let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let g x = let xx = f x in (xx, xx! -> b) in g), b)"}
{"fix": "let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=b) in inwwhile), b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = wwhile((let inwwhile x = f x in (inwwhile b, (inwwhile b)!=b)), b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = wwhile((let inwwhile x = f x in (x, (inwwhile b)!=b)), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let inwwhile x = f x in (x, (inwwhile b)! -> b)), b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=b)), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx! -> b)), b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=b) in inwwhile), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx! -> b) in inwwhile), b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=(f b)) in inwwhile), b)", "bad": "let _ = fixpoint (collatz, 3)", "annotated": "let _ = fixpoint (collatz, 3)"}
{"fix": "let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=(f b)) in inwwhile), b)", "bad": "let _ = fixpoint (collatz, 48)", "annotated": "let _ = fixpoint (collatz, 48)"}
{"fix": "let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=(f b)) in inwwhile), b)", "bad": "let _ = fixpoint (collatz, 107)", "annotated": "let _ = fixpoint (collatz, 107)"}
{"fix": "let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=(f b)) in inwwhile), b)", "bad": "let _ = fixpoint (collatz, 9001)", "annotated": "let _ = fixpoint (collatz, 9001)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (res, res!=(f b)) in helper), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = let res = f x in (res, res!=(f b)) in helper), b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (f b, res!=(f b)) in helper), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = let res = f x in (f b, res!=(f b)) in helper), b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (b, res!=(f b)) in helper), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = let res = f x in (b, res!=(f b)) in helper), b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (res, res!=b) in helper), b)", "bad": "let _ = fixpoint (collatz, 3)", "annotated": "let _ = fixpoint (collatz, 3)"}
{"fix": "let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (res, res!=b) in helper), b)", "bad": "let _ = fixpoint (collatz, 48)", "annotated": "let _ = fixpoint (collatz, 48)"}
{"fix": "let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (res, res!=b) in helper), b)", "bad": "let _ = fixpoint (collatz, 107)", "annotated": "let _ = fixpoint (collatz, 107)"}
{"fix": "let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (res, res!=b) in helper), b)", "bad": "let _ = fixpoint (collatz, 9001)", "annotated": "let _ = fixpoint (collatz, 9001)"}
{"fix": "let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (res, res!=b) in helper), b)", "bad": "let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (f b, res!=b) in helper), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = let res = f x in (f b, res!=b) in helper), b)"}
{"fix": "let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (res, res!=b) in helper), b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (res, res!=(f b)) in helper), b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (res, res!=(f b)) in \nprintf(\"%d\\n\", helper)), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = let res = f x in (res, res!=(f b)) in \nprintf(\"%d\\n\", helper)), b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nwwhile(let helper x = (f x != (f b)) in helper), b", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile(let helper x = (f x != (f b)) in helper), b"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": ")", "annotated": ")"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nwwhile(let helper x = (f x != (f b)) in helper b), b", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile(let helper x = (f x != (f b)) in helper b), b"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nwwhile(let helper x = (f x != (f b)) in helper), b", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile(let helper x = (f x != (f b)) in helper), b"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nwwhile(let helper x = (f x, f x != (f b)) in helper), b", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile(let helper x = (f x, f x != (f b)) in helper), b"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nwwhile(let helper x = (f x, f x = (f b)) in helper), b", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile(let helper x = (f x, f x = (f b)) in helper), b"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nwwhile(let helper x = (f x, f x = (f b)) in helper b), b", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile(let helper x = (f x, f x = (f b)) in helper b), b"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": ")", "annotated": ")"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nwwhile(let helper x = (f x, f x = (f b)) in helper b, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile(let helper x = (f x, f x = (f b)) in helper b, b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nwwhile(let helper x = (f x, f x = (f b)) in helper b, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile(let helper x = (f x, f x = (f b)) in helper b, b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, f x = (f b)) in helper b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = (f x, f x = (f b)) in helper b), b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, (f x)=(f b)) in helper b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = (f x, (f x)=(f b)) in helper b), b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, (f x)=(f b)) in helper), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = (f x, (f x)=(f b)) in helper), b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nwwhile((let helper x = (f b, b=(f b)) in helper), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = (f b, b=(f b)) in helper), b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nwwhile((let helper x = (f b, b=(f b)) in helper b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = (f b, b=(f b)) in helper b), b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nwwhile((let helper x = (f b, b=f b) in helper), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = (f b, b=f b) in helper), b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, b!=f x) in helper), b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, b=f x) in helper), b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = \nwwhile((let helper x = f x, b=f x in helper b), b)", "bad": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, b=f x) in helper b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = (f x, b=f x) in helper b), b)"}
{"fix": "let fixpoint (f,b) = \nwwhile((let helper x = f x, b=f x in helper b), b)", "bad": "let fixpoint (f,b) = \nwwhile((let helper x = f x, b=f x in helper b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = f x, b=f x in helper b), b)"}
{"fix": "let fixpoint (f,b) = \nwwhile((let helper x = f x, b=f x in helper b), b)", "bad": "let fixpoint (f,b) = \nwwhile((let helper x = f x, b=f x in helper), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = f x, b=f x in helper), b)"}
{"fix": "let fixpoint (f,b) = \nwwhile((let helper x = f x, b=f x in helper b), b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, f x = b) in helper), b)", "bad": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, b=f x) in helper b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = (f x, b=f x) in helper b), b)"}
{"fix": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, f x = b) in helper), b)", "bad": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, b=f x) in (helper b)), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = (f x, b=f x) in (helper b)), b)"}
{"fix": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, f x = b) in helper), b)", "bad": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, b=f x) in helper b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = (f x, b=f x) in helper b), b)"}
{"fix": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, f x = b) in helper), b)", "bad": "let fixpoint (f,b) = \nwwhile((let helper b = (f b, b=f x) in helper), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper b = (f b, b=f x) in helper), b)"}
{"fix": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, f x = b) in helper), b)", "bad": "let fixpoint (f,b) = \nwwhile((let helper b = (f b, b=f b) in helper), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper b = (f b, b=f b) in helper), b)"}
{"fix": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, f x = b) in helper), b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, f x = b) in helper), b)", "bad": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, b < 10) in helper), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = (f x, b < 10) in helper), b)"}
{"fix": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, f x = b) in helper), b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, f x=x) in helper), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = (f x, f x=x) in helper), b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = \nwwhile((let helper x = (f b, x!=(f x)) in helper), b)", "bad": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, (f x)=x) in helper b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = (f x, (f x)=x) in helper b), b)"}
{"fix": "let fixpoint (f,b) = \nwwhile((let helper x = (f b, x!=(f x)) in helper), b)", "bad": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, (f x)=x) in helper), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = (f x, (f x)=x) in helper), b)"}
{"fix": "let fixpoint (f,b) = \nwwhile((let helper x = (f b, x!=(f x)) in helper), b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = \nwwhile((let helper x = (f b, x!=(f x)) in helper), b)", "bad": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, x!=(f x)) in helper b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = (f x, x!=(f x)) in helper b), b)"}
{"fix": "let fixpoint (f,b) = \nwwhile((let helper x = (f b, x!=(f x)) in helper), b)", "bad": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, x!=(f x)) in helper), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = (f x, x!=(f x)) in helper), b)"}
{"fix": "let fixpoint (f,b) = \nwwhile((let helper x = (f b, x!=(f x)) in helper), b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = \nwwhile((let helper x = (f b, x!=(f x)) in helper), b)", "bad": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, x!=(f x)) in (helper b)), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = (f x, x!=(f x)) in (helper b)), b)"}
{"fix": "let fixpoint (f,b) = \nwwhile((let helper x = (f b, x!=(f x)) in helper), b)", "bad": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, x!=(f x)) in helper b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = (f x, x!=(f x)) in helper b), b)"}
{"fix": "let fixpoint (f,b) = \nwwhile((let helper x = (f b, x!=(f x)) in helper), b)", "bad": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, x!=(f x)) in helper), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = (f x, x!=(f x)) in helper), b)"}
{"fix": "let fixpoint (f,b) = \nwwhile((let helper x = (f b, x!=(f x)) in helper), b)", "bad": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, b!=(f x)) in helper), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = (f x, b!=(f x)) in helper), b)"}
{"fix": "let fixpoint (f,b) = \nwwhile((let helper x = (f b, x!=(f x)) in helper), b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = \nwwhile((let helper x = let xx = f x in (f x, x!=(f x)) in helper), b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nwwhile((let helper x = let xx = f x in (xx, x!=(xx)) in helper), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = let xx = f x in (xx, x!=(xx)) in helper), b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let _ = fixpoint (collatz, 3)", "annotated": "let _ = fixpoint (collatz, 3)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let _ = fixpoint (collatz, 48)", "annotated": "let _ = fixpoint (collatz, 48)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let _ = fixpoint (collatz, 107)", "annotated": "let _ = fixpoint (collatz, 107)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let _ = fixpoint (collatz, 9001)", "annotated": "let _ = fixpoint (collatz, 9001)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, x!=(f x)) in helper), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = (f x, x!=(f x)) in helper), b)"}
{"fix": "let sqsum xs = \nlet f a x = (+)\nin\nlet base = f 2 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = base + xs**2 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = failwith \"to be implemented\" in\nlet base = base + xs**2 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = (+)\nin\nlet base = f 2 xs\nin\nList.fold_left f base xs", "bad": "let _ = sqsum []", "annotated": "let _ = sqsum []"}
{"fix": "let sqsum xs = \nlet f a x = (+)\nin\nlet base = f 2 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = base**2 in\nlet base = base+a in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = base**2 in\nlet base = base+a in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = (+)\nin\nlet base = f 2 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = base**2 in\nlet base = a in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = base**2 in\nlet base = a in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = (+)\nin\nlet base = f 2 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a**2 in\nlet base = a in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a**2 in\nlet base = a in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = (+)\nin\nlet base = f 2 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = int a**2 in\nlet base = a in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = int a**2 in\nlet base = a in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = (+)\nin\nlet base = f 2 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a+base in\nlet base = a in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a+base in\nlet base = a in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = (+)\nin\nlet base = f 2 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a in\nlet base = a in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a in\nlet base = a in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = (+)\nin\nlet base = f 2 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = (+) in\nlet base = a in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = (+) in\nlet base = a in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = (+)\nin\nlet base = f 2 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = (+) in\nlet base = base + f a x in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = (+) in\nlet base = base + f a x in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = (+)\nin\nlet base = f 2 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = (+) in\nlet base = f a x in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = (+) in\nlet base = f a x in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = (+)\nin\nlet base = f 2 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = (+) in\nlet base = base in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = (+) in\nlet base = base in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = (+)\nin\nlet base = f 2 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = (+) in\nlet base = a ** 2 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = (+) in\nlet base = a ** 2 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = (+)\nin\nlet base = f 2 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = (+) in\nlet base = 3**2 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = (+) in\nlet base = 3**2 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = (+)\nin\nlet base = f 2 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = (+) in\nlet base = 2 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = (+) in\nlet base = 2 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = (+)\nin\nlet base = f 2 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = (+) in\nlet base = base + 1 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = (+) in\nlet base = base + 1 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = (+)\nin\nlet base = f 2 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = (+) in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = (+) in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = (+)\nin\nlet base = f 2 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = (+)\nin\nlet base = base + a**2\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = (+)\nin\nlet base = base + a**2\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = (+)\nin\nlet base = f 2 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = (+)\nin\nlet base = a**2\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = (+)\nin\nlet base = a**2\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = (+)\nin\nlet base = f 2 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = (+)\nin\nlet base = f a**2 x\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = (+)\nin\nlet base = f a**2 x\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = (+)\nin\nlet base = f 2 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = (+)\nin\nlet base = f 2 x\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = (+)\nin\nlet base = f 2 x\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a in\nlet base = f 2 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a**2 in\nlet base = f 2 xs\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a**2 in\nlet base = f 2 xs\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a in\nlet base = f 2 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a + base in\nlet base = f 2 xs\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a + base in\nlet base = f 2 xs\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a*a in\nlet base = f 2 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a*a in\nlet base = []\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a*a in\nlet base = []\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a*a in\nlet base = f 2 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a*a in\nlet base = _\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a*a in\nlet base = _\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a*a in\nlet base = f 2 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> []\n| x::xs' -> f x xs'\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> []\n| x::xs' -> f x xs'\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a*a in\nlet base = 0\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = x*x in\nlet base = f 2 xs\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = x*x in\nlet base = f 2 xs\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a*a in\nlet base = f 4 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = \nmatch x with\n| hd::tl -> hd * hd + f a tl\nin\nlet base = f 4 xs\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = \nmatch x with\n| hd::tl -> hd * hd + f a tl\nin\nlet base = f 4 xs\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a*a in\nlet base = f 4 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = \nmatch x with\n| hd::tl -> hd * hd + (f a tl)\nin\nlet base = f 4 xs\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = \nmatch x with\n| hd::tl -> hd * hd + (f a tl)\nin\nlet base = f 4 xs\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a*a in\nlet base = f 4 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = \nmatch x with\n| hd::tl -> hd * hd\nin\nlet base = f 4 xs\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = \nmatch x with\n| hd::tl -> hd * hd\nin\nlet base = f 4 xs\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = f 4 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = f 4 xs\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a + x*x in\nlet base = f 4 xs\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a*a in\nlet base = f (f 0 xs) xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a*a in\nlet base = f a xs\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a*a in\nlet base = f a xs\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a*a in\nlet base = f (f 0 xs) xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a*a in\nlet base = f base xs\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a*a in\nlet base = f base xs\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a*a in\nlet base = f (f 0 xs) xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a*a in\nlet base = f (f a xs) xs\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a*a in\nlet base = f (f a xs) xs\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a*a in\nlet base = f 4 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a*a in\nlet base = f _ xs\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a*a in\nlet base = f _ xs\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a*a in\nlet base = f 4 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a*a in\nlet base = f 4 thing\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a*a in\nlet base = f 4 thing\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a*a in\nlet base = f 8 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = f 4 xs\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a*a + x in\nlet base = f 4 xs\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a*a in\nlet base = f 8 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a*a in\nlet base = base + f 4 xs\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a*a in\nlet base = base + f 4 xs\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a*a in\nlet base = f 8 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a*a in\nlet base = f base xs\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a*a in\nlet base = f base xs\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a*a in\nlet base = f 8 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a*a in\nlet base = f xs xs\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a*a in\nlet base = f xs xs\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> 0\n| hd::tl -> f (f 0 hd) tl\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> base\n| hd::tl -> f (f base hd) tl\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> base\n| hd::tl -> f (f base hd) tl\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> 0\n| hd::tl -> f (f 0 hd) tl\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> 0\n| hd::tl -> f (f base hd) tl\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> 0\n| hd::tl -> f (f base hd) tl\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> 4\n| hd::tl -> f (f 2 hd) tl\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x =  \nmatch xs with\n| [] -> a\n| hd::tl -> f (f a hd) tl in\nlet base = 0\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x =  \nmatch xs with\n| [] -> a\n| hd::tl -> f (f a hd) tl in\nlet base = 0\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> 4\n| hd::tl -> f (f 2 hd) tl\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet rec f a x =  \nmatch xs with\n| [] -> a\n| hd::tl -> f (f a hd) tl in\nlet base = 0\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet rec f a x =  \nmatch xs with\n| [] -> a\n| hd::tl -> f (f a hd) tl in\nlet base = 0\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a*a in\nlet base = f 2 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a*a in\nlet base = base\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a*a in\nlet base = base\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> f 0 xs\n| hd::tl -> f (f hd hd) tl\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> f 0 xs\n| hd::tl -> f (f base hd) tl\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> f 0 xs\n| hd::tl -> f (f base hd) tl\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> f 0 xs\n| hd::tl -> f (f hd hd) tl\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> f 0 xs\n| hd::tl -> f (f a hd) tl\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> f 0 xs\n| hd::tl -> f (f a hd) tl\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| hd::tl -> f (f hd hd) tl\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> xs\n| hd::tl -> f (f hd hd) tl\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a*a in\nlet base = \nmatch xs with\n| [] -> xs\n| hd::tl -> f (f hd hd) tl\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| hd::tl -> f hd hd + f (f hd hd) tl\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a*a in\nlet base = \nmatch xs with\n| hd::tl -> f hd hd + f tl tl\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a*a in\nlet base = \nmatch xs with\n| hd::tl -> f hd hd + f tl tl\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = match xs with\n| [] -> a\n| hd::tl -> hd*hd in\nlet base = f 0 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = match xs with\n| [] -> a\n| hd::tl -> f hd tl in\nlet base = f 0 xs\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = match xs with\n| [] -> a\n| hd::tl -> f hd tl in\nlet base = f 0 xs\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = \nmatch xs with\n| [] -> a\n| hd::tl -> a + hd*hd in\nlet base = f 4 xs\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = \nmatch xs with\n| [] -> a\n| hd::tl -> a + hd*hd in\nlet base = []\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = \nmatch xs with\n| [] -> a\n| hd::tl -> a + hd*hd in\nlet base = []\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = match xs with\n| [] -> 0\n| hd::tl -> f 0 hd\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = \nmatch xs with\n| [] -> a\n| hd::tl -> a + x*x in\nlet base = f 0 xs\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = \nmatch xs with\n| [] -> a\n| hd::tl -> a + x*x in\nlet base = f 0 xs\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = match xs with\n| [] -> 0\n| hd::tl -> f 0 hd\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = match xs with\n| [] -> []\n| hd::tl -> f 0 hd\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a + x*x in\nlet base = match xs with\n| [] -> []\n| hd::tl -> f 0 hd\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = \nmatch xs with\n| [] -> f 0 0\n| hd::tl -> f 0 hd\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = \nmatch xs with\n| [] -> f 0 []\n| hd::tl -> f 0 hd\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a + x*x in\nlet base = \nmatch xs with\n| [] -> f 0 []\n| hd::tl -> f 0 hd\nin\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = \nmatch xs with\n| [] -> 0\n| hd::tl -> f 0 hd\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = \nmatch xs with\n| [] -> 0\n| hd::tl -> f -1 hd\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a + x*x in\nlet base = \nmatch xs with\n| [] -> 0\n| hd::tl -> f -1 hd\nin\nList.fold_left f base xs"}
{"fix": "let _ = sqsum [1;2;3]", "bad": "let _ = sqsum [1;2;3]\n\nList.fold_left (fun sum a -> sum + a * a) 0 [2;5;3;1]", "annotated": "let _ = sqsum [1;2;3]\n\nList.fold_left (fun sum a -> sum + a * a) 0 [2;5;3;1]"}
{"fix": "let pipe fs = \nlet f a x = x in\nlet base = 0\nin\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = x in\nlet base = 0\nin\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x in\nlet base = 0\nin\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = 0\nin\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = 0\nin\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  in\nlet base = x\nin\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  in\nlet base = x\nin\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x -> a x in\nlet base = x\nin\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x -> a x in\nlet base = x\nin\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun x -> 0\nin\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun x\nin\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x -> a x in\nlet base = fun x\nin\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x -> x a in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x -> x a in\nlet base = fun x -> x\nin\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun x -> 0\nin\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x -> a x in\nlet base = x\nin\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x -> a x in\nlet base = x\nin\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun x -> 0\nin\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun x -> a\nin\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x -> a x in\nlet base = fun x -> a\nin\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun y ->  a x in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun y ->  y a x in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun y ->  y a x in\nlet base = fun x -> x\nin\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun k -> x k(a) in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun y ->  a (y x) in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun y ->  a (y x) in\nlet base = fun x -> x\nin\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun k -> x a in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun k -> x a in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun k -> x k(k) in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun k -> x k(f a k) in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun k -> x k(f a k) in\nlet base = fun x -> x\nin\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun k -> x k(a) in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun k -> x k(a) in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun k -> a x in\nlet base = fun y -> y\nin\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun k -> fun a x in\nlet base = fun y -> y\nin\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun k -> fun a x in\nlet base = fun y -> y\nin\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun k -> a x in\nlet base = fun y -> y\nin\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun k -> a k(x) in\nlet base = fun y -> y\nin\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun k -> a k(x) in\nlet base = fun y -> y\nin\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun k -> x k a in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun k -> x k a in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun k -> x a k in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "bad": "et _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "et _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun k -> x a k in\nlet base = fun x -> x\nin\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "bad": "let rec clone x n =\nmatch n > 0 with\n| true -> x::(clone x n-1)\n| false -> x", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  -> \nmatch n > 0 with\n| true -> x::(clone x n-1)\n| false -> x"}
{"fix": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "bad": "let _ = clone 3 5", "annotated": "let _ = clone 3 5"}
{"fix": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "bad": "let _ = clone \"foo\" 2", "annotated": "let _ = clone \"foo\" 2"}
{"fix": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "bad": "let _ = clone clone (-3)", "annotated": "let _ = clone clone (-3)"}
{"fix": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "bad": "let rec clone x n =\nmatch n > 0 with\n| true -> x::(clone x n-1)\n| false -> x::[]", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  -> \nmatch n > 0 with\n| true -> x::(clone x n-1)\n| false -> x::[]"}
{"fix": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "bad": "let _ = clone 3 5", "annotated": "let _ = clone 3 5"}
{"fix": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "bad": "let _ = clone \"foo\" 2", "annotated": "let _ = clone \"foo\" 2"}
{"fix": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "bad": "let _ = clone clone (-3)", "annotated": "let _ = clone clone (-3)"}
{"fix": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "bad": "let rec clone x n =\nmatch n > 0 with\n| true -> x @ clone x n-1\n| false -> x @ []", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  -> \nmatch n > 0 with\n| true -> x @ clone x n-1\n| false -> x @ []"}
{"fix": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "bad": "let _ = clone 3 5", "annotated": "let _ = clone 3 5"}
{"fix": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "bad": "let _ = clone \"foo\" 2", "annotated": "let _ = clone \"foo\" 2"}
{"fix": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "bad": "let rec clone x n =\nmatch n > 0 with\n| true -> x @ clone x n-1\n| false -> []", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  -> \nmatch n > 0 with\n| true -> x @ clone x n-1\n| false -> []"}
{"fix": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "bad": "let rec clone x n =\nmatch n = 0 with\n| true -> x\n| false -> x @ clone x n-1", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  -> \nmatch n = 0 with\n| true -> x\n| false -> x @ clone x n-1"}
{"fix": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "bad": "let _ = clone 3 5", "annotated": "let _ = clone 3 5"}
{"fix": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "bad": "let _ = clone \"foo\" 2", "annotated": "let _ = clone \"foo\" 2"}
{"fix": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "bad": "let rec clone x n =\nmatch n = 0 with\n| true -> (x)\n| false -> (x) @ (clone x n-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  -> \nmatch n = 0 with\n| true -> (x)\n| false -> (x) @ (clone x n-1)"}
{"fix": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "bad": "let _ = clone 3 5", "annotated": "let _ = clone 3 5"}
{"fix": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "bad": "let _ = clone \"foo\" 2", "annotated": "let _ = clone \"foo\" 2"}
{"fix": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "bad": "let _ = clone clone (-3)", "annotated": "let _ = clone clone (-3)"}
{"fix": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "bad": "let rec clone x n =\nmatch n = 0 with\n| true -> []\n| false -> (x) @ (clone x n-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  -> \nmatch n = 0 with\n| true -> []\n| false -> (x) @ (clone x n-1)"}
{"fix": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "bad": "let _ = clone 3 5", "annotated": "let _ = clone 3 5"}
{"fix": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "bad": "let _ = clone \"foo\" 2", "annotated": "let _ = clone \"foo\" 2"}
{"fix": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "bad": "let _ = clone clone (-3)", "annotated": "let _ = clone clone (-3)"}
{"fix": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "bad": "let rec clone x n =\nmatch n = 0 with\n| true -> []\n| false -> (x) :: (clone x n-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  -> \nmatch n = 0 with\n| true -> []\n| false -> (x) :: (clone x n-1)"}
{"fix": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "bad": "let rec clone x n =\nmatch n = 0 with\n| true -> []\n| false -> (x) @ (clone x n-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  -> \nmatch n = 0 with\n| true -> []\n| false -> (x) @ (clone x n-1)"}
{"fix": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "bad": "let rec clone x n =\nmatch n = 0 with\n| true -> []\n| false -> (x) :: (clone x n-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  -> \nmatch n = 0 with\n| true -> []\n| false -> (x) :: (clone x n-1)"}
{"fix": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "bad": "let _ = clone 3 5", "annotated": "let _ = clone 3 5"}
{"fix": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "bad": "let _ = clone \"foo\" 2", "annotated": "let _ = clone \"foo\" 2"}
{"fix": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "bad": "let _ = clone clone (-3)", "annotated": "let _ = clone clone (-3)"}
{"fix": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "bad": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x n-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  -> \nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x n-1)"}
{"fix": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "bad": "let _ = clone 3 5", "annotated": "let _ = clone 3 5"}
{"fix": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "bad": "let _ = clone \"foo\" 2", "annotated": "let _ = clone \"foo\" 2"}
{"fix": "let rec clone x n =\nmatch (n = 0) with\n| true -> []\n| false -> (x) :: (clone x (n-1))", "bad": "let _ = clone clone (-3)", "annotated": "let _ = clone clone (-3)"}
{"fix": "let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\nclone 0 (List.length l1 - List.length l2) @ l2\nelse if (List.length l1 < List.length l2) then\nclone 0 (List.length l2 - List.length l1) @ l1", "bad": "let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\n(clone 0 (List.length l1 - List.length l2)) @ l2\nelse if (List.length l1 < List.length l2) then\nclone 0 (List.length l2 - List.length l1) @ l1", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \nif(List.length l1 > List.length l2) then\n(clone 0 (List.length l1 - List.length l2)) @ l2\nelse if (List.length l1 < List.length l2) then\nclone 0 (List.length l2 - List.length l1) @ l1"}
{"fix": "let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\nclone 0 (List.length l1 - List.length l2) @ l2\nelse if (List.length l1 < List.length l2) then\nclone 0 (List.length l2 - List.length l1) @ l1", "bad": "let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\n(clone 0 (List.length l1 - List.length l2)) @ l2\nelse if (List.length l1 < List.length l2) then\n(clone 0 (List.length l2 - List.length l1)) @ l1", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \nif(List.length l1 > List.length l2) then\n(clone 0 (List.length l1 - List.length l2)) @ l2\nelse if (List.length l1 < List.length l2) then\n(clone 0 (List.length l2 - List.length l1)) @ l1"}
{"fix": "let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\nclone 0 (List.length l1 - List.length l2) @ l2\nelse if (List.length l1 < List.length l2) then\nclone 0 (List.length l2 - List.length l1) @ l1", "bad": "let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\nclone 0 (List.length l1 - List.length l2) @ l2\nelse if (List.length l1 < List.length l2) then\nclone 0 (List.length l2 - List.length l1) @ l1", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \nif(List.length l1 > List.length l2) then\nclone 0 (List.length l1 - List.length l2) @ l2\nelse if (List.length l1 < List.length l2) then\nclone 0 (List.length l2 - List.length l1) @ l1"}
{"fix": "let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\nl1::(clone 0 (List.length l1 - List.length l2) @ l2)\nelse if (List.length l1 < List.length l2) then\nl2::(clone 0 (List.length l2 - List.length l1) @ l1)", "bad": "let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\nl1::(clone 0 (List.length l1 - List.length l2) @ l2)\nelse if (List.length l1 < List.length l2) then\nclone 0 (List.length l2 - List.length l1) @ l1", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \nif(List.length l1 > List.length l2) then\nl1::(clone 0 (List.length l1 - List.length l2) @ l2)\nelse if (List.length l1 < List.length l2) then\nclone 0 (List.length l2 - List.length l1) @ l1"}
{"fix": "let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\nl1::((clone 0 (List.length l1 - List.length l2)) @ l2)\nelse if (List.length l1 < List.length l2) then\nl2::((clone 0 (List.length l2 - List.length l1)) @ l1)", "bad": "let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\nl1::((clone 0 (List.length l1 - List.length l2)) @ l2)\nelse if (List.length l1 < List.length l2) then\nl2::((clone 0 (List.length l2 - List.length l1)) @ l1)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \nif(List.length l1 > List.length l2) then\nl1::((clone 0 (List.length l1 - List.length l2)) @ l2)\nelse if (List.length l1 < List.length l2) then\nl2::((clone 0 (List.length l2 - List.length l1)) @ l1)"}
{"fix": "let padZero l1 l2 =\nmatch List.length l1 > List.length l2 with\n| true -> l1::((clone 0 (List.length l1 - List.length l2)) @ l2)\n| false -> ((clone 0 (List.length l2 - List.length l1)) @ [l1])::l2", "bad": "let padZero l1 l2 =\nif(List.length l1 > List.length l2) then\nl1@[(clone 0 (List.length l1 - List.length l2)) @ [l2]]\nelse if (List.length l1 < List.length l2) then\n((clone 0 (List.length l2 - List.length l1)) @ [l1])::l2", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \nif(List.length l1 > List.length l2) then\nl1@[(clone 0 (List.length l1 - List.length l2)) @ [l2]]\nelse if (List.length l1 < List.length l2) then\n((clone 0 (List.length l2 - List.length l1)) @ [l1])::l2"}
{"fix": "let _ = (([0;0]@[1;1]), [1])", "bad": "let _ = [9;9;9;9]::([0;0]@[1;1])", "annotated": "let _ = [9;9;9;9]::([0;0]@[1;1])"}
{"fix": "let _ = (([0;0]@[1;1]), [1])", "bad": "let padZero l1 l2 =\nmatch List.length l1 > List.length l2 with\n| true -> (l1,((clone 0 (List.length l1 - List.length l2)) @ l2))\n| false -> (((clone 0 (List.length l2 - List.length l1)) @ [l1]),l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \nmatch List.length l1 > List.length l2 with\n| true -> (l1,((clone 0 (List.length l1 - List.length l2)) @ l2))\n| false -> (((clone 0 (List.length l2 - List.length l1)) @ [l1]),l2)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = [0] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = f l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = () in\nlet base = ([],[]) in\nlet args = f l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = ([],[]) in\nlet args = f l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = ([],[]) in\nlet args = f l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = () in\nlet base = ([],[]) in\nlet args = f l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = in\nlet base = ([],[]) in\nlet args = f l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = in\nlet base = ([],[]) in\nlet args = f l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = () in\nlet base = ([],[]) in\nlet args = f l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = ([],[]) in\nlet base = ([],[]) in\nlet args = f l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = ([],[]) in\nlet base = ([],[]) in\nlet args = f l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let rec mulByDigit i l = \nlet comb a (hd::tl) =\na + hd\nin\nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i-9 != 0) then\n(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "bad": "let rec mulByDigit i l = \nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i/10 != 0) then\nhd*i mod 10::(hd*i/10 + mBDhelper i tl)\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i/10 != 0) then\nhd*i mod 10::(hd*i/10 + mBDhelper i tl)\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l"}
{"fix": "let rec mulByDigit i l = \nlet comb a (hd::tl) =\na + hd\nin\nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i-9 != 0) then\n(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "bad": "let rec mulByDigit i l = \nlet rec mBDhelper i x =\nmatch x with\n| [] -> 0\n| hd::tl ->\nif (hd*i/10 != 0) then\n(hd*i mod 10)::(hd*i/10 + mBDhelper i tl)\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet rec mBDhelper i x =\nmatch x with\n| [] -> 0\n| hd::tl ->\nif (hd*i/10 != 0) then\n(hd*i mod 10)::(hd*i/10 + mBDhelper i tl)\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l"}
{"fix": "let rec mulByDigit i l = \nlet comb a (hd::tl) =\na + hd\nin\nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i-9 != 0) then\n(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "bad": "let rec mulByDigit i l = \nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i-9 != 0) then\n(hd*i/10)::(hd*i mod 10 + mBDhelper i tl)\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i-9 != 0) then\n(hd*i/10)::(hd*i mod 10 + mBDhelper i tl)\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l"}
{"fix": "let rec mulByDigit i l = \nlet comb a b =\nmatch b with\n| [] -> (a)\n| hd::tl -> (a + hd)\nin\nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i-9 != 0) then\n(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "bad": "let rec mulByDigit i l = \nlet comb a b =\nmatch b with\n| [] -> a\n| hd::tl -> a + hd\nin\nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i-9 != 0) then\n(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet comb a b =\nmatch b with\n| [] -> a\n| hd::tl -> a + hd\nin\nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i-9 != 0) then\n(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l"}
{"fix": "let rec mulByDigit i l = \nlet comb a b =\nmatch b with\n| [] -> [a]\n| hd::tl -> [a + hd]::[tl]\nin\nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i > 9) then\n(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "bad": "let rec mulByDigit i l = \nlet comb a b =\nmatch b with\n| [] -> [a]\n| hd::tl -> [a + hd]::tl\nin\nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i > 9) then\n(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet comb a b =\nmatch b with\n| [] -> [a]\n| hd::tl -> [a + hd]::tl\nin\nlet rec mBDhelper i x =\nmatch x with\n| [] -> []\n| hd::tl ->\nif (hd*i > 9) then\n(hd*i/10)::(comb (hd*i mod 10) (mBDhelper i tl))\nelse\n(hd*i)::(mBDhelper i tl)\nin\nmBDhelper i l"}
{"fix": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nlet carry =\nmatch a with\n| (x,y) -> x in\nmatch x with\n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = () in\nlet base = ([],[]) in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = () in\nlet base = ([],[]) in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nmatch x with\n| (addend_a,addend_b) ->\nlet prevcarry = \nmatch a with\n| (x, y) -> x in\nlet new_carry = (prevcarry + addend_a + addend_b) / 10 in\nlet digit = (prevcarry + addend_a + addend_b) mod 10\nin\nmatch a with\n| (x,[]) -> (new_carry, new_carry::[digit]) \n| (x, c::d::y) -> (new_carry, new_carry::digit::d::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nmatch x with\n| (addend_a,addend_b) ->\nlet prevcarry = \nmatch a with\n| (x, y) -> x in\nlet new_carry = (prevcarry + addend_a + addend_b) / 10 in\nlet digit = (prevcarry + addend_a + addend_b) mod 10\nin\nmatch a with\n| (x,[]) -> (new_carry, new_carry::digit) \n| (x, c::d::y) -> (new_carry, new_carry::digit::d::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  -> \nlet add (l1, l2) =\nlet f a x =\nmatch x with\n| (addend_a,addend_b) ->\nlet prevcarry = \nmatch a with\n| (x, y) -> x in\nlet new_carry = (prevcarry + addend_a + addend_b) / 10 in\nlet digit = (prevcarry + addend_a + addend_b) mod 10\nin\nmatch a with\n| (x,[]) -> (new_carry, new_carry::digit) \n| (x, c::d::y) -> (new_carry, new_carry::digit::d::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0\nin\nList.fold_left f base xs", "bad": "let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> (,)\n| hd::tl -> List.append (x,hd) (argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> (,)\n| hd::tl -> List.append (x,hd) (argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = l1 in\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> (x,[])\n| hd::tl -> List.append (x,hd) (argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = l1 in\nlet base = ([], 1) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> (x,[])\n| hd::tl -> List.append (x,[hd]) (argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = l1 in\nlet base = ([], 1) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> (x,[])\n| hd::tl -> List.append (x,[hd]) (argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = l1 in\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> (x,[])\n| hd::tl -> List.append (x,hd) (argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = l1 in\nlet base = ([], 1) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> (x,0)\n| hd::tl -> List.append (x,hd) (argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = l1 in\nlet base = ([], 1) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> (x,0)\n| hd::tl -> List.append (x,hd) (argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = l1 in\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| hd::tl -> \nif (tl=[]) then (x,hd) \nelse (x,hd)::(argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = l1 in\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> (x,[])\n| hd::tl -> List.append ((x,hd)) (argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = l1 in\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> (x,[])\n| hd::tl -> List.append ((x,hd)) (argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0\nin\nList.fold_left f base xs", "bad": "let bigMul l1 l2 = \nlet f a x = List.combine a x in\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| hd::tl -> \nif (tl=[]) then [(x,hd)]\nelse (x,hd)::(argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = List.combine a x in\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| hd::tl -> \nif (tl=[]) then [(x,hd)]\nelse (x,hd)::(argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0\nin\nList.fold_left f base xs", "bad": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "annotated": "let _ = bigMul [9;9;9;9] [9;9;9;9]"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0\nin\nList.fold_left f base xs", "bad": "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]", "annotated": "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0\nin\nList.fold_left f base xs", "bad": "let bigMul l1 l2 = \nlet f a x = a::x in\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| hd::tl -> \nif (tl=[]) then [(x,hd)]\nelse (x,hd)::(argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = a::x in\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| hd::tl -> \nif (tl=[]) then [(x,hd)]\nelse (x,hd)::(argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let rec digitsOfInt n = \nif n >0 then n/10::[n mod 10]\nelse []", "bad": "let rec digitsOfInt n = match n with \n0 -> []\n| n -> [n % 10]::digitsOfInt (n/10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  match n with \n0 -> []\n| n -> [n % 10]::digitsOfInt (n/10)"}
{"fix": "let rec digitsOfInt n = \nif n >0 then n/10::[n mod 10]\nelse []", "bad": "let _ = digitsOfInt 3124", "annotated": "let _ = digitsOfInt 3124"}
{"fix": "let rec digitsOfInt n = \nif n >0 then n/10::[n mod 10]\nelse []", "bad": "let _ = digitsOfInt 352663", "annotated": "let _ = digitsOfInt 352663"}
{"fix": "let rec digitsOfInt n = \nif n >0 then n/10::[n mod 10]\nelse []", "bad": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt(n/10)::n mod 10\nelse []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n > 0 then digitsOfInt(n/10)::n mod 10\nelse []"}
{"fix": "let rec digitsOfInt n = \nif n >0 then n/10::[n mod 10]\nelse []", "bad": "let _ = digitsOfInt 3124", "annotated": "let _ = digitsOfInt 3124"}
{"fix": "let rec digitsOfInt n = \nif n >0 then n/10::[n mod 10]\nelse []", "bad": "let _ = digitsOfInt 352663", "annotated": "let _ = digitsOfInt 352663"}
{"fix": "let rec digitsOfInt n = \nif n >0 then n/10::[n mod 10]\nelse []", "bad": "let rec digitsOfInt n = \nif n > 0 then digitsOfInt n/10::n mod 10\nelse []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n > 0 then digitsOfInt n/10::n mod 10\nelse []"}
{"fix": "let rec digitsOfInt n = \nif n >0 then n/10::[n mod 10]\nelse []", "bad": "let _ = digitsOfInt 3124", "annotated": "let _ = digitsOfInt 3124"}
{"fix": "let rec digitsOfInt n = \nif n >0 then n/10::[n mod 10]\nelse []", "bad": "let _ = digitsOfInt 352663", "annotated": "let _ = digitsOfInt 352663"}
{"fix": "let rec digitsOfInt n = \nif n >0 then n/10::[n mod 10]\nelse []", "bad": "let rec digitsOfInt n = \nif n >0 then n/10::n mod 10\nelse []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n >0 then n/10::n mod 10\nelse []"}
{"fix": "let rec digitsOfInt n = \nif n > 0 then (n mod 10) :: (digitsOfInt (n/10))\nelse []", "bad": "if n > 0 then (n mod 10) :: (digitsOfInt (n/10))\nelse []", "annotated": "if n > 0 then (n mod 10) :: (digitsOfInt (n/10))\nelse []"}
{"fix": "let rec digitsOfInt n = \nif n > 0 then (n mod 10) :: (digitsOfInt (n/10))\nelse []", "bad": "et rec digitsOfInt n = \nif n > 0 then (n mod 10) :: (digitsOfInt (n/10))\nelse []", "annotated": "et rec digitsOfInt : int -> int list = fun  n  ->  \nif n > 0 then (n mod 10) :: (digitsOfInt (n/10))\nelse []"}
{"fix": "let additivePersistence n = \nlet count = 0 in\nif n < 10 then count\nelse sumList(digitsOfInt n)", "bad": "let rec additivePersistence n = match n with\n| [] -> []\n| h :: t -> t + digitsOfInt (additivePersistence h)", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  match n with\n| [] -> []\n| h :: t -> t + digitsOfInt (additivePersistence h)"}
{"fix": "let additivePersistence n = \nlet count = 0 in\nif n < 10 then count\nelse sumList(digitsOfInt n)", "bad": "let rec additivePersistence n = \nif n < 10 then n + sum\nelse let sum _ = sumList (digitsOfInt(n))", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif n < 10 then n + sum\nelse let sum _ = sumList (digitsOfInt(n))"}
{"fix": "let additivePersistence n = \nlet count = 0 in\nif n < 10 then count\nelse sumList(digitsOfInt n)", "bad": "let rec additivePersistence n = \nif n < 10 then n + sum\nelse let sum _ = sumList (digitsOfInt n)", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif n < 10 then n + sum\nelse let sum _ = sumList (digitsOfInt n)"}
{"fix": "let additivePersistence n = \nlet count = 0 in\nif n < 10 then count\nelse sumList(digitsOfInt n)", "bad": "let rec additivePersistence n = \nif n < 10 then n + sum\nelse let sum _ = additivePersistence sumList (digitsOfInt n)", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif n < 10 then n + sum\nelse let sum _ = additivePersistence sumList (digitsOfInt n)"}
{"fix": "let additivePersistence n = \nlet count = 0 in\nif n < 10 then count\nelse sumList(digitsOfInt n)", "bad": "let rec additivePersistence n = \nif n < 10 then n + sum\nelse let sum = additivePersistence sumList (digitsOfInt n)", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif n < 10 then n + sum\nelse let sum = additivePersistence sumList (digitsOfInt n)"}
{"fix": "let additivePersistence n = \nlet count = 0 in\nif n < 10 then count\nelse sumList(digitsOfInt n)", "bad": "let additivePersistence n = \nif n < 10 then count\nelse (sumList (digitsOfInt n), count + 1)", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nif n < 10 then count\nelse (sumList (digitsOfInt n), count + 1)"}
{"fix": "let additivePersistence n = \nlet count = 0 in\nif n < 10 then count\nelse sumList(digitsOfInt n)", "bad": "let additivePersistence n = \nlet count = 0 in\nif n < 10 then count\nelse (sumList (digitsOfInt n), count + 1)", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet count = 0 in\nif n < 10 then count\nelse (sumList (digitsOfInt n), count + 1)"}
{"fix": "let additivePersistence n = \nlet count = 0 in\nif n < 10 then count\nelse sumList(digitsOfInt n)", "bad": "let additivePersistence n = \nlet count = 0 in\nif n < 10 then count\nelse sumList (digitsOfInt n) count + 1", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet count = 0 in\nif n < 10 then count\nelse sumList (digitsOfInt n) count + 1"}
{"fix": "let additivePersistence n = \nlet count = 0 in\nif n < 10 then 1\nelse 1 + sumList(digitsOfInt n)", "bad": "let additivePersistence n = \nlet count = 0 in\nif n < 10 then count\nelse count + 1 sumList(digitsOfInt n)", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet count = 0 in\nif n < 10 then count\nelse count + 1 sumList(digitsOfInt n)"}
{"fix": "let additivePersistence n = \nlet count = 0 in\nif n < 10 then 1\nelse 1 + sumList(digitsOfInt n)", "bad": "let additivePersistence n = \nlet count = 0 in\nif n < 10 then count\nelse count + 1 in sumList(digitsOfInt n)", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet count = 0 in\nif n < 10 then count\nelse count + 1 in sumList(digitsOfInt n)"}
{"fix": "let rec additivePersistence n = \nif n < 10 then 1\nelse 1 + additivePersistence (sumList(digitsOfInt n))", "bad": "let rec additivePersistence n = \nif n < 10 then 1\nelse 1 + additivePersistence sumList(digitsOfInt n)", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif n < 10 then 1\nelse 1 + additivePersistence sumList(digitsOfInt n)"}
{"fix": "let rec digitalRoot n = \nlet sum = 0 in\nif n < 10 then n + sum\nelse sum = digitalRoot(sumList(digitsOfInt n))", "bad": "let rec digitalRoot n = \nif n < 10 then n + sum\nelse let sum = digitalRoot(sumList(digitsOfInt n))", "annotated": "let rec digitalRoot : int -> int = fun  n  ->  \nif n < 10 then n + sum\nelse let sum = digitalRoot(sumList(digitsOfInt n))"}
{"fix": "let rec assoc (d,k,l) =   \nmatch l with\n| [] -> d\n| x :: xs -> match x with\n| (s,i) -> if s = k then i\nelse assoc(d,k,xs)", "bad": "let rec assoc (d,k,l) =   \nmatch l with\n| [] -> d\n| x :: xs -> match x\n| (s,i) -> if s = k then i\nelse assoc(d,k,xs)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->    \nmatch l with\n| [] -> d\n| x :: xs -> match x\n| (s,i) -> if s = k then i\nelse assoc(d,k,xs)"}
{"fix": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h = seen) = false then seen' @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "et removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h = seen) = false then seen' @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h = seen) = false then seen@ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "et removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h = seen) = false then seen@ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h = seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "et removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h = seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "et removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": " _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "annotated": " _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"}
{"fix": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "bad": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) + eval(w,x,y))/2.0)\n| Times(v,w) -> eval(v,x,y) * eval(v,x,y)\n| Thresh(a,b,c,d) -> (eval(a,x,y) < eval(b,x,y) ? eval(c,x,y) : eval(d,x,y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) + eval(w,x,y))/2.0)\n| Times(v,w) -> eval(v,x,y) * eval(v,x,y)\n| Thresh(a,b,c,d) -> (eval(a,x,y) < eval(b,x,y) ? eval(c,x,y) : eval(d,x,y))"}
{"fix": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "bad": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)"}
{"fix": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "bad": "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "annotated": "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)"}
{"fix": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "bad": "let _ = eval (sampleExpr,0.5,0.2)", "annotated": "let _ = eval (sampleExpr,0.5,0.2)"}
{"fix": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "bad": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) + eval(w,x,y))/2.0)\n| Times(v,w) -> eval(v,x,y) * eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) + eval(w,x,y))/2.0)\n| Times(v,w) -> eval(v,x,y) * eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)"}
{"fix": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "bad": ")", "annotated": ")"}
{"fix": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "bad": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)"}
{"fix": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "bad": "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "annotated": "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)"}
{"fix": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "bad": "let _ = eval (sampleExpr,0.5,0.2)", "annotated": "let _ = eval (sampleExpr,0.5,0.2)"}
{"fix": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "bad": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) + eval(w,x,y))/2.0)\n| Times(v,w) -> eval(v,x,y) * eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) + eval(w,x,y))/2.0)\n| Times(v,w) -> eval(v,x,y) * eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)"}
{"fix": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "bad": ")", "annotated": ")"}
{"fix": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "bad": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)"}
{"fix": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "bad": "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "annotated": "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)"}
{"fix": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "bad": "let _ = eval (sampleExpr,0.5,0.2)", "annotated": "let _ = eval (sampleExpr,0.5,0.2)"}
{"fix": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "bad": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) + .eval(w,x,y))/2.0)\n| Times(v,w) -> eval(v,x,y) * eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) + .eval(w,x,y))/2.0)\n| Times(v,w) -> eval(v,x,y) * eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)"}
{"fix": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "bad": ")", "annotated": ")"}
{"fix": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "bad": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)"}
{"fix": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "bad": "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "annotated": "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)"}
{"fix": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "bad": "let _ = eval (sampleExpr,0.5,0.2)", "annotated": "let _ = eval (sampleExpr,0.5,0.2)"}
{"fix": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "bad": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/2.0)\n| Times(v,w) -> eval(v,x,y) * eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/2.0)\n| Times(v,w) -> eval(v,x,y) * eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)"}
{"fix": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "bad": ")", "annotated": ")"}
{"fix": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "bad": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)"}
{"fix": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "bad": "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "annotated": "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)"}
{"fix": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "bad": "let _ = eval (sampleExpr,0.5,0.2)", "annotated": "let _ = eval (sampleExpr,0.5,0.2)"}
{"fix": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "bad": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) * eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) * eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)"}
{"fix": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "bad": ")", "annotated": ")"}
{"fix": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "bad": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)"}
{"fix": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "bad": "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "annotated": "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)"}
{"fix": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "bad": "let _ = eval (sampleExpr,0.5,0.2)", "annotated": "let _ = eval (sampleExpr,0.5,0.2)"}
{"fix": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec build (rand, depth) = \nif depth > 0 \nthen d = d -1 in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,d))\n| 1 -> buildCosine(build(rand,d))\n| 2 -> buildAverage(build(rand,d))\n| 3 -> buildTimes(build(rand,d))\n| 4 -> buildThresh(build(rand,d))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 \nthen d = d -1 in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,d))\n| 1 -> buildCosine(build(rand,d))\n| 2 -> buildAverage(build(rand,d))\n| 3 -> buildTimes(build(rand,d))\n| 4 -> buildThresh(build(rand,d))"}
{"fix": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec build (rand, depth) = \nif depth > 0 \nthen depth = depth -1 in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 \nthen depth = depth -1 in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))"}
{"fix": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = depth -1 in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 \nthen let depth = depth -1 in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))"}
{"fix": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = depth -1 in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,depth)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 \nthen let depth = depth -1 in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,depth)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))"}
{"fix": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec build (rand, depth) = \nif depth > 0 \nthen let d = depth -1 in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,d)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 \nthen let d = depth -1 in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,d)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))"}
{"fix": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,depth)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,depth)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))"}
{"fix": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,depth)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,depth)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"}
{"fix": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"}
{"fix": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildY()", "bad": " rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": " rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"}
{"fix": "let pipe fs = \nlet f a x = fun nest -> (x(a nest))  in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = f nest -> x(a nest)  in\nlet base = f x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = f nest -> x(a nest)  in\nlet base = f x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun nest -> (x(a nest))  in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = fun nest -> (x(a nest))  in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun nest -> (x(a nest))  in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun nest -> (x(a nest))  in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = f nest -> (x(a nest))  in\nlet base = f x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = f nest -> (x(a nest))  in\nlet base = f x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun nest -> (x(a nest))  in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = fun nest -> (x(a nest))  in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun nest -> (x(a nest))  in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "bad": "let stringOfList f l = \"[\"^sepConcat \";\" [List.map(f l)]^\"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\"^sepConcat \";\" [List.map(f l)]^\"]\""}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "bad": "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "annotated": "let _ = stringOfList string_of_int [1;2;3;4;5;6]"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "bad": "let _ = stringOfList (fun x -> x) [\"foo\"]", "annotated": "let _ = stringOfList (fun x -> x) [\"foo\"]"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "bad": "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "annotated": "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "bad": "let stringOfList f l = \"[\"^sepConcat \";\"^[List.map(f l)]^\"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\"^sepConcat \";\"^[List.map(f l)]^\"]\""}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "bad": "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "annotated": "let _ = stringOfList string_of_int [1;2;3;4;5;6]"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "bad": "let _ = stringOfList (fun x -> x) [\"foo\"]", "annotated": "let _ = stringOfList (fun x -> x) [\"foo\"]"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "bad": "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "annotated": "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "bad": "let stringOfList f l = \"[\"^sepConcat \";\" [List.map(f l)]^\"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\"^sepConcat \";\" [List.map(f l)]^\"]\""}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "bad": "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "annotated": "let _ = stringOfList string_of_int [1;2;3;4;5;6]"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "bad": "let _ = stringOfList (fun x -> x) [\"foo\"]", "annotated": "let _ = stringOfList (fun x -> x) [\"foo\"]"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "bad": "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "annotated": "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "bad": "let stringOfList f l = \"[\"^sepConcat \";\" [List.map(f l)]^\"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\"^sepConcat \";\" [List.map(f l)]^\"]\""}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "bad": "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "annotated": "let _ = stringOfList string_of_int [1;2;3;4;5;6]"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "bad": "let _ = stringOfList (fun x -> x) [\"foo\"]", "annotated": "let _ = stringOfList (fun x -> x) [\"foo\"]"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "bad": "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "annotated": "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "bad": "let stringOfList f l = \"[\"^sepConcat \";\" List.map(f l)^\"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\"^sepConcat \";\" List.map(f l)^\"]\""}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "bad": "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "annotated": "let _ = stringOfList string_of_int [1;2;3;4;5;6]"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "bad": "let _ = stringOfList (fun x -> x) [\"foo\"]", "annotated": "let _ = stringOfList (fun x -> x) [\"foo\"]"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "bad": "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "annotated": "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"}
{"fix": "let stringOfList f l = \"[\"^(sepConcat \";\" (List.map f l))^\"]\"", "bad": "let stringOfList f l = \"[\"^sepConcat \";\" List.map(f l)^\"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\"^sepConcat \";\" List.map(f l)^\"]\""}
{"fix": "let stringOfList f l = \"[\"^(sepConcat \";\" (List.map f l))^\"]\"", "bad": "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "annotated": "let _ = stringOfList string_of_int [1;2;3;4;5;6]"}
{"fix": "let stringOfList f l = \"[\"^(sepConcat \";\" (List.map f l))^\"]\"", "bad": "let _ = stringOfList (fun x -> x) [\"foo\"]", "annotated": "let _ = stringOfList (fun x -> x) [\"foo\"]"}
{"fix": "let stringOfList f l = \"[\"^(sepConcat \";\" (List.map f l))^\"]\"", "bad": "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "annotated": "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"}
{"fix": "let stringOfList f l = \"[\"^(sepConcat \";\" (List.map f l))^\"]\"", "bad": "let stringOfList f l = \"[\"^sepConcat(\";\" List.map(f l))^\"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\"^sepConcat(\";\" List.map(f l))^\"]\""}
{"fix": "let stringOfList f l = \"[\"^(sepConcat \";\" (List.map f l))^\"]\"", "bad": "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "annotated": "let _ = stringOfList string_of_int [1;2;3;4;5;6]"}
{"fix": "let stringOfList f l = \"[\"^(sepConcat \";\" (List.map f l))^\"]\"", "bad": "let _ = stringOfList (fun x -> x) [\"foo\"]", "annotated": "let _ = stringOfList (fun x -> x) [\"foo\"]"}
{"fix": "let stringOfList f l = \"[\"^(sepConcat \";\" (List.map f l))^\"]\"", "bad": "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "annotated": "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"}
{"fix": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y = clone (List.hd l1) (List.length l1 - List.length l2) in\n(y, l2)\nelse let z = clone (List.hd l2) (List.length l2 - List.length l1) in\n(z, l1)", "bad": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen l1, l2\nelse if List.length l1 > List.length l2", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 = List.length l2\nthen l1, l2\nelse if List.length l1 > List.length l2"}
{"fix": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y = clone (List.hd l1) (List.length l1 - List.length l2) in\n(y, l2)\nelse let z = clone (List.hd l2) (List.length l2 - List.length l1) in\n(z, l1)", "bad": "let y =clone List.hd l1 (List.length l1 - List.length l2)\ny, l2", "annotated": "let y =clone List.hd l1 (List.length l1 - List.length l2)\ny, l2"}
{"fix": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y = clone (List.hd l1) (List.length l1 - List.length l2) in\n(y, l2)\nelse let z = clone (List.hd l2) (List.length l2 - List.length l1) in\n(z, l1)", "bad": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen l1, l2\nelse if (List.length l1 > List.length l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 = List.length l2\nthen l1, l2\nelse if (List.length l1 > List.length l2)"}
{"fix": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y = clone (List.hd l1) (List.length l1 - List.length l2) in\n(y, l2)\nelse let z = clone (List.hd l2) (List.length l2 - List.length l1) in\n(z, l1)", "bad": "let y =clone List.hd l1 (List.length l1 - List.length l2)\ny, l2", "annotated": "let y =clone List.hd l1 (List.length l1 - List.length l2)\ny, l2"}
{"fix": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y = clone (List.hd l1) (List.length l1 - List.length l2) in\n(y, l2)\nelse let z = clone (List.hd l2) (List.length l2 - List.length l1) in\n(z, l1)", "bad": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen l1, l2\nelse if (List.length l1) > (List.length l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 = List.length l2\nthen l1, l2\nelse if (List.length l1) > (List.length l2)"}
{"fix": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y = clone (List.hd l1) (List.length l1 - List.length l2) in\n(y, l2)\nelse let z = clone (List.hd l2) (List.length l2 - List.length l1) in\n(z, l1)", "bad": "let y =clone List.hd l1 (List.length l1 - List.length l2)\ny, l2", "annotated": "let y =clone List.hd l1 (List.length l1 - List.length l2)\ny, l2"}
{"fix": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y = clone (List.hd l1) (List.length l1 - List.length l2) in\n(y, l2)\nelse let z = clone (List.hd l2) (List.length l2 - List.length l1) in\n(z, l1)", "bad": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y =clone List.hd l1 (List.length l1 - List.length l2)\n(y, l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y =clone List.hd l1 (List.length l1 - List.length l2)\n(y, l2)"}
{"fix": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y = clone (List.hd l1) (List.length l1 - List.length l2) in\n(y, l2)\nelse let z = clone (List.hd l2) (List.length l2 - List.length l1) in\n(z, l1)", "bad": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y =clone List.hd l1 (List.length l1 - List.length l2) then(y, l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y =clone List.hd l1 (List.length l1 - List.length l2) then(y, l2)"}
{"fix": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y = clone (List.hd l1) (List.length l1 - List.length l2) in\n(y, l2)\nelse let z = clone (List.hd l2) (List.length l2 - List.length l1) in\n(z, l1)", "bad": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y =clone List.hd l1 (List.length l1 - List.length l2) -> (y, l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y =clone List.hd l1 (List.length l1 - List.length l2) -> (y, l2)"}
{"fix": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y = clone (List.hd l1) (List.length l1 - List.length l2) in\n(y, l2)\nelse let z = clone (List.hd l2) (List.length l2 - List.length l1) in\n(z, l1)", "bad": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y =clone List.hd l1 (List.length l1 - List.length l2) (y, l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y =clone List.hd l1 (List.length l1 - List.length l2) (y, l2)"}
{"fix": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y = clone (List.hd l1) (List.length l1 - List.length l2) in\n(y, l2)\nelse let z = clone (List.hd l2) (List.length l2 - List.length l1) in\n(z, l1)", "bad": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y =clone l1 (List.length l1 - List.length l2) in\n(y, l2)\nelse let z = clone l2 (List.length l2 - List.length l1) in\n(z, l1)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y =clone l1 (List.length l1 - List.length l2) in\n(y, l2)\nelse let z = clone l2 (List.length l2 - List.length l1) in\n(z, l1)"}
{"fix": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y = clone (List.hd l1) (List.length l1 - List.length l2) in\n(y, l2)\nelse let z = clone (List.hd l2) (List.length l2 - List.length l1) in\n(z, l1)", "bad": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y =clone List.hd l1 (List.length l1 - List.length l2) in\n(y, l2)\nelse let z = clone List.hd l2 (List.length l2 - List.length l1) in\n(z, l1)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y =clone List.hd l1 (List.length l1 - List.length l2) in\n(y, l2)\nelse let z = clone List.hd l2 (List.length l2 - List.length l1) in\n(z, l1)"}
{"fix": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y = clone (List.hd l1) (List.length l1 - List.length l2) in\n(y, l2)\nelse let z = clone (List.hd l2) (List.length l2 - List.length l1) in\n(z, l1)", "bad": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y = clone List.hd l1 (List.length l1 - List.length l2) in\n(y, l2)\nelse let z = clone List.hd l2 (List.length l2 - List.length l1) in\n(z, l1)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y = clone List.hd l1 (List.length l1 - List.length l2) in\n(y, l2)\nelse let z = clone List.hd l2 (List.length l2 - List.length l1) in\n(z, l1)"}
{"fix": "let rec removeZero l = \nmatch l with \n| x::xs -> if x = 0 then removeZero(xs) else l", "bad": "let rec removeZero l = \nmatch l with \nx::xs -> if x = 0 then removeZero(xs)\n| [] -> xs", "annotated": "let rec removeZero : int list -> int list = fun  l  ->  \nmatch l with \nx::xs -> if x = 0 then removeZero(xs)\n| [] -> xs"}
{"fix": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  in\nlet base = [] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  in\nlet base = [] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  failwith \"tba\" in\nlet base = [] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  failwith \"tba\" in\nlet base = [] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let rec removeZero l = failwith \"to be implemented\"", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nif d1 + d2 > 9 then let carry = 1\nelse then let carry = 0\nmatch a with \n| (c,result) -> (carry, d1+d2+c)", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nif d1 + d2 > 9 then let carry = 1\nelse then let carry = 0\nmatch a with \n| (c,result) -> (carry, d1+d2+c)"}
{"fix": "let rec removeZero l = failwith \"to be implemented\"", "bad": "let base = (0,[]) in\nlet args = List.combine(List.rev l1 List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let base = (0,[]) in\nlet args = List.combine(List.rev l1 List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let rec removeZero l = failwith \"to be implemented\"", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> match a with\n| (carry,[result]) -> if carry = 1 then \n\nmatch \nlet base = (0,[]) in\n\nif d1 + d2 > 9 then let carry = 1\nelse let carry = 0", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> match a with\n| (carry,[result]) -> if carry = 1 then \n\nmatch \nlet base = (0,[]) in\n\nif d1 + d2 > 9 then let carry = 1\nelse let carry = 0"}
{"fix": "let rec removeZero l = failwith \"to be implemented\"", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nif d1 + d2 > 9 then let carry = 1\nelse let carry = 0\nmatch a with \n| (c,result) -> (carry, d1+d2+c)", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nif d1 + d2 > 9 then let carry = 1\nelse let carry = 0\nmatch a with \n| (c,result) -> (carry, d1+d2+c)"}
{"fix": "let rec removeZero l = failwith \"to be implemented\"", "bad": "let base = (0,[]) in\nlet args = List.combine(List.rev l1 List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let base = (0,[]) in\nlet args = List.combine(List.rev l1 List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)\nelse (0,(d1+d2)::result) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nif (d1 + d2 > 9) then let carry = 1\nelse let carry = 0\nmatch a with \n| (c,result) -> (carry, d1+d2+c)", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nif (d1 + d2 > 9) then let carry = 1\nelse let carry = 0\nmatch a with \n| (c,result) -> (carry, d1+d2+c)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)\nelse (0,(d1+d2)::result) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let base = (0,[]) in\nlet args = List.combine(List.rev l1 List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let base = (0,[]) in\nlet args = List.combine(List.rev l1 List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)\nelse (0,(d1+d2)::result) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nif (d1 + d2 > 9) then let carry = 1\nelse carry = 0\nmatch a with \n| (c,result) -> (carry, d1+d2+c)", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nif (d1 + d2 > 9) then let carry = 1\nelse carry = 0\nmatch a with \n| (c,result) -> (carry, d1+d2+c)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)\nelse (0,(d1+d2)::result) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let base = (0,[]) in\nlet args = List.combine(List.rev l1 List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let base = (0,[]) in\nlet args = List.combine(List.rev l1 List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)\nelse (0,(d1+d2)::result) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nif (d1 + d2 > 9) then let carry = 1\nelse let carry = 0\nmatch a with \n| (c,result) -> (carry, d1+d2+c)", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nif (d1 + d2 > 9) then let carry = 1\nelse let carry = 0\nmatch a with \n| (c,result) -> (carry, d1+d2+c)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)\nelse (0,(d1+d2)::result) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let base = (0,[]) in\nlet args = List.combine(List.rev l1 List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let base = (0,[]) in\nlet args = List.combine(List.rev l1 List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)\nelse (0,(d1+d2)::result) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)\nelse (0,(d1+d2)::result)", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)\nelse (0,(d1+d2)::result)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)\nelse (0,(d1+d2)::result) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let base = (0,[]) in\nlet args = List.combine(List.rev l1 List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let base = (0,[]) in\nlet args = List.combine(List.rev l1 List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)\nelse (0,(d1+d2)::result) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)\nelse (0,(d1+d2)::result) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev l1 List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)\nelse (0,(d1+d2)::result) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev l1 List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)\nelse (0,(d1+d2)::result) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)\nelse (0,(d1+d2)::result) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev l1, List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)\nelse (0,(d1+d2)::result) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev l1, List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)\nelse (0,(d1+d2+carry)::result) in\nlet base = (0,[]) in\nlet args = [(0,0)]@List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)\nelse (0,(d1+d2+carry)::result) in\nlet base = (0,[]) in\nlet args = [0]@[List.combine(List.rev l1)(List.rev l2)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)\nelse (0,(d1+d2+carry)::result) in\nlet base = (0,[]) in\nlet args = [0]@[List.combine(List.rev l1)(List.rev l2)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)\nelse (0,(d1+d2+carry)::result) in\nlet base = (0,[]) in\nlet args = [(0,0)]@List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)\nelse (0,(d1+d2+carry)::result) in\nlet base = (0,[]) in\nlet args = [0]@List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)\nelse (0,(d1+d2+carry)::result) in\nlet base = (0,[]) in\nlet args = [0]@List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigMul l1 l2 = \nmatch l2 with\n| x::xs -> xs", "bad": "let bigMul l1 l2 =  \nlet f a x =  match x with \n| (_,n) -> \nmatch a with\n| (numzero,result) ->\n(i + 1, bigAdd(mulByDigit n l1 @ clone 0 i) result)", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->   \nlet f a x =  match x with \n| (_,n) -> \nmatch a with\n| (numzero,result) ->\n(i + 1, bigAdd(mulByDigit n l1 @ clone 0 i) result)"}
{"fix": "let bigMul l1 l2 = \nmatch l2 with\n| x::xs -> xs", "bad": "let base = (0,[]) in\nlet args = List.combine (List.rev l1)(List.rev l2)", "annotated": "let base = (0,[]) in\nlet args = List.combine (List.rev l1)(List.rev l2)"}
{"fix": "let bigMul l1 l2 = \nmatch l2 with\n| x::xs -> xs", "bad": ")", "annotated": ")"}
{"fix": "let bigMul l1 l2 = \nmatch l2 with\n| x::xs -> xs", "bad": "let (_, res) = List.fold_left f base args in\nres", "annotated": "let (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nmatch l2 with\n| x::xs -> xs", "bad": "let bigMul l1 l2 =  \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd(mulByDigit x l1 @ clone 0 numzero) result)", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->   \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd(mulByDigit x l1 @ clone 0 numzero) result)"}
{"fix": "let bigMul l1 l2 = \nmatch l2 with\n| x::xs -> xs", "bad": "let base = (0,[]) in\nlet args = List.rev l2", "annotated": "let base = (0,[]) in\nlet args = List.rev l2"}
{"fix": "let bigMul l1 l2 = \nmatch l2 with\n| x::xs -> xs", "bad": "let (_, res) = List.fold_left f base args in\nres", "annotated": "let (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nmatch l2 with\n| x::xs -> xs", "bad": "let bigMul l1 l2 =  \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd(mulByDigit * l1 @ clone 0 numzero) result)", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->   \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd(mulByDigit * l1 @ clone 0 numzero) result)"}
{"fix": "let bigMul l1 l2 = \nmatch l2 with\n| x::xs -> xs", "bad": "let base = (0,[]) in\nlet args = List.rev l2", "annotated": "let base = (0,[]) in\nlet args = List.rev l2"}
{"fix": "let bigMul l1 l2 = \nmatch l2 with\n| x::xs -> xs", "bad": "let (_, res) = List.fold_left f base args in\nres", "annotated": "let (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nmatch l2 with\n| x::xs -> xs", "bad": "let bigMul l1 l2 =  \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd(mulByDigit * l1 :: clone 0 numzero) result)", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->   \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd(mulByDigit * l1 :: clone 0 numzero) result)"}
{"fix": "let bigMul l1 l2 = \nmatch l2 with\n| x::xs -> xs", "bad": "let base = (0,[]) in\nlet args = List.rev l2", "annotated": "let base = (0,[]) in\nlet args = List.rev l2"}
{"fix": "let bigMul l1 l2 = \nmatch l2 with\n| x::xs -> xs", "bad": "let (_, res) = List.fold_left f base args in\nres", "annotated": "let (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nmatch l2 with\n| x::xs -> xs", "bad": "let bigMul l1 l2 =  \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd(mulByDigit * l1 :: clone 0 numzero) result) in\nlet base = (0,[]) in\nlet args = List.rev l2", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->   \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd(mulByDigit * l1 :: clone 0 numzero) result) in\nlet base = (0,[]) in\nlet args = List.rev l2"}
{"fix": "let bigMul l1 l2 = \nmatch l2 with\n| x::xs -> xs", "bad": "let (_, res) = List.fold_left f base args in\nres", "annotated": "let (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nmatch l2 with\n| x::xs -> xs", "bad": "let bigMul l1 l2 =  \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd(mulByDigit * l1 :: clone 0 numzero) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->   \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd(mulByDigit * l1 :: clone 0 numzero) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nmatch l2 with\n| x::xs -> xs", "bad": "let bigMul l1 l2 =  \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd(mulByDigit l1 x :: clone 0 numzero) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->   \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd(mulByDigit l1 x :: clone 0 numzero) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nmatch l2 with\n| x::xs -> xs", "bad": "let bigMul l1 l2 =  \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd(mulByDigit x l1 :: clone 0 numzero) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->   \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd(mulByDigit x l1 :: clone 0 numzero) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nmatch l2 with\n| x::xs -> xs", "bad": "let bigMul l1 l2 =  \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd((mulByDigit x l1) :: clone 0 numzero) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->   \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd((mulByDigit x l1) :: clone 0 numzero) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, (bigAdd((mulByDigit x l1) @ clone 0 numzero)) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nmatch l2 with\n| x::xs -> xs in\nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd((mulByDigit x l1) :: clone 0 numzero) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nmatch l2 with\n| x::xs -> xs in\nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd((mulByDigit x l1) :: clone 0 numzero) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, (bigAdd((mulByDigit x l1) @ clone 0 numzero)) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nmatch l2 with\n| x::xs -> t in\nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd((mulByDigit x l1) :: clone 0 numzero) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nmatch l2 with\n| x::xs -> t in\nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd((mulByDigit x l1) :: clone 0 numzero) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, (bigAdd((mulByDigit x l1) @ clone 0 numzero)) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd((mulByDigit x l1) :: clone 0 numzero) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, bigAdd((mulByDigit x l1) :: clone 0 numzero) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, (bigAdd((mulByDigit x l1) @ clone 0 numzero)) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, (bigAdd((mulByDigit x l1) :: clone 0 numzero)) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x =  \nmatch a with\n| (numzero,result) ->\n(numzero + 1, (bigAdd((mulByDigit x l1) :: clone 0 numzero)) result) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let rec digitsOfInt n = \nif n <= 0\nthen []\nelse n - (n/10) * 10 :: digitsOfInt (n/10)", "bad": "let rec digitsOfInt n = \nif n <= 0\nthen []\nelse n - (n/10) * 10 :: digitsOfInt n/10", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n <= 0\nthen []\nelse n - (n/10) * 10 :: digitsOfInt n/10"}
{"fix": "let _ = additivePersistence (-1)", "bad": "let _ = additivePersistence -1", "annotated": "let _ = additivePersistence -1"}
{"fix": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> append (listReverse tl) [hd]", "bad": "let _ = listReverse [1; 2; 3; 4]", "annotated": "let _ = listReverse [1; 2; 3; 4]"}
{"fix": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> append (listReverse tl) [hd]", "bad": "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]", "annotated": "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]"}
{"fix": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> append (listReverse tl) [hd]", "bad": "let _ = listReverse [1; 2; 3; 4]", "annotated": "let _ = listReverse [1; 2; 3; 4]"}
{"fix": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> append (listReverse tl) [hd]", "bad": "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]", "annotated": "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]"}
{"fix": "let palindrome w = match (explode w) with\n| [] -> true\n| head::[] -> true\n| head::tail -> \nif head = List.hd (listReverse tail)\nthen palindrome (List.tl (listReverse tail))\nelse false", "bad": "let palindrome w = match (explode w) with\n| [] -> true\n| head::[] -> true\n| head::tail -> \nif head = hd (listReverse w)\nthen palindrome (tl (listReverse tail))\nelse false", "annotated": "let palindrome : string -> bool = fun  w  ->  match (explode w) with\n| [] -> true\n| head::[] -> true\n| head::tail -> \nif head = hd (listReverse w)\nthen palindrome (tl (listReverse tail))\nelse false"}
{"fix": "let palindrome w = match (explode w) with\n| [] -> true\n| head::[] -> true\n| head::tail -> \nif head = List.hd (listReverse tail)\nthen palindrome (List.tl (listReverse tail))\nelse false", "bad": "let palindrome w = match (explode w) with\n| [] -> true\n| head::[] -> true\n| head::tail -> \nif head = List.hd (listReverse w)\nthen palindrome (List.tl (listReverse tail))\nelse false", "annotated": "let palindrome : string -> bool = fun  w  ->  match (explode w) with\n| [] -> true\n| head::[] -> true\n| head::tail -> \nif head = List.hd (listReverse w)\nthen palindrome (List.tl (listReverse tail))\nelse false"}
{"fix": "let palindrome w = match (explode w) with\n| [] -> true\n| head::[] -> true\n| head::tail -> \nif head = List.hd (listReverse tail)\nthen palindrome (List.tl (listReverse tail))\nelse false", "bad": "let palindrome w = match (explode w) with\n| [] -> true\n| head::[] -> true\n| head::tail -> \nif head = List.hd (listReverse [w])\nthen palindrome (List.tl (listReverse [tail]))\nelse false", "annotated": "let palindrome : string -> bool = fun  w  ->  match (explode w) with\n| [] -> true\n| head::[] -> true\n| head::tail -> \nif head = List.hd (listReverse [w])\nthen palindrome (List.tl (listReverse [tail]))\nelse false"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (di,ki) ->\nif ki = k\nthen di\nelse assoc (d,k,t)", "bad": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (di * ki) ->\nif ki = k\nthen di\nelse assoc (d,k,t)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with\n| [] -> d\n| h::t -> match h with\n| (di * ki) ->\nif ki = k\nthen di\nelse assoc (d,k,t)"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (di,ki) ->\nif ki = k\nthen di\nelse assoc (d,k,t)", "bad": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (di,ki) ->\nif ki = k\nthen di\nelse assoc (d,k,t)", "bad": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| di * ki ->\nif ki = k\nthen di\nelse assoc (d,k,t)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with\n| [] -> d\n| h::t -> match h with\n| di * ki ->\nif ki = k\nthen di\nelse assoc (d,k,t)"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (di,ki) ->\nif ki = k\nthen di\nelse assoc (d,k,t)", "bad": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (di * ki) ->\nif ki = k\nthen di\nelse assoc (d,k,t)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with\n| [] -> d\n| h::t -> match h with\n| (di * ki) ->\nif ki = k\nthen di\nelse assoc (d,k,t)"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (di,ki) ->\nif ki = k\nthen di\nelse assoc (d,k,t)", "bad": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (di*ki) ->\nif ki = k\nthen di\nelse assoc (d,k,t)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with\n| [] -> d\n| h::t -> match h with\n| (di*ki) ->\nif ki = k\nthen di\nelse assoc (d,k,t)"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (ki,di) ->\nif ki = k\nthen di\nelse assoc (d,k,t)", "bad": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen\nthen seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif List.mem (h, seen)\nthen seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif List.mem (h, seen)\nthen seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen\nthen seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif List.mem h\nthen seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif List.mem h\nthen seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let fixpoint (f,b) = wwhile (\nlet g a = \nf a, f a != a\nin \ng, b)", "bad": " g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": " g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = wwhile ((fun a -> f a, f a != a), b)", "bad": "let fixpoint (f,b) = wwhile (\nfun a ->\nf a, f a != a\nin \ng, b", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (\nfun a ->\nf a, f a != a\nin \ng, b"}
{"fix": "let fixpoint (f,b) = wwhile ((fun a -> f a, f a != a), b)", "bad": "let fixpoint (f,b) = wwhile (\nfun a ->\nf a, f a != a, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (\nfun a ->\nf a, f a != a, b)"}
{"fix": "let fixpoint (f,b) = wwhile ((fun a -> f a, f a != a), b)", "bad": "let fixpoint (f,b) = wwhile (\nfun a ->\nf a, f a != a\n, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (\nfun a ->\nf a, f a != a\n, b)"}
{"fix": "let fixpoint (f,b) = wwhile ((fun a -> f a, f a != a), b)", "bad": "let fixpoint (f,b) = wwhile (\nfun a ->\nf a, f a != a\n, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (\nfun a ->\nf a, f a != a\n, b)"}
{"fix": "let fixpoint (f,b) = wwhile ((fun a -> f a, f a != a), b)", "bad": "let fixpoint (f,b) = wwhile (fun a -> f a, f a != a, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun a -> f a, f a ! ->  a, b)"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> String.concat \"pi* \" ^ exprToString s", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> String.concat sep [\"pi* \"; exprToString s]", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> String.concat sep [\"pi* \"; exprToString s]"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi *. eval e)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi * eval e)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi * eval e)"}
{"fix": "let rec build (rand, depth) =\nif \n(depth = 0)\nthen\nmatch rand(0,2) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \nmatch rand (0,100) with\n| i when (i<5) -> \nbuildSine (build (rand, depth-1))\n| i when (i<10) -> \nbuildCosine (build (rand, depth-1))\n| i when (i<20) -> \nbuildAverage (build (rand, depth-1), build (rand, depth-1))\n| i when (i<80) -> \nbuildTimes (build (rand, depth-1), build (rand, depth-1))\n| i when (i<100) ->\nbuildThresh (build (rand, depth-1), build (rand, depth-1), \nbuild (rand, depth-1), build (rand, depth-1))", "bad": "let rec build (rand, depth) =\nif \n(depth = 0)\nthen\nmatch rand(0,2) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \nmatch rand (0,100) with\n| i if (i<5) -> \nbuildSine (build (rand, depth-1))\n| i if (i<10) -> \nbuildCosine (build (rand, depth-1))\n| i if (i<20) -> \nbuildAverage (build (rand, depth-1), build (rand, depth-1))\n| i if (i<80) -> \nbuildTimes (build (rand, depth-1), build (rand, depth-1))\n| i if (i<100) ->\nbuildThresh (build (rand, depth-1), build (rand, depth-1), \nbuild (rand, depth-1), build (rand, depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nif \n(depth = 0)\nthen\nmatch rand(0,2) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \nmatch rand (0,100) with\n| i if (i<5) -> \nbuildSine (build (rand, depth-1))\n| i if (i<10) -> \nbuildCosine (build (rand, depth-1))\n| i if (i<20) -> \nbuildAverage (build (rand, depth-1), build (rand, depth-1))\n| i if (i<80) -> \nbuildTimes (build (rand, depth-1), build (rand, depth-1))\n| i if (i<100) ->\nbuildThresh (build (rand, depth-1), build (rand, depth-1), \nbuild (rand, depth-1), build (rand, depth-1))"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> \nx\n| VarY -> \ny\n| Sine e1 -> \nsin(pi *. eval (e1,x,y))\n| Cosine e1 -> \ncos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> \n(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0\n| Times (e1,e2) -> \neval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif (eval(e1,x,y)<eval(e2,x,y))\nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Log e1 ->\nlet b = eval (e1,x,y)\nin\nif (b > 1.0)\nthen log(b)\nelse 0.0", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> \nx\n| VarY -> \ny\n| Sine e1 -> \nsin(pi *. eval (e1,x,y))\n| Cosine e1 -> \ncos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> \n(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0\n| Times (e1,e2) -> \neval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif (eval(e1,x,y)<eval(e2,x,y))\nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Log e1 ->\nlet b = eval (e1,x,y)\nin\nif (b > 1.0)\nthen log(b)\nelse 0", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> \nx\n| VarY -> \ny\n| Sine e1 -> \nsin(pi *. eval (e1,x,y))\n| Cosine e1 -> \ncos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> \n(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0\n| Times (e1,e2) -> \neval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif (eval(e1,x,y)<eval(e2,x,y))\nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Log e1 ->\nlet b = eval (e1,x,y)\nin\nif (b > 1.0)\nthen log(b)\nelse 0"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> \nx\n| VarY -> \ny\n| Sine e1 -> \nsin(pi *. eval (e1,x,y))\n| Cosine e1 -> \ncos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> \n(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0\n| Times (e1,e2) -> \neval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif (eval(e1,x,y)<eval(e2,x,y))\nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Log e1 ->\nlet b = eval (e1,x,y)\nin\nif (b > 1.0)\nthen log(b)\nelse 0.0\n| SumOfSquares (e1,e2,e3) ->\n(eval(e1,x,y) ** 2.0) +. (eval(e2,x,y) ** 2.0) +. (eval(e3,x,y) ** 2.0)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> \nx\n| VarY -> \ny\n| Sine e1 -> \nsin(pi *. eval (e1,x,y))\n| Cosine e1 -> \ncos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> \n(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0\n| Times (e1,e2) -> \neval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif (eval(e1,x,y)<eval(e2,x,y))\nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Log e1 ->\nlet b = eval (e1,x,y)\nin\nif (b > 1.0)\nthen log(b)\nelse 0.0\n| SumOfSquares (e1,e2,e3) ->\n(eval(e1,x,y) ** 2.0) + (eval(e2,x,y) ** 2.0) + (eval(e3,x,y) ** 2.0)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> \nx\n| VarY -> \ny\n| Sine e1 -> \nsin(pi *. eval (e1,x,y))\n| Cosine e1 -> \ncos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> \n(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0\n| Times (e1,e2) -> \neval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif (eval(e1,x,y)<eval(e2,x,y))\nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Log e1 ->\nlet b = eval (e1,x,y)\nin\nif (b > 1.0)\nthen log(b)\nelse 0.0\n| SumOfSquares (e1,e2,e3) ->\n(eval(e1,x,y) ** 2.0) + (eval(e2,x,y) ** 2.0) + (eval(e3,x,y) ** 2.0)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> \nx\n| VarY -> \ny\n| Sine e1 -> \nsin(pi *. eval (e1,x,y))\n| Cosine e1 -> \ncos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> \n(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0\n| Times (e1,e2) -> \neval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif (eval(e1,x,y)<eval(e2,x,y))\nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Log e1 ->\nlet b = eval (e1,x,y)\nin\nif (b > 1.0)\nthen log(b)\nelse 0.0\n| SumOfSquares (e1,e2,e3) ->\n(eval(e1,x,y) ** 2.0) +. (eval(e2,x,y) ** 2.0) +. (eval(e3,x,y) ** 2.0)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> \nx\n| VarY -> \ny\n| Sine e1 -> \nsin(pi *. eval (e1,x,y))\n| Cosine e1 -> \ncos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> \n(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0\n| Times (e1,e2) -> \neval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif (eval(e1,x,y)<eval(e2,x,y))\nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Log e1 ->\nlet b = eval (e1,x,y)\nin\nif (b > 1.0)\nthen log(b)\nelse 0.0\n| SumOfSquares (e1,e2,e3) ->\n(eval(e1,x,y) **. 2.0) + (eval(e2,x,y) **. 2.0) + (eval(e3,x,y) **. 2.0)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> \nx\n| VarY -> \ny\n| Sine e1 -> \nsin(pi *. eval (e1,x,y))\n| Cosine e1 -> \ncos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> \n(eval (e1,x,y) +. eval (e2,x,y)) /. 2.0\n| Times (e1,e2) -> \neval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif (eval(e1,x,y)<eval(e2,x,y))\nthen eval(e3,x,y)\nelse eval(e4,x,y)\n| Log e1 ->\nlet b = eval (e1,x,y)\nin\nif (b > 1.0)\nthen log(b)\nelse 0.0\n| SumOfSquares (e1,e2,e3) ->\n(eval(e1,x,y) **. 2.0) + (eval(e2,x,y) **. 2.0) + (eval(e3,x,y) **. 2.0)"}
{"fix": "let sqsum xs = \nlet f a x = x**2.0 in\nlet base = 0.0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = x**2 in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = x**2 in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = x**2.0 in\nlet base = 0.0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = x**2.0 in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = x**2.0 in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = x**2.0 in\nlet base = 0.0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = x**.2.0 in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = x**.2.0 in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = sqsum [1;2;3;4]", "annotated": "let _ = sqsum [1;2;3;4]"}
{"fix": "let sqsum xs = \nlet f a x = x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = x*xin", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = x*xin"}
{"fix": "let sqsum xs = \nlet f a x = x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let base = 0 in\nList.fold_left f base xs", "annotated": "let base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = base + x in\nlet base = x*x in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = base + x in\nlet base = x*x in\nList.fold_left f base xs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = z in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = z in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fs in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fs in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun a->a in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun a->a in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun a->a in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = 'a->'a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = 'a->'a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x  in\nlet base = fun b->b in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x  in\nlet base = fun b->b in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x (a->a) in\nlet base = fun a->a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x (a->a) in\nlet base = fun a->a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x  in\nlet base = fun b->b in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a->a in\nlet base = fun a->a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a->a in\nlet base = fun a->a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun c->x c in\nlet base = fun b->b in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x-> x a in\nlet base = fun b->b in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x-> x a in\nlet base = fun b->b in\nList.fold_left f base fs"}
{"fix": "let stringOfList f l = sepConcat \"; \" (List.map f l)", "bad": "let stringOfList f l = List.map sepConcat \";\" l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map sepConcat \";\" l"}
{"fix": "let padZero l1 l2 = \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif (length1 > length2)\nthen List.append (clone 0 (length1 - length2)), length2\nelse List.append (clone 0 (length2 - length1)), length1", "bad": "let padZero l1 l2 = \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif (lenth1 > length2)\nthen List.append (clone 0 (length1 - length2)), length2\nelse List.append (clone 0 (length2 - length1)), length1", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif (lenth1 > length2)\nthen List.append (clone 0 (length1 - length2)), length2\nelse List.append (clone 0 (length2 - length1)), length1"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "bad": "let rec sumList xs = match xs with\n| [] -> []\n| h::t -> h+sumList t", "annotated": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n| [] -> []\n| h::t -> h+sumList t"}
{"fix": "let rec digitsOfInt n = \nif n < 0\nthen true\nelse false", "bad": "let rec digitsOfInt n = \nif n < 0\nthen []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0\nthen []"}
{"fix": "let rec digitsOfInt n = \nif n < 0\nthen true\nelse false", "bad": "let rec digitsOfInt n = \nif n < 0\nthen -> []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0\nthen -> []"}
{"fix": "let rec digitsOfInt n = \nif n < 0\nthen true\nelse false", "bad": "let rec digitsOfInt n = \nif n < 0\nthen true", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0\nthen true"}
{"fix": "let rec digitsOfInt n = \nif n < 0\nthen []\nelse []", "bad": "let rec digitsOfInt n = \nif n < 0\nthen []\nelse", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0\nthen []\nelse"}
{"fix": "let rec digitsOfInt n = \nif n < 0\nthen []\nelse \nlet (x,y) = (n mod 10, n / 10) in\nn::(digitsOfInt n)", "bad": "let rec digitsOfInt n = \n| n < 0 -> true", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \n| n < 0 -> true"}
{"fix": "let rec digitsOfInt n = \nif n < 0\nthen []\nelse \nlet (x,y) = (n mod 10, n / 10) in\nn::(digitsOfInt n)", "bad": "let rec digitsOfInt n =", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> "}
{"fix": "let rec digitsOfInt n = \nif n < 0\nthen []\nelse \nlet (x,y) = (n mod 10, n / 10) in\nn::(digitsOfInt n)", "bad": "with\n| n < 0 -> true", "annotated": "with\n| n < 0 -> true"}
{"fix": "let rec digitsOfInt n = \nif n > 0\nthen []\nelse if (n mod 10) < 10\nthen []\nelse (n mod 10)::(digitsOfInt (n / 10))", "bad": "let rec digitsOfInt n = \nif n > 0\nthen []\nelse \nif (n mod 10) < 10\nthen [x]\nelse x::(digitsOfInt (n / 10))", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n > 0\nthen []\nelse \nif (n mod 10) < 10\nthen [x]\nelse x::(digitsOfInt (n / 10))"}
{"fix": "let rec digitsOfInt n = \nif n > 0\nthen []\nelse if (n mod 10) < 10\nthen []\nelse (n mod 10)::(digitsOfInt (n / 10))", "bad": "let rec digitsOfInt n = \nif n > 0\nthen []\nelse if (n mod 10) < 10\nthen []\nelse x::(digitsOfInt (n / 10))", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n > 0\nthen []\nelse if (n mod 10) < 10\nthen []\nelse x::(digitsOfInt (n / 10))"}
{"fix": "let rec additivePersistence n = \nlet x = sumList n in\nif x < 10\nthen countlist n\nelse additivePersistence [x]", "bad": "let rec additivePersistence n = \nlet x = sumList n in\nif x < 10\nthen countlist n\nelse additivePersistence x", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet x = sumList n in\nif x < 10\nthen countlist n\nelse additivePersistence x"}
{"fix": "let rec additivePersistence n = \nif sumList (digits n) < 10\nthen numdigits (digits n)\nelse additivePersistence (sumList (digits n))", "bad": "let rec additivePersistence n = \nif sumList (digits n) < 10\nthen numdigits n\nelse additivePersistence sumList n", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif sumList (digits n) < 10\nthen numdigits n\nelse additivePersistence sumList n"}
{"fix": "let rec additivePersistence n = \nif sumList (digits n) < 10\nthen numdigits (digits n)\nelse additivePersistence (sumList (digits n))", "bad": "let rec additivePersistence n = \nif sumList (digits n) < 10\nthen numdigits (digits n)\nelse additivePersistence sumList n", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif sumList (digits n) < 10\nthen numdigits (digits n)\nelse additivePersistence sumList n"}
{"fix": "let rec additivePersistence n = \nif sumList (digits n) < 10\nthen numdigits (digits n)\nelse additivePersistence (sumList (digits n))", "bad": "let rec additivePersistence n = \nif sumList (digits n) < 10\nthen numdigits (digits n)\nelse additivePersistence (sumList n)", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif sumList (digits n) < 10\nthen numdigits (digits n)\nelse additivePersistence (sumList n)"}
{"fix": "let _ = digitsOfInt (-3124)", "bad": "let _ = digitsOfInt -3124", "annotated": "let _ = digitsOfInt -3124"}
{"fix": "let _ = digitsOfInt (-3124)", "bad": "let _ = digitsOfInt -3124", "annotated": "let _ = digitsOfInt -3124"}
{"fix": "let rec wwhile (f,b) =\nlet (b',c') = f b in\nif c'\nthen wwhile (f, b')\nelse\nb'", "bad": "let rec wwhile (f,b) =\nlet (b',c') = f b in\nif c'\nthen f b'\nelse\nb'", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> \nlet (b',c') = f b in\nif c'\nthen f b'\nelse\nb'"}
{"fix": "let fixpoint (f,b) = wwhile ((fun x -> if (x=b) then (b,false) else (f x,true)),b)", "bad": "let fixpoint (f,b) = wwhile (fun x -> if(f x)=x then (b,false) else (f x,true),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun x -> if(f x) -> x then (b,false) else (f x,true),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((fun x -> if (x=b) then (b,false) else (f x,true)),b)", "bad": "let fixpoint (f,b) = wwhile (fun x -> if (x=b) then (b,false) else (f x,true),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun x -> if (x -> b) then (b,false) else (f x,true),b)"}
{"fix": "let rec exprToString e = match e with \nVarX -> 1\n| VarY-> 1\n| Sine x -> 1\n| Cosine  x -> 1\n| Average (x,y) -> 1\n| Times  (x,y)  -> 1\n| Thresh  (x,y,z,w) -> 1", "bad": "let rec exprToString e = match e with \nVarX -> printf \"A\"\n| VarY-> printf \"A\"\n| Sine x -> printf \"A\"\n| Cosine  x -> printf \"A\"\n| Average x y -> printf \"A\"\n| Times  x y  -> printf \"A\"\n| Thresh  x y z w -> printf \"A\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with \nVarX -> printf \"A\"\n| VarY-> printf \"A\"\n| Sine x -> printf \"A\"\n| Cosine  x -> printf \"A\"\n| Average x y -> printf \"A\"\n| Times  x y  -> printf \"A\"\n| Thresh  x y z w -> printf \"A\""}
{"fix": "let rec exprToString e = match e with \nVarX -> 1\n| VarY-> 1\n| Sine x -> 1\n| Cosine  x -> 1\n| Average (x,y) -> 1\n| Times  (x,y)  -> 1\n| Thresh  (x,y,z,w) -> 1", "bad": "let rec exprToString e = match e with \nVarX -> printf \"A\"\n| VarY-> printf \"A\"\n| Sine x -> printf \"A\"\n| Cosine  x -> printf \"A\"\n| Average (x,y) -> printf \"A\"\n| Times  (x,y)  -> printf \"A\"\n| Thresh  (x,y,z,w) -> printf \"A\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with \nVarX -> printf \"A\"\n| VarY-> printf \"A\"\n| Sine x -> printf \"A\"\n| Cosine  x -> printf \"A\"\n| Average (x,y) -> printf \"A\"\n| Times  (x,y)  -> printf \"A\"\n| Thresh  (x,y,z,w) -> printf \"A\""}
{"fix": "let rec exprToString e = match e with \nVarX -> 1\n| VarY-> 1\n| Sine x -> 1\n| Cosine  x -> 1\n| Average (x,y) -> 1\n| Times  (x,y)  -> 1\n| Thresh  (x,y,z,w) -> 1", "bad": "let rec exprToString e = match e with \nVarX -> Printf.printf \"A\"\n| VarY-> printf \"A\"\n| Sine x -> printf \"A\"\n| Cosine  x -> printf \"A\"\n| Average (x,y) -> printf \"A\"\n| Times  (x,y)  -> printf \"A\"\n| Thresh  (x,y,z,w) -> printf \"A\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with \nVarX -> Printf.printf \"A\"\n| VarY-> printf \"A\"\n| Sine x -> printf \"A\"\n| Cosine  x -> printf \"A\"\n| Average (x,y) -> printf \"A\"\n| Times  (x,y)  -> printf \"A\"\n| Thresh  (x,y,z,w) -> printf \"A\""}
{"fix": "let rec exprToString e = match e with \nVarX -> Printf.sprintf \"x\"\n| VarY-> Printf.sprintf \"y\"\n| Sine x ->Printf.sprintf \"\"\n| Cosine  x -> Printf.sprintf \"\"\n| Average (x,y) -> Printf.sprintf \"\"\n| Times  (x,y)  -> Printf.sprintf \"\"\n| Thresh  (x,y,z,w) -> Printf.sprintf \"%s<%s?%s:\" (exprToString x) (exprToString y) (exprToString z)", "bad": "let rec exprToString e = match e with \nlet sprintf=Printf.sprintf in\nVarX -> sprintf(\"x\")\n| VarY-> sprintf(\"x\")\n| Sine x ->3\n| Cosine  x -> 4\n| Average (x,y) -> 5\n| Times  (x,y)  -> 6\n| Thresh  (x,y,z,w) -> sprintf(\"%s<%s?%s:\") x,y,z", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with \nlet sprintf=Printf.sprintf in\nVarX -> sprintf(\"x\")\n| VarY-> sprintf(\"x\")\n| Sine x ->3\n| Cosine  x -> 4\n| Average (x,y) -> 5\n| Times  (x,y)  -> 6\n| Thresh  (x,y,z,w) -> sprintf(\"%s<%s?%s:\") x,y,z"}
{"fix": "let rec exprToString e = match e with \nVarX -> Printf.sprintf \"x\"\n| VarY-> Printf.sprintf \"y\"\n| Sine x ->Printf.sprintf \"\"\n| Cosine  x -> Printf.sprintf \"\"\n| Average (x,y) -> Printf.sprintf \"\"\n| Times  (x,y)  -> Printf.sprintf \"\"\n| Thresh  (x,y,z,w) -> Printf.sprintf \"%s<%s?%s:\" (exprToString x) (exprToString y) (exprToString z)", "bad": "let rec exprToString e = match e with \nVarX -> Printf.sprintf(\"x\")\n| VarY-> sprintf(\"x\")\n| Sine x ->3\n| Cosine  x -> 4\n| Average (x,y) -> 5\n| Times  (x,y)  -> 6\n| Thresh  (x,y,z,w) -> sprintf(\"%s<%s?%s:\") x,y,z", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with \nVarX -> Printf.sprintf(\"x\")\n| VarY-> sprintf(\"x\")\n| Sine x ->3\n| Cosine  x -> 4\n| Average (x,y) -> 5\n| Times  (x,y)  -> 6\n| Thresh  (x,y,z,w) -> sprintf(\"%s<%s?%s:\") x,y,z"}
{"fix": "let rec exprToString e = match e with \nVarX -> Printf.sprintf \"x\"\n| VarY-> Printf.sprintf \"y\"\n| Sine x ->Printf.sprintf \"\"\n| Cosine  x -> Printf.sprintf \"\"\n| Average (x,y) -> Printf.sprintf \"\"\n| Times  (x,y)  -> Printf.sprintf \"\"\n| Thresh  (x,y,z,w) -> Printf.sprintf \"%s<%s?%s:\" (exprToString x) (exprToString y) (exprToString z)", "bad": "let rec exprToString e = match e with \nVarX -> Printf.sprintf(\"x\")\n| VarY-> Printf.sprintf(\"x\")\n| Sine x ->Printf.sprintf (\"\")\n| Cosine  x -> Printf.sprintf (\"\")\n| Average (x,y) -> Printf.sprintf (\"\")\n| Times  (x,y)  -> Printf.sprintf (\"\")\n| Thresh  (x,y,z,w) -> Printf.sprintf(\"%s<%s?%s:\") x,y,z", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with \nVarX -> Printf.sprintf(\"x\")\n| VarY-> Printf.sprintf(\"x\")\n| Sine x ->Printf.sprintf (\"\")\n| Cosine  x -> Printf.sprintf (\"\")\n| Average (x,y) -> Printf.sprintf (\"\")\n| Times  (x,y)  -> Printf.sprintf (\"\")\n| Thresh  (x,y,z,w) -> Printf.sprintf(\"%s<%s?%s:\") x,y,z"}
{"fix": "let rec exprToString e = match e with \nVarX -> Printf.sprintf \"x\"\n| VarY-> Printf.sprintf \"y\"\n| Sine x ->Printf.sprintf \"\"\n| Cosine  x -> Printf.sprintf \"\"\n| Average (x,y) -> Printf.sprintf \"\"\n| Times  (x,y)  -> Printf.sprintf \"\"\n| Thresh  (x,y,z,w) -> Printf.sprintf \"%s<%s?%s:\" (exprToString x) (exprToString y) (exprToString z)", "bad": "let rec exprToString e = match e with \nVarX -> Printf.sprintf \"x\"\n| VarY-> Printf.sprintf \"x\"\n| Sine x ->Printf.sprintf \"\"\n| Cosine  x -> Printf.sprintf \"\"\n| Average (x,y) -> Printf.sprintf \"\"\n| Times  (x,y)  -> Printf.sprintf \"\"\n| Thresh  (x,y,z,w) -> Printf.sprintf \"%s<%s?%s:\" x,y,z", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with \nVarX -> Printf.sprintf \"x\"\n| VarY-> Printf.sprintf \"x\"\n| Sine x ->Printf.sprintf \"\"\n| Cosine  x -> Printf.sprintf \"\"\n| Average (x,y) -> Printf.sprintf \"\"\n| Times  (x,y)  -> Printf.sprintf \"\"\n| Thresh  (x,y,z,w) -> Printf.sprintf \"%s<%s?%s:\" x,y,z"}
{"fix": "let rec exprToString e = match e with \nVarX -> Printf.sprintf \"x\"\n| VarY-> Printf.sprintf \"y\"\n| Sine x ->Printf.sprintf \"\"\n| Cosine  x -> Printf.sprintf \"\"\n| Average (x,y) -> Printf.sprintf \"\"\n| Times  (x,y)  -> Printf.sprintf \"\"\n| Thresh  (x,y,z,w) -> Printf.sprintf \"%s<%s?%s:\" (exprToString x) (exprToString y) (exprToString z)", "bad": "let rec exprToString e = match e with \nVarX -> Printf.sprintf \"x\"\n| VarY-> Printf.sprintf \"x\"\n| Sine x ->Printf.sprintf \"\"\n| Cosine  x -> Printf.sprintf \"\"\n| Average (x,y) -> Printf.sprintf \"\"\n| Times  (x,y)  -> Printf.sprintf \"\"\n| Thresh  (x,y,z,w) -> Printf.sprintf \"%s<%s?%s:\" x y z", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with \nVarX -> Printf.sprintf \"x\"\n| VarY-> Printf.sprintf \"x\"\n| Sine x ->Printf.sprintf \"\"\n| Cosine  x -> Printf.sprintf \"\"\n| Average (x,y) -> Printf.sprintf \"\"\n| Times  (x,y)  -> Printf.sprintf \"\"\n| Thresh  (x,y,z,w) -> Printf.sprintf \"%s<%s?%s:\" x y z"}
{"fix": "let rec exprToString e = match e with \nVarX -> Printf.sprintf \"x\"\n| VarY-> Printf.sprintf \"y\"\n| Sine x ->Printf.sprintf \"\"\n| Cosine  x -> Printf.sprintf \"\"\n| Average (x,y) -> Printf.sprintf \"\"\n| Times  (x,y)  -> Printf.sprintf \"\"\n| Thresh  (x,y,z,w) -> Printf.sprintf \"%s<%s?%s:\" (exprToString x) (exprToString y) (exprToString z)", "bad": "let rec exprToString e = match e with \nVarX -> Printf.sprintf \"x\"\n| VarY-> Printf.sprintf \"y\"\n| Sine x ->Printf.sprintf \"\"\n| Cosine  x -> Printf.sprintf \"\"\n| Average (x,y) -> Printf.sprintf \"\"\n| Times  (x,y)  -> Printf.sprintf \"\"\n| Thresh  (x,y,z,w) -> Printf.sprintf \"%s<%s?%s:\" exprToString x exprToString y exprToStringz", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with \nVarX -> Printf.sprintf \"x\"\n| VarY-> Printf.sprintf \"y\"\n| Sine x ->Printf.sprintf \"\"\n| Cosine  x -> Printf.sprintf \"\"\n| Average (x,y) -> Printf.sprintf \"\"\n| Times  (x,y)  -> Printf.sprintf \"\"\n| Thresh  (x,y,z,w) -> Printf.sprintf \"%s<%s?%s:\" exprToString x exprToString y exprToStringz"}
{"fix": "eval(Sine(VarX),0.,0.)", "bad": "eval(Sine(0))", "annotated": "eval(Sine(0))"}
{"fix": "eval(Sine(VarX),0.,0.)", "bad": "eval(Sine(VarX),0,0)", "annotated": "eval(Sine(VarX),0,0)"}
{"fix": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y))\n| Cosine a -> x\n| Average (a,b) -> x\n| Times (a,b) -> x\n| Thresh (a,b,c,d) -> x", "bad": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(pi*eval(a,x,y))\n| Cosine a -> x\n| Average (a,b) -> x\n| Times (a,b) -> x\n| Thresh (a,b,c,d) -> x", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(pi*eval(a,x,y))\n| Cosine a -> x\n| Average (a,b) -> x\n| Times (a,b) -> x\n| Thresh (a,b,c,d) -> x"}
{"fix": "let pi = 4.0 *. atan 1.0", "bad": "eval(a,x,y)*2.", "annotated": "eval(a,x,y)*2."}
{"fix": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y)*.pi)\n| Cosine a -> cos(eval(a,x,y)*.pi)\n| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y) /. 2.)\n| Times (a,b) -> x\n| Thresh (a,b,c,d) -> x", "bad": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y)*.pi)\n| Cosine a -> cos(eval(a,x,y)*.pi)\n| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y) /. 2)\n| Times (a,b) -> x\n| Thresh (a,b,c,d) -> x", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y)*.pi)\n| Cosine a -> cos(eval(a,x,y)*.pi)\n| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y) /. 2)\n| Times (a,b) -> x\n| Thresh (a,b,c,d) -> x"}
{"fix": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> x", "bad": "let _ = eval (sampleExpr,0.5,0.2)", "annotated": "let _ = eval (sampleExpr,0.5,0.2)"}
{"fix": "let _ = eval (sampleExpr1,0.5,0.2)", "bad": "let _ = eval (sampleExpr,0.5,0.2)", "annotated": "let _ = eval (sampleExpr,0.5,0.2)"}
{"fix": "let g1 () = failwith \"to be implemented\"", "bad": "build(rand,1)", "annotated": "build(rand,1)"}
{"fix": "let rec build (rand, depth) =", "bad": "let rec build (rand, depth) =", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> "}
{"fix": "let rec build (rand, depth) = \nif depth<2\nthen let x=rand(0,2) in\nmatch x with\n|0 -> buildX()\n|1 -> buildY()\nelse\nlet x=rand(0,5) in\nmatch x with\n|0 -> buildSine(build(rand,depth))\n|1 -> buildCosine(build(rand,depth))", "bad": "let rec build (rand, depth) = \nif depth<2\nthen let x=rand(0,2) in\nmatch x with\n|0 -> buildX()\n|1 -> buildY()\nelse\nlet x=rand(0,5) in\nmatch x with\n|0 -> buildSin(build(rand,depth))\n|1 -> buildCosin(build(rand,depth))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth<2\nthen let x=rand(0,2) in\nmatch x with\n|0 -> buildX()\n|1 -> buildY()\nelse\nlet x=rand(0,5) in\nmatch x with\n|0 -> buildSin(build(rand,depth))\n|1 -> buildCosin(build(rand,depth))"}
{"fix": "let g1 () = doRandomGray(2,1,1)", "bad": "build(rand,1)", "annotated": "build(rand,1)"}
{"fix": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))\n| Clamp (a,b,c) -> if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)", "bad": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (.9*eval(a,x,y)) else (.1*eval(a,x,y))\n| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (.9*eval(a,x,y)) else (.1*eval(a,x,y))\n| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)"}
{"fix": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))\n| Clamp (a,b,c) -> if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)", "bad": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (.9*.eval(a,x,y)) else (.1*.eval(a,x,y)\n| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (.9*.eval(a,x,y)) else (.1*.eval(a,x,y)\n| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)"}
{"fix": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))\n| Clamp (a,b,c) -> if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)", "bad": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y)\n| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y)\n| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)"}
{"fix": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))\n| Clamp (a,b,c) -> if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)", "bad": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))\n| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))\n| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)"}
{"fix": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))\n| Clamp (a,b,c) -> if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)", "bad": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))\n| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y)  eval(a,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))\n| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y)  eval(a,x,y)"}
{"fix": "let sqsum xs = \nlet f a x = x*x\nin\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = sqsum [1;2;3;4]", "annotated": "let _ = sqsum [1;2;3;4]"}
{"fix": "let sqsum xs = \nlet f a x = x*x\nin\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = sqsum [(-1); (-2); (-3); (-4)]", "annotated": "let _ = sqsum [(-1); (-2); (-3); (-4)]"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = x(a) in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = x(a) in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x(a) in\nlet base = f 0 in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = f 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x(a) in\nlet base = a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x(a) in\nlet base = a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun a -> 0 in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun a->a in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fun a' in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun a' in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun a->a in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fun a'->_ in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun a'->_ in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun a->a in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fun 'a->'a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun 'a->'a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = 'a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = 'a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = a in\nlet base = fun a -> a in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = fun a -> a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = fun a -> a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun z -> a (x z) in\nlet base = fun a-> f a in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = fun a-> f a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = fun a-> f a in\nList.fold_left f base fs"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base =  sepConcat sep t in\nlet l =  h in\nList.fold_left f base l", "bad": "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "annotated": "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base =  sepConcat sep t in\nlet l =  h in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base =  sepConcat sep t in\nlet l =  f in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base =  sepConcat sep t in\nlet l =  f in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \"\" in\nlet base =  sepConcat sep t in\nlet l =  h in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base =  sepConcat sep t in\nlet l =  \"\" in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base =  sepConcat sep t in\nlet l =  \"\" in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^a in\nlet base =  sepConcat sep t in\nlet l =  t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \"\" in\nlet base =  sepConcat sep t in\nlet l =  \"\" in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \"\" in\nlet base =  sepConcat sep t in\nlet l =  \"\" in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^a in\nlet base =  sepConcat sep t in\nlet l =  t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \"\" in\nlet base =  sepConcat sep {} in\nlet l =  \"\" in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \"\" in\nlet base =  sepConcat sep {} in\nlet l =  \"\" in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^a in\nlet base =  sepConcat sep t in\nlet l =  t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \"\" in\nlet base =  sepConcat sep [] in\nlet l =  \"\" in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \"\" in\nlet base =  sepConcat sep [] in\nlet l =  \"\" in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^a in\nlet base =  sepConcat sep t in\nlet l =  t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \"\" in\nlet base =  \"\" in\nlet l =  \"\" in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \"\" in\nlet base =  \"\" in\nlet l =  \"\" in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  if t=[] then \"A\" else h in\nlet l =  sl in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  if t=[] then \"A\" else t in\nlet l =  sl in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base =  if t=[] then \"A\" else t in\nlet l =  sl in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x in\nlet base =  if t=[] then sep else h in\nlet l =  sl in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x in\nlet base =  if t=\"\" then sep else h in\nlet l =  sl in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x in\nlet base =  if t=\"\" then sep else h in\nlet l =  sl in\nList.fold_left f base l"}
{"fix": "let _ = sepConcat \"X\" [\"hello\"]", "bad": "let _ = sepConcat \"X\" [\"hello\"]\n\nfun x -> x", "annotated": "let _ = sepConcat \"X\" [\"hello\"]\n\nfun x -> x"}
{"fix": "let _ = sepConcat \"X\" [\"hello\"]", "bad": "let stringOfList f l = failwith List.map (fun x-> \"\") l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  failwith List.map (fun x-> \"\") l"}
{"fix": "let _ = sepConcat \"X\" [\"hello\"]", "bad": "let _ = sepConcat \"X\" [\"hello\"]\n\nfun x -> x", "annotated": "let _ = sepConcat \"X\" [\"hello\"]\n\nfun x -> x"}
{"fix": "let _ = sepConcat \"X\" [\"hello\"]", "bad": "let stringOfList f l = failwith List.map (fun x-> \"\") l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  failwith List.map (fun x-> \"\") l"}
{"fix": "let asd_ x = x", "bad": "let stringOfList f l = failwith List.map (fun x-> x) (l)", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  failwith List.map (fun x-> x) (l)"}
{"fix": "let stringOfList f l = List.map (sepConcat \"\") l", "bad": "let stringOfList f l = List.map asd l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map asd l"}
{"fix": "let stringOfList f l = List.map (sepConcat \" \") l", "bad": "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "annotated": "let _ = stringOfList string_of_int [1;2;3;4;5;6]"}
{"fix": "let stringOfList f l = List.map (sepConcat \"\") l", "bad": "let stringOfList f l = List.map (sepConcat \" \") l.string", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map (sepConcat \" \") l.string"}
{"fix": "let stringOfList f l = List.map (fun x->x) l", "bad": "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "annotated": "let _ = stringOfList string_of_int [1;2;3;4;5;6]"}
{"fix": "let stringOfList f l = List.map (fun x-> Printf.sprintf \"%d\" x) l", "bad": "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "annotated": "let _ = stringOfList string_of_int [1;2;3;4;5;6]"}
{"fix": "let stringOfList f l = List.map (sepConcat f) l", "bad": "let _ = stringOfList (fun x -> x) [\"foo\"]", "annotated": "let _ = stringOfList (fun x -> x) [\"foo\"]"}
{"fix": "let stringOfList f l = List.map (f) l", "bad": "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "annotated": "let _ = stringOfList string_of_int [1;2;3;4;5;6]"}
{"fix": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let rec clone x n =\nlet acc = [] in\nif x=0\nthen acc\nelse acc::clone x n-1", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  -> \nlet acc = [] in\nif x=0\nthen acc\nelse acc::clone x n-1"}
{"fix": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let rec clone x n =\nlet acc = [] in\nif n=0\nthen acc\nelse clone x::acc n-1", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  -> \nlet acc = [] in\nif n=0\nthen acc\nelse clone x::acc n-1"}
{"fix": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let rec clone x n =\nlet acc = [] in\nif n=0\nthen acc\nelse clone x::acc n-1", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  -> \nlet acc = [] in\nif n=0\nthen acc\nelse clone x::acc n-1"}
{"fix": "let rec clone x n =\nlet accum=[] in\nif n<1\nthen []\nelse clone x n", "bad": "let rec clone x n =\nlet accum=[] in\nif n<1\nthen []\nelse clone x n-1", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  -> \nlet accum=[] in\nif n<1\nthen []\nelse clone x n-1"}
{"fix": "let rec clone x n =\nlet accum=[] in\nif n<1\nthen []\nelse clone x n", "bad": "let rec clone x n =\nlet accum=[] in\nif n<1\nthen []\nelse clone x ne", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  -> \nlet accum=[] in\nif n<1\nthen []\nelse clone x ne"}
{"fix": "let rec clone x n =\nlet accum=[] in\nif n<1\nthen []\nelse clone x (n-1)", "bad": "let rec clone x n =\nlet accum=[] in\nif n<1\nthen []\nelse clone x n-1", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  -> \nlet accum=[] in\nif n<1\nthen []\nelse clone x n-1"}
{"fix": "let _ = clone 3 5", "bad": "let _ = clone 3 -1", "annotated": "let _ = clone 3 -1"}
{"fix": "let padZero l1 l2 = ((clone (clone 0 1)::l1 2),l2)", "bad": "let _ = padZero [9;9] [1;0;0;2]", "annotated": "let _ = padZero [9;9] [1;0;0;2]"}
{"fix": "let padZero l1 l2 = ((clone 0::l1 2),l2)", "bad": "let _ = padZero [9;9] [1;0;0;2]", "annotated": "let _ = padZero [9;9] [1;0;0;2]"}
{"fix": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = padZero [9;9] [1;0;0;2]", "annotated": "let _ = padZero [9;9] [1;0;0;2]"}
{"fix": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen List.append (clone 0 (b-a)) l1\nelse []", "bad": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nList.append (clone 0 (b-a)) l1", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\nif(a<b)\nList.append (clone 0 (b-a)) l1"}
{"fix": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen List.append (clone 0 (b-a)) l1\nelse []", "bad": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nList.append (clone 0 (b-a)) l1", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\nif(a<b)\nList.append (clone 0 (b-a)) l1"}
{"fix": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen List.append (clone 0 (b-a)) l1\nelse []", "bad": "let _ = padZero [9;9] [1;0;0;2]", "annotated": "let _ = padZero [9;9] [1;0;0;2]"}
{"fix": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen List.append (clone 0 (b-a)) l1\nelse []", "bad": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nList.append l2 l1", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\nif(a<b)\nList.append l2 l1"}
{"fix": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen List.append (clone 0 (b-a)) l1\nelse []", "bad": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nList.append (clone 0 (b-a)) l1\nelse []", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\nif(a<b)\nList.append (clone 0 (b-a)) l1\nelse []"}
{"fix": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\na", "bad": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen (List.append (clone 0 (b-a)) l1)\nelse if(b<a)\nthen (List.append (clone 0 (a-b)) l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\nif(a<b)\nthen (List.append (clone 0 (b-a)) l1)\nelse if(b<a)\nthen (List.append (clone 0 (a-b)) l2)"}
{"fix": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\na", "bad": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen (List.append (clone 0 (b-a)) l1)\nelse if(b<a)\nthen (List.append (clone 0 (a-b)) l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\nif(a<b)\nthen (List.append (clone 0 (b-a)) l1)\nelse if(b<a)\nthen (List.append (clone 0 (a-b)) l2)"}
{"fix": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\na", "bad": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen (List.append (clone 0 (b-a)) l1)\nelse if(b<a)\nthen List.append (clone 0 (a-b)) l2", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\nif(a<b)\nthen (List.append (clone 0 (b-a)) l1)\nelse if(b<a)\nthen List.append (clone 0 (a-b)) l2"}
{"fix": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\na", "bad": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen (List.append (clone 0 (b-a)) l1)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\nif(a<b)\nthen (List.append (clone 0 (b-a)) l1)"}
{"fix": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\na", "bad": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen List.append (clone 0 (b-a)) l1", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\nif(a<b)\nthen List.append (clone 0 (b-a)) l1"}
{"fix": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\na", "bad": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen List.append (clone 0 b-a) l1", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\nif(a<b)\nthen List.append (clone 0 b-a) l1"}
{"fix": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\na", "bad": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen List.append (clone 0 1) l1", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\nif(a<b)\nthen List.append (clone 0 1) l1"}
{"fix": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\na", "bad": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(1)\nthen List.append (clone 0 1) l1", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\nif(1)\nthen List.append (clone 0 1) l1"}
{"fix": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\na", "bad": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(true)\nthen List.append (clone 0 1) l1", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\nif(true)\nthen List.append (clone 0 1) l1"}
{"fix": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\na", "bad": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(true)\nthen List.append l1 l1", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\nif(true)\nthen List.append l1 l1"}
{"fix": "let padZero l1 l2 = List.length l1", "bad": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen a", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\nif(a<b)\nthen a"}
{"fix": "let padZero l1 l2 = List.length l1", "bad": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen 1", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\nif(a<b)\nthen 1"}
{"fix": "let padZero l1 l2 = List.length l1", "bad": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen 1", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\nif(a<b)\nthen 1"}
{"fix": "let padZero l1 l2 = List.length l1", "bad": "let padZero l1 l2 = let (a,b)=(List.length l1,List.length l2) in\nif(a<b)\nthen \"\"", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let (a,b) -> (List.length l1,List.length l2) in\nif(a<b)\nthen \"\""}
{"fix": "let padZero l1 l2 = let a = List.length l1 in\na", "bad": "let padZero l1 l2 = let a = List.length l1", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let a  ->  List.length l1"}
{"fix": "let padZero l1 l2 = let a = List.length l1 in\nlet b= List.length l2 in\nif (1<2)\nthen 1\nelse 2", "bad": "let padZero l1 l2 = let a = List.length l1 in\nlet b= List.length l2 in\nif (a<b)\nthen a", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let a  ->  List.length l1 in\nlet b= List.length l2 in\nif (a<b)\nthen a"}
{"fix": "let padZero l1 l2 = let a = List.length l1 in\nlet b= List.length l2 in\nif (1<2)\nthen 1\nelse 2", "bad": "let padZero l1 l2 = let a = List.length l1 in\nlet b= List.length l2 in\nif (1<2)\nthen 1", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let a  ->  List.length l1 in\nlet b= List.length l2 in\nif (1<2)\nthen 1"}
{"fix": "let padZero l1 l2 = let a = List.length l1 in\nlet b= List.length l2 in\nif (1<2)\nthen 1\nelse 2", "bad": "let padZero l1 l2 = let a = List.length l1 in\nlet b= List.length l2 in\nif (1<2)\nthen clone 0 1", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let a  ->  List.length l1 in\nlet b= List.length l2 in\nif (1<2)\nthen clone 0 1"}
{"fix": "let stringOfList f l = sepConcat \",\" (List.map (f) l)", "bad": "let stringOfList f l = sepConcat(\" \" (List.map (f) l))", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat(\" \" (List.map (f) l))"}
{"fix": "let stringOfList f l = (sepConcat \";\" (List.map (f) l))", "bad": "let stringOfList f l = \"[\"::(sepConcat \";\" (List.map (f) l))", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\"::(sepConcat \";\" (List.map (f) l))"}
{"fix": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let stringOfList f l = (sepConcat \";\" (List.map (f) l)).\"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  (sepConcat \";\" (List.map (f) l)).\"]\""}
{"fix": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x+1::a in\nlet base = [] in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  x+1::a in\nlet base = [] in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = x*x+a in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x+1::a in\nlet base = [] in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  x+1::a in\nlet base = [] in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a  in\nlet base = ([],[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a  in\nlet base = [] in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  a  in\nlet base = [] in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\na=(t,(h+x))::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\na=(t,(h+x))::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\na=(_,(h+x))\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\na=(_,(h+x))\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\na=(l1,(h+x))\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\na=(l1,(h+x))\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\nx+h\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\nx+h\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n(x+h,_)\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n(x+h,_)\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n(x+h,[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n(x+h,[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n(0,0)::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n(0,0)::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n0::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n0::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n[0;0]::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n[0;0]::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n[[0];[0]]::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n[[0];[0]]::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],[])::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],[])::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],0)::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],0)::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n[([],0)]::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n[([],0)]::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n[],0::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n[],0::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n[]::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n[]::a\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\na=(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\na=(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\na=(t,b)\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\na=(t,b)\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\na=([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\na=([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\n([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\na=([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,_) =a  in\na=([],[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\na=(l1,[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\na=(l1,[])\nin\nlet base = (List.rev l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\nlet (_,asd4)=padZero asd3 (asd2::b) in\n(asd3,asd4)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h::t in\n(asd,padZero(asd,x+h::b))\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h::t in\n(asd,padZero(asd,x+h::b))\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\nlet (_,asd4)=padZero asd3 (asd2::b) in\n(asd3,asd4)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h::t in\n(asd,padZero(asd,(x+h::b)))\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h::t in\n(asd,padZero(asd,(x+h::b)))\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\nlet (_,asd4)=padZero asd3 (asd2::b) in\n(asd3,asd4)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\n(asd3,padZero(asd3,asd2))\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\n(asd3,padZero(asd3,asd2))\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\nlet (_,asd4)=padZero asd3 (asd2::b) in\n(asd3,asd4)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\n(asd3,padZero(asd3 asd2))\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\n(asd3,padZero(asd3 asd2))\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\nlet (_,asd4)=padZero asd3 (asd2::b) in\n(asd3,asd4)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\n(asd3,padZero asd3 asd2)\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\n(asd3,padZero asd3 asd2)\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\nlet (_,asd4)=padZero asd3 (asd2::b) in\n(asd3,asd4)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\n(asd3,padZero asd3 asd2::b)\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\n(asd3,padZero asd3 asd2::b)\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\nlet (_,asd4)=padZero asd3 (asd2::b) in\n(asd3,asd4)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\n(asd3,padZero asd3 (asd2::b))\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\n(asd3,padZero asd3 (asd2::b))\nelse\n(t,x+h::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\nlet (_,asd4)=padZero asd3 (asd2::b) in\n(asd3,asd4)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\n(asd3,padZero asd3 (asd2::b))\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x/h) > 0)\nthen\nlet asd= x/h in\nlet asd2=x+h-(asd*10) in\nlet asd3=asd::t in\n(asd3,padZero asd3 (asd2::b))\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[] & (x+h)>9)\nthen\nlet asd2=x+h-10 in\nlet asd3=asd2::b in\n([],1::asd3)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[])\nthen\nlet asd2=x+h-10 in\nlet asd3=t in\nlet asd3=h2+1::t2 in\n(_,asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[])\nthen\nlet asd2=x+h-10 in\nlet asd3=t in\nlet asd3=h2+1::t2 in\n(_,asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[] & (x+h)>9)\nthen\nlet asd2=x+h-10 in\nlet asd3=asd2::b in\n([],1::asd3)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[])\nthen\nlet asd2=x+h-10 in\nlet asd3=t in\nlet asd3=h2+1::t2 in\n([],asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nlet asd2=x+h-10 in\nlet h2::t2=t in\nlet asd3=h2+1::t2 in\n(asd3,asd2::b)\nelse if(t=[])\nthen\nlet asd2=x+h-10 in\nlet asd3=t in\nlet asd3=h2+1::t2 in\n([],asd2::b)\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nif(t=[])\nthen\n([],1::(x+h-10)::b)\nelse\nlet h2::t2=t in\n((h2+1::t2),(x+h-10)::b)\n\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nif((t=[])\nthen\n([],1::(x+h-10)::b)\nelse\nlet h2::t2=t in\n((h2+1::t2),(x+h-10)::b)\n\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  \nlet (h::t,b) =a  in\nif((x+h) > 9)\nthen\nif((t=[])\nthen\n([],1::(x+h-10)::b)\nelse\nlet h2::t2=t in\n((h2+1::t2),(x+h-10)::b)\n\nelse\n(t,(x+h)::b)\nin\nlet base = (List.rev l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let rec mulByDigit i l = \nlet accum = [] in\nlet rec helper x l accum= \nif(x != 0)\nthen\nhelper (x-1) l (bigAdd l accum)\nelse accum\nin\nmulByDigit i (helper i l accum)", "bad": "let rec mulByDigit i l = \nlet accum = [] in\nlet rec helper i l accum = \nif(i ~=0)\nthen\nmatch l with\n| h::t -> list.concat (helper i-1 t (bigAdd h h)) accum\nelse accum\nin\nhelper", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet accum = [] in\nlet rec helper i l accum = \nif(i ~=0)\nthen\nmatch l with\n| h::t -> list.concat (helper i-1 t (bigAdd h h)) accum\nelse accum\nin\nhelper"}
{"fix": "let rec mulByDigit i l = \nlet accum = [] in\nlet rec helper x l accum= \nif(x != 0)\nthen\nhelper (x-1) l (bigAdd l accum)\nelse accum\nin\nmulByDigit i (helper i l accum)", "bad": "let rec mulByDigit i l = \nlet accum = [] in\nlet rec helper i l accum = \nif(i != 0)\nthen\nmatch l with\n| h::t -> list.concat (helper i-1 t (bigAdd h h)) accum\nelse accum\nin\nhelper", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet accum = [] in\nlet rec helper i l accum = \nif(i != 0)\nthen\nmatch l with\n| h::t -> list.concat (helper i-1 t (bigAdd h h)) accum\nelse accum\nin\nhelper"}
{"fix": "let rec mulByDigit i l = \nlet accum = [] in\nlet rec helper x l accum= \nif(x != 0)\nthen\nhelper (x-1) l (bigAdd l accum)\nelse accum\nin\nmulByDigit i (helper i l accum)", "bad": "let rec mulByDigit i l = \nlet accum = [] in\nlet rec helper x l accum= \nif(x != 0)\nthen\nhelper x-1 l (bigAdd l accum)\nelse accum\nin\nmulByDigit (helper i l accum)", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet accum = [] in\nlet rec helper x l accum= \nif(x != 0)\nthen\nhelper x-1 l (bigAdd l accum)\nelse accum\nin\nmulByDigit (helper i l accum)"}
{"fix": "let rec mulByDigit i l = \nlet accum = [] in\nlet rec helper x l accum= \nif(x != 0)\nthen\nhelper (x-1) l (bigAdd l accum)\nelse accum\nin\nmulByDigit i (helper i l accum)", "bad": "let rec mulByDigit i l = \nlet accum = [] in\nlet rec helper x l accum= \nif(x != 0)\nthen\nhelper (x-1) l (bigAdd l accum)\nelse accum\nin\nmulByDigit (helper i l accum)", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet accum = [] in\nlet rec helper x l accum= \nif(x != 0)\nthen\nhelper (x-1) l (bigAdd l accum)\nelse accum\nin\nmulByDigit (helper i l accum)"}
{"fix": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(mulByDigit x q,[]) in \nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\nmulByDigit x q in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (q,w) = a in\nmulByDigit x q in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(mulByDigit x q,[]) in \nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(mulByDigit x q)", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (q,w) = a in\n(mulByDigit x q)"}
{"fix": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(mulByDigit x q,[]) in \nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(mulByDigit x q) in \nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (q,w) = a in\n(mulByDigit x q) in \nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(q+1,mulByDigit x l1) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n((+)1,mulByDigit x q) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (q,w) = a in\n((+)1,mulByDigit x q) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(q+1,mulByDigit x l1) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(q+1,mulByDigit x q) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (q,w) = a in\n(q+1,mulByDigit x q) in \nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let rec wwhile (f,b) =   \nlet (b', c') = f b in \nif c' then \nwwhile (f,b') \nelse \nb'", "bad": "let rec wwhile (f,b) =   \nlet (b', c') = f b in \nif c' then \nwwhile (f,b') \nelse \nb'", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->    \nlet (b', c') = f b in \nif c' then \nwwhile (f,b') \nelse \nb'"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = wwhile (let f b =  let fb  = f b in\n(fb,fb=b) ,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let f b =  let fb   ->  f b in\n(fb,fb=b) ,b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = wwhile (let f b in  let fb  = f b in\n(fb,fb=b) ,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let f b in  let fb   ->  f b in\n(fb,fb=b) ,b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = wwhile ((  let fb  = f b in\n(fb,fb=b)) ,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((  let fb   ->  f b in\n(fb,fb=b)) ,b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = wwhile ((  let w b = let fb  = f b in\n(fb,fb=b)) ,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((  let w b = let fb   ->  f b in\n(fb,fb=b)) ,b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = wwhile ((  let w b = let fb  = f b in \n(fb,fb=b) in f b) ,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((  let w b = let fb   ->  f b in \n(fb,fb=b) in f b) ,b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = wwhile ((  let w b' = let fb  = f b' in \n(fb,fb=b') in f b) ,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((  let w b' = let fb   ->  f b' in \n(fb,fb=b') in f b) ,b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = wwhile ((  let w b' = let fb  = f b' in \n(fb,fb=b') in f b') ,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((  let w b' = let fb   ->  f b' in \n(fb,fb=b') in f b') ,b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = wwhile ((  let w b' = let fb  = f b' in \n(fb,fb=b') in f b) ,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((  let w b' = let fb   ->  f b' in \n(fb,fb=b') in f b) ,b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = let w b' = let fb  = f b' in \n(fb,fb=b') in  wwhile ( w ,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let w b' = let fb   ->  f b' in \n(fb,fb=b') in  wwhile ( w ,b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) =  wwhile (let w b' = let fb  = f b' in \n(fb,fb=b') in  w ,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) =  wwhile (let w b' = let fb   ->  f b' in \n(fb,fb=b') in  w ,b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let _ = exprToString build (makeRand,5)", "bad": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand 1 2 in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand 1 5 with\n| 1 -> buildSine(b)\n| 2 -> buildCosine(b)\n| 3 -> buildAverage(b,build(rand,depth-1))\n| 4 -> buildTimes(b,build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0 then\nlet x= rand 1 2 in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand 1 5 with\n| 1 -> buildSine(b)\n| 2 -> buildCosine(b)\n| 3 -> buildAverage(b,build(rand,depth-1))\n| 4 -> buildTimes(b,build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"}
{"fix": "let rec build (rand, depth) = \nif depth = 0 then\nlet x= rand (1,2) in \nif x=1 then\nbuildX()\nelse\nbuildY()\nelse\nlet b = build(rand,depth-1) in \nmatch rand(1,5) with\n| 1 -> buildSine(b)\n| 2 -> buildCosine(b)\n| 3 -> buildAverage(b,build(rand,depth-1))\n| 4 -> buildTimes(b,build(rand,depth-1))\n| _ -> buildThresh(b,build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "bad": "let _ = exprToString (build (makeRand,5))", "annotated": "let _ = exprToString (build (makeRand,5))"}
{"fix": "let _ = let rand=makeRand(10,10) in exprToString (build (rand,5))", "bad": "let _ = let rand=makeRand(10,39) in exprToString (build (rand,5))", "annotated": "let _ = let rand=makeRand(10,39) in exprToString (build (rand,5))"}
{"fix": "let sqsum xs = \nlet f a x = (a*a)+ x  in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a^2::x  in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a^2::x  in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = (a*a)+ x  in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = sqsum []", "annotated": "let _ = sqsum []"}
{"fix": "let sqsum xs = \nlet f a x = (a*a)+ x  in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = sqsum [1;2;3;4]", "annotated": "let _ = sqsum [1;2;3;4]"}
{"fix": "let sqsum xs = \nlet f a x = (a*a)+ x  in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = sqsum [(-1); (-2); (-3); (-4)]", "annotated": "let _ = sqsum [(-1); (-2); (-3); (-4)]"}
{"fix": "let sqsum xs = \nlet f a x = (a*a)+ x  in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = (a^2)::x  in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = (a^2)::x  in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = (a*a)+ x  in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = sqsum []", "annotated": "let _ = sqsum []"}
{"fix": "let sqsum xs = \nlet f a x = (a*a)+ x  in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = sqsum [1;2;3;4]", "annotated": "let _ = sqsum [1;2;3;4]"}
{"fix": "let sqsum xs = \nlet f a x = (a*a)+ x  in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = sqsum [(-1); (-2); (-3); (-4)]", "annotated": "let _ = sqsum [(-1); (-2); (-3); (-4)]"}
{"fix": "let sqsum xs = \nlet f a x = (a*a)+ x  in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = (a^2.)::x  in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = (a^2.)::x  in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = (a*a)+ x  in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = (a*a)::x  in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = (a*a)::x  in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = (a*a)+ x  in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = sqsum []", "annotated": "let _ = sqsum []"}
{"fix": "let sqsum xs = \nlet f a x = (a*a)+ x  in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = sqsum [1;2;3;4]", "annotated": "let _ = sqsum [1;2;3;4]"}
{"fix": "let sqsum xs = \nlet f a x = (a*a)+ x  in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = sqsum [(-1); (-2); (-3); (-4)]", "annotated": "let _ = sqsum [(-1); (-2); (-3); (-4)]"}
{"fix": "let pipe fs n= \nlet f a x = x a  in\nlet base = n in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = x a  in\nlet base = f   in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a  in\nlet base = f a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a  in\nlet base = f a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a  in\nlet base = f   in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a  in\nlet base = f _ in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a  in\nlet base = f _ in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a  in\nlet base = f   in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a  in\nlet base = f fs in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a  in\nlet base = f fs in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a  in\nlet base = f   in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a  in\nlet base = _  in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a  in\nlet base = _  in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x   in\nlet base = f   in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a  in\nlet base = f fs  in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a  in\nlet base = f fs  in\nList.fold_left f base fs"}
{"fix": "let pipe fs  = \nlet f a x = x   in\nlet base = 0   in\nList.fold_left f base fs", "bad": "let pipe fs  = \nlet f a x = x   in\nlet base =   in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs   ->  \nlet f a x = x   in\nlet base =   in\nList.fold_left f base fs"}
{"fix": "let pipe fs  = \nlet f a x = x   in\nlet base = 0   in\nList.fold_left f base fs", "bad": "let pipe fs  = \nlet f a x = x   in\nlet base =   in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs   ->  \nlet f a x = x   in\nlet base =   in\nList.fold_left f base fs"}
{"fix": "let pipe fs  = \nlet f a x = x a  in\nlet base = function y ->y  in\nList.fold_left f base fs", "bad": "let pipe fs  = \nlet f a x = x a  in\nlet base = function y   in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs   ->  \nlet f a x = x a  in\nlet base = function y   in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = function y -> y  in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = function y -> y  in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fun y  in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun y  in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = function y -> y  in\nList.fold_left f base", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = function y -> y  in\nList.fold_left f base", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = function y -> y  in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = function y -> y  in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = function y -> y  in\nList.fold_left f base xs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = function y -> y  in\nList.fold_left f base xs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = function y -> y  in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "bad": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (map f l)) ^ \"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\" ^ (sepConcat \"; \" (map f l)) ^ \"]\""}
{"fix": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "bad": "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "annotated": "let _ = stringOfList string_of_int [1;2;3;4;5;6]"}
{"fix": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "bad": "let _ = stringOfList (fun x -> x) [\"foo\"]", "annotated": "let _ = stringOfList (fun x -> x) [\"foo\"]"}
{"fix": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "bad": "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "annotated": "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"}
{"fix": "let rec clone x n = \nlet rec helper x n acc =\nif n<= 0 then\nacc\nelse\nhelper x (n-1) (x::acc) \nin\nhelper x n []", "bad": "let rec clone x n = \nlet rec helper x n acc \nif n<= 0 then\nacc\nelse\nhelper x (n-1) (x::acc) \nin\nhelper x n []", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nlet rec helper x n acc \nif n<= 0 then\nacc\nelse\nhelper x (n-1) (x::acc) \nin\nhelper x n []"}
{"fix": "let padZero l1 l2 = \nlet len1=List.length l1 in \nlet len2=List.length l2 in\nif len1>len2 then\nl1\nelse\nl2", "bad": "let padZero l1 l2 = \nlet len1=List.length l1 in \nlet len2=List.length l2 in\nif len1>len2 then\n((clone 0 (len1-len2)) @ len2),len1", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet len1=List.length l1 in \nlet len2=List.length l2 in\nif len1>len2 then\n((clone 0 (len1-len2)) @ len2),len1"}
{"fix": "let padZero l1 l2 = \nlet len1=List.length l1 in \nlet len2=List.length l2 in\nif len1>len2 then\nl1\nelse\nl2", "bad": ")\nelse\n((clone 0 (len2-len1)) @ len1),len2", "annotated": ")\nelse\n((clone 0 (len2-len1)) @ len1),len2"}
{"fix": "let padZero l1 l2 = \nlet len1=List.length l1 in \nlet len2=List.length l2 in\nif len1>len2 then\nl1\nelse\nl2", "bad": ")", "annotated": ")"}
{"fix": "let padZero l1 l2 = \nlet len1=List.length l1 in \nlet len2=List.length l2 in\nif len1>len2 then\nl1\nelse\nl2", "bad": "let _ = padZero [9;9] [1;0;0;2]", "annotated": "let _ = padZero [9;9] [1;0;0;2]"}
{"fix": "let padZero l1 l2 = \nlet len1=List.length l1 in \nlet len2=List.length l2 in\nif len1>len2 then\nl1\nelse\nl2", "bad": "let _ = padZero [1;0;0;2] [9;9]", "annotated": "let _ = padZero [1;0;0;2] [9;9]"}
{"fix": "let padZero l1 l2 = \nlet len1=List.length l1 in \nlet len2=List.length l2 in\nif len1>len2 then\n(clone 0 (len1-len2)) \nelse\n(clone 0 (len2-len1))", "bad": "let padZero l1 l2 = \nlet len1=List.length l1 in \nlet len2=List.length l2 in\nif len1>len2 then\n(clone 0 (len1-len2)) \nelse\n((clone 0 (len2-len1)) @ l1),l2", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet len1=List.length l1 in \nlet len2=List.length l2 in\nif len1>len2 then\n(clone 0 (len1-len2)) \nelse\n((clone 0 (len2-len1)) @ l1),l2"}
{"fix": "let padZero l1 l2 = \nlet len1=List.length l1 in \nlet len2=List.length l2 in\nif len1>len2 then\n(clone 0 (len1-len2)) \nelse\n(clone 0 (len2-len1))", "bad": ")", "annotated": ")"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet (v,l)=x in\nlet (ac,la)=a in\nlet mul= mulByDigit v l in\nlet shift= mulByDigit ac mul in \n(ac*10,bigAdd shift la)\nin\nlet base = (1,[]) in\nlet args = List.map (fun x -> (x,(List.rev l2))) l1 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet (v,l)=x in\nlet (ac,la)=a in\nlet mul= mulByDigit v l in\nlet shift= mulByDigit ac a in \n(ac*10,bigAdd mul shift)\nin\nlet base = (1,[]) in\nlet args = List.map (fun x -> (x,l2)) l1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet (v,l)=x in\nlet (ac,la)=a in\nlet mul= mulByDigit v l in\nlet shift= mulByDigit ac a in \n(ac*10,bigAdd mul shift)\nin\nlet base = (1,[]) in\nlet args = List.map (fun x -> (x,l2)) l1 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet (v,l)=x in\nlet (ac,la)=a in\nlet mul= mulByDigit v l in\nlet shift= mulByDigit ac mul in \n(ac*10,bigAdd shift la)\nin\nlet base = (1,[]) in\nlet args = List.map (fun x -> (x,(List.rev l2))) l1 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet (v,l)=x in\nlet (ac,la)=a in\nlet mul= mulByDigit v l in\nlet shift= mulByDigit mul ac in \n(ac*10,bigAdd shift la)\nin\nlet base = (1,[]) in\nlet args = List.map (fun x -> (x,(List.rev l2))) l1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet (v,l)=x in\nlet (ac,la)=a in\nlet mul= mulByDigit v l in\nlet shift= mulByDigit mul ac in \n(ac*10,bigAdd shift la)\nin\nlet base = (1,[]) in\nlet args = List.map (fun x -> (x,(List.rev l2))) l1 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let pipe fs = \nlet f a x = x(a) in\nlet base = function y ->y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x(a) in\nlet base = function  in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x(a) in\nlet base = function  in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x(a) in\nlet base = function y ->y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x(a) in\nlet base = function x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x(a) in\nlet base = function x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =  x(a) in\nlet base = function y ->y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = function x(a) in\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = function x(a) in\nlet base = 0 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =  x(a) in\nlet base = function y ->y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = function _ ->x(a) in\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = function _ ->x(a) in\nlet base = 0 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =  x(a) in\nlet base = function y ->y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  x(a) in\nlet base = function in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  x(a) in\nlet base = function in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = function v ->  x (a v) in\nlet base = function y ->y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = function f' -> f' x(a) in\nlet base = function y ->y in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = function f' -> f' x(a) in\nlet base = function y ->y in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = function v ->  x (a v) in\nlet base = function y ->y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = function f'->  x(f' a) in\nlet base = function y ->y in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = function f'->  x(f' a) in\nlet base = function y ->y in\nList.fold_left f base fs"}
{"fix": "let rec multByDigit i l =\nlet rec helper i l2 acc s =\nmatch l2 with\n| []   -> \ns::acc\n| h::t -> \nlet n = i*h + s in\nif n>9 then\nhelper i t ((n mod 10)::acc) (n/10) \nelse\nhelper i t (n::acc) 0\nin \nremoveZero (helper i (List.rev l) [] 0)", "bad": "let rec multByDigit i l =\nrec helper i l2 acc s =\nmatch l2 with\n| []   -> \ns::acc\n| h::t -> \nlet n = i*h + s in\nif n>9 then\nhelper i t ((n mod 10)::acc) (n/10) \nelse\nhelper i t (n::acc) 0\nin \nremoveZero (helper i (List.rev l) [] 0)", "annotated": "let rec multByDigit i l =\nrec helper i l2 acc s =\nmatch l2 with\n| []   -> \ns::acc\n| h::t -> \nlet n = i*h + s in\nif n>9 then\nhelper i t ((n mod 10)::acc) (n/10) \nelse\nhelper i t (n::acc) 0\nin \nremoveZero (helper i (List.rev l) [] 0)"}
{"fix": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (n mod 10) :: (helper (n / 10)) in\nhelper n", "bad": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (n mod 10) @ (helper (n / 10)) in\nhelper n", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (n mod 10) @ (helper (n / 10)) in\nhelper n"}
{"fix": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  helper (n / 10) @ [(n mod 10)] in\nhelper n", "bad": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (n mod 10) :: (helper (n / 10)) in\n(helper n).reverse", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (n mod 10) :: (helper (n / 10)) in\n(helper n).reverse"}
{"fix": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  helper (n / 10) @ [(n mod 10)] in\nhelper n", "bad": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (n mod 10) :: (helper (n / 10)) in\nlet rec reverse xs =\nmatch xs with\n| [] -> xs\n| hd :: tl -> (reverse tl) :: hd in\nreverse (helper n)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (n mod 10) :: (helper (n / 10)) in\nlet rec reverse xs =\nmatch xs with\n| [] -> xs\n| hd :: tl -> (reverse tl) :: hd in\nreverse (helper n)"}
{"fix": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  helper (n / 10) @ [(n mod 10)] in\nhelper n", "bad": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (n mod 10) :: (helper (n / 10)) in\nlet rec reverse xs =\nmatch xs with\n| [] -> []\n| hd :: tl -> (reverse tl) :: hd in\nreverse (helper n)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (n mod 10) :: (helper (n / 10)) in\nlet rec reverse xs =\nmatch xs with\n| [] -> []\n| hd :: tl -> (reverse tl) :: hd in\nreverse (helper n)"}
{"fix": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  helper (n / 10) @ [(n mod 10)] in\nhelper n", "bad": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  append (helper (n / 10)) (n mod 10) in\nhelper n", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  append (helper (n / 10)) (n mod 10) in\nhelper n"}
{"fix": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  helper (n / 10) @ [(n mod 10)] in\nhelper n", "bad": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  append [helper (n / 10)] [(n mod 10)] in\nhelper n", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  append [helper (n / 10)] [(n mod 10)] in\nhelper n"}
{"fix": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  helper (n / 10) @ [(n mod 10)] in\nhelper n", "bad": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  append [helper (n / 10)] [n mod 10] in\nhelper n", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  append [helper (n / 10)] [n mod 10] in\nhelper n"}
{"fix": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  helper (n / 10) @ [(n mod 10)] in\nhelper n", "bad": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  append [helper (n / 10)] [(n mod 10)] in\nhelper n", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  append [helper (n / 10)] [(n mod 10)] in\nhelper n"}
{"fix": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  helper (n / 10) @ [(n mod 10)] in\nhelper n", "bad": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (append [helper (n / 10)] [(n mod 10)]) in\nhelper n", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (append [helper (n / 10)] [(n mod 10)]) in\nhelper n"}
{"fix": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  helper (n / 10) @ [(n mod 10)] in\nhelper n", "bad": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  helper (n / 10) @ [(n mod 10)]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  helper (n / 10) @ [(n mod 10)]"}
{"fix": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  helper (n / 10) @ [(n mod 10)] in\nhelper n", "bad": ") in\nhelper n", "annotated": ") in\nhelper n"}
{"fix": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  helper (n / 10) @ [(n mod 10)] in\nhelper n", "bad": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  helper (n / 10) @ [(n mod 10)]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  helper (n / 10) @ [(n mod 10)]"}
{"fix": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (append (helper (n / 10)) [(n mod 10)]) in\nhelper n", "bad": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (append helper (n / 10) [(n mod 10)]) in\nhelper n", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| n ->  (append helper (n / 10) [(n mod 10)]) in\nhelper n"}
{"fix": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "bad": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  helper (append [(m / 10)] [(m mod 10)]) in\nhelper n", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> (append tl (hd :: xs2)) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  helper (append [(m / 10)] [(m mod 10)]) in\nhelper n"}
{"fix": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> hd :: append tl xs2 in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "bad": "let rec digitsOfInt n = \nlet rec append xs1 xs2 = \nmatch xs2 with \n| [] -> xs1\n| hd :: tl -> (append (xs1 :: hd) tl) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet rec append xs1 xs2 = \nmatch xs2 with \n| [] -> xs1\n| hd :: tl -> (append (xs1 :: hd) tl) in\nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n"}
{"fix": "let _ = digitsOfInt 352663", "bad": "let _ = digitsOfInt 3124", "annotated": "let _ = digitsOfInt 3124"}
{"fix": "let rec additivePersistence n = \nlet rec helper count x =\nif (x < 10) then count else  (helper (count + 1) (sumList (digits n)))\nin (helper 0 n)", "bad": "let _ = additivePersistence 9876", "annotated": "let _ = additivePersistence 9876"}
{"fix": "let rec additivePersistence n = \nlet rec helper count x =\nif (count = 1) then count else  (helper (count + 1) (sumList (digits n)))\nin (helper 0 n)", "bad": "let _ = additivePersistence 9876", "annotated": "let _ = additivePersistence 9876"}
{"fix": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "bad": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n"}
{"fix": "let rec digitsOfInt n = \nlet rec helper x =\nmatch x with \n| 0 -> [] \n| m ->  (append (helper (m / 10)) [(m mod 10)]) in\nhelper n", "bad": "let rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> hd :: (append tl xs2)", "annotated": "let rec append xs1 xs2 = \nmatch xs1 with \n| [] -> xs2\n| hd :: tl -> hd :: (append tl xs2)"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l = \nlet rec helper xs result =\nmatch xs with\n| [] -> result\n| hd :: tl ->  helper tl  (hd :: result) in\nhelper xs []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec helper xs result =\nmatch xs with\n| [] -> result\n| hd :: tl ->  helper tl  (hd :: result) in\nhelper xs []"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l = \nlet rec helper xs result =\nmatch xs with\n| [] -> result\n| hd :: tl ->  helper tl  (hd :: result) in\nhelper xs []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec helper xs result =\nmatch xs with\n| [] -> result\n| hd :: tl ->  helper tl  (hd :: result) in\nhelper xs []"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l = \nlet rec helper xs result =\nmatch xs with\n| [] -> result\n| hd :: tl ->  helper tl  (hd :: result) in\nhelper l []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec helper xs result =\nmatch xs with\n| [] -> result\n| hd :: tl ->  helper tl  (hd :: result) in\nhelper l []"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then h :: seen else seen  in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "et _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "annotated": "et _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen then h :: seen else seen  in\nlet rest' = t in helper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "et _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "annotated": "et _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"}
{"fix": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) = xx)),b)", "bad": "let fixpoint (f,b) = wwhile (let xx = f xx in (xx, (f xx) = xx),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let xx = f xx in (xx, (f xx)  ->  xx),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) = xx)),b)", "bad": "let fixpoint (f,b) = wwhile (let xx = in (xx, (f xx) = xx),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let xx = in (xx, (f xx)  ->  xx),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) = xx)),b)", "bad": "let fixpoint (f,b) = wwhile (fun xx ((xx, (f xx) = xx)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun xx ((xx, (f xx)  ->  xx)),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) = xx)),b)", "bad": "let fixpoint (f,b) = wwhile (fun xx ((xx, f xx = xx)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun xx ((xx, f xx  ->  xx)),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) = xx)),b)", "bad": "let fixpoint (f,b) = wwhile (fun xx -> ((xx, f xx = xx)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun xx -> ((xx, f xx  ->  xx)),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) = xx)),b)", "bad": "let fixpoint (f,b) = wwhile (fun xx -> (xx, f xx = xx),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun xx -> (xx, f xx  ->  xx),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) = xx)),b)", "bad": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, f xx = xx)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun xx -> (xx, f xx  ->  xx)),b)"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let rec wwhile (f,b) =\nlet rec acc result =\nlet res = (f result) in\nmatch res with\n(b', c') -> if c' then acc b' else b'\nin\nacc b", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> \nlet rec acc result =\nlet res = (f result) in\nmatch res with\n(b', c') -> if c' then acc b' else b'\nin\nacc b"}
{"fix": "let fixpoint (f,b) = wwhile ((fun xx -> (f xx, (f xx) != xx)),b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 100)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 100)"}
{"fix": "let fixpoint (f,b) = wwhile ((fun xx -> (f xx, (f xx) != xx)),b)", "bad": "let fixpoint (f,b) = wwhile ((fun xx -> (xx, (f xx) != xx)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun xx -> (xx, (f xx) ! ->  xx)),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((fun xx -> (f xx, (f xx) != xx)),b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 739085 )", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 739085 )"}
{"fix": "let fixpoint (f,b) = wwhile ((fun xx -> (f xx, (f xx) != xx)),b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 739080 )", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 739080 )"}
{"fix": "exprToString VarX", "bad": "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX x -> sprintf \"%s\" x\n| VarY y -> sprintf \"%s\" y in\nacc e\n\nexprToString VarX", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nlet acc curr result = \nmatch curr with \n| VarX x -> sprintf \"%s\" x\n| VarY y -> sprintf \"%s\" y in\nacc e\n\nexprToString VarX"}
{"fix": "exprToString VarX", "bad": "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX x -> sprintf \"%s\" x\n| VarY y -> sprintf \"%s\" y in\nacc e \"\"\n\nexprToString VarX", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nlet acc curr result = \nmatch curr with \n| VarX x -> sprintf \"%s\" x\n| VarY y -> sprintf \"%s\" y in\nacc e \"\"\n\nexprToString VarX"}
{"fix": "exprToString VarX", "bad": "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX-> sprintf \"x\" \n| VarY y -> sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nlet acc curr result = \nmatch curr with \n| VarX-> sprintf \"x\" \n| VarY y -> sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX"}
{"fix": "exprToString VarX", "bad": "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX-> sprintf \"x\" \n| VarY y -> sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nlet acc curr result = \nmatch curr with \n| VarX-> sprintf \"x\" \n| VarY y -> sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX"}
{"fix": "exprToString VarX", "bad": "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX-> sprintf \"x\" \n| VarY -> sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nlet acc curr result = \nmatch curr with \n| VarX-> sprintf \"x\" \n| VarY -> sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX"}
{"fix": "exprToString VarX", "bad": "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX-> sprintf \"x\" \n| VarY -> sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nlet acc curr result = \nmatch curr with \n| VarX-> sprintf \"x\" \n| VarY -> sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX"}
{"fix": "exprToString VarX", "bad": "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX-> printf \"x\" \n| VarY -> printf \"y\" in\nacc e \"\"\n\nexprToString VarX", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nlet acc curr result = \nmatch curr with \n| VarX-> printf \"x\" \n| VarY -> printf \"y\" in\nacc e \"\"\n\nexprToString VarX"}
{"fix": "exprToString VarX", "bad": "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nlet acc curr result = \nmatch curr with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX"}
{"fix": "exprToString VarX", "bad": "let rec exprToString e = \nlet acc curr result = \nmatch curr with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nlet acc curr result = \nmatch curr with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX"}
{"fix": "exprToString VarX", "bad": "let rec exprToString e = \nlet rec acc curr result = \nmatch curr with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nlet rec acc curr result = \nmatch curr with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX"}
{"fix": "exprToString VarX", "bad": "let rec exprToString e = \nlet rec acc curr result = \nmatch curr with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nlet rec acc curr result = \nmatch curr with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\" in\nacc e \"\"\n\nexprToString VarX"}
{"fix": "exprToString VarX", "bad": "let rec exprToString e = \nlet rec accu curr result = \nmatch curr with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\" in\naccu e \"\"\n\nexprToString VarX", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nlet rec accu curr result = \nmatch curr with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\" in\naccu e \"\"\n\nexprToString VarX"}
{"fix": "exprToString VarX", "bad": "let rec exprToString e = \nlet rec accu curr result = \nmatch curr with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\" in\naccu e \"\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nlet rec accu curr result = \nmatch curr with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\" in\naccu e \"\""}
{"fix": "exprToString VarX", "bad": "let rec exprToString e = \nmatch e with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\"  \n| Sine x   -> Printf.sprintf \"Sine(%s)\" exprToString x", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nmatch e with \n| VarX-> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\"  \n| Sine x   -> Printf.sprintf \"Sine(%s)\" exprToString x"}
{"fix": "exprToString VarX", "bad": "let rec exprToString e = \nmatch e with \n| VarX -> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\"  \n| Sine x -> Printf.sprintf \"Sine\\(%s\\)\" exprToString x", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nmatch e with \n| VarX -> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\"  \n| Sine x -> Printf.sprintf \"Sine\\(%s\\)\" exprToString x"}
{"fix": "exprToString VarX", "bad": "let rec exprToString e = \nmatch e with \n| VarX -> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\"  \n| Sine x -> Printf.sprintf \"Sine(%s)\" exprToString x", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nmatch e with \n| VarX -> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\"  \n| Sine x -> Printf.sprintf \"Sine(%s)\" exprToString x"}
{"fix": "exprToString VarX", "bad": "let rec exprToString e = \nmatch e with \n| VarX -> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\"  \n| Sine x -> Printf.sprintf \"Sine(%s)\" (exprToString x)", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nmatch e with \n| VarX -> Printf.sprintf \"x\" \n| VarY -> Printf.sprintf \"y\"  \n| Sine x -> Printf.sprintf \"Sine(%s)\" (exprToString x)"}
{"fix": "let rec assoc (d,k,l) = \nlet rec acc xs = \nmatch xs with \n| (k', v') :: tl -> \nif k' = k then \nv' else \nacc tl\n| [] -> d\n| _ -> failwith \"This ain't your mom's hashmap\"\nin\nacc l", "bad": "exprToString Sine(VarX)", "annotated": "exprToString Sine(VarX)"}
{"fix": "let rec assoc (d,k,l) = \nlet rec acc xs = \nmatch xs with \n| (k', v') :: tl -> \nif k' = k then \nv' else \nacc tl\n| [] -> d\n| _ -> failwith \"This ain't your mom's hashmap\"\nin\nacc l", "bad": "exprToString Sine(VarX)", "annotated": "exprToString Sine(VarX)"}
{"fix": "let rec assoc (d,k,l) = \nlet rec acc xs = \nmatch xs with \n| (k', v') :: tl -> \nif k' = k then \nv' else \nacc tl\n| [] -> d\n| _ -> failwith \"This ain't your mom's hashmap\"\nin\nacc l", "bad": "| failwith \"Why don't you just make me write a lisp compiler\"\n\n\nexprToString Sine(VarX)", "annotated": "| failwith \"Why don't you just make me write a lisp compiler\"\n\n\nexprToString Sine(VarX)"}
{"fix": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> Printf.sprintf \"Sine(%s)\" (exprToString x)\n\nexprToString Sine(VarX)", "bad": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> Printf.sprintf \"Sine(%s)\" (exprToString x)", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> Printf.sprintf \"Sine(%s)\" (exprToString x)"}
{"fix": "exprToString Sine(VarX)", "bad": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> Printf.sprintf \"Sine(%s)\" (exprToString x)", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> Printf.sprintf \"Sine(%s)\" (exprToString x)"}
{"fix": "exprToString Sine(VarX)", "bad": "exprToString Sine(VarX)", "annotated": "exprToString Sine(VarX)"}
{"fix": "exprToString Sine(VarX)", "bad": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> Printf.sprintf \"Sine(%s)\" (exprToString x)\n| _ -> failwith \"are we writing a lisp compiler now\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> Printf.sprintf \"Sine(%s)\" (exprToString x)\n| _ -> failwith \"are we writing a lisp compiler now\""}
{"fix": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> Printf.sprintf \"Sine(pi*%s)\" (exprToString x)\n| \n| _ -> failwith \"are we writing a lisp compiler now\"", "bad": "let _ = exprToString (Sine(VarX))", "annotated": "let _ = exprToString (Sine(VarX))"}
{"fix": "let _ = exprToString (Sine(VarX))", "bad": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> Printf.sprintf \"Sine(pi*%s)\" (exprToString x)\n| _ -> failwith \"are we writing a lisp compiler now\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> Printf.sprintf \"Sine(pi*%s)\" (exprToString x)\n| _ -> failwith \"are we writing a lisp compiler now\""}
{"fix": "let _ = exprToString (Sine(Average(VarX, VarY)))", "bad": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\nexprToString e1\nexprToString e2\n| _ -> failwith \"are we writing a lisp compiler now\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\nexprToString e1\nexprToString e2\n| _ -> failwith \"are we writing a lisp compiler now\""}
{"fix": "let _ = exprToString (Sine(Average(VarX, VarY)))", "bad": "let rec exprToString e = \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| _ -> failwith \"are we writing a lisp compiler now\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(e') -> Printf.sprintf \"sin(pi*%s)\" (exprToString e')\n| Cosine(e') -> Printf.sprintf \"cos(pi*%s)\" (exprToString e')\n| Average(e1, e2) -> Printf.sprintf \"((%s+%s)/2)\" \n(exprToString e1) \n(exprToString e2)\n| Times (e1, e2) -> Printf.sprintf \"%s*%s\"\n(exprToString e1)\n(exprToString e2)\n| _ -> failwith \"are we writing a lisp compiler now\""}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(eval(e', x, y))\n| Cosine(e') -> cos(eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) + eval(e2, x, y))/2\n| Times (e1, e2) -> (eval(e1, x, y) * eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(eval(e', x, y))\n| Cosine(e') -> cos(eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) + eval(e2, x, y))/2\n| Times (e1, e2) -> (eval(e1, x, y) * eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\""}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(eval(e', x, y))\n| Cosine(e') -> cos(eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/2\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(eval(e', x, y))\n| Cosine(e') -> cos(eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/2\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\""}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(eval(e', x, y))\n| Cosine(e') -> cos(eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(eval(e', x, y))\n| Cosine(e') -> cos(eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\""}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "bad": "let _ = eval (sampleExpr1,0.5,0.2)", "annotated": "let _ = eval (sampleExpr1,0.5,0.2)"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\""}
{"fix": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "bad": "let rec assoc (d,k,l) = \nmatch l with \n| (k', v') :: tl -> \nif k' = k then \nv' else \nassoc (d, k, tl)\n| [] -> d\n| _ -> failwith \"This ain't your mom's hashmap\"", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  \nmatch l with \n| (k', v') :: tl -> \nif k' = k then \nv' else \nassoc (d, k, tl)\n| [] -> d\n| _ -> failwith \"This ain't your mom's hashmap\""}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let rec wwhile (f,b) =\nlet res = (f b) in\nmatch res with\n(b', c') -> if c' then wwhile (f, b') else b'", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> \nlet res = (f b) in\nmatch res with\n(b', c') -> if c' then wwhile (f, b') else b'"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs (eval e))\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs (eval e))\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\""}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs (eval (e, x, y)))\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs (eval (e, x, y)))\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\""}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (absF (eval (e, x, y)))\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (absF (eval (e, x, y)))\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\""}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\"", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| _ -> failwith \"we are seriously writing a lisp compiler god save us all\""}
{"fix": "let _  = eval (Quad (VarX, VarY, VarX), 0.5, 0.5)", "bad": "let _  = eval (Quad (VarX, VarY, VarX), 0.5, -0.5)", "annotated": "let _  = eval (Quad (VarX, VarY, VarX), 0.5, -0.5)"}
{"fix": "let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)", "bad": "let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next next)\n| 4 -> buildTimes next next\n| 5 -> buildThresh next next next next\n| 6 -> buildSqrt next\n| 7 -> buildGauss next next next", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n| 0 -> VarX\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next next)\n| 4 -> buildTimes next next\n| 5 -> buildThresh next next next next\n| 6 -> buildSqrt next\n| 7 -> buildGauss next next next"}
{"fix": "let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)", "bad": "let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes next next\n| 5 -> buildThresh next next next next\n| 6 -> buildSqrt next\n| 7 -> buildGauss next next next", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n| 0 -> VarX\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes next next\n| 5 -> buildThresh next next next next\n| 6 -> buildSqrt next\n| 7 -> buildGauss next next next"}
{"fix": "let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)", "bad": "let rec build (rand, depth) = match depth with\n| 0 -> VarX\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n| 0 -> VarX\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)"}
{"fix": ")\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)", "bad": "let rec build (rand, depth) = match depth with\n(| 0 -> match rand (1, 2) with\n1 -> buildX\n| 2 -> buildY)\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n(| 0 -> match rand (1, 2) with\n1 -> buildX\n| 2 -> buildY)\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)"}
{"fix": ")\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)", "bad": "let rec build (rand, depth) = match depth with\n( 0 -> match rand (1, 2) with\n1 -> buildX\n| 2 -> buildY)\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n( 0 -> match rand (1, 2) with\n1 -> buildX\n| 2 -> buildY)\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)"}
{"fix": ")\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (next, next)\n| 4 -> buildTimes (next, next)\n| 5 -> buildThresh (next, next, next, next)\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, next, next)", "bad": "let rec build (rand, depth) = match depth with\n0 -> match rand (1, 2) with\n1 -> buildX\n| 2 -> buildY", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n0 -> match rand (1, 2) with\n1 -> buildX\n| 2 -> buildY"}
{"fix": "let buildAbs(e)\t\t\t   = Abs(e)", "bad": "let buildSqrt(e)                   = Sqrt(e)", "annotated": "let build: ((int * int -> int) * int) -> expr = fun Sqrt(e)                    ->  Sqrt(e)"}
{"fix": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (1, 3) with\n1-> VarX\n| 2 -> VarY )\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 8) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))", "bad": "let rec build (rand, depth) = match depth with\n| 0 -> (match rand (1, 3) with\n1-> VarX\n| 2 -> VarY )\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n| 0 -> (match rand (1, 3) with\n1-> VarX\n| 2 -> VarY )\n| _ -> let next = build (rand, depth - 1) in\nmatch rand (1, 7) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))"}
{"fix": "let g1 () = failwith \"to be implemented\"", "bad": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 8) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| _ -> buildAbs next)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 8) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildGauss (next, \nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| _ -> buildAbs next)"}
{"fix": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Logistic (e1, e2, e3) -> \n(2.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y) *. eval(e3, x, y )))\n-. 1.0))\n| _ -> failwith \"error\"", "bad": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Logistic (e1, e2, e3) -> \n(2.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y)))\n-. 1.0) ** eval (e3, x, y))\n| _ -> failwith \"error\"", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Logistic (e1, e2, e3) -> \n(2.0 /. (1.0 -. exp (~-. (eval (e1, x, y) *. eval (e2, x, y)))\n-. 1.0) ** eval (e3, x, y))\n| _ -> failwith \"error\""}
{"fix": "let g1 () = failwith \"to be implemented\"", "bad": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 1) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 6) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n| 0 -> \n(match rand (0, 1) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 6) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next)"}
{"fix": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 6) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildLogistic (next,\nbuild (rand, depth - 1), \nbuild (rand, depth - 1)))", "bad": "let rec build (rand, depth) = match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 6) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildLogistic (next,\nbuild (rand, depth - 1), \nbuild (rand, depth - 1)))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n| 0 -> \n(match rand (0, 2) with\n| 0-> VarX\n| 1 -> VarY \n| _ -> VarY)\n| _ -> let next = build (rand, depth - 1) in\n(match rand (1, 6) with\n| 1-> buildSine next\n| 2 -> buildCosine next\n| 3 -> buildAverage (build (rand, depth - 1), build (rand, depth - 1))\n| 4 -> buildTimes (next, build (rand, depth - 1))\n| 5 -> buildThresh (next, \nbuild (rand, depth - 1),\nbuild (rand, depth - 1), \nbuild (rand, depth - 1))\n| 6 -> buildSqrt next\n| 7 -> buildLogistic (next,\nbuild (rand, depth - 1), \nbuild (rand, depth - 1)))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a + x^2 in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a + x^2 in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a +. x ** 2in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a +. x ** 2in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a +. x ** 2.0 in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a +. x ** 2.0 in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a + x*xin", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a + x*xin"}
{"fix": "let pipe fs =\nlet rec iter acc curr = \nmatch curr with \n|[] -> acc\n| h::tl -> iter (h acc) tl in\niter (fun y-> y) fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = x in\nList.fold_left f base fs"}
{"fix": "let pipe fs =\nlet rec iter acc curr = \nmatch curr with \n|[] -> acc\n| h::tl -> iter (h acc) tl in\niter (fun y-> y) fs", "bad": "let pipe fs = \nlet f a x = fs (a x) in\nlet base = x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fs (a x) in\nlet base = x in\nList.fold_left f base fs"}
{"fix": "let pipe fs =\nlet rec iter acc curr = \nmatch curr with \n|[] -> acc\n| h::tl -> iter (h acc) tl in\niter (fun y-> y) fs", "bad": "let pipe fs = \nlet f a x = fs (a x) in\nlet base = fun y -> y in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fs (a x) in\nlet base = fun y -> y in\nList.fold_left f base fs"}
{"fix": "let pipe fs =\nlet rec iter acc curr = \nmatch curr with \n|[] -> acc\n| h::tl -> iter (h acc) tl in\niter (fun y-> y) fs", "bad": "let pipe fs =\nlet rec iter acc curr = \nmatch curr with \n|[] -> acc\n| h::tl -> iter (h curr) tl in\niter (fun y-> y) fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> \nlet rec iter acc curr = \nmatch curr with \n|[] -> acc\n| h::tl -> iter (h curr) tl in\niter (fun y-> y) fs"}
{"fix": "let _ = pipe [] 3", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs =\nlet rec iter acc curr = \nmatch curr with \n|[] -> acc\n| h::tl -> iter (h (acc)) tl in\niter (fun y-> y) fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs =\nlet rec iter acc curr = \nmatch curr with \n|[] -> acc\n| h::tl -> iter (h (acc)) tl in\niter (fun y-> y) fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)]", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)]"}
{"fix": "let pipe fs =\nlet rec iter acc curr = \nmatch curr with \n|[] -> acc\n| h::tl -> iter (fun x -> (h (acc x))) tl in\niter id fs", "bad": "let pipe fs =\nlet rec iter acc curr = \nmatch curr with \n|[] -> acc\n| h::tl -> iter (fun x -> (h (acc x)) tl in\niter id fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> \nlet rec iter acc curr = \nmatch curr with \n|[] -> acc\n| h::tl -> iter (fun x -> (h (acc x)) tl in\niter id fs"}
{"fix": "let pipe fs = \nlet f a x =  fun y -> (a (x y))   in\nlet base = fun y -> y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  fun y -> ((a (x y))   in\nlet base = fun y -> y in\nList.fold_left f base fs *", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  fun y -> ((a (x y))   in\nlet base = fun y -> y in\nList.fold_left f base fs *"}
{"fix": "let pipe fs = \nlet f a x =  fun y -> (a (x y))   in\nlet base = fun y -> y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  fun y -> ((a (x y))   in\nlet base = fun y -> y in\nList.fold_left f base fs *", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  fun y -> ((a (x y))   in\nlet base = fun y -> y in\nList.fold_left f base fs *"}
{"fix": "let pipe fs = \nlet f a x =  fun y -> (a (x y))   in\nlet base = fun y -> y in\nList.fold_left f base fs", "bad": ")", "annotated": ")"}
{"fix": "let pipe fs = \nlet f a x =  fun y -> (a (x y))   in\nlet base = fun y -> y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  fun y -> (a (x y))   in\nlet base = fun y -> y in\nList.fold_left f base fs *", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  fun y -> (a (x y))   in\nlet base = fun y -> y in\nList.fold_left f base fs *"}
{"fix": "let stringOfList f l = \n\"[\" ^ List.fold_left (^) \n\"\"\n(List.map f l) ^ \"]\"", "bad": "let stringOfList f l = \n\"[\" ^ List.map f l ^ \"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \n\"[\" ^ List.map f l ^ \"]\""}
{"fix": "let stringOfList f l = \n\"[\" ^\nList.fold_left (fun x acc -> x ^ \"; \" ^ acc) \n\"\"\n(List.map f l) ^ \"]\"", "bad": "let stringOfList f l = \n\"[\" (fun x acc -> x ^ \"; \" ^ acc) \nList.fold_left (^) \n\"\"\n(List.map f l) ^ \"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \n\"[\" (fun x acc -> x ^ \"; \" ^ acc) \nList.fold_left (^) \n\"\"\n(List.map f l) ^ \"]\""}
{"fix": "let stringOfList f l = \n\"[\" ^\n(List.fold_right (fun x acc -> x ^ \"; \" ^ acc) \n(List.map f l) \n\"\")\n^ \"]\"", "bad": "let stringOfList f l = \n\"[\" ^\nList.fold_right (fun x acc -> x ^ \"; \" ^ acc) \n\"\"\n(List.map f l) ^ \"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \n\"[\" ^\nList.fold_right (fun x acc -> x ^ \"; \" ^ acc) \n\"\"\n(List.map f l) ^ \"]\""}
{"fix": "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\n( clone 0 (len2 - len1) @ l1,\nclone 0 (len1 - len2)@  l2)", "bad": "let padZero l1 l2 = \nlet len1 = List.len l1 in\nlet len2 = List.len l2 in\n( clone 0 (len2 - len1) @ l1,\nclone 0 (len1 - len2)@  l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet len1 = List.len l1 in\nlet len2 = List.len l2 in\n( clone 0 (len2 - len1) @ l1,\nclone 0 (len1 - len2)@  l2)"}
{"fix": "let padZero l1 l2 = \nlet diff = (List.length l2) - (List.length l1) in\n( clone 0 diff @ l1,\nclone 0 (-diff) @  l2)", "bad": "let padZero l1 l2 = \nlet diff = (List.length l2) - (List.length l1) in\n( clone 0 diff @ l1,\nclone 0 -diff @  l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet diff = (List.length l2) - (List.length l1) in\n( clone 0 diff @ l1,\nclone 0 -diff @  l2)"}
{"fix": "let rec removeZero l = match l with\n| [] -> l\n| h :: t -> if (h = 0) then removeZero t \nelse l", "bad": "let rec removeZero l = match l with\n| [] -> l\n| h :: t -> if (h = 0) then removeZer t \nelse l", "annotated": "let rec removeZero : int list -> int list = fun  l  ->  match l with\n| [] -> l\n| h :: t -> if (h = 0) then removeZer t \nelse l"}
{"fix": "let _ = bigAdd [1] [2]", "bad": "let _ = bigAdd [1] [2];\n\n\nlet _ = bigAdd [9;9] [1;0;0;2]", "annotated": "let _ = bigAdd [1] [2];\n\n\nlet _ = bigAdd [9;9] [1;0;0;2]"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n((if (addit > 10) then (addit / 10) else 0), \n( addit mod 10 :: num)\t)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n((if (addit > 10) then (addit / 10) else 0), \n( addit mod 10 :: num)\t  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n((if (addit > 10) then (addit / 10) else 0), \n( addit mod 10 :: num)\t  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f x a = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n((if (addit > 10) then 1 else 0), \n( addit mod 10 :: num))  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_right f args base in res\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n((if (addit > 10) then 1 else 0), \n( addit mod 10 :: num))  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_right f args base in res\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n((if (addit > 10) then 1 else 0), \n( addit mod 10 :: num))  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_right f args base in res\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, ((addit mod 10) :: num)) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry \nprint_int l1' in\n(addit / 10, ( addit mod 10 :: num)) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry \nprint_int l1' in\n(addit / 10, ( addit mod 10 :: num)) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, ((addit mod 10) :: num)) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nif (x = [] && carry > 0) then carry :: num else num", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nif (x = [] && carry > 0) then carry :: num else num"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, ((addit mod 10) :: num)) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = x in\nlet (l1', l2') = a in \nlet addit = l1' + l2' + carry in\n(addit / 10, ((addit mod 10) :: num)) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = x in\nlet (l1', l2') = a in \nlet addit = l1' + l2' + carry in\n(addit / 10, ((addit mod 10) :: num)) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  \nlet (carry, num) = a in \nlet (l1, l2) = x in\n(0, l1 :: num)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \n(0, x :: a)", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \n(0, x :: a)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  \nlet (carry, num) = a in \nlet (l1, l2) = x in\n(0, l1 :: num)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  (0, x :: a) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x =  (0, x :: a) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  \nlet (carry, num) = a in \nlet (l1, l2) = x in\n(0, l1 :: num)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  (0, x :: a) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x =  (0, x :: a) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  \nlet (carry, num) = a in \nlet (l1, l2) = x in\n(0, l1 :: num)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  let (l1, l2) = x in\n(0, l2 :: a)", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x =  let (l1, l2) = x in\n(0, l2 :: a)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  \nlet (carry, num) = a in \nlet (l1, l2) = x in\n(0, l1 :: num)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  let (l1, l2) = x in\n(0, l2 :: a)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x =  let (l1, l2) = x in\n(0, l2 :: a)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  \nlet (carry, num) = a in \nlet (l1, l2) = x in\n(0, l1 :: num)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  let (l1, l2) = x in\n(0, l2 :: a)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x =  let (l1, l2) = x in\n(0, l2 :: a)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  \nlet (carry, num) = a in \nlet (l1, l2) = x in\n(0, l1 :: num)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  let (l1, l2) = x in\n(0, l1 :: a)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x =  let (l1, l2) = x in\n(0, l1 :: a)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  \nlet (carry, num) = a in \nlet (l1, l2) = x in\n(0, l1 :: num)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  \nlet (carry, nume ) = a in \nlet (l1, l2) = x in\n(0, l1 :: num)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x =  \nlet (carry, nume ) = a in \nlet (l1, l2) = x in\n(0, l1 :: num)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  \nlet (carry, num) = a in \nlet (l1, l2) = x in\n(0, l1 :: num)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  \nlet (carry, nume ) = a in \nlet (l1, l2) = x in\n(0, l1 :: num)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x =  \nlet (carry, nume ) = a in \nlet (l1, l2) = x in\n(0, l1 :: num)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ [(addit mod 10)]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ ((addit mod 10) )) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ ((addit mod 10) )) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ [(addit mod 10)]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ (addit mod 10) )", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ (addit mod 10) )"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ [(addit mod 10)]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "bad": ") in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "annotated": ") in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ [(addit mod 10)]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ (addit mod 10) ) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ (addit mod 10) ) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ [(addit mod 10)]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ (addit mod 10) ) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ (addit mod 10) ) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ [(addit mod 10)]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (car, res) = List.fold_left f base args in car\nin \n(add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ [(addit mod 10)]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in _\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ [(addit mod 10)]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in _\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ [(addit mod 10)]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ [(addit mod 10)]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZeros (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ [(addit mod 10)]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZeros (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(if addit >= 10 then 1 else 0, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(if addit >= 10 then 1 else 0, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(if addit >= 10 then 1 else 0, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(if addit >= 10 then 1 else 0, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine [0; l1] [0; l2] in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine [0; l1] [0; l2] in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2)", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nfailwith (Printf.sprintf \"hi %d\" addit)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nfailwith printf.sprintf \"hi %d\" addit\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nfailwith printf.sprintf \"hi %d\" addit\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nfailwith (Printf.sprintf \"hi %d\" addit)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nfailwith Printf.sprintf \"hi %d\" addit\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nfailwith Printf.sprintf \"hi %d\" addit\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf \"hi %d\" car \n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf \"hi %d\" car \n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" car )\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" car )\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" car );\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" car );\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" car; )\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" car; )\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry; )\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry; )\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (\"hi %d\") carry; )\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (\"hi %d\") carry; )\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (\"hi %d\") carry", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (\"hi %d\") carry"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf (\"hi %d\") carry", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf (\"hi %d\") carry"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (\"hi %d\") carry)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (\"hi %d\") carry)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (\"hi %d\") carry)", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (\"hi %d\") carry)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.kprintf (\"hi %d\") carry)", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.kprintf (\"hi %d\") carry)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.kprintf (\"hi %d\") carry)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.kprintf (\"hi %d\") carry)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (\"hi %d\") carry)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (\"hi %d\") carry)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (\"hi %d\" carry)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (\"hi %d\" carry)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (\"hi %d\" carry))\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (\"hi %d\" carry))\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\\n\" addit; in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %s\" carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %s\" carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\\n\" addit; in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\\n\" addit\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\\n\" addit\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\\n\" addit; in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\\n\" addit; in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\\n\" addit; in\n(if addit >= 10 then 1 else 0), num @ [addit mod 10]", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\\n\" addit; in\n(if addit >= 10 then 1 else 0), num @ [addit mod 10]"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\\n\" addit; in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\\n\" addit; in\n(if addit >= 10 then 1 else 0), num @ [addit mod 10]", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\\n\" addit; in\n(if addit >= 10 then 1 else 0), num @ [addit mod 10]"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\\n\" addit; in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": ") in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": ") in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\\n\" addit; in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\\n\" addit in\n(if addit >= 10 then 1 else 0), num @ [addit mod 10]", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\\n\" addit in\n(if addit >= 10 then 1 else 0), num @ [addit mod 10]"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\\n\" addit; in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\\n\" addit; in\n(if addit >= 10 then 1 else 0), num @ [addit mod 10]", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\\n\" addit; in\n(if addit >= 10 then 1 else 0), num @ [addit mod 10]"}
{"fix": "let _ = bigAdd [1; 9] [2]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\"; in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\"; in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf \"%d\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf (\"%d\\n\" addit);\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf (\"%d\\n\" addit);\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf \"%d\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf (\"%d\\n\", addit);\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf (\"%d\\n\", addit);\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%8d%8d%8d\\n\" l1' l2' carry; (if addit >= 10 then 1 else 0), num @ [addit mod 10])", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%8d%8d%8d\\n\" l1' l2' carry; (if addit >= 10 then 1 else 0), num @ [addit mod 10])"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%8d%8d%8d\\n\"; l1'; l2'; carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%8d%8d%8d\\n\"; l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%8d%8d%8d\\n\"; l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf; Printf.sprintf \"%8d%8d%8d\\n\"; l1'; l2'; carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf Printf.sprintf \"%8d%8d%8d\\n\"; l1'; l2'; carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf Printf.sprintf \"%8d%8d%8d\\n\"; l1'; l2'; carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry); ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry); ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\"; Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s \"Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s \"Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\"; Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\" Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\" Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = Printf.printf \"%d\\n\" addit in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = Printf.printf \"%d\\n\" addit in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = Printf.printf \"%d\\n\" addit in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = Printf.printf \"%d\\n\" addit in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = Printf.printf \"%d\\n\" addit in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = Printf.printf \"%d\\n\" addit in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = Printf.printf \"%d\\n\" addit in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = Printf.printf \"%d\\n\" addit in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((Printf.printf \"%s\\n\" addit);\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((Printf.printf \"%s\\n\" addit);\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = Printf.printf \"%d\\n\" addit in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(let _ = Printf.printf \"%s\\n\" addit);\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(let _ = Printf.printf \"%s\\n\" addit);\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = Printf.printf \"%d\\n\" addit in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = Printf.printf \"%s\\n\" addit in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = Printf.printf \"%s\\n\" addit in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = Printf.printf \"%d\\n\" addit in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = Printf.printf \"%d\\n\" addit in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = Printf.printf \"%d\\n\" addit in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = Printf.printf (string_of_int addit) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = Printf.printf (string_of_int addit) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10), num @ [addit mod 10]", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10), num @ [addit mod 10]"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine (List.rev ([0] @ l1)) (List.rev ([0]@ l2)) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine (List.reverse ([0] @ l1)) (List.Reverse ([0]@ l2)) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine (List.reverse ([0] @ l1)) (List.Reverse ([0]@ l2)) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine (List.rev ([0] @ l1)) (List.rev ([0]@ l2)) in\nlet (car, res) = List.fold_left f base args in \nList.rev res\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine (List.rev ([0] @ l1)) (List.rev ([0]@ l2)) in\nlet (car, res) = List.fold_left f base args in \nList.reve res\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine (List.rev ([0] @ l1)) (List.rev ([0]@ l2)) in\nlet (car, res) = List.fold_left f base args in \nList.reve res\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let rec mulByDigit i l = if i = 0 then 0\nelse if i = 1 then l \nelse (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)\nelse bigAdd l (mulByDibit (i - 1) l)", "bad": "let _ = mulByDigit 9 [9;9;9;9]", "annotated": "let _ = mulByDigit 9 [9;9;9;9]"}
{"fix": "let rec mulByDigit i l = if i = 0 then 0\nelse if i = 1 then l \nelse (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)\nelse bigAdd l (mulByDibit (i - 1) l)", "bad": "let rec mulByDigit i l = if i = 1 then l \nelse mulByDigit (i - 1) (bigAdd l l)", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l = if i  ->  1 then l \nelse mulByDigit (i - 1) (bigAdd l l)"}
{"fix": "let rec mulByDigit i l = if i = 0 then 0\nelse if i = 1 then l \nelse (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)\nelse bigAdd l (mulByDibit (i - 1) l)", "bad": "let _ = mulByDigit 9 [9;9;9;9]", "annotated": "let _ = mulByDigit 9 [9;9;9;9]"}
{"fix": "let rec mulByDigit i l = if i = 0 then 0\nelse if i = 1 then l \nelse (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)\nelse bigAdd l (mulByDibit (i - 1) l)", "bad": "let rec mulByDigit i l = if i = 0 then 0\nelse if i = 1 then l \nelse l", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l = if i  ->  0 then 0\nelse if i = 1 then l \nelse l"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(place + 1 ,bigAdd num (mulByDigit (x * placement) l1)) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement =  10 ** place  in\n(addit / 10, (addit mod 10) :: num) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet (place, num) = a in\nlet placement =  10 ** place  in\n(addit / 10, (addit mod 10) :: num) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(place + 1 ,bigAdd num (mulByDigit (x * placement) l1)) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(addit / 10, (addit mod 10) :: num) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(addit / 10, (addit mod 10) :: num) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(place + 1 ,bigAdd num (mulByDigit (x * placement) l1)) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(bigAdd a mulByDigit (x * place) l1) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(bigAdd a mulByDigit (x * place) l1) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(place + 1 ,bigAdd num (mulByDigit (x * placement) l1)) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(bigAdd a mulByDigit ((x * place) l1)) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(bigAdd a mulByDigit ((x * place) l1)) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(place + 1 ,bigAdd num (mulByDigit (x * placement) l1)) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(bigAdd a (mulByDigit (x * place) l1)) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(bigAdd a (mulByDigit (x * place) l1)) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(place + 1 ,bigAdd num (mulByDigit (x * placement) l1)) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(place + 1 , bigAdd num (mulByDigit (x * place) l1)) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(place + 1 , bigAdd num (mulByDigit (x * place) l1)) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(place + 1 ,bigAdd num (mulByDigit (x * placement) l1)) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(place + 1 ,bigAdd num (mulByDigit (x * place) l1)) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(place + 1 ,bigAdd num (mulByDigit (x * place) l1)) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(place + 1 ,bigAdd num (mulByDigit (x * placement) l1)) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "annotated": "let _ = bigMul [9;9;9;9] [9;9;9;9]"}
{"fix": "let _ = digitsOfInt 1", "bad": "let _ = digitsOfInt -1", "annotated": "let _ = digitsOfInt -1"}
{"fix": "let _ = digitsOfInt 1", "bad": "let _ = digitsOfInt -1.5", "annotated": "let _ = digitsOfInt -1.5"}
{"fix": "let _ = digitsOfInt 1", "bad": "let _ = digitsOfInt -1", "annotated": "let _ = digitsOfInt -1"}
{"fix": "let rec sumList xs = match xs with\n| []     -> 0 \n| hd::tl -> hd + sumList tl", "bad": "let _ = digitsOfInt -12", "annotated": "let _ = digitsOfInt -12"}
{"fix": "let rec addPHelper n pos =\nlet sum = sumList pos in \nif sum < 10\nthen sum\nelse addPHelper sum pos", "bad": "let rec addPHelper n pos =\nlet sum = sumList pos in \nif sum < 10\nthen sum\nelse addPHelper sum", "annotated": "let rec addPHelper n pos =\nlet sum = sumList pos in \nif sum < 10\nthen sum\nelse addPHelper sum"}
{"fix": "let rec addPHelper n pos =\nlet sum = sumList pos in \nif sum < 10\nthen sum\nelse addPHelper sum pos", "bad": "let additivePersistence n = \nlet pos = digits n in\naddPHelper n pos", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet pos = digits n in\naddPHelper n pos"}
{"fix": "let rec addPHelper n pos =\nlet sum = sumList pos in \nif sum < 10\nthen sum\nelse addPHelper sum pos", "bad": "let _ = additivePersistence 9876", "annotated": "let _ = additivePersistence 9876"}
{"fix": "let _ = additivePersistence 1", "bad": "let _ = additivePersistence 1", "annotated": "let _ = additivePersistence 1"}
{"fix": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "bad": "let rec build (rand, depth) = match depth with\n| 0 -> buildX \n| 1 -> (build (rand, depth-(depth -1)))\n| 2 -> buildTimes(build (rand, depth-(depth -2)), build(rand, depth-(depth -2)))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n| 0 -> buildX \n| 1 -> (build (rand, depth-(depth -1)))\n| 2 -> buildTimes(build (rand, depth-(depth -2)), build(rand, depth-(depth -2)))"}
{"fix": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "bad": "let rec build (rand, depth) = match depth with\n| 0 -> buildX \n| 1 -> (build (rand, depth-(depth -1)))\n| 2 -> buildTimes(build (rand, depth-(depth -2)), build(rand, depth-(depth -2)))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n| 0 -> buildX \n| 1 -> (build (rand, depth-(depth -1)))\n| 2 -> buildTimes(build (rand, depth-(depth -2)), build(rand, depth-(depth -2)))"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX              -> x\n| VarY              -> y\n| Sine(e)          -> sin(pi *. eval(e,x,y))\n| Cosine(e)        -> cos(pi *. eval(e,x,y))\n| Average(e1,e2)   -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.\n| Times(e1,e2)     -> eval(e1,x,y) *. eval(e2,x,y)\n(* | PowerUp(e1,e2)   -> (abs(eval(e1,x,y))) ** (abs(eval(e2,x,y))) *)\n| Square2(e1,e2,e3)-> sqrt((eval(e1,x,y))**2. +. (eval(e2,x,y))**2. +. (eval(e3,x,y))**2.)/. 2.     (* New Operator *)\n| Thresh(a,b,a_less,b_less) -> \nif eval(a,x,y) < eval(b,x,y)\nthen eval(a_less, x, y)\nelse eval(b_less, x, y)", "bad": "let rec eval (e,x,y) = match e with \n| BuildX()              -> x\n| VarY              -> y\n| Sine(e)          -> sin(pi *. eval(e,x,y))\n| Cosine(e)        -> cos(pi *. eval(e,x,y))\n| Average(e1,e2)   -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.\n| Times(e1,e2)     -> eval(e1,x,y) *. eval(e2,x,y)\n(* | PowerUp(e1,e2)   -> (abs(eval(e1,x,y))) ** (abs(eval(e2,x,y))) *)\n| Square2(e1,e2,e3)-> sqrt((eval(e1,x,y))**2. +. (eval(e2,x,y))**2. +. (eval(e3,x,y))**2.)/. 2.     (* New Operator *)\n| Thresh(a,b,a_less,b_less) -> \nif eval(a,x,y) < eval(b,x,y)\nthen eval(a_less, x, y)\nelse eval(b_less, x, y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| BuildX()              -> x\n| VarY              -> y\n| Sine(e)          -> sin(pi *. eval(e,x,y))\n| Cosine(e)        -> cos(pi *. eval(e,x,y))\n| Average(e1,e2)   -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.\n| Times(e1,e2)     -> eval(e1,x,y) *. eval(e2,x,y)\n(* | PowerUp(e1,e2)   -> (abs(eval(e1,x,y))) ** (abs(eval(e2,x,y))) *)\n| Square2(e1,e2,e3)-> sqrt((eval(e1,x,y))**2. +. (eval(e2,x,y))**2. +. (eval(e3,x,y))**2.)/. 2.     (* New Operator *)\n| Thresh(a,b,a_less,b_less) -> \nif eval(a,x,y) < eval(b,x,y)\nthen eval(a_less, x, y)\nelse eval(b_less, x, y)"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX              -> x\n| VarY              -> y\n| Sine(e)          -> sin(pi *. eval(e,x,y))\n| Cosine(e)        -> cos(pi *. eval(e,x,y))\n| Average(e1,e2)   -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.\n| Times(e1,e2)     -> eval(e1,x,y) *. eval(e2,x,y)\n(* | PowerUp(e1,e2)   -> (abs(eval(e1,x,y))) ** (abs(eval(e2,x,y))) *)\n| Square2(e1,e2,e3)-> sqrt((eval(e1,x,y))**2. +. (eval(e2,x,y))**2. +. (eval(e3,x,y))**2.)/. 2.     (* New Operator *)\n| Thresh(a,b,a_less,b_less) -> \nif eval(a,x,y) < eval(b,x,y)\nthen eval(a_less, x, y)\nelse eval(b_less, x, y)", "bad": "eval (Times(VarX,VarY), 0.5, -0.5)", "annotated": "eval (Times(VarX,VarY), 0.5, -0.5)"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX              -> x\n| VarY              -> y\n| Sine(e)          -> sin(pi *. eval(e,x,y))\n| Cosine(e)        -> cos(pi *. eval(e,x,y))\n| Average(e1,e2)   -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.\n| Times(e1,e2)     -> eval(e1,x,y) *. eval(e2,x,y)\n(* | PowerUp(e1,e2)   -> (abs(eval(e1,x,y))) ** (abs(eval(e2,x,y))) *)\n| Square2(e1,e2,e3)-> sqrt((eval(e1,x,y))**2. +. (eval(e2,x,y))**2. +. (eval(e3,x,y))**2.)/. 2.     (* New Operator *)\n| Thresh(a,b,a_less,b_less) -> \nif eval(a,x,y) < eval(b,x,y)\nthen eval(a_less, x, y)\nelse eval(b_less, x, y)", "bad": "eval (Cosine(Times(VarX,VarY)), 0.5,-0.5)", "annotated": "eval (Cosine(Times(VarX,VarY)), 0.5,-0.5)"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX              -> x\n| VarY              -> y\n| Sine(e)          -> sin(pi *. eval(e,x,y))\n| Cosine(e)        -> cos(pi *. eval(e,x,y))\n| Average(e1,e2)   -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.\n| Times(e1,e2)     -> eval(e1,x,y) *. eval(e2,x,y)\n(* | PowerUp(e1,e2)   -> (abs(eval(e1,x,y))) ** (abs(eval(e2,x,y))) *)\n| Square2(e1,e2,e3)-> sqrt((eval(e1,x,y))**2. +. (eval(e2,x,y))**2. +. (eval(e3,x,y))**2.)/. 2.     (* New Operator *)\n| Thresh(a,b,a_less,b_less) -> \nif eval(a,x,y) < eval(b,x,y)\nthen eval(a_less, x, y)\nelse eval(b_less, x, y)", "bad": "eval (Sine(Average(VarX,VarY)), 0.5, -0.5)", "annotated": "eval (Sine(Average(VarX,VarY)), 0.5, -0.5)"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX              -> x\n| VarY              -> y\n| Sine(e)          -> sin(pi *. eval(e,x,y))\n| Cosine(e)        -> cos(pi *. eval(e,x,y))\n| Average(e1,e2)   -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.\n| Times(e1,e2)     -> eval(e1,x,y) *. eval(e2,x,y)\n(* | PowerUp(e1,e2)   -> (abs(eval(e1,x,y))) ** (abs(eval(e2,x,y))) *)\n| Square2(e1,e2,e3)-> sqrt((eval(e1,x,y))**2. +. (eval(e2,x,y))**2. +. (eval(e3,x,y))**2.)/. 2.     (* New Operator *)\n| Thresh(a,b,a_less,b_less) -> \nif eval(a,x,y) < eval(b,x,y)\nthen eval(a_less, x, y)\nelse eval(b_less, x, y)", "bad": "eval (Sine(Average(VarX,VarY)), 0.3 ,0.3)", "annotated": "eval (Sine(Average(VarX,VarY)), 0.3 ,0.3)"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX              -> x\n| VarY              -> y\n| Sine(e)          -> sin(pi *. eval(e,x,y))\n| Cosine(e)        -> cos(pi *. eval(e,x,y))\n| Average(e1,e2)   -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.\n| Times(e1,e2)     -> eval(e1,x,y) *. eval(e2,x,y)\n(* | PowerUp(e1,e2)   -> (abs(eval(e1,x,y))) ** (abs(eval(e2,x,y))) *)\n| Square2(e1,e2,e3)-> sqrt((eval(e1,x,y))**2. +. (eval(e2,x,y))**2. +. (eval(e3,x,y))**2.)/. 2.     (* New Operator *)\n| Thresh(a,b,a_less,b_less) -> \nif eval(a,x,y) < eval(b,x,y)\nthen eval(a_less, x, y)\nelse eval(b_less, x, y)", "bad": "eval (sampleExpr1,0.5,0.2)", "annotated": "eval (sampleExpr1,0.5,0.2)"}
{"fix": "let pipe fs = \nlet f a x = x (a+1) in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = [fs a] in\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = [fs a] in\nlet base = 0 in\nList.fold_left f base fs"}
{"fix": "let rec wwhile (f,b) = \nlet ( a , b ) = (f b) in\n5", "bad": "let rec wwhile (f,b) = \nlet ( a , b ) = f b in\nif b then wwhile f a else a", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet ( a , b ) = f b in\nif b then wwhile f a else a"}
{"fix": "let rec wwhile (f,b) = \nlet ( a , b ) = (f b) in\n5", "bad": "let rec wwhile (f,b) = \nlet ( a , b ) = (f b) in\nif b then wwhile f a else a", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet ( a , b ) = (f b) in\nif b then wwhile f a else a"}
{"fix": "let rec wwhile (f,b) = \nlet ( a , b ) = (f b) in\n5", "bad": "let rec wwhile (f,b) = \nlet ( a , b ) = (f b) in\nif b then wwhile (f a) else a", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet ( a , b ) = (f b) in\nif b then wwhile (f a) else a"}
{"fix": "let rec wwhile (f,b) = \nlet ( b' , c' ) = f b in\nif c' then wwhile ( f, b' ) else b'", "bad": "let rec wwhile (f,b) = \nlet ( b' , c' ) = (f b) in\nif c' then f b' else b'", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet ( b' , c' ) = (f b) in\nif c' then f b' else b'"}
{"fix": "let rec wwhile (f,b) = \nlet ( b' , c' ) = f b in\nif c' then wwhile ( f, b' ) else b'", "bad": "let rec wwhile (f,b) = \nlet ( b' , c' ) = (f b) in\nif c' then wwhile (f b') else b'", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet ( b' , c' ) = (f b) in\nif c' then wwhile (f b') else b'"}
{"fix": "let rec wwhile (f,b) = \nlet ( b' , c' ) = f b in\nif c' then wwhile ( f, b' ) else b'", "bad": "let rec wwhile (f,b) = \nlet ( b' , c' ) = f b in\nif c' then wwhile f b' else b'", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet ( b' , c' ) = f b in\nif c' then wwhile f b' else b'"}
{"fix": "let fixpoint (f,b) = \nlet rec helper (f, b) =\nlet b' = f b in\nif b' = b then b' else helper (f, b')\nin helper (f, b)", "bad": "let fixpoint (f,b) = \nlet rec helper (f, b) =\nlet b' = f b in\nif b' = b then b' else helper (f, b')", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet rec helper (f, b) =\nlet b' = f b in\nif b' = b then b' else helper (f, b')"}
{"fix": "let _ = fixpoint (collatz, 9349802374897001)", "bad": "let _ = fixpoint (collatz, 93rew001)", "annotated": "let _ = fixpoint (collatz, 93rew001)"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e' x y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval e' x y ) )\n| Average ( e1, e2 )\n-> (( eval e1 x y ) +. ( eval e2 x y )) /. 2\n| Times ( e1, e2 )\n-> ( eval e1 x y ) *. ( eval e2 x y )\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e' x y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval e' x y ) )\n| Average ( e1, e2 )\n-> (( eval e1 x y ) +. ( eval e2 x y )) /. 2\n| Times ( e1, e2 )\n-> ( eval e1 x y ) *. ( eval e2 x y )\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) )\n| Cosine e'\n-> cos ( pi *. ( eval e' x y ) )\n| Average ( e1, e2 )\n-> (( eval e1 x y ) +. ( eval e2 x y )) /. 2\n| Times ( e1, e2 )\n-> ( eval e1 x y ) *. ( eval e2 x y )\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) )\n| Cosine e'\n-> cos ( pi *. ( eval e' x y ) )\n| Average ( e1, e2 )\n-> (( eval e1 x y ) +. ( eval e2 x y )) /. 2\n| Times ( e1, e2 )\n-> ( eval e1 x y ) *. ( eval e2 x y )\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval e' x y ) )\n| Average ( e1, e2 )\n-> (( eval e1 x y ) +. ( eval e2 x y )) /. 2\n| Times ( e1, e2 )\n-> ( eval e1 x y ) *. ( eval e2 x y )\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval e' x y ) )\n| Average ( e1, e2 )\n-> (( eval e1 x y ) +. ( eval e2 x y )) /. 2\n| Times ( e1, e2 )\n-> ( eval e1 x y ) *. ( eval e2 x y )\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2\n| Times ( e1, e2 )\n-> ( eval e1 x y ) *. ( eval e2 x y )\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2\n| Times ( e1, e2 )\n-> ( eval e1 x y ) *. ( eval e2 x y )\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval e1 x y ) *. ( eval e2 x y )\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval e1 x y ) *. ( eval e2 x y )\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a x y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b x y ) then eval ( a_less x y ) else eval ( b_less x y )"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )"}
{"fix": "let _ = eval (Average(VarX,VarY)), 5.0, 10.0", "bad": "let _ = eval (sampleExpr1,0.5,0.2)", "annotated": "let _ = eval (sampleExpr1,0.5,0.2)"}
{"fix": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "bad": "let _ = eval ((Average(VarX,VarY)), 5.0, 10.0 )", "annotated": "let _ = eval ((Average(VarX,VarY)), 5.0, 10.0 )"}
{"fix": "let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")", "bad": "let _ = eval sampleExpr 0.5 0.2", "annotated": "let _ = eval sampleExpr 0.5 0.2"}
{"fix": "let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\")", "bad": "let _ = eval( sampleExpr, 0.5, 0.2 )", "annotated": "let _ = eval( sampleExpr, 0.5, 0.2 )"}
{"fix": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )\n| Factorial e'\n-> factorial( eval( e', x, y ), 1 )\n| Sum3( e1, e2, e3 )\n-> eval( e1, x, y ) +. eval( e2, x, y ) +. eval( e3, x, y )", "bad": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )\n| Factorial e'\n-> factorial( eval( e' ), 1 )\n| Sum3( e1, e2, e3 )\n-> eval( e1 ) +. eval( e2 ) +. eval( e3 )", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )\n| Factorial e'\n-> factorial( eval( e' ), 1 )\n| Sum3( e1, e2, e3 )\n-> eval( e1 ) +. eval( e2 ) +. eval( e3 )"}
{"fix": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )\n| Factorial e'\n-> factorial( eval( e', x, y ), 1 )\n| Sum3( e1, e2, e3 )\n-> eval( e1, x, y ) +. eval( e2, x, y ) +. eval( e3, x, y )", "bad": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )\n| Factorial e'\n-> factorial (eval( e', x, y )) 1.0 \n| Sum3( e1, e2, e3 )\n-> eval( e1, x, y ) +. eval( e2, x, y ) +. eval( e3, x, y )", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t\t\t\t\n-> x\n| VarY\n-> y\n| Sine e'\n-> sin ( pi *. ( eval (e', x, y ) ) )\n| Cosine e'\n-> cos ( pi *. ( eval (e', x, y ) ) )\n| Average ( e1, e2 )\n-> (( eval( e1, x, y ) ) +. ( eval( e2, x, y ))) /. 2.0\n| Times ( e1, e2 )\n-> ( eval( e1, x, y )) *. ( eval( e2, x, y ))\n| Thresh ( a, b, a_less, b_less )\n-> if eval ( a, x ,y ) < eval ( b, x, y ) then eval ( a_less, x, y ) else eval ( b_less, x, y )\n| Factorial e'\n-> factorial (eval( e', x, y )) 1.0 \n| Sum3( e1, e2, e3 )\n-> eval( e1, x, y ) +. eval( e2, x, y ) +. eval( e3, x, y )"}
{"fix": "let _ = eval (Factorial(VarX), 5.0, 4.0 )", "bad": "let _ = eval (Factorial(VarX), 5.0, 0.0 )", "annotated": "let _ = eval (Factorial(VarX), 5.0, 0.0 )"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x))", "bad": "let fixpoint (f,b) = wwhile ( (f, ( b, ( f b ) = b ))), b", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ( (f, ( b, ( f b )  ->  b ))), b"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x))", "bad": "let fixpoint (f,b) = wwhile ( f b, b )", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( f b, b )"}
{"fix": "let fixpoint (f,b) = wwhile ( (f b) = b , b )", "bad": "let fixpoint (f,b) = wwhile ( (f b), b )", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( (f b), b )"}
{"fix": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )", "bad": "let fixpoint (f,b) = wwhile ( f, (f b) = b , b )", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ( f, (f b)  ->  b , b )"}
{"fix": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )", "bad": "let fixpoint (f,b) = wwhile ( \nlet f' b' = let xx = f b in ( b' = b ) \n, b )", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( \nlet f' b' = let xx = f b in ( b' = b ) \n, b )"}
{"fix": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )", "bad": "let fixpoint (f,b) = wwhile ( \nlet f' b' = f b in ( b' = b ) \n, b )", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( \nlet f' b' = f b in ( b' = b ) \n, b )"}
{"fix": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )", "bad": "let fixpoint (f,b) = wwhile ( \nlet b' = f b in ( b' = b ) \n, b )", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( \nlet b' = f b in ( b' = b ) \n, b )"}
{"fix": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )", "bad": "let fixpoint (f,b) = wwhile ( \nlet f x = let xx = x*x*x in (xx, xx < 512) in wwhile (f,2)\n, b )", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( \nlet f x = let xx = x*x*x in (xx, xx < 512) in wwhile (f,2)\n, b )"}
{"fix": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )", "bad": "let fixpoint (f,b) = wwhile ( \nlet f x = let xx = x*x*x in (xx, xx < 512)\n, b )", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( \nlet f x = let xx = x*x*x in (xx, xx < 512)\n, b )"}
{"fix": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )", "bad": "let fixpoint (f,b) = wwhile ( \nlet f x = let xx = x*x*x in (xx, xx < 512)\n, b )", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( \nlet f x = let xx = x*x*x in (xx, xx < 512)\n, b )"}
{"fix": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )", "bad": "let fixpoint (f,b) = wwhile ( \nlet f x = x*x*x in (xx, xx < 512)\n, b )", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( \nlet f x = x*x*x in (xx, xx < 512)\n, b )"}
{"fix": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )", "bad": "let fixpoint (f,b) = wwhile ( \nlet f x = let xx = x*x*x in (xx, xx < 512)\n, b )", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( \nlet f x = let xx = x*x*x in (xx, xx < 512)\n, b )"}
{"fix": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )", "bad": "let fixpoint (f,b) = wwhile ( \nlet f' x = let xx = x*x*x in (xx, xx < 512)\n, b )", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( \nlet f' x = let xx = x*x*x in (xx, xx < 512)\n, b )"}
{"fix": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )", "bad": "let fixpoint (f,b) = wwhile ( \nlet b' = f b in ( f, b' = b)\n, b )", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( \nlet b' = f b in ( f, b' = b)\n, b )"}
{"fix": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )", "bad": "let fixpoint (f,b) =  \nlet b' = f b in wwhile( ( f, b' = b)\n, b )", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->   \nlet b' = f b in wwhile( ( f, b' = b)\n, b )"}
{"fix": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )", "bad": "let fixpoint (f,b) =  \nlet b' = f b in wwhile( ( f , b' = b)\n, b )", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->   \nlet b' = f b in wwhile( ( f , b' = b)\n, b )"}
{"fix": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )", "bad": "let fixpoint (f,b) =  \nlet b' = f b in wwhile( f , b' = b\n, b )", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->   \nlet b' = f b in wwhile( f , b' = b\n, b )"}
{"fix": "let fixpoint (f,b) = wwhile ( \nlet f' b' = ( f, b = b' ) in f b\n, b )", "bad": "let fixpoint (f,b) = wwhile ( \nlet f' b' = f b in ( f', b' = b )\n, b )", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( \nlet f' b' = f b in ( f', b' = b )\n, b )"}
{"fix": "let fixpoint (f,b) = wwhile ( \nlet f' b' = ( f, b = b' ) in f b\n, b )", "bad": "let fixpoint (f,b) = wwhile ( \nlet b' = f b in ( f, b' = b )\n, b )", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( \nlet b' = f b in ( f, b' = b )\n, b )"}
{"fix": "let fixpoint (f,b) = wwhile ( \nlet f' b' = ( f, b = b' ) in f b\n, b )", "bad": "let fixpoint (f,b) = wwhile ( \nlet b' = f b in ( f, (b' = b) )\n, b )", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( \nlet b' = f b in ( f, (b' = b) )\n, b )"}
{"fix": "let fixpoint (f,b) = wwhile ( \nlet f' b' = ( f, b = b' ) in f b\n, b )", "bad": "let fixpoint (f,b) = wwhile ( \nlet f' b' = ( f b, b = b' )\n, b )", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( \nlet f' b' = ( f b, b = b' )\n, b )"}
{"fix": "let fixpoint (f,b) = wwhile ( \nlet f' b' = ( f, b = b' ) in f b\n, b )", "bad": "let fixpoint (f,b) = wwhile ( \nlet f' b' = ( f b, b = b' ) in f b\n, b )", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( \nlet f' b' = ( f b, b = b' ) in f b\n, b )"}
{"fix": "let fixpoint (f,b) = wwhile ( \nlet f' = ( f, b = f b ) in f b\n, b )", "bad": "let fixpoint (f,b) = wwhile ( \nlet f' b' = ( f, b = b' ) in f b\n, b )", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( \nlet f' b' = ( f, b = b' ) in f b\n, b )"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 512)", "bad": "let f x = let xx = x*x*x in (xx, xx < 512) in wwhile (f,2)", "annotated": "let f x = let xx = x*x*x in (xx, xx < 512) in wwhile (f,2)"}
{"fix": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = fs a in\nlet base = fs x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fs a in\nlet base = fs x in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = fs a in\nlet base = fs in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fs a in\nlet base = fs in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = fs a x in\nlet base = fs a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fs a x in\nlet base = fs a in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = fs a x in\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fs a x in\nlet base = 0 in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = fs a in\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fs a in\nlet base = 0 in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = fs x in\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fs x in\nlet base = 0 in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = 0 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = [] in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = [] in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = [] in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = [] in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = 'a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = 'a in\nList.fold_left f base fs"}
{"fix": "let _ = pipe [] 3", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs y = \nlet f a x = x a in\nlet base = y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x  in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x  in\nlet base = fun x -> x  in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x  in\nlet base = fun x -> x  in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x  in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a + x a in\nlet base = fun x -> x  in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a + x a in\nlet base = fun x -> x  in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x  in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x + x a in\nlet base = fun x -> x  in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x + x a in\nlet base = fun x -> x  in\nList.fold_left f base fs"}
{"fix": "let pipe fs y = \nlet f a x = x a in\nlet base = y  in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs y = \nlet f a x = x a in\nlet base = y  in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a -> x in\nlet base = fun x -> x  in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a -> x in\nlet base = fun x -> x  in\nList.fold_left f base fs"}
{"fix": "let pipe fs y = \nlet f a x = x a in\nlet base = y  in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x', y -> x a + a", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x', y -> x a + a"}
{"fix": "let pipe fs y = \nlet f a x = x a in\nlet base = y  in\nList.fold_left f base fs", "bad": "let base = fun x -> x  in\nList.fold_left f base fs", "annotated": "let base = fun x -> x  in\nList.fold_left f base fs"}
{"fix": "let pipe fs y = \nlet f a x = x a in\nlet base = y  in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x' y -> x a + a", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x' y -> x a + a"}
{"fix": "let pipe fs y = \nlet f a x = x a in\nlet base = y  in\nList.fold_left f base fs", "bad": "let base = fun x -> x  in\nList.fold_left f base fs", "annotated": "let base = fun x -> x  in\nList.fold_left f base fs"}
{"fix": "let pipe fs y = \nlet f a x = x a in\nlet base = y  in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x' y -> x a + a", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x' y -> x a + a"}
{"fix": "let pipe fs y = \nlet f a x = x a in\nlet base = y  in\nList.fold_left f base fs", "bad": "let base = fun x -> x  in\nList.fold_left f base fs", "annotated": "let base = fun x -> x  in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x a  in\nlet base = fun x -> x  in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x y -> y+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x y -> y+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x a  in\nlet base = fun x -> x  in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x y -> y+x); (fun x y -> x + y)] 3", "annotated": "let _ = pipe [(fun x y -> y+x); (fun x y -> x + y)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x a  in\nlet base = fun x -> x  in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x' y -> x a + a in\nlet base = fun x -> x  in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x' y -> x a + a in\nlet base = fun x -> x  in\nList.fold_left f base fs"}
{"fix": "let _ = pipe [(fun x -> x ^ \", \" ^ x); (fun x -> x ^ \", \" ^ x ^ \"!\")] \"corn\"", "bad": "let _ = pipe [(fun x -> x ^ \", \" ^ x); (fun x -> x ^ \", \" ^ x ^ \"!\")] corn", "annotated": "let _ = pipe [(fun x -> x ^ \", \" ^ x); (fun x -> x ^ \", \" ^ x ^ \"!\")] corn"}
{"fix": "let cat = pipe []", "bad": "let _ = pipe [(fun x -> x ^ \", \" ^ x); (fun x -> x ^ \", \" ^ x ^ \"!\")] \"corn\"", "annotated": "let _ = pipe [(fun x -> x ^ \", \" ^ x); (fun x -> x ^ \", \" ^ x ^ \"!\")] \"corn\""}
{"fix": "let cat = pipe []", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let cat = pipe []", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep ^ a in\nlet base = sepConcat sep t in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep ^ a in\nlet base = \"\" in\nlet l = sepConcat sep t in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep ^ a in\nlet base = \"\" in\nlet l = sepConcat sep t in\nList.fold_left f base l"}
{"fix": "let stringOfList f l = match l with\n[] -> \"\"\n| h::t -> \nlet f' a x = x ^ a in\nlet base = f h in\nlet l = t in\nList.fold_left f' base l", "bad": "let stringOfList f l = match l with\n[] -> \"\"\n| h::t -> f h ^ stringOfList f t", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  match l with\n[] -> \"\"\n| h::t -> f h ^ stringOfList f t"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fs a in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fs a in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fs in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fs in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fun x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun y -> y in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun y -> y in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a -> x in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a -> x in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun y -> y in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a + x in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a + x in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun y -> y in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x + x in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x + x in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun y -> y in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x -> a -> x in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x -> a -> x in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun y -> y in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun y -> y in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun y -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun y -> a in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun y-> y in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun -> a in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun y -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (a,x) in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (a,x) in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun y -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun y -> fun x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun y -> fun x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let _ = pipe [] 3", "bad": "let cat = pipe [(fun x -> x + x )] 3", "annotated": "let cat = pipe [(fun x -> x + x )] 3"}
{"fix": "clone 0 5", "bad": "List.append clone 0 5 a", "annotated": "List.append clone 0 5 a"}
{"fix": "clone 0 5", "bad": "List.append clone( 0 5 ) a", "annotated": "List.append clone( 0 5 ) a"}
{"fix": "let rec padZero l1 l2 = \nlet diffsize = List.length l1 - List.length l2 in\nif diffsize > 0 then\n( l1, List.append (clone 0 diffsize) l2 )\nelse\n( (List.append (clone 0 ((List.length l1) - (List.length l2))) l1),  l2 )", "bad": "let rec padZero l1 l2 = \nif List.length l1 > List.length l2 then\n( l1, List.append (clone 0 ((List.length l1) - (List.length l2))), l2 )\nelse if List.length l1 < List.length l2 then\n( (List.append (clone 0 ((List.length l1) - (List.length l2))) l1),  l2 )\nelse\n( l1, l2 )", "annotated": "let rec padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 > List.length l2 then\n( l1, List.append (clone 0 ((List.length l1) - (List.length l2))), l2 )\nelse if List.length l1 < List.length l2 then\n( (List.append (clone 0 ((List.length l1) - (List.length l2))) l1),  l2 )\nelse\n( l1, l2 )"}
{"fix": "let rec padZero l1 l2 = \nlet diffsize = List.length l1 - List.length l2 in\nif diffsize > 0 then\n( l1, List.append (clone 0 diffsize) l2 )\nelse\n( List.append (clone 0 ( -1 * diffsize )) l1,  l2 )", "bad": "let rec padZero l1 l2 = \nlet diffsize = List.length l1 - List.length l2 in\nif diffsize > 0 then\n( l1, List.append (clone 0 diffsize) l2 )\nelse\n( List.append clone 0 ( -1 * diffsize ) l1,  l2 )", "annotated": "let rec padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet diffsize = List.length l1 - List.length l2 in\nif diffsize > 0 then\n( l1, List.append (clone 0 diffsize) l2 )\nelse\n( List.append clone 0 ( -1 * diffsize ) l1,  l2 )"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1::t1, h2::t2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [0] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1::t1, h2::t2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [0] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1::t1, h2::t2) -> ( [], ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a )\n| _ -> ( [], a )\nin\nlet base = [0] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1::t1, h2::t2) -> ( [], ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a )\n| _ -> ( [], a )\nin\nlet base = [0] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1::t1, h2::t2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [0] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1::t1, h2::t2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [0] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1::t1, h2::t2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [0] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1::t1, h2::t2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [0] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = ([],[]) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = ([],[]) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = ([],[]) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = ([],[]) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> (removeZero (((h1 + h2) / 10 )::(( h1 + h2) mod 10 ))) :: a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> (removeZero (((h1 + h2) / 10 )::(( h1 + h2) mod 10 ))) :: a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> (removeZero (((h1 + h2) / 10 )::[(( h1 + h2) mod 10 )])) :: a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> (removeZero (((h1 + h2) / 10 )::[(( h1 + h2) mod 10 )])) :: a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (x1, x2) -> match a with\n(h1, h2::t2) -> let sum = x1 + x2 + h2 in\n( ( sum / 10 ) , sum::( sum mod 10 )::t2)\nin\nlet base = (0,[0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (x1, x2) -> match a with\n(_, h2::t2) ->\n( ((x1 + x2 + h2) / 10 ) , (x1 + x2 + h2) / 10 )::(( x1 + x2 + h2 ) mod 10 )::t2", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| (x1, x2) -> match a with\n(_, h2::t2) ->\n( ((x1 + x2 + h2) / 10 ) , (x1 + x2 + h2) / 10 )::(( x1 + x2 + h2 ) mod 10 )::t2"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (x1, x2) -> match a with\n(h1, h2::t2) -> let sum = x1 + x2 + h2 in\n( ( sum / 10 ) , sum::( sum mod 10 )::t2)\nin\nlet base = (0,[0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": ")\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": ")\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigMul l1 l2 = \nlet f a x = match x with\n| (x1, x2) -> match a with\n( h1, h2::t2) -> let mul = x1 * x2 * h1 + h2 in\n( ( h1 + 1 ) , (mul / 10)::( mul mod 10 )::t2)\n| (_,_) -> (0,[0]) in\nlet base = (1,[0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = match x with\n| (x1, x2) -> match a with\n( h1, h2::t2) -> let mul = x1 * x2 * h1 + h2 in\n( ( h1 + 1 , (mul / 10)::( mul mod 10 )::t2)\n| (_,_) -> (0,[0]) in\nlet base = (1,[0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match x with\n| (x1, x2) -> match a with\n( h1, h2::t2) -> let mul = x1 * x2 * h1 + h2 in\n( ( h1 + 1 , (mul / 10)::( mul mod 10 )::t2)\n| (_,_) -> (0,[0]) in\nlet base = (1,[0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = match x with\n| (x1, x2) -> match a with\n( h1, h2::t2) -> let mul = x1 * x2 * h1 + h2 in\n( ( h1 + 1 ) , (mul / 10)::( mul mod 10 )::t2)\n| (_,_) -> (0,[0]) in\nlet base = (1,[0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = match x with\n| (x1, x2) -> match a with\n( h1, h2::t2) -> let mul = x1 * x2 * h1 + h2 in\n( ( h1 + 1 , (mul / 10))::( mul mod 10 )::t2)\n| (_,_) -> (0,[0]) in\nlet base = (1,[0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match x with\n| (x1, x2) -> match a with\n( h1, h2::t2) -> let mul = x1 * x2 * h1 + h2 in\n( ( h1 + 1 , (mul / 10))::( mul mod 10 )::t2)\n| (_,_) -> (0,[0]) in\nlet base = (1,[0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = match x with\n| (x1, x2) -> match a with\n( h1, h2::t2) -> let mul = x1 * x2 * h1 + h2 in\n( ( h1 + 1 ) , (mul / 10)::( mul mod 10 )::t2)\n| (_,_) -> (0,[0]) in\nlet base = (1,[0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = match x with\n| (x1, x2) -> match a with\n( h1, h2::t2) -> let mul = x1 * x2 * h1 + h2 in\n( ( h1 + 1 , (mul / 10))::(( mul mod 10 )::t2))\n| (_,_) -> (0,[0]) in\nlet base = (1,[0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match x with\n| (x1, x2) -> match a with\n( h1, h2::t2) -> let mul = x1 * x2 * h1 + h2 in\n( ( h1 + 1 , (mul / 10))::(( mul mod 10 )::t2))\n| (_,_) -> (0,[0]) in\nlet base = (1,[0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet ( pos, total ) = a in\n( pos + 1, mulByDigit (int_of_float (10.0 ** float_of_int pos)) l2 ) in \nlet base = (0,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet ( pos, total ) = a in\n( pos + 1, mulByDigit ( 10 ** pos) l2 ) in \nlet base = (0,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet ( pos, total ) = a in\n( pos + 1, mulByDigit ( 10 ** pos) l2 ) in \nlet base = (0,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet ( pos, total ) = a in\n( pos + 1, mulByDigit (int_of_float (10.0 ** float_of_int pos)) l2 ) in \nlet base = (0,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet ( pos, total ) = a in\n( pos + 1, mulByDigit ( 10.0 ** pos) l2 ) in \nlet base = (0,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet ( pos, total ) = a in\n( pos + 1, mulByDigit ( 10.0 ** pos) l2 ) in \nlet base = (0,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet ( pos, total ) = a in\n( pos + 1, mulByDigit (int_of_float (10.0 ** float_of_int pos)) l2 ) in \nlet base = (0,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet ( pos, total ) = a in\n( pos + 1, mulByDigit ( 10.0 ** float_of_int pos) l2 ) in \nlet base = (0,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet ( pos, total ) = a in\n( pos + 1, mulByDigit ( 10.0 ** float_of_int pos) l2 ) in \nlet base = (0,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let rec sumList xs = \nif xs = [] then 0\nelse let h::t = xs in\nh + (sumList t)", "bad": "let rec sumList xs = \nif (hd xs) = [] then 0\nelse let h::t = xs in\nh + (sumList t)", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nif (hd xs) = [] then 0\nelse let h::t = xs in\nh + (sumList t)"}
{"fix": "let rec sumList xs = \nif xs = [] then 0\nelse let h::t = xs in\nh + (sumList t)", "bad": "let rec sumList xs = \nif (xs hd xs) = [] then 0\nelse let h::t = xs in\nh + (sumList t)", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nif (xs hd xs) = [] then 0\nelse let h::t = xs in\nh + (sumList t)"}
{"fix": "let rec sumList xs = \nif xs = [] then 0\nelse let h::t = xs in\nh + (sumList t)", "bad": "let rec sumList xs = \nif (List.hd xs) = [] then 0\nelse let h::t = xs in\nh + (sumList t)", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nif (List.hd xs) = [] then 0\nelse let h::t = xs in\nh + (sumList t)"}
{"fix": "let rec digitsOfInt n = \nif (n mod 2 = 0) & (n > 0) then\nlet rec loop input =\nif input = 0 then []\nelse (loop (input / 10))@[(input mod 10)]\nin (loop n)\nelse []", "bad": "let rec digitsOfInt n = \nif (n mod 2 = 0) and (n > 0) then\nlet rec loop input =\nif input = 0 then []\nelse (loop (input / 10))@[(input mod 10)]\nin (loop n)\nelse []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif (n mod 2 = 0) and (n > 0) then\nlet rec loop input =\nif input = 0 then []\nelse (loop (input / 10))@[(input mod 10)]\nin (loop n)\nelse []"}
{"fix": "let rec additivePersistence n = \nif (n / 10) = 0 then n\nelse additivePersistence (sumList (digits n))", "bad": "let rec additivePersistence n = \nif (n / 10) = 0 then n\nelse additivePersistence (sumList digits n)", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif (n / 10) = 0 then n\nelse additivePersistence (sumList digits n)"}
{"fix": "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if ((List.tl lst) = lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false", "bad": "let palindrome w = \nif (List.hd w) = (List.tl w) then\nlet b::rest = w in\nlet c @ (x::[]) = rest in\npalindrome x", "annotated": "let palindrome : string -> bool = fun  w  ->  \nif (List.hd w) = (List.tl w) then\nlet b::rest = w in\nlet c @ (x::[]) = rest in\npalindrome x"}
{"fix": "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if ((List.tl lst) = lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false", "bad": "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.size lst) < 2 then []\nelse if (List.hd lst) = (List.tl lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.size (palHelper wEx)) = 0 then true\nelse false", "annotated": "let palindrome : string -> bool = fun  w  ->  \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.size lst) < 2 then []\nelse if (List.hd lst) = (List.tl lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.size (palHelper wEx)) = 0 then true\nelse false"}
{"fix": "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if ((List.tl lst) = lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false", "bad": "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if (List.hd lst) = (List.tl lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false", "annotated": "let palindrome : string -> bool = fun  w  ->  \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if (List.hd lst) = (List.tl lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false"}
{"fix": "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if ((List.tl lst) = lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false", "bad": "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if (List.hd lst) = (List.tl lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false", "annotated": "let palindrome : string -> bool = fun  w  ->  \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if (List.hd lst) = (List.tl lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false"}
{"fix": "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if ((List.tl lst) = lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false", "bad": "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if (List.tl lst) = (List.hd lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false", "annotated": "let palindrome : string -> bool = fun  w  ->  \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if (List.tl lst) = (List.hd lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false"}
{"fix": "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if ((List.tl lst) = lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false", "bad": "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if (List.tl lst) == (List.hd lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false", "annotated": "let palindrome : string -> bool = fun  w  ->  \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if (List.tl lst) == (List.hd lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false"}
{"fix": "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if ((List.tl lst) = lst) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false", "bad": "let palindrome w = \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if ((List.tl lst) = (List.hd lst)) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false", "annotated": "let palindrome : string -> bool = fun  w  ->  \nlet wEx = explode w in\nlet rec palHelper lst =\nif (List.length lst) < 2 then []\nelse if ((List.tl lst) = (List.hd lst)) then\nlet b::rest = lst in\nlet b2::rest2 = listReverse rest in\npalHelper rest2\nelse [1]\nin\nif (List.length (palHelper wEx)) = 0 then true\nelse false"}
{"fix": "let rec digitsOfInt n = \nif (n mod 2 = 0) && (n > 0) then\nlet rec loop input =\nif input < 10 then [input]\nelse let [y] = (loop (input / 10)) in\ny::[(input mod 10)]\nin loop n\nelse []", "bad": "let rec digitsOfInt n = \nif (n mod 2 = 0) && (n > 0) then\nlet rec loop input =\nif input < 10 then input\nelse (loop (input / 10))::[(input mod 10)]\nin (loop n)\nelse []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif (n mod 2 = 0) && (n > 0) then\nlet rec loop input =\nif input < 10 then input\nelse (loop (input / 10))::[(input mod 10)]\nin (loop n)\nelse []"}
{"fix": "let fixpoint (f,b) = \nlet y = (f b) in match y with\n| (aPrime, _) -> \nif b = aPrime then b\nelse fixpoint (f, aPrime)", "bad": "let fixpoint (f,b) = \nif b = (f b) then b\nelse fixpoint (f, f b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nif b = (f b) then b\nelse fixpoint (f, f b)"}
{"fix": "let fixpoint (f,b) = \nlet y = (f b) in match y with\n| (aPrime, _) -> \nif b = aPrime then b\nelse fixpoint (f, aPrime)", "bad": "let fixpoint (f,b) = \nlet y = f b in\nif b = y then b\nelse fixpoint (f, y)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet y = f b in\nif b = y then b\nelse fixpoint (f, y)"}
{"fix": "let fixpoint (f,b) = \nlet y = (f b) in match y with\n| (aPrime, _) -> \nif b = aPrime then b\nelse fixpoint (f, aPrime)", "bad": "let fixpoint (f,b) = \nlet y = f b in\nif b = y then b\nelse fixpoint (f, y)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet y = f b in\nif b = y then b\nelse fixpoint (f, y)"}
{"fix": "let fixpoint (f,b) = \nlet y = (f b) in match y with\n| (aPrime, _) -> \nif b = aPrime then b\nelse fixpoint (f, aPrime)", "bad": "let fixpoint (f,b) = \nlet y = (f b) in\nif b = y then b\nelse fixpoint (f, y)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet y = (f b) in\nif b = y then b\nelse fixpoint (f, y)"}
{"fix": "let fixpoint (f,b) = \nlet y = (f b) in match y with\n| (aPrime, _) -> \nif b = aPrime then b\nelse fixpoint (f, aPrime)", "bad": "let fixpoint (f,b) = \nlet y = (f b) in match y with\n| aPrime -> \nif b = aPrime then b\nelse fixpoint (f, aPrime)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet y = (f b) in match y with\n| aPrime -> \nif b = aPrime then b\nelse fixpoint (f, aPrime)"}
{"fix": "let rec eval (e,x,y) = match e with\n| Thresh (e1,e2,e3,e4) ->\nif (eval (e1,x,y)) < (eval (e2,x,y))\nthen (eval (e3,x,y))\nelse (eval (e4,x,y))\n| Times (e1,e2) -> (eval (e1,x,y)) *. (eval (e2,x,y))\n| Average (e1,e2) -> ( (eval (e1,x,y)) +. (eval (e2,x,y)) ) /. 2.0\n| Cosine (e1) -> cos ( 3.142 *. (eval (e1,x,y)) )\n| Sine (e1) -> sin ( 3.142 *. (eval (e1,x,y)) )\n| VarY -> y\n| VarX -> x", "bad": "let rec eval (e,x,y) = match e with\n| Thresh (e1,e2,e3,e4) ->\nif (eval (e1,x,y)) < (eval (e2,x,y))\nthen (eval (e3,x,y))\nelse (eval (e4,x,y))\n| Times (e1,e2) -> (eval (e1,x,y)) *. (eval (e2,x,y))\n| Average (e1,e2) -> ( (eval (e1,x,y)) +. (eval (e2,x,y)) ) / 2.0\n| Cosine (e1) -> cos ( 3.142 *. (eval (e1,x,y)) )\n| Sine (e1) -> sin ( 3.142 *. (eval (e1,x,y)) )\n| VarY -> y\n| VarX -> x", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (e1,e2,e3,e4) ->\nif (eval (e1,x,y)) < (eval (e2,x,y))\nthen (eval (e3,x,y))\nelse (eval (e4,x,y))\n| Times (e1,e2) -> (eval (e1,x,y)) *. (eval (e2,x,y))\n| Average (e1,e2) -> ( (eval (e1,x,y)) +. (eval (e2,x,y)) ) / 2.0\n| Cosine (e1) -> cos ( 3.142 *. (eval (e1,x,y)) )\n| Sine (e1) -> sin ( 3.142 *. (eval (e1,x,y)) )\n| VarY -> y\n| VarX -> x"}
{"fix": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "bad": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )\nelse if y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )\nelse if y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )"}
{"fix": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "bad": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )\nelse if y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )\nelse if y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )"}
{"fix": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "bad": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )\nelse if y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),build(rand, depth-1), build(rand, depth-1) )", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )\nelse if y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),build(rand, depth-1), build(rand, depth-1) )"}
{"fix": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "bad": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )"}
{"fix": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "bad": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )\nelse if y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )\nelse if y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )"}
{"fix": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in build(rand , y-1)", "bad": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )"}
{"fix": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in build(rand , y-1)", "bad": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif (y = 2) then buildSine( build(rand, depth-1) )", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif (y = 2) then buildSine( build(rand, depth-1) )"}
{"fix": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "bad": "let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in build(rand , y-1) \nif (y = 2) then buildSine( build(rand, depth-1) ) \nelse \nif y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in build(rand , y-1) \nif (y = 2) then buildSine( build(rand, depth-1) ) \nelse \nif y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )"}
{"fix": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "bad": "let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif (y = 2) then buildSine( build(rand, depth-1) ) \nelse \nif y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif (y = 2) then buildSine( build(rand, depth-1) ) \nelse \nif y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )"}
{"fix": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "bad": "let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildX()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildX()"}
{"fix": "let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nbuildX()", "bad": "let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildX()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildX()"}
{"fix": "let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nbuildX()", "bad": "let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y == 2 then buildX()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y == 2 then buildX()"}
{"fix": "let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nbuildX()", "bad": "let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then 5", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then 5"}
{"fix": "let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nbuildX()", "bad": "let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\ny", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\ny"}
{"fix": "let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nbuildX()", "bad": "let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif (y = 2) then y", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif (y = 2) then y"}
{"fix": "let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nbuildX()", "bad": "let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nif (y = 2) then y", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nif (y = 2) then y"}
{"fix": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "bad": "let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nif y = 2 then buildX()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nif y = 2 then buildX()"}
{"fix": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "bad": "let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nif y = 2 then y", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nif y = 2 then y"}
{"fix": "buildX()", "bad": "let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then VarX else VarY\nelse\nlet y = rand(2,6) in\nif y = 2 then y", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0 then\nif rand(0,1) = 0 then VarX else VarY\nelse\nlet y = rand(2,6) in\nif y = 2 then y"}
{"fix": "buildX()", "bad": "let rec build (rand, depth) = \nif depth = 0 then\nif rand (0,1) = 0 then VarX else VarY\nelse\nlet y = rand (2,6) in\nif y = 2 then y", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0 then\nif rand (0,1) = 0 then VarX else VarY\nelse\nlet y = rand (2,6) in\nif y = 2 then y"}
{"fix": "buildX()", "bad": "let rec build (rand, depth) = \nif depth = 0 then\nif rand (0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand (2,6) in\nif y = 2 then y", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0 then\nif rand (0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand (2,6) in\nif y = 2 then y"}
{"fix": "let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in\nbuildX()", "bad": "if depth = 0 then\nif rand (0,1) = 0 then buildX() else buildY()", "annotated": "if depth = 0 then\nif rand (0,1) = 0 then buildX() else buildY()"}
{"fix": "let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in\nbuildX()", "bad": "let rec build (rand, depth) = \nif depth = 0 then\nif rand (0,1) = 0 then buildX() else buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0 then\nif rand (0,1) = 0 then buildX() else buildY()"}
{"fix": "let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in\nbuildX()", "bad": "let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in\nif y = 2 then y", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in\nif y = 2 then y"}
{"fix": "let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in\nbuildX()", "bad": "let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()"}
{"fix": "let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in\nbuildX()", "bad": "let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()"}
{"fix": "let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in match y with\n| 2 -> buildSine( build(rand, depth-1) ) \n| 3 -> buildCosine( build(rand, depth-1) )\n| 4 -> buildAverage( build(rand, depth-1), build(rand, depth-1) )\n| 5 -> buildTimes( build(rand, depth-1), build(rand, depth-1) )\n| 6 -> buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )", "bad": "let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in match y with\n| 2 -> buildSine( build(rand, depth-1) ) \n| 3 -> buildCosine( build(rand, depth-1) )\n| 4 -> buildAverage( build(rand, depth-1), build(rand, depth-1) )\n| 5 -> buildTimes( build(rand, depth-1), build(rand, depth-1) )\n| 6 -> buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )  *", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in match y with\n| 2 -> buildSine( build(rand, depth-1) ) \n| 3 -> buildCosine( build(rand, depth-1) )\n| 4 -> buildAverage( build(rand, depth-1), build(rand, depth-1) )\n| 5 -> buildTimes( build(rand, depth-1), build(rand, depth-1) )\n| 6 -> buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )  *"}
{"fix": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = a (x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a (x a) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = (fun y -> y) in\nList.fold_left f base fs"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = h::t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x =  in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x =  in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l"}
{"fix": "let _ = sepConcat \"X\" [\"hello\"]", "bad": "let _ = sepConcat \"X\" [\"hello\"]\n\nstring_of_int 5", "annotated": "let _ = sepConcat \"X\" [\"hello\"]\n\nstring_of_int 5"}
{"fix": "let _ = sepConcat \"X\" [\"hello\"]", "bad": "let _ = sepConcat \"X\" [\"hello\"]\n\nstring_of_int 5", "annotated": "let _ = sepConcat \"X\" [\"hello\"]\n\nstring_of_int 5"}
{"fix": "let _ = sepConcat \"X\" [\"hello\"]", "bad": "let _ = sepConcat \"X\" [\"hello\"]\n\nstring_of_int [1]", "annotated": "let _ = sepConcat \"X\" [\"hello\"]\n\nstring_of_int [1]"}
{"fix": "let stringOfList f l = sepConcat \"; \" (List.append (\"[\"::List.map f l) [\"]\"])", "bad": "let stringOfList f l = sepConcat \"; \" [\"[\"; List.map f l;\"]\"]", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat \"; \" [\"[\"; List.map f l;\"]\"]"}
{"fix": "let stringOfList f l = sepConcat \"; \" (List.append (\"[\"::List.map f l) [\"]\"])", "bad": "let stringOfList f l = sepConcat \"; \" [[\"[\"]; List.map f l;[\"]\"]]", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat \"; \" [[\"[\"]; List.map f l;[\"]\"]]"}
{"fix": "let stringOfList f l = sepConcat \"; \" (List.append (\"[\"::List.map f l) [\"]\"])", "bad": "let stringOfList f l = sepConcat \"; \" (List.append (\"[\"::List.map f l) \"]\")", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat \"; \" (List.append (\"[\"::List.map f l) \"]\")"}
{"fix": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "bad": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" List.map f l) ^ \"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\" ^ (sepConcat \"; \" List.map f l) ^ \"]\""}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([],r) , acc) -> failwith \"should never reach here\"\n| ((h::[],r), acc) -> (([],0), r::acc)\n| ((h::t,r) , acc) -> \nlet sum = h+x+r in\n((t,sum/10), (sum mod 10)::acc)\nin\nlet (pad1, pad2) = padZero l1 l2 in\nlet base = ((List.rev pad1,0) , []) in\nlet args = (List.rev pad2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1+h2+r) in\nhelper ((sum%10)::acc2) (sum/10) t1 t2)\nin\n(0, helper [] 0 padded1 padded2)\nin\nlet base = [] in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1+h2+r) in\nhelper ((sum%10)::acc2) (sum/10) t1 t2)\nin\n(0, helper [] 0 padded1 padded2)\nin\nlet base = [] in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([],r) , acc) -> failwith \"should never reach here\"\n| ((h::[],r), acc) -> (([],0), r::acc)\n| ((h::t,r) , acc) -> \nlet sum = h+x+r in\n((t,sum/10), (sum mod 10)::acc)\nin\nlet (pad1, pad2) = padZero l1 l2 in\nlet base = ((List.rev pad1,0) , []) in\nlet args = (List.rev pad2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1+h2+r) in\nhelper ((sum % 10)::acc2) (sum/10) t1 t2)\nin\n(0, helper [] 0 padded1 padded2)\nin\nlet base = [] in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1+h2+r) in\nhelper ((sum % 10)::acc2) (sum/10) t1 t2)\nin\n(0, helper [] 0 padded1 padded2)\nin\nlet base = [] in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([],r) , acc) -> failwith \"should never reach here\"\n| ((h::[],r), acc) -> (([],0), r::acc)\n| ((h::t,r) , acc) -> \nlet sum = h+x+r in\n((t,sum/10), (sum mod 10)::acc)\nin\nlet (pad1, pad2) = padZero l1 l2 in\nlet base = ((List.rev pad1,0) , []) in\nlet args = (List.rev pad2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1 + h2 + r) in\nhelper ((sum % 10)::acc2) (sum/10) t1 t2)\nin\n(0, helper [] 0 padded1 padded2)\nin\nlet base = [] in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1 + h2 + r) in\nhelper ((sum % 10)::acc2) (sum/10) t1 t2)\nin\n(0, helper [] 0 padded1 padded2)\nin\nlet base = [] in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([],r) , acc) -> failwith \"should never reach here\"\n| ((h::[],r), acc) -> (([],0), r::acc)\n| ((h::t,r) , acc) -> \nlet sum = h+x+r in\n((t,sum/10), (sum mod 10)::acc)\nin\nlet (pad1, pad2) = padZero l1 l2 in\nlet base = ((List.rev pad1,0) , []) in\nlet args = (List.rev pad2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1 + h2 + r) in\nhelper ((sum mod 10)::acc2) (sum/10) t1 t2)\nin\n(0, helper [] 0 padded1 padded2)\nin\nlet base = [] in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1 + h2 + r) in\nhelper ((sum mod 10)::acc2) (sum/10) t1 t2)\nin\n(0, helper [] 0 padded1 padded2)\nin\nlet base = [] in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([],r) , acc) -> failwith \"should never reach here\"\n| ((h::[],r), acc) -> (([],0), r::acc)\n| ((h::t,r) , acc) -> \nlet sum = h+x+r in\n((t,sum/10), (sum mod 10)::acc)\nin\nlet (pad1, pad2) = padZero l1 l2 in\nlet base = ((List.rev pad1,0) , []) in\nlet args = (List.rev pad2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1 + h2 + r) in\nhelper ((sum mod 10)::acc2) (sum/10) t1 t2)\nin\n(0, helper [] 0 padded1 padded2)\nin\nlet base = (0 , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1 + h2 + r) in\nhelper ((sum mod 10)::acc2) (sum/10) t1 t2)\nin\n(0, helper [] 0 padded1 padded2)\nin\nlet base = (0 , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([],r) , acc) -> failwith \"should never reach here\"\n| ((h::[],r), acc) -> (([],0), r::acc)\n| ((h::t,r) , acc) -> \nlet sum = h+x+r in\n((t,sum/10), (sum mod 10)::acc)\nin\nlet (pad1, pad2) = padZero l1 l2 in\nlet base = ((List.rev pad1,0) , []) in\nlet args = (List.rev pad2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1 + h2 + r) in\nhelper ((sum mod 10)::acc2) (sum/10) t1 t2)\nin\n(0, helper [] 0 padded1 padded2)\nin\nlet base = (0 , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1 + h2 + r) in\nhelper ((sum mod 10)::acc2) (sum/10) t1 t2)\nin\n(0, helper [] 0 padded1 padded2)\nin\nlet base = (0 , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([],r) , acc) -> failwith \"should never reach here\"\n| ((h::[],r), acc) -> (([],0), r::acc)\n| ((h::t,r) , acc) -> \nlet sum = h+x+r in\n((t,sum/10), (sum mod 10)::acc)\nin\nlet (pad1, pad2) = padZero l1 l2 in\nlet base = ((List.rev pad1,0) , []) in\nlet args = (List.rev pad2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1 + h2 + r) in\nhelper ((sum mod 10)::acc2) (sum/10) t1 t2)\nin\n(0, helper [] 0 padded1 padded2)\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1 + h2 + r) in\nhelper ((sum mod 10)::acc2) (sum/10) t1 t2)\nin\n(0, helper [] 0 padded1 padded2)\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([],r) , acc) -> failwith \"should never reach here\"\n| ((h::[],r), acc) -> (([],0), r::acc)\n| ((h::t,r) , acc) -> \nlet sum = h+x+r in\n((t,sum/10), (sum mod 10)::acc)\nin\nlet (pad1, pad2) = padZero l1 l2 in\nlet base = ((List.rev pad1,0) , []) in\nlet args = (List.rev pad2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1 + h2 + r) in\nhelper ((sum mod 10)::acc2) (sum/10) t1 t2)\nin\n([], helper [] 0 padded1 padded2)\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1 + h2 + r) in\nhelper ((sum mod 10)::acc2) (sum/10) t1 t2)\nin\n([], helper [] 0 padded1 padded2)\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([],r) , acc) -> failwith \"should never reach here\"\n| ((h::[],r), acc) -> (([],0), r::acc)\n| ((h::t,r) , acc) -> \nlet sum = h+x+r in\n((t,sum/10), (sum mod 10)::acc)\nin\nlet (pad1, pad2) = padZero l1 l2 in\nlet base = ((List.rev pad1,0) , []) in\nlet args = (List.rev pad2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1 + h2 + r) in\nhelper ((sum mod 10)::acc2) (sum/10) t1 t2)\nin\n([], helper [] 0 (List.rev padded1) (List.rev padded2))\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| (_, acc) -> \nlet (padded1, padded2) = padZero acc x in\nlet rec helper acc2 r lst1 lst2 = match lst1 with\n| [] -> (match r with\n| 0 -> acc2\n| _ -> List.append acc2 [r])\n| h1::t1 -> (match lst2 with\n| [] -> failwith \"Should never reach here!\"\n| h2::t2 -> let sum = (h1 + h2 + r) in\nhelper ((sum mod 10)::acc2) (sum/10) t1 t2)\nin\n([], helper [] 0 (List.rev padded1) (List.rev padded2))\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([],r) , acc) -> failwith \"should never reach here\"\n| ((h::[],r), acc) -> (([],0), r::acc)\n| ((h::t,r) , acc) -> \nlet sum = h+x+r in\n((t,sum/10), (sum mod 10)::acc)\nin\nlet (pad1, pad2) = padZero l1 l2 in\nlet base = ((List.rev pad1,0) , []) in\nlet args = (List.rev pad2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet g = \n(fun (c,d) -> (List.rev c; List.rev d) (padZero ((fun (a,b) -> b) a) x) in\nlet rec helper acc r (lst1, lst2) = \nif lst1 = [] then acc\nelse\nlet h1::t1 = lst1 in\nlet h2::t2 = lst2 in\nlet sum = h1+h2+r in\nhelper (sum mod 10)::acc (sum/10) (t1, t2)\nin\nhelper [] 0 g\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet g = \n(fun (c,d) -> (List.rev c; List.rev d) (padZero ((fun (a,b) -> b) a) x) in\nlet rec helper acc r (lst1, lst2) = \nif lst1 = [] then acc\nelse\nlet h1::t1 = lst1 in\nlet h2::t2 = lst2 in\nlet sum = h1+h2+r in\nhelper (sum mod 10)::acc (sum/10) (t1, t2)\nin\nhelper [] 0 g\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([],r) , acc) -> failwith \"should never reach here\"\n| ((h::[],r), acc) -> (([],0), r::acc)\n| ((h::t,r) , acc) -> \nlet sum = h+x+r in\n((t,sum/10), (sum mod 10)::acc)\nin\nlet (pad1, pad2) = padZero l1 l2 in\nlet base = ((List.rev pad1,0) , []) in\nlet args = (List.rev pad2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet g = \n(fun (c,d) -> (List.rev c; List.rev d)) (padZero ((fun (a,b) -> b) a) x) in\nlet rec helper acc r (lst1, lst2) = \nif lst1 = [] then acc\nelse\nlet h1::t1 = lst1 in\nlet h2::t2 = lst2 in\nlet sum = h1+h2+r in\nhelper (sum mod 10)::acc (sum/10) (t1, t2)\nin\nhelper [] 0 g\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet g = \n(fun (c,d) -> (List.rev c; List.rev d)) (padZero ((fun (a,b) -> b) a) x) in\nlet rec helper acc r (lst1, lst2) = \nif lst1 = [] then acc\nelse\nlet h1::t1 = lst1 in\nlet h2::t2 = lst2 in\nlet sum = h1+h2+r in\nhelper (sum mod 10)::acc (sum/10) (t1, t2)\nin\nhelper [] 0 g\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([],r) , acc) -> failwith \"should never reach here\"\n| ((h::[],r), acc) -> (([],0), r::acc)\n| ((h::t,r) , acc) -> \nlet sum = h+x+r in\n((t,sum/10), (sum mod 10)::acc)\nin\nlet (pad1, pad2) = padZero l1 l2 in\nlet base = ((List.rev pad1,0) , []) in\nlet args = (List.rev pad2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet g = \n(fun (c,d) -> (List.rev c; List.rev d)) (padZero ((fun (a,b) -> b) a) x) in\nlet rec helper acc r (lst1, lst2) = \nif lst1 = [] then acc\nelse\nlet h1::t1 = lst1 in\nlet h2::t2 = lst2 in\nlet sum = h1+h2+r in\nhelper ((sum mod 10)::acc) (sum/10) (t1, t2)\nin\nhelper [] 0 g\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet g = \n(fun (c,d) -> (List.rev c; List.rev d)) (padZero ((fun (a,b) -> b) a) x) in\nlet rec helper acc r (lst1, lst2) = \nif lst1 = [] then acc\nelse\nlet h1::t1 = lst1 in\nlet h2::t2 = lst2 in\nlet sum = h1+h2+r in\nhelper ((sum mod 10)::acc) (sum/10) (t1, t2)\nin\nhelper [] 0 g\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([],r) , acc) -> failwith \"should never reach here\"\n| ((h::[],r), acc) -> (([],0), r::acc)\n| ((h::t,r) , acc) -> \nlet sum = h+x+r in\n((t,sum/10), (sum mod 10)::acc)\nin\nlet (pad1, pad2) = padZero l1 l2 in\nlet base = ((List.rev pad1,0) , []) in\nlet args = (List.rev pad2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet g = \n(fun (c,d) -> (List.rev c, List.rev d)) (padZero ((fun (a,b) -> b) a) x) in\nlet rec helper acc r (lst1, lst2) = \nif lst1 = [] then acc\nelse\nlet h1::t1 = lst1 in\nlet h2::t2 = lst2 in\nlet sum = h1+h2+r in\nhelper ((sum mod 10)::acc) (sum/10) (t1, t2)\nin\nhelper [] 0 g\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet g = \n(fun (c,d) -> (List.rev c, List.rev d)) (padZero ((fun (a,b) -> b) a) x) in\nlet rec helper acc r (lst1, lst2) = \nif lst1 = [] then acc\nelse\nlet h1::t1 = lst1 in\nlet h2::t2 = lst2 in\nlet sum = h1+h2+r in\nhelper ((sum mod 10)::acc) (sum/10) (t1, t2)\nin\nhelper [] 0 g\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([],r) , acc) -> failwith \"should never reach here\"\n| ((h::[],r), acc) -> (([],0), r::acc)\n| ((h::t,r) , acc) -> \nlet sum = h+x+r in\n((t,sum/10), (sum mod 10)::acc)\nin\nlet (pad1, pad2) = padZero l1 l2 in\nlet base = ((List.rev pad1,0) , []) in\nlet args = (List.rev pad2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet g = \n(fun (c,d) -> (List.rev c, List.rev d)) (padZero ((fun (a,b) -> b) a) x) in\nlet rec helper acc r (lst1, lst2) = \nif lst1 = [] then acc\nelse\nlet h1::t1 = lst1 in\nlet h2::t2 = lst2 in\nlet sum = h1+h2+r in\nhelper ((sum mod 10)::acc) (sum/10) (t1, t2)\nin\n([], helper [] 0 g)\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet g = \n(fun (c,d) -> (List.rev c, List.rev d)) (padZero ((fun (a,b) -> b) a) x) in\nlet rec helper acc r (lst1, lst2) = \nif lst1 = [] then acc\nelse\nlet h1::t1 = lst1 in\nlet h2::t2 = lst2 in\nlet sum = h1+h2+r in\nhelper ((sum mod 10)::acc) (sum/10) (t1, t2)\nin\n([], helper [] 0 g)\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([],r) , acc) -> failwith \"should never reach here\"\n| ((h::[],r), acc) -> (([],0), r::acc)\n| ((h::t,r) , acc) -> \nlet sum = h+x+r in\n((t,sum/10), (sum mod 10)::acc)\nin\nlet (pad1, pad2) = padZero l1 l2 in\nlet base = ((List.rev pad1,0) , []) in\nlet args = (List.rev pad2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet g = \n(fun (c,d) -> (List.rev c, List.rev d)) (padZero ((fun (q,r) -> r) a) x) in\nlet rec helper acc r (lst1, lst2) = \nif lst1 = [] then acc\nelse\nlet h1::t1 = lst1 in\nlet h2::t2 = lst2 in\nlet sum = h1+h2+r in\nhelper ((sum mod 10)::acc) (sum/10) (t1, t2)\nin\n([], helper [] 0 g)\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet g = \n(fun (c,d) -> (List.rev c, List.rev d)) (padZero ((fun (q,r) -> r) a) x) in\nlet rec helper acc r (lst1, lst2) = \nif lst1 = [] then acc\nelse\nlet h1::t1 = lst1 in\nlet h2::t2 = lst2 in\nlet sum = h1+h2+r in\nhelper ((sum mod 10)::acc) (sum/10) (t1, t2)\nin\n([], helper [] 0 g)\nin\nlet base = ([] , []) in\nlet args = [[l1];[l2]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([],r) , acc) -> failwith \"should never reach here\"\n| ((h::[],r), acc) -> (([],0), r::acc)\n| ((h::t,r) , acc) -> \nlet sum = h+x+r in\n((t,sum/10), (sum mod 10)::acc)\nin\nlet (pad1, pad2) = padZero l1 l2 in\nlet base = ((List.rev pad1,0) , []) in\nlet args = (List.rev pad2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (([],r) , acc) -> failwith \"should never reach here\"\n| ((h::[],r), acc) -> (([],0), r::acc)\n| ((h::t,r) , acc) -> \nlet sum = h+x+r in\n((t,sum/10), (sum mod 10)::acc)\nin\nlet (pad1, pad2) = padZero l1 l2 in\nlet base = (List.rev pad1 , []) in\nlet args = (List.rev pad2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| (([],r) , acc) -> failwith \"should never reach here\"\n| ((h::[],r), acc) -> (([],0), r::acc)\n| ((h::t,r) , acc) -> \nlet sum = h+x+r in\n((t,sum/10), (sum mod 10)::acc)\nin\nlet (pad1, pad2) = padZero l1 l2 in\nlet base = (List.rev pad1 , []) in\nlet args = (List.rev pad2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigMul l1 l2 = \nif (l1 = [] || l2 = []) then []\nelse\nlet f a x = match a with\n| ((lst,decPlace), acc) ->\n((lst,decPlace+1), bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in\nlet base = ((l1,0), []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nif (l1 = [] || l2 = []) then []\nelse\nlet f a x = match a with\n| ((lst,decPlace), acc) ->\n((lst,decPlace+1) bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace)) in\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nif (l1 = [] || l2 = []) then []\nelse\nlet f a x = match a with\n| ((lst,decPlace), acc) ->\n((lst,decPlace+1) bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace)) in\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nif (l1 = [] || l2 = []) then []\nelse\nlet f a x = match a with\n| ((lst,decPlace), acc) ->\n((lst,decPlace+1), bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in\nlet base = ((l1,0), []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nif (l1 = [] || l2 = []) then []\nelse\nlet f a x = match a with\n| ((lst,decPlace), acc) ->\n((lst,decPlace+1) bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nif (l1 = [] || l2 = []) then []\nelse\nlet f a x = match a with\n| ((lst,decPlace), acc) ->\n((lst,decPlace+1) bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nif (l1 = [] || l2 = []) then []\nelse\nlet f a x = match a with\n| ((lst,decPlace), acc) ->\n((lst,decPlace+1), bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in\nlet base = ((l1,0), []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nif (l1 = [] || l2 = []) then []\nelse\nlet f a x = match a with\n| ((lst,decPlace), acc) ->\n((lst,decPlace+1) bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in\nlet base = ((l1,0), []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nif (l1 = [] || l2 = []) then []\nelse\nlet f a x = match a with\n| ((lst,decPlace), acc) ->\n((lst,decPlace+1) bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in\nlet base = ((l1,0), []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt (n/10)", "bad": "let rec digitsOfInt n = if n <= 0 -> []\nelse n mod 10 :: digitofInt n/10", "annotated": "let rec digitsOfInt : int -> int list = fun  n = if n < ->  0 -> []\nelse n mod 10 :: digitofInt n/10"}
{"fix": "let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt (n/10)", "bad": "let rec digitsOfInt n = if n <= 0 then -> []\nelse n mod 10 :: digitofInt n/10", "annotated": "let rec digitsOfInt : int -> int list = fun  n = if n < ->  0 then -> []\nelse n mod 10 :: digitofInt n/10"}
{"fix": "let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt (n/10)", "bad": "let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsofInt n/10s", "annotated": "let rec digitsOfInt : int -> int list = fun  n = if n < ->  0 then [] else n mod 10::digitsofInt n/10s"}
{"fix": "let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt (n/10)", "bad": "let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt n/10s", "annotated": "let rec digitsOfInt : int -> int list = fun  n = if n < ->  0 then [] else n mod 10::digitsOfInt n/10s"}
{"fix": "let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt (n/10)", "bad": "let rec digitsOfInt n = if n <= 0 then [] else n mod 10::digitsOfInt n/10", "annotated": "let rec digitsOfInt : int -> int list = fun  n = if n < ->  0 then [] else n mod 10::digitsOfInt n/10"}
{"fix": "let rec digitsOfInt n = if n <= 0 then [] else n mod 10 @ digitsOfInt (n/10)", "bad": "let rec digitsOfInt n = if n <= 0 then [] else digitsOfInt (n/10):: n mod 10", "annotated": "let rec digitsOfInt : int -> int list = fun  n = if n < ->  0 then [] else digitsOfInt (n/10):: n mod 10"}
{"fix": "let digitsOfInt n = \nlet rec digitsHelper n l = if n = 0 then l else digitsHelper (n/10) (n mod 10::l)\nin\nif n<=0 then [] else digitsHelper n []", "bad": "let rec digitsOfInt n = if n <= 0 then [] else digitsHelper n []", "annotated": "let rec digitsOfInt : int -> int list = fun  n = if n < ->  0 then [] else digitsHelper n []"}
{"fix": "let digitsOfInt n = \nlet rec digitsHelper n l = if n = 0 then l else digitsHelper (n/10) (n mod 10::l)\nin\nif n<=0 then [] else digitsHelper n []", "bad": "let rec digitsHelper n l = if n = 0 then l else (n/10) n mod 10::l", "annotated": "let rec digitsHelper n l = if n = 0 then l else (n/10) n mod 10::l"}
{"fix": "let digitsOfInt n = \nlet rec digitsHelper n l = if n = 0 then l else digitsHelper (n/10) (n mod 10::l)\nin\nif n<=0 then [] else digitsHelper n []", "bad": "let digitsOfInt n = \nlet rec digitsHelper n l = if n = 0 then l else (n/10) n mod 10::l\nin\nif n<=0 then [] else digitsHelper n []", "annotated": "let digitsOfInt : int -> int list = fun  n  ->  \nlet rec digitsHelper n l = if n = 0 then l else (n/10) n mod 10::l\nin\nif n<=0 then [] else digitsHelper n []"}
{"fix": "let digitsOfInt n = \nlet rec digitsHelper n l = if n = 0 then l else digitsHelper (n/10) (n mod 10::l)\nin\nif n<=0 then [] else digitsHelper n []", "bad": "let digitsOfInt n = \nlet rec digitsHelper n l = if n = 0 then l else (n/10) (n mod 10::l)\nin\nif n<=0 then [] else digitsHelper n []", "annotated": "let digitsOfInt : int -> int list = fun  n  ->  \nlet rec digitsHelper n l = if n = 0 then l else (n/10) (n mod 10::l)\nin\nif n<=0 then [] else digitsHelper n []"}
{"fix": "let rec digitalRoot n = \nlet rec digHelper n = if n < 10 then n else digHelper (sumList (digitsOfInt n))\nin\ndigHelper n", "bad": "let rec digitalRoot n = \nlet rec digHelper n = if n < 10 then n else digHelper (sumList n)\nin\ndigHelper n", "annotated": "let rec digitalRoot : int -> int = fun  n  ->  \nlet rec digHelper n = if n < 10 then n else digHelper (sumList n)\nin\ndigHelper n"}
{"fix": "let rec digitalRoot n = \nlet rec digHelper n = if n < 10 then n else digHelper (sumList (digitsOfInt n))\nin\ndigHelper n", "bad": "let _ = digitalRoot 9876", "annotated": "let _ = digitalRoot 9876"}
{"fix": "let rec listReverse l = \nlet rec listHelper l l2 = match l with\n| [] -> l2 \n| h::t -> listHelper t (h::l2)\nin\nlistHelper l []", "bad": "let rec listReverse l = \nlet rec listHelper l l2 = match l with\n| [] -> l2 \n| h::t -> listHelper t h::l2\nin\nlistHelper l []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec listHelper l l2 = match l with\n| [] -> l2 \n| h::t -> listHelper t h::l2\nin\nlistHelper l []"}
{"fix": "let rec listReverse l = \nlet rec listHelper l l2 = match l with\n| [] -> l2 \n| h::t -> listHelper t (h::l2)\nin\nlistHelper l []", "bad": "let _ = listReverse [1; 2; 3; 4]", "annotated": "let _ = listReverse [1; 2; 3; 4]"}
{"fix": "let rec listReverse l = \nlet rec listHelper l l2 = match l with\n| [] -> l2 \n| h::t -> listHelper t (h::l2)\nin\nlistHelper l []", "bad": "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]", "annotated": "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> if fst h = k then snd h else assoc (d, k, t)", "bad": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then true else assoc d k t", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with\n| [] -> d\n| (s,i)::t -> if s = k then true else assoc d k t"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> if fst h = k then snd h else assoc (d, k, t)", "bad": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> if fst h = k then snd h else assoc (d, k, t)", "bad": "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> if fst h = k then snd h else assoc (d, k, t)", "bad": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then true else assoc (d k t)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with\n| [] -> d\n| (s,i)::t -> if s = k then true else assoc (d k t)"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> if fst h = k then snd h else assoc (d, k, t)", "bad": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d k t)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d k t)"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> if fst h = k then snd h else assoc (d, k, t)", "bad": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i) as h::t -> if s = k then i else assoc (d k t)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with\n| [] -> d\n| (s,i) as h::t -> if s = k then i else assoc (d k t)"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> if fst h = k then snd h else assoc (d, k, t)", "bad": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| ((s,i) as h)::t -> if s = k then i else assoc (d k t)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with\n| [] -> d\n| ((s,i) as h)::t -> if s = k then i else assoc (d k t)"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> if fst h = k then snd h else assoc (d, k, t)", "bad": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> if fst h = k then snd h else assoc (d k t)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with\n| [] -> d\n| h::t -> if fst h = k then snd h else assoc (d k t)"}
{"fix": "let rec wwhile (f,b) = if snd (f b) then wwhile (f, fst (f b)) else fst (f b)", "bad": "let rec wwhile (f,b) = let snd (f b) then wwhile f fst (f b) else fst (f b)", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  let snd (f b) then wwhile f fst (f b) else fst (f b)"}
{"fix": "let rec wwhile (f,b) = if snd (f b) then wwhile (f, fst (f b)) else fst (f b)", "bad": "let rec wwhile (f,b) = let snd f b then wwhile f fst f b else fst f b", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  let snd f b then wwhile f fst f b else fst f b"}
{"fix": "let rec wwhile (f,b) = if snd (f b) then wwhile (f, fst (f b)) else fst (f b)", "bad": "let rec wwhile (f,b) = if snd f b then wwhile f fst f b else fst f b", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  if snd f b then wwhile f fst f b else fst f b"}
{"fix": "let fixpoint (f,b) = let fx b' = (f b', f b' = b') in\nwwhile(fx,b)", "bad": "let fixpoint (f,b) = wwhile ((if f b = b then (true,b) else (false,b)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((if f b  ->  b then (true,b) else (false,b)),b)"}
{"fix": "let fixpoint (f,b) = let fx b' = (f b', f b' = b') in\nwwhile(fx,b)", "bad": "let fixpoint (f,b) = wwhile (((f b) = b, (f b)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (((f b)  ->  b, (f b)),b)"}
{"fix": "let fixpoint (f,b) = let fx b' = (f b', f b' = b') in\nwwhile(fx,b)", "bad": "let fixpoint (f,b) = wwhile (f b, f b = b,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (f b, f b  ->  b,b)"}
{"fix": "let fixpoint (f,b) = let fx b' = (f b', f b' = b') in\nwwhile(fx,b)", "bad": "let fixpoint (f,b) = \nwwhile(if f b = b then (f b, true) else (f b, false),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile(if f b = b then (f b, true) else (f b, false),b)"}
{"fix": "let fixpoint (f,b) = let fx b' = (f b', f b' = b') in\nwwhile(fx,b)", "bad": "let fixpoint (f,b) = \nwwhile((if f b = b then (f b, true) else (f b, false)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((if f b = b then (f b, true) else (f b, false)),b)"}
{"fix": "let fixpoint (f,b) = let fx b' = (f b', f b' = b') in\nwwhile(fx,b)", "bad": "let fixpoint (f,b) = \nwwhile(let fx = if f b = b then (b,true) else (b,false),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile(let fx = if f b = b then (b,true) else (b,false),b)"}
{"fix": "let fixpoint (f,b) = let fx b' = (f b', f b' = b') in\nwwhile(fx,b)", "bad": "let fixpoint (f,b) = \nwwhile((let fx = if f b = b then (b,true) else (b,false)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let fx = if f b = b then (b,true) else (b,false)),b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = let fx b= (f b, f b = b) in\nwwhile(fx,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let fx b= (f b, f b  ->  b) in\nwwhile(fx,b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": ")", "annotated": ")"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let _ = fixpoint (collatz, 3)", "annotated": "let _ = fixpoint (collatz, 3)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nlet fx b = (f b, not (f b = b)) in\nwwhile(fx,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet fx b = (f b, not (f b = b)) in\nwwhile(fx,b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nwwhile(fun x = f x , not (f x = x),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile(fun x = f x , not (f x = x),b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nwwhile(fun x = f x , not (f x = x),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile(fun x = f x , not (f x = x),b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nwwhile(fun x -> f x , not (f x = x),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile(fun x -> f x , not (f x = x),b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nwwhile(fun x -> (f x , not (f x = x)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile(fun x -> (f x , not (f x = x)),b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nwwhile((fun x -> f x , not (f x = x)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((fun x -> f x , not (f x = x)),b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nwwhile(fun x -> f x  not (f x = x),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile(fun x -> f x  not (f x = x),b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nwwhile((fun x -> f x  not (f x = x)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((fun x -> f x  not (f x = x)),b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nwwhile((fun x -> f x , not (f x = x)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((fun x -> f x , not (f x = x)),b)"}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = match e with \n| VarX -> \"VarX\"\n| VarY -> \"VarY\"\n| Sine e1 -> \"Sine(\"^ exprToString e1 ^ \")\"\n| Cosine e1 -> \"Cosine(\" ^ exprToString e1 ^ \")\"\n| Average e1 e11 -> \"Average(\" ^ exprToString e1 ^ \",\" ^ exprToString e2 ^ \")\"\n| Times e1 e2 -> \"Times(\" ^ exprToString e1 ^ \",\" ^ exprToString e2 ^ \")\"\n| Thresh e1 e2 e3 e4 -> \"Thresh(\" ^  exprToString e1 ^ \",\" ^ exprToString e2 ^\",\" ^ exprToString e3 ^ \",\" ^ exprToString e4 ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with \n| VarX -> \"VarX\"\n| VarY -> \"VarY\"\n| Sine e1 -> \"Sine(\"^ exprToString e1 ^ \")\"\n| Cosine e1 -> \"Cosine(\" ^ exprToString e1 ^ \")\"\n| Average e1 e11 -> \"Average(\" ^ exprToString e1 ^ \",\" ^ exprToString e2 ^ \")\"\n| Times e1 e2 -> \"Times(\" ^ exprToString e1 ^ \",\" ^ exprToString e2 ^ \")\"\n| Thresh e1 e2 e3 e4 -> \"Thresh(\" ^  exprToString e1 ^ \",\" ^ exprToString e2 ^\",\" ^ exprToString e3 ^ \",\" ^ exprToString e4 ^ \")\""}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = match e with \n| VarX -> \"VarX\"\n| VarY -> \"VarY\"\n| Sine e1 -> \"Sine(\"^ exprToString e1 ^ \")\"\n| Cosine e1 -> \"Cosine(\" ^ exprToString e1 ^ \")\"\n| Average (e1,e2) -> \"Average(\" ^ exprToString e1 ^ \",\" ^ exprToString e2 ^ \")\"\n| Times e1 e2 -> \"Times(\" ^ exprToString e1 ^ \",\" ^ exprToString e2 ^ \")\"\n| Thresh e1 e2 e3 e4 -> \"Thresh(\" ^  exprToString e1 ^ \",\" ^ exprToString e2 ^\",\" ^ exprToString e3 ^ \",\" ^ exprToString e4 ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with \n| VarX -> \"VarX\"\n| VarY -> \"VarY\"\n| Sine e1 -> \"Sine(\"^ exprToString e1 ^ \")\"\n| Cosine e1 -> \"Cosine(\" ^ exprToString e1 ^ \")\"\n| Average (e1,e2) -> \"Average(\" ^ exprToString e1 ^ \",\" ^ exprToString e2 ^ \")\"\n| Times e1 e2 -> \"Times(\" ^ exprToString e1 ^ \",\" ^ exprToString e2 ^ \")\"\n| Thresh e1 e2 e3 e4 -> \"Thresh(\" ^  exprToString e1 ^ \",\" ^ exprToString e2 ^\",\" ^ exprToString e3 ^ \",\" ^ exprToString e4 ^ \")\""}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = match e with \n| VarX -> \"VarX\"\n| VarY -> \"VarY\"\n| Sine e1 -> \"Sine(\"^ exprToString e1 ^ \")\"\n| Cosine e1 -> \"Cosine(\" ^ exprToString e1 ^ \")\"\n| Average (e1,e2) -> \"Average(\" ^ exprToString e1 ^ \",\" ^ exprToString e2 ^ \")\"\n| Times e1 e2 -> \"Times(\" ^ exprToString e1 ^ \",\" ^ exprToString e2 ^ \")\"\n| Thresh e1 e2 e3 e4 -> \"Thresh(\" ^  exprToString e1 ^ \",\" ^ exprToString e2 ^\",\" ^ exprToString e3 ^ \",\" ^ exprToString e4 ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with \n| VarX -> \"VarX\"\n| VarY -> \"VarY\"\n| Sine e1 -> \"Sine(\"^ exprToString e1 ^ \")\"\n| Cosine e1 -> \"Cosine(\" ^ exprToString e1 ^ \")\"\n| Average (e1,e2) -> \"Average(\" ^ exprToString e1 ^ \",\" ^ exprToString e2 ^ \")\"\n| Times e1 e2 -> \"Times(\" ^ exprToString e1 ^ \",\" ^ exprToString e2 ^ \")\"\n| Thresh e1 e2 e3 e4 -> \"Thresh(\" ^  exprToString e1 ^ \",\" ^ exprToString e2 ^\",\" ^ exprToString e3 ^ \",\" ^ exprToString e4 ^ \")\""}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = match e with \n| VarX -> \"VarX\"\n| VarY -> \"VarY\"\n| Sine e1 -> \"Sine(\"^ exprToString e1 ^ \")\"\n| Cosine e1 -> \"Cosine(\" ^ exprToString e1 ^ \")\"\n| Average (e1,e2) -> \"Average(\" ^ exprToString e1 ^ \",\" ^ exprToString e2 ^ \")\"\n| Times (e1,e2) -> \"Times(\" ^ exprToString e1 ^ \",\" ^ exprToString e2 ^ \")\"\n| Thresh (e1,e2,e3,e4) -> \"Thresh(\" ^  exprToString e1 ^ \",\" ^ exprToString e2 ^\",\" ^ exprToString e3 ^ \",\" ^ exprToString e4 ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with \n| VarX -> \"VarX\"\n| VarY -> \"VarY\"\n| Sine e1 -> \"Sine(\"^ exprToString e1 ^ \")\"\n| Cosine e1 -> \"Cosine(\" ^ exprToString e1 ^ \")\"\n| Average (e1,e2) -> \"Average(\" ^ exprToString e1 ^ \",\" ^ exprToString e2 ^ \")\"\n| Times (e1,e2) -> \"Times(\" ^ exprToString e1 ^ \",\" ^ exprToString e2 ^ \")\"\n| Thresh (e1,e2,e3,e4) -> \"Thresh(\" ^  exprToString e1 ^ \",\" ^ exprToString e2 ^\",\" ^ exprToString e3 ^ \",\" ^ exprToString e4 ^ \")\""}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi .* exprToString e1)\n| Cosine e1 -> cos(pi .* exprToString e1)\n| Average (e1,e2) -> ((exprToString e1 .+ exprToString e2 )./2)\n| Times (e1,e2) -> exprToString e1 .* exprToString e2 \n| Thresh (e1,e2,e3,e4) -> (exprToString e1 < exprToString e2 ? exprToString e3 : exprToString e4)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi .* exprToString e1)\n| Cosine e1 -> cos(pi .* exprToString e1)\n| Average (e1,e2) -> ((exprToString e1 .+ exprToString e2 )./2)\n| Times (e1,e2) -> exprToString e1 .* exprToString e2 \n| Thresh (e1,e2,e3,e4) -> (exprToString e1 < exprToString e2 ? exprToString e3 : exprToString e4)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. exprToString e1)\n| Cosine e1 -> cos(pi *. exprToString e1)\n| Average (e1,e2) -> ((exprToString e1 +. exprToString e2 )/.2)\n| Times (e1,e2) -> exprToString e1 *. exprToString e2 \n| Thresh (e1,e2,e3,e4) -> (exprToString e1 < exprToString e2 ? exprToString e3 : exprToString e4)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. exprToString e1)\n| Cosine e1 -> cos(pi *. exprToString e1)\n| Average (e1,e2) -> ((exprToString e1 +. exprToString e2 )/.2)\n| Times (e1,e2) -> exprToString e1 *. exprToString e2 \n| Thresh (e1,e2,e3,e4) -> (exprToString e1 < exprToString e2 ? exprToString e3 : exprToString e4)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? eval (e3,x,y) : eval (e4,x,y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? eval (e3,x,y) : eval (e4,x,y))"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? eval (e3,x,y) : eval (e4,x,y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? eval (e3,x,y) : eval (e4,x,y))"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? eval (e3,x,y) : eval (e4,x,y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? eval (e3,x,y) : eval (e4,x,y))"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? eval (e3,x,y):eval (e4,x,y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? eval (e3,x,y):eval (e4,x,y))"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? eval (e3,x,y) : eval(e4,x,y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? eval (e3,x,y) : eval(e4,x,y))"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? (eval (e3,x,y)) : eval(e4,x,y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? (eval (e3,x,y)) : eval(e4,x,y))"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? (eval (e3,x,y)) : (eval(e4,x,y)))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? (eval (e3,x,y)) : (eval(e4,x,y)))"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> ((eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y)))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> ((eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y)))"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))", "bad": "eval", "annotated": "eval"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))"}
{"fix": "let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "bad": "let rec build (rand, depth) =\nlet expChooser (r,d) =  match r with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,d-1))\n| 3\n-> buildCosine(build (rand,d-1))\n| 4\n-> buildAverage(build (rand,d-1), build (rand,d-1))\n| 5\n-> buildTimes(build (rand,d-1), build (rand,d-1))\n| 6\n-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))\nin  if (depth < 1) then expChooser rand (0,2) else expChooser rand (2,7)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nlet expChooser (r,d) =  match r with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,d-1))\n| 3\n-> buildCosine(build (rand,d-1))\n| 4\n-> buildAverage(build (rand,d-1), build (rand,d-1))\n| 5\n-> buildTimes(build (rand,d-1), build (rand,d-1))\n| 6\n-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))\nin  if (depth < 1) then expChooser rand (0,2) else expChooser rand (2,7)"}
{"fix": "let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "bad": "let rec build (rand, depth) =\nlet expChooser (r,d) =  match r with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,d-1))\n| 3\n-> buildCosine(build (rand,d-1))\n| 4\n-> buildAverage(build (rand,d-1), build (rand,d-1))\n| 5\n-> buildTimes(build (rand,d-1), build (rand,d-1))\n| 6\n-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))\nin  if (depth < 1) then expChooser rand (0,2) depth else expChooser rand (2,7) depth", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nlet expChooser (r,d) =  match r with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,d-1))\n| 3\n-> buildCosine(build (rand,d-1))\n| 4\n-> buildAverage(build (rand,d-1), build (rand,d-1))\n| 5\n-> buildTimes(build (rand,d-1), build (rand,d-1))\n| 6\n-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))\nin  if (depth < 1) then expChooser rand (0,2) depth else expChooser rand (2,7) depth"}
{"fix": "let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "bad": "let rec build (rand, depth) =\nlet expChooser (r,d) =  match r with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,d-1))\n| 3\n-> buildCosine(build (rand,d-1))\n| 4\n-> buildAverage(build (rand,d-1), build (rand,d-1))\n| 5\n-> buildTimes(build (rand,d-1), build (rand,d-1))\n| 6\n-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))\nin  if (depth < 1) then (expChooser (rand (0,2), depth) else (expChooser (rand (2,7)), depth)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nlet expChooser (r,d) =  match r with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,d-1))\n| 3\n-> buildCosine(build (rand,d-1))\n| 4\n-> buildAverage(build (rand,d-1), build (rand,d-1))\n| 5\n-> buildTimes(build (rand,d-1), build (rand,d-1))\n| 6\n-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))\nin  if (depth < 1) then (expChooser (rand (0,2), depth) else (expChooser (rand (2,7)), depth)"}
{"fix": "let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "bad": "let rec build (rand, depth) =\nlet expChooser (r,d) =  match r with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,d-1))\n| 3\n-> buildCosine(build (rand,d-1))\n| 4\n-> buildAverage(build (rand,d-1), build (rand,d-1))\n| 5\n-> buildTimes(build (rand,d-1), build (rand,d-1))\n| 6\n-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))\nin  if (depth < 1) then (expChooser (rand (0,2)), depth) else (expChooser (rand (2,7)), depth)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nlet expChooser (r,d) =  match r with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,d-1))\n| 3\n-> buildCosine(build (rand,d-1))\n| 4\n-> buildAverage(build (rand,d-1), build (rand,d-1))\n| 5\n-> buildTimes(build (rand,d-1), build (rand,d-1))\n| 6\n-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))\nin  if (depth < 1) then (expChooser (rand (0,2)), depth) else (expChooser (rand (2,7)), depth)"}
{"fix": "let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "bad": "let rec build (rand, depth) =\nlet expChooser (r,d) =  match r with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,d-1))\n| 3\n-> buildCosine(build (rand,d-1))\n| 4\n-> buildAverage(build (rand,d-1), build (rand,d-1))\n| 5\n-> buildTimes(build (rand,d-1), build (rand,d-1))\n| 6\n-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))\nin  if (depth < 1) then (expChooser (rand (0,2)), depth) else (expChooser (rand (2,7)), depth)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nlet expChooser (r,d) =  match r with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,d-1))\n| 3\n-> buildCosine(build (rand,d-1))\n| 4\n-> buildAverage(build (rand,d-1), build (rand,d-1))\n| 5\n-> buildTimes(build (rand,d-1), build (rand,d-1))\n| 6\n-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))\nin  if (depth < 1) then (expChooser (rand (0,2)), depth) else (expChooser (rand (2,7)), depth)"}
{"fix": "let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "bad": "let rec build (rand, depth) = let n = \nif (depth < 1) then rand (0,2) else rand(2,7)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let n  ->  \nif (depth < 1) then rand (0,2) else rand(2,7)"}
{"fix": "let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "bad": "match n with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "annotated": "match n with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))"}
{"fix": "let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "bad": "let rec build (rand, depth) = let n = \nif (depth < 1) then rand (0,2) else rand(2,7)\nmatch n with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let n  ->  \nif (depth < 1) then rand (0,2) else rand(2,7)\nmatch n with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))"}
{"fix": "let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "bad": "let rec build (rand, depth) = let n = \nmatch n with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))\nin if (depth < 1) then rand (0,2) else rand(2,7)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let n  ->  \nmatch n with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))\nin if (depth < 1) then rand (0,2) else rand(2,7)"}
{"fix": "let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "bad": "let rec build (rand, depth) = \nlet n = \nmatch n with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))\nin n = if (depth < 1) then rand (0,2) else rand(2,7)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet n = \nmatch n with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))\nin n = if (depth < 1) then rand (0,2) else rand(2,7)"}
{"fix": "let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "bad": "let rec build (rand, depth) = \nlet n = if (depth < 1) then rand (0,2) else rand(2,7)\nmatch n with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet n = if (depth < 1) then rand (0,2) else rand(2,7)\nmatch n with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))"}
{"fix": "let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "bad": "let rec build (rand, depth) = \nlet n = if (depth < 1) then match rand(0,2) with else match rand(2,7) with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet n = if (depth < 1) then match rand(0,2) with else match rand(2,7) with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))"}
{"fix": "let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "bad": "let rec build (rand, depth) = \nlet n = if (depth < 1) then (match rand(0,2) with) else (match rand(2,7) with)\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet n = if (depth < 1) then (match rand(0,2) with) else (match rand(2,7) with)\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))"}
{"fix": "let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "bad": "let rec build (rand, depth) = \nif (depth < 1) then (match rand(0,2) with) else (match rand(2,7) with)\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif (depth < 1) then (match rand(0,2) with) else (match rand(2,7) with)\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))"}
{"fix": "let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "bad": "let rec build (rand, depth) = \nlet num = if (depth < 1) rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet num = if (depth < 1) rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))"}
{"fix": "let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "bad": "let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))\n| Power (e1,e2) -> eval (e1,x,y) ** abs_float (eval (e2,x,y))\n| Comp (e1,e2,e3) -> (float_of_int (-1)) *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))\n| Power (e1,e2) -> eval (e1,x,y) ** abs_float eval (e2,x,y)\n| Comp (e1,e2,e3) -> (float_of_int (-1)) *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))\n| Power (e1,e2) -> eval (e1,x,y) ** abs_float eval (e2,x,y)\n| Comp (e1,e2,e3) -> (float_of_int (-1)) *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))\n| Power (e1,e2) -> eval (e1,x,y) ** abs_float (eval (e2,x,y))\n| Comp (e1,e2,e3) -> (float_of_int (-1)) *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))\n| Power (e1,e2) -> eval (e1,x,y) ** abs_float (eval (e2,x,y))\n| Comp (e1,e2,e3) -> (float_of_int (-1)) *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))\n| Power (e1,e2) -> eval (e1,x,y) ** abs_float (eval (e2,x,y))\n| Comp (e1,e2,e3) -> (float_of_int (-1)) *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y)"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base =  1 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a + f x in\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a + f x in\nlet base = 0 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base =  1 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a + f x in\nlet base = x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a + f x in\nlet base = x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base =  1 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a + x a in\nlet base = x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a + x a in\nlet base = x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base =  1 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base =  _ in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base =  _ in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base =  (fun x -> x) in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base =  (fun x -> x) in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base =  (fun x -> x) in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a = x a in\nlet base = fun x -> x in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a = x a in\nlet base = fun x -> x in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a = x a in\nlet base = 0 in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a = x a in\nlet base = 0 in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a = f (a y) in\nlet base = fun x -> x in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a = f (a y) in\nlet base = fun x -> x in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a = x (a y) in\nlet base = fun x -> x in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a = x (a y) in\nlet base = fun x -> x in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a = x a in\nlet base = fun x -> x in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a = x a in\nlet base = fun x -> x in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =  x a in \nlet base = fun x -> x in \nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x =  x a in \nlet base = fun x -> x in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a = fun x a -> x a in \nlet base = fun x -> x in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a = fun x a -> x a in \nlet base = fun x -> x in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =  x a in \nlet base = fun x -> x in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a = fun x a t-> x (a t) in \nlet base = fun x -> x in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a = fun x a t-> x (a t) in \nlet base = fun x -> x in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =  x a in \nlet base = fun x -> x in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a = (fun x y -> x (a y)) in \nlet base = fun x -> x in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a = (fun x y -> x (a y)) in \nlet base = fun x -> x in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =  x a in \nlet base = fun x -> x in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a = fun y ->  x (a y) in \nlet base = fun x -> x in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a = fun y ->  x (a y) in \nlet base = fun x -> x in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =  x a in \nlet base = fun x -> x in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = let a = fun y ->  x (a y) in \nlet base = fun x -> x in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = let a = fun y ->  x (a y) in \nlet base = fun x -> x in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =  x a in \nlet base = fun x -> x in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  x a", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  x a"}
{"fix": "let pipe fs = \nlet f a x =  x a in \nlet base = fun x -> x in \nList.fold_left f base fs", "bad": "let base = fun x -> x in \nList.fold_left f base fs", "annotated": "let base = fun x -> x in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =  fun y -> x (a y) in \nlet base = fun x -> x in \nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x =  fun y -> x (a y) in \nlet base = fun x -> x in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  let a = x a in \nlet base = fun x -> x in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  let a = x a in \nlet base = fun x -> x in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =  fun y -> x (a y) in \nlet base = fun x -> x in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  a x in \nlet base = fun x -> x in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  a x in \nlet base = fun x -> x in \nList.fold_left f base fs"}
{"fix": "let stringOfList f l = \"[\" ^ (sepConcat \";\" (List.map f l)) ^ \"]\"", "bad": "let stringOfList f l = \"[\" ^ List.map sepConcat \";\" l ^ \"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\" ^ List.map sepConcat \";\" l ^ \"]\""}
{"fix": "let stringOfList f l = \"[\" ^ (sepConcat \";\" (List.map f l)) ^ \"]\"", "bad": "let stringOfList f l = \"[\" ^ sepConcat \";\" List.map f l ^ \"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\" ^ sepConcat \";\" List.map f l ^ \"]\""}
{"fix": "let rec clone x n = \nlet rec cloneHelper (x,n,acc) = if (n < 0) then acc else cloneHelper(x,n-1,x::acc) in\ncloneHelper(x,n,[])", "bad": "let rec clone x n = \nlet rec cloneHelper x n acc = if n < 0 then acc else cloneHelper x n-1 x::acc in\ncloneHelper x n []", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nlet rec clone : 'a -> int -> 'a list = fun  x n  ->  if n < 0 then acc else cloneHelper x n-1 x::acc in\ncloneHelper x n []"}
{"fix": "let rec clone x n = \nlet rec cloneHelper (x,n,acc) = if (n < 0) then acc else cloneHelper(x,n-1,x::acc) in\ncloneHelper(x,n,[])", "bad": "let rec clone x n = \nlet rec cloneHelper x n acc = if n < 0 then acc else cloneHelper (x,n-1,x::acc) in\ncloneHelper x n []", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nlet rec clone : 'a -> int -> 'a list = fun  x n  ->  if n < 0 then acc else cloneHelper (x,n-1,x::acc) in\ncloneHelper x n []"}
{"fix": "let rec clone x n = \nlet rec cloneHelper (x,n,acc) = if (n < 0) then acc else cloneHelper(x,n-1,x::acc) in\ncloneHelper(x,n,[])", "bad": "let rec clone x n = \nlet rec cloneHelper x n acc = if n < 0 then acc else cloneHelper (x,n-1,x::acc) in\ncloneHelper x n []", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nlet rec clone : 'a -> int -> 'a list = fun  x n  ->  if n < 0 then acc else cloneHelper (x,n-1,x::acc) in\ncloneHelper x n []"}
{"fix": "let rec clone x n = \nlet rec cloneHelper (x,n,acc) = if (n < 0) then acc else cloneHelper(x,n-1,x::acc) in\ncloneHelper(x,n,[])", "bad": "let rec clone x n = \nlet rec cloneHelper x n acc = if n < 0 then acc else cloneHelper (x,n-1,x::acc) in\ncloneHelper (x ,n,[])", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nlet rec clone : 'a -> int -> 'a list = fun  x n  ->  if n < 0 then acc else cloneHelper (x,n-1,x::acc) in\ncloneHelper (x ,n,[])"}
{"fix": "let rec clone x n = \nlet rec cloneHelper (x,n,acc) = if (n < 0) then acc else cloneHelper(x,n-1,x::acc) in\ncloneHelper(x,n,[])", "bad": "let rec clone x n = \nlet rec cloneHelper x n acc = if n < 0 then acc else cloneHelper (x,n-1,x::acc) in\ncloneHelper (x,n,[])", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nlet rec clone : 'a -> int -> 'a list = fun  x n  ->  if n < 0 then acc else cloneHelper (x,n-1,x::acc) in\ncloneHelper (x,n,[])"}
{"fix": "let rec clone x n = \nlet rec cloneHelper (x,n,acc) = if (n < 0) then acc else cloneHelper(x,n-1,x::acc) in\ncloneHelper(x,n,[])", "bad": "let rec clone x n = if n < 0 then [] else clone x n-1", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  if n < 0 then [] else clone x n-1"}
{"fix": "let rec clone x n = \nlet rec cloneHelper (x,n,acc) = if (n < 0) then acc else cloneHelper(x,n-1,x::acc) in\ncloneHelper(x,n,[])", "bad": "let rec clone x n = if n < 0 then [] else clone (x,n-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  if n < 0 then [] else clone (x,n-1)"}
{"fix": "let rec clone x n = \nlet rec cloneHelper (x,n,acc) = if (n < 0) then acc else cloneHelper(x,n-1,x::acc) in\ncloneHelper(x,n,[])", "bad": "let rec clone x n = \nlet cloneHelper (x,n,acc) = if (n < 0) then acc else cloneHelper(x,n-1,x::acc) in\ncloneHelper(x,n,[])", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nlet clone : 'a -> int -> 'a list = fun  x n  ->  if (n < 0) then acc else cloneHelper(x,n-1,x::acc) in\ncloneHelper(x,n,[])"}
{"fix": "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append (clone 0 (abs diff)) l1 else l2", "bad": "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append (clone 0 (abs diff)) l1\nelse if (diff > 0) then List.append (clone 0 diff) l2", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append (clone 0 (abs diff)) l1\nelse if (diff > 0) then List.append (clone 0 diff) l2"}
{"fix": "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append (clone 0 (abs diff)) l1 else l2", "bad": "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append ((clone 0 (abs diff)) l1)\nelse if (diff > 0) then List.append ((clone 0 diff) l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append ((clone 0 (abs diff)) l1)\nelse if (diff > 0) then List.append ((clone 0 diff) l2)"}
{"fix": "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append (clone 0 (abs diff)) l1 else l2", "bad": "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append ((clone 0 (abs diff)),l1)\nelse if (diff > 0) then List.append ((clone 0 diff),l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append ((clone 0 (abs diff)),l1)\nelse if (diff > 0) then List.append ((clone 0 diff),l2)"}
{"fix": "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append (clone 0 (abs diff)) l1 else l2", "bad": "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then (List.append ((clone 0 (abs diff)),l1),l2)\nelse if (diff > 0) then (l1,List.append ((clone 0 diff),l2))", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then (List.append ((clone 0 (abs diff)),l1),l2)\nelse if (diff > 0) then (l1,List.append ((clone 0 diff),l2))"}
{"fix": "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append (clone 0 (abs diff)) l1 else l2", "bad": "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then (List.combine ((clone 0 (abs diff)),l1),l2)\nelse if (diff > 0) then (l1,List.combine ((clone 0 diff),l2))", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then (List.combine ((clone 0 (abs diff)),l1),l2)\nelse if (diff > 0) then (l1,List.combine ((clone 0 diff),l2))"}
{"fix": "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append (clone 0 (abs diff)) l1 else l2", "bad": "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append (clone 0 (abs diff)) l1\nelse if (diff > 0) then List.append (clone 0 diff) l2", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append (clone 0 (abs diff)) l1\nelse if (diff > 0) then List.append (clone 0 diff) l2"}
{"fix": "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append (clone 0 (abs diff)) l1 else l2", "bad": "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append (clone 0 (abs diff)) l1\nelse if (diff > 0) then List.append (clone 0 diff) l2", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append (clone 0 (abs diff)) l1\nelse if (diff > 0) then List.append (clone 0 diff) l2"}
{"fix": "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append (clone 0 (abs diff)) l1 else l2", "bad": "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append (clone 0 (abs diff)) l1", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append (clone 0 (abs diff)) l1"}
{"fix": "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append (clone 0 (abs diff)) l1 else if (diff > 0) then l1 else l1", "bad": "let padZero l1 l2 = \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append (clone 0 (abs diff)) l1 else if l2 else l1", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet diff = List.length l1 - List.length l2 in\nif (diff < 0) then List.append (clone 0 (abs diff)) l1 else if l2 else l1"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) mod 10 in\n(sum/10, sum mod 10) in\nlet base = (0,0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres::[] \nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + (fst x + snd x) mod 10 in\nlet base = 0 in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = a + (fst x + snd x) mod 10 in\nlet base = 0 in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) mod 10 in\n(sum/10, sum mod 10) in\nlet base = (0,0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres::[] \nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) mod 10 in\n(sum/10, sum mod 10) in\nlet base = (0,0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) mod 10 in\n(sum/10, sum mod 10) in\nlet base = (0,0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nList.rev res\nin \nremoveZero (add (padZero 0::l1 0::l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine (List.reverse l1) (List.reverse l2) in\nlet (_, res) = List.fold_left f base args in\nList.reverse res\nin \nremoveZero (add (padZero 0::l1 0::l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine (List.reverse l1) (List.reverse l2) in\nlet (_, res) = List.fold_left f base args in\nList.reverse res\nin \nremoveZero (add (padZero 0::l1 0::l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nList.rev res\nin \nremoveZero (add (padZero 0::l1 0::l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nList.reverse res\nin \nremoveZero (add (padZero 0::l1 0::l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nList.reverse res\nin \nremoveZero (add (padZero 0::l1 0::l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nList.rev res\nin \nremoveZero (add (padZero (0::l1) (0::l2)))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nList.rev res\nin \nremoveZero (add (padZero (0::l1) (0::l2))\n\nlet _ = bigAdd [5;1] [5;4]", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nList.rev res\nin \nremoveZero (add (padZero (0::l1) (0::l2))\n\nlet _ = bigAdd [5;1] [5;4]"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero (0::l1) (0::l2)))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero (0:l1) (0:l2)))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero (0:l1) (0:l2)))"}
{"fix": "let bigMul l1 l2 = \nlet f a x = (fst a + 1, bigAdd (snd a) (List.append l1 (clone 0 (fst a)))) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = (fst a + 1, bigAdd snd a (List.append l1 (clone 0 (fst a)))) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = (fst a + 1, bigAdd snd a (List.append l1 (clone 0 (fst a)))) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let rec digitsOfInt n = \nif n < 1 then []\nelse n mod 10 :: digitsOfInt(n/10)", "bad": "let rec digitsOfInt n = match n with\n| n < 1 -> []\n| n mod 10 :: digitsofInt(n/10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  match n with\n| n < 1 -> []\n| n mod 10 :: digitsofInt(n/10)"}
{"fix": "let rec digitsOfInt n = \nif n < 1 then []\nelse n mod 10 :: digitsOfInt(n/10)", "bad": "let rec digitsOfInt n = match n with\nif n < 1 then []\nelse n mod 10 :: digitsofInt(n/10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  match n with\nif n < 1 then []\nelse n mod 10 :: digitsofInt(n/10)"}
{"fix": "let rec digitsOfInt n = \nif n < 1 then []\nelse n mod 10 :: digitsOfInt(n/10)", "bad": "let rec digitsOfInt n = \nif n < 1 then []\nelse n mod 10 :: digitsofInt(n/10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 1 then []\nelse n mod 10 :: digitsofInt(n/10)"}
{"fix": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\nadditivePersistence(addList(digitsOfInt(n)))", "bad": "let rec additivePersistence n = \nlet count = 0 in\nif digitsOfInt(n).length = 1 then \ncount\nelse\nadditivePersistence(addList(digitsofInt(n)))", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet count = 0 in\nif digitsOfInt(n).length = 1 then \ncount\nelse\nadditivePersistence(addList(digitsofInt(n)))"}
{"fix": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\nadditivePersistence(addList(digitsOfInt(n)))", "bad": "let rec additivePersistence n = \nlet count = 0 in\nif List.length digitsOfInt(n) = 1 then \ncount\nelse\nadditivePersistence(addList(digitsofInt(n)))", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet count = 0 in\nif List.length digitsOfInt(n) = 1 then \ncount\nelse\nadditivePersistence(addList(digitsofInt(n)))"}
{"fix": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\nadditivePersistence(addList(digitsOfInt(n)))", "bad": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length digitsOfInt(n)) = 1 then \ncount\nelse\nadditivePersistence(addList(digitsofInt(n)))", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet count = 0 in\nif (List.length digitsOfInt(n)) = 1 then \ncount\nelse\nadditivePersistence(addList(digitsofInt(n)))"}
{"fix": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\nadditivePersistence(addList(digitsOfInt(n)))", "bad": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\nadditivePersistence(addList(digitsofInt(n)))", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\nadditivePersistence(addList(digitsofInt(n)))"}
{"fix": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\nadditivePersistence(addList(digitsOfInt(n)))", "bad": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\nadditivePersistence(addList(digitsofInt(n)))", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\nadditivePersistence(addList(digitsofInt(n)))"}
{"fix": "addList[1;2;3;4]", "bad": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\ninc count\nadditivePersistence(addList(digitsOfInt(n)))", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\ninc count\nadditivePersistence(addList(digitsOfInt(n)))"}
{"fix": "addList[1;2;3;4]", "bad": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\nincr count\nadditivePersistence(addList(digitsOfInt(n)))", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\nincr count\nadditivePersistence(addList(digitsOfInt(n)))"}
{"fix": "addList[1;2;3;4]", "bad": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\nincr(count)\nadditivePersistence(addList(digitsOfInt(n)))", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse\nincr(count)\nadditivePersistence(addList(digitsOfInt(n)))"}
{"fix": "addList[1;2;3;4]", "bad": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse (\nincr(count)\nadditivePersistence(addList(digitsOfInt(n)))\n)", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse (\nincr(count)\nadditivePersistence(addList(digitsOfInt(n)))\n)"}
{"fix": "addList[1;2;3;4]", "bad": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse (\nincr(count)", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse (\nincr(count)"}
{"fix": "addList[1;2;3;4]", "bad": "additivePersistence(addList(digitsOfInt(n)))\n)", "annotated": "additivePersistence(addList(digitsOfInt(n)))\n)"}
{"fix": "addList[1;2;3;4]", "bad": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse \nincr(count)", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse \nincr(count)"}
{"fix": "addList[1;2;3;4]", "bad": "additivePersistence(addList(digitsOfInt(n)))", "annotated": "additivePersistence(addList(digitsOfInt(n)))"}
{"fix": "addList[1;2;3;4]", "bad": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse \ncount = count + 1\nadditivePersistence(addList(digitsOfInt(n)))", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse \ncount = count + 1\nadditivePersistence(addList(digitsOfInt(n)))"}
{"fix": "addList[1;2;3;4]", "bad": "let rec additivePersistence n = \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse \nlet count = count + 1\nadditivePersistence(addList(digitsOfInt(n)))", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet count = 0 in\nif (List.length(digitsOfInt(n))) = 1 then \ncount\nelse \nlet count = count + 1\nadditivePersistence(addList(digitsOfInt(n)))"}
{"fix": "let rec addList (f,xs) = match xs with\n| [] -> 0\n| h::t -> h+ addList(f,t)", "bad": "addList digitsOfInt 5", "annotated": "addList digitsOfInt 5"}
{"fix": "let rec addNum n = \nif n < 10 then n\nelse \naddList(digitsOfInt(n))", "bad": "let rec addNum = match n with\nif n < 10 then n\nelse \naddList(digitsOfInt(n))", "annotated": "let rec addNum = match n with\nif n < 10 then n\nelse \naddList(digitsOfInt(n))"}
{"fix": "let rec addNum n = \nif n < 10 then n\nelse \naddList(digitsOfInt(n))", "bad": "let rec addNum = \nif n < 10 then n\nelse \naddList(digitsOfInt(n))", "annotated": "let rec addNum = \nif n < 10 then n\nelse \naddList(digitsOfInt(n))"}
{"fix": "let rec addList xs = match xs with\n| [] -> 0\n| h::t -> h + addList t", "bad": "let rec additivePersistence n = \nlet count = 0 in \nif n < 10 then\ncount + 1\nelse \nlet count = count + 1", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet count = 0 in \nif n < 10 then\ncount + 1\nelse \nlet count = count + 1"}
{"fix": "let palindrome w = \nlet l = explode w in\nif listReverse(l) = l then\ntrue\nelse\nfalse", "bad": "let palindrome w = \nlet l = explode s in\nif listReverse(l) = l then\ntrue\nelse\nfalse", "annotated": "let palindrome : string -> bool = fun  w  ->  \nlet l = explode s in\nif listReverse(l) = l then\ntrue\nelse\nfalse"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =\nif List.mem h seen\nthen\nseen\nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =\nif List.mem h seen\nthen\nseem\nelse\nh::seem\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =\nif List.mem h seen\nthen\nseem\nelse\nh::seem\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let rec wwhile (f,b) = \nlet a', b' = f b in  \nif b' = true \nthen wwhile (f, b')\nelse a'", "bad": " rec wwhile (f,b) = \nlet f b = x, y in \nif y = true \nthen wwhile (f, x)\nelse x", "annotated": " rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet f b = x, y in \nif y = true \nthen wwhile (f, x)\nelse x"}
{"fix": "let rec wwhile (f,b) = \nlet a', b' = f b in  \nif b' = true \nthen wwhile (f, b')\nelse a'", "bad": " rec wwhile (f,b) = \nlet f b = (x, y) in \nif y = true \nthen wwhile (f, x)\nelse x", "annotated": " rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet f b = (x, y) in \nif y = true \nthen wwhile (f, x)\nelse x"}
{"fix": "let rec wwhile (f,b) = \nlet a', b' = f b in  \nif b' = true \nthen wwhile (f, b')\nelse a'", "bad": "let rec wwhile (f,b) = \nlet f(b) = (x, y) in \nif y = true \nthen wwhile (f, x)\nelse x", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet f(b) = (x, y) in \nif y = true \nthen wwhile (f, x)\nelse x"}
{"fix": "let rec wwhile (f,b) = \nlet a', b' = f b in  \nif b' = true \nthen wwhile (f, b')\nelse a'", "bad": "let rec wwhile (f,b) = \nlet f(b) = (x, y) in \nif x = true \nthen wwhile (f, x)\nelse x", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet f(b) = (x, y) in \nif x = true \nthen wwhile (f, x)\nelse x"}
{"fix": "let rec wwhile (f,b) = \nlet a', b' = f b in  \nif b' = true \nthen wwhile (f, b')\nelse a'", "bad": "let rec wwhile (f,b) = \nlet f(b) = (b', c') in \nif c' = true \nthen wwhile (f, b')\nelse x", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet f(b) = (b', c') in \nif c' = true \nthen wwhile (f, b')\nelse x"}
{"fix": "let rec wwhile (f,b) = \nlet a', b' = f b in  \nif b' = true \nthen wwhile (f, b')\nelse a'", "bad": "let rec wwhile (f,b) = \nlet f(b) = b', c' in \nif c' = true \nthen wwhile (f, b')\nelse x", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet f(b) = b', c' in \nif c' = true \nthen wwhile (f, b')\nelse x"}
{"fix": "let rec wwhile (f,b) = \nlet a', b' = f b in  \nif b' = true \nthen wwhile (f, b')\nelse a'", "bad": "let rec wwhile (f,b) = \nlet f b = b', c' in \nif c' = true \nthen wwhile (f, b')\nelse x", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet f b = b', c' in \nif c' = true \nthen wwhile (f, b')\nelse x"}
{"fix": "let rec wwhile (f,b) = \nlet a', b' = f b in  \nif b' = true \nthen wwhile (f, b')\nelse a'", "bad": "let rec wwhile (f,b) = \nlet f b = q, x in \nif c' = true \nthen wwhile (f, b')\nelse x", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet f b = q, x in \nif c' = true \nthen wwhile (f, b')\nelse x"}
{"fix": "let rec wwhile (f,b) = \nlet a', b' = f b in  \nif b' = true \nthen wwhile (f, b')\nelse a'", "bad": "let rec wwhile (f,b) = \nlet f b = q, x \nif c' = true \nthen wwhile (f, b')\nelse x", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet f b = q, x \nif c' = true \nthen wwhile (f, b')\nelse x"}
{"fix": "let rec wwhile (f,b) = \nlet a', b' = f b in  \nif b' = true \nthen wwhile (f, b')\nelse a'", "bad": "let rec wwhile (f,b) = \nlet f b = q, x in  \nif c' = true \nthen wwhile (f, b')\nelse x", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet f b = q, x in  \nif c' = true \nthen wwhile (f, b')\nelse x"}
{"fix": "let rec wwhile (f,b) = \nlet a', b' = f b in  \nif b' = true \nthen wwhile (f, b')\nelse a'", "bad": "let rec wwhile (f,b) = \nlet f b = w in  \nif c' = true \nthen wwhile (f, b')\nelse x", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet f b = w in  \nif c' = true \nthen wwhile (f, b')\nelse x"}
{"fix": "let rec wwhile (f,b) = \nlet b', c' = f b in  \nif c' = true \nthen wwhile (f, b')\nelse b'", "bad": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "annotated": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}
{"fix": "let fixpoint (f,b) = \nlet f' b' = \nif f(b') = b'\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)", "bad": "let fixpoint (f,b) = \nlet f' = fun b'\nif(f(b') = b')\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet f' = fun b'\nif(f(b') = b')\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)"}
{"fix": "let fixpoint (f,b) = \nlet f' b' = \nif f(b') = b'\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)", "bad": "let fixpoint (f,b) = \nlet f' = fun b' = \nif(f(b') = b')\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet f' = fun b' = \nif(f(b') = b')\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)"}
{"fix": "let fixpoint (f,b) = \nlet f' b' = \nif f(b') = b'\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)", "bad": "let fixpoint (f,b) = \nlet fun f' b' =  \nif(f(b') = b')\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet fun f' b' =  \nif(f(b') = b')\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)"}
{"fix": "let fixpoint (f,b) = \nlet f' b' = \nif f(b') = b'\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)", "bad": "let fixpoint (f,b) = \nlet f' b' =  fun\nif(f(b') = b')\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet f' b' =  fun\nif(f(b') = b')\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)"}
{"fix": "let fixpoint (f,b) = \nlet f' b' = \nif f(b') = b'\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)", "bad": "let fixpoint (f,b) = \nlet f' b' =  fun\nif(f(b') = b')\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet f' b' =  fun\nif(f(b') = b')\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)"}
{"fix": "let fixpoint (f,b) = \nlet f' b' = \nif f(b') = b'\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)", "bad": "let fixpoint (f,b) = \nlet f' b' =  fun\nif(f(b') = b')\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet f' b' =  fun\nif(f(b') = b')\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)"}
{"fix": "let fixpoint (f,b) = \nlet f' b' = \nif f(b') = b'\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)", "bad": "let fixpoint (f,b) = \nlet f' b' =  fun\nif(f(b') = b')\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet f' b' =  fun\nif(f(b') = b')\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)"}
{"fix": "let fixpoint (f,b) = \nlet f' b' = \nif f(b') = b'\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)", "bad": "let fixpoint (f,b) = \nlet f' b' =  fun\nif(f(b') = b')\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet f' b' =  fun\nif(f(b') = b')\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)"}
{"fix": "let fixpoint (f,b) = \nlet f' b' = \nif f(b') = b'\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)", "bad": "let fixpoint (f,b) = \nlet f' b' =  function\nif(f(b') = b')\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet f' b' =  function\nif(f(b') = b')\nthen (b', true)\nelse\n(b', false)\nin \nwwhile(f' , b)"}
{"fix": "let rec exprToString e = match e with\n| VarX\t\t  -> \"x\"\n| VarY\t\t  -> \"y\"\n| Sine e1\t  -> \"(sin\"^ exprToString e1 ^\")\"\n| Cosine e1\t  -> \"(cos\"^exprToString e1 ^ \")\"\n| Average (e1, e2)-> \"(\"^ exprToString e1 ^\"+\" ^ exprToString e2 ^ \")/2\"\n| Times (e1, e2)  -> \"(\"^ exprToString e1 ^\"*\"^exprToString e2 ^\")\"\n| Thresh (e1, e2, e3, e4) -> \"(\"^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \")?(\"^ exprToString e3 ^ \"):(\"^exprToString e4 ^ \")\"", "bad": "exprToString (Sine(VarX))", "annotated": "exprToString (Sine(VarX))"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval(e))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval(e))"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval(e1))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval(e1))"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval e1)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval e1)"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval e1)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval e1)"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval e1, x, y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval e1, x, y)"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))"}
{"fix": "let pi = 4.0 *. atan 1.0", "bad": "let pi = 4.0 *. atan 1.0\n\n(* eval : expr -> float * float -> float \nEvaluator for expressions in x and y *)\n1<2?3:4", "annotated": "let pi = 4.0 *. atan 1.0\n\n(* eval : expr -> float * float -> float \nEvaluator for expressions in x and y *)\n1<2?3:4"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)/. 2.0)\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif \neval(e1, x, y) < eval(e2, x, y)\nthen\neval(e3, x, y)\nelse\neval(e4, x, y)", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)/. 2.0)\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif \n(eval(e1, x, y) < eval(e2, x, y) )\nthen\neval(e3, x, y)\nelse\neval(e4, x, y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)/. 2.0)\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif \n(eval(e1, x, y) < eval(e2, x, y) )\nthen\neval(e3, x, y)\nelse\neval(e4, x, y)"}
{"fix": "let pipe fs = \nlet f a x = (x a) in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = (x a) in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = (x a) in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let pipe fs = \nlet f a x = (x a) in\nlet base = [] in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = (x a) in\nlet base = fun g x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (x a) in\nlet base = x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (x a) in\nlet base = x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (x a) in\nlet base = fun g x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (x a) in\nlet base = a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (x a) in\nlet base = a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (x a) in\nlet base = fun g x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (x a) in\nlet base = g x->x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (x a) in\nlet base = g x->x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (x a) in\nlet base = fun g x -> x in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = (x a) in\nlet base = fun g x -> x in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun q -> x(a(q)) in\nlet base = fun g q -> q in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let rec clone x n = match n with\n| 0 -> []\n| _ -> x::(clone x (n-1))", "bad": "let rec clone x n =  \n| 0 -> []\n| _ -> x::clone n-1", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->   \n| 0 -> []\n| _ -> x::clone n-1"}
{"fix": "let rec clone x n = match n with\n| 0 -> []\n| _ -> x::(clone x (n-1))", "bad": "let rec clone x n = match n with\n| 0 -> []\n| _ -> x::clone n-1", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with\n| 0 -> []\n| _ -> x::clone n-1"}
{"fix": "let rec clone x n = match n with\n| 0 -> []\n| _ -> x::(clone x (n-1))", "bad": "let rec clone x n = match n with\n| 0 -> []\n| _ -> x::clone (x n-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with\n| 0 -> []\n| _ -> x::clone (x n-1)"}
{"fix": "let rec clone x n = match n with\n| 0 -> []\n| _ -> x::(clone x (n-1))", "bad": "let rec clone x n = match n with\n| 0 -> []\n| _ -> x::(clone x n-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with\n| 0 -> []\n| _ -> x::(clone x n-1)"}
{"fix": "let padZero l1 l2 =\nlet lenl1 = List.length l1 in\nlet lenl2 = List.length l2 in\nif lenl1 > lenl2\nthen (l1, (clone 0 (lenl1-lenl2))@l2)\nelse ((clone 0 (lenl2-lenl1))@l1, l2)", "bad": "let padZero l1 l2 =\nlet lenl1 = List.length l1 in\nlet lenl2 = List.length l2 in\nif lenl1 > lenl2\nthen (l1, (clone 0 lenl1-lenl2)@l2)\nelse ((clone 0 lenl2-lenl1)@l1, l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \nlet lenl1 = List.length l1 in\nlet lenl2 = List.length l2 in\nif lenl1 > lenl2\nthen (l1, (clone 0 lenl1-lenl2)@l2)\nelse ((clone 0 lenl2-lenl1)@l1, l2)"}
{"fix": "let _ = removeZero [0;0;0;0]", "bad": "let _ = removeZero [0;0;0;0]\n\n*", "annotated": "let _ = removeZero [0;0;0;0]\n\n*"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rem = match a with\n| (x, y) -> x in\nmatch x with \n| (add_a, add_b) -> let new_carry = (rem + add_a + add_b)/10 in\nlet digit = (rem + add_a + add_b) mod 10 in\nmatch a with\n| (x, y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rem = match a in\n| (x, y) -> x in\nmatch x with \n| (add_a, add_b) -> let new_carry = (rem + add_a + add_b)/10 in\nlet digit = (rem + add_a + add_b) mod 10 in\nmatch a with\n| (x, y) -> new_carry, digit::y", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet rem = match a in\n| (x, y) -> x in\nmatch x with \n| (add_a, add_b) -> let new_carry = (rem + add_a + add_b)/10 in\nlet digit = (rem + add_a + add_b) mod 10 in\nmatch a with\n| (x, y) -> new_carry, digit::y"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rem = match a with\n| (x, y) -> x in\nmatch x with \n| (add_a, add_b) -> let new_carry = (rem + add_a + add_b)/10 in\nlet digit = (rem + add_a + add_b) mod 10 in\nmatch a with\n| (x, y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": ") in\n\nlet base = (0, []) in\nlet args = List.rev(List.combine(l1, l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": ") in\n\nlet base = (0, []) in\nlet args = List.rev(List.combine(l1, l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rem = match a with\n| (x, y) -> x in\nmatch x with \n| (add_a, add_b) -> let new_carry = (rem + add_a + add_b)/10 in\nlet digit = (rem + add_a + add_b) mod 10 in\nmatch a with\n| (x, y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rem = match a with\n| (x, y) -> x in\nmatch x with \n| (add_a, add_b) -> let new_carry = (rem + add_a + add_b)/10 in\nlet digit = (rem + add_a + add_b) mod 10 in\nmatch a with\n| (x, y) -> new_carry, digit::y", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet rem = match a with\n| (x, y) -> x in\nmatch x with \n| (add_a, add_b) -> let new_carry = (rem + add_a + add_b)/10 in\nlet digit = (rem + add_a + add_b) mod 10 in\nmatch a with\n| (x, y) -> new_carry, digit::y"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rem = match a with\n| (x, y) -> x in\nmatch x with \n| (add_a, add_b) -> let new_carry = (rem + add_a + add_b)/10 in\nlet digit = (rem + add_a + add_b) mod 10 in\nmatch a with\n| (x, y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": ") in\n\nlet base = (0, []) in\nlet args = List.rev(List.combine(l1, l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": ") in\n\nlet base = (0, []) in\nlet args = List.rev(List.combine(l1, l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rem = match a with\n| (x, y) -> x in\nmatch x with \n| (add_a, add_b) -> let new_carry = (rem + add_a + add_b)/10 in\nlet digit = (rem + add_a + add_b) mod 10 in\nmatch a with\n| (x, y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rem = match a with\n| (x, y) -> x in\nmatch x with \n| (add_a, add_b) -> let new_carry = (rem + add_a + add_b)/10 in\nlet digit = (rem + add_a + add_b) mod 10 in\nmatch a with\n| (x, y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine(l1, l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet rem = match a with\n| (x, y) -> x in\nmatch x with \n| (add_a, add_b) -> let new_carry = (rem + add_a + add_b)/10 in\nlet digit = (rem + add_a + add_b) mod 10 in\nmatch a with\n| (x, y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine(l1, l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, _) = a in\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, (norm_sum::y)) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, _) = a in\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, norm_sum::y)", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (rem, _) = a in\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, norm_sum::y)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, _) = a in\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, (norm_sum::y)) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, _) = a in\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, (norm_sum::y)) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, _) = a in\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, norm_sum::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (rem, _) = a in\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, norm_sum::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let rec removeZero l = match l with\n| []      -> []\n| h::t    -> \nif h = 0 \nthen removeZero(t)\nelse h::t", "bad": "let rec removeZero l = match l with\n| []      -> []\n| h::t    -> \nif h = 0 \nthen removeZero(t)\nelse h::t\n\nList.combine([1;2] [3;4])", "annotated": "let rec removeZero : int list -> int list = fun  l  ->  match l with\n| []      -> []\n| h::t    -> \nif h = 0 \nthen removeZero(t)\nelse h::t\n\nList.combine([1;2] [3;4])"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\nif ((List.length acc) = (List.length l1)) || (List.length acc = List.length l2)\nthen if rem = 1\nthen (0, 1::acc) \nelse (0, acc)\nelse\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\nif (acc.length = l1.length) || (acc.length = l2.length)\nthen if rem = 1\nthen (0, 1::acc) \nelse (0, acc)\nelse\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\nif (acc.length = l1.length) || (acc.length = l2.length)\nthen if rem = 1\nthen (0, 1::acc) \nelse (0, acc)\nelse\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\n\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \nlet larger = if List.length l1 > List.length l2 then l1 else l2 in\nif ((List.length acc) = (List.length larger)-1)\nthen if rem = 1\nthen (0, [1;norm_sum]@acc) \nelse (0, acc)\nelse\n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\n\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \nlet larger = if List.length l1 > List.length l2 then l1 else l2 in\nif ((List.length acc) = (List.length larger)-1)\nthen if rem = 1\nthen (0, [1;norm_sum]@acc) \nelse (0, acc)\nelse\n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZ", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\n\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \nlet larger = if List.length l1 > List.length l2 then l1 else l2 in\nif ((List.length acc) = (List.length larger)-1)\nthen if rem = 1\nthen (0, [1;norm_sum]@acc) \nelse (0, acc)\nelse\n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZ"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\n\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \nlet larger = if List.length l1 > List.length l2 then l1 else l2 in\nif ((List.length acc) = (List.length larger)-1)\nthen if rem = 1\nthen (0, [1;norm_sum]@acc) \nelse (0, norm_sum::acc)\nelse\n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\n\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \nlet larger = if List.length l1 > List.length l2 then l1 else l2 in\nif ((List.length acc) = (List.length larger)-1)\nthen if rem = 1\nthen (0, [1;norm_sum]@acc) \nelse (0, norm_sum@acc)\nelse\n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\n\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \nlet larger = if List.length l1 > List.length l2 then l1 else l2 in\nif ((List.length acc) = (List.length larger)-1)\nthen if rem = 1\nthen (0, [1;norm_sum]@acc) \nelse (0, norm_sum@acc)\nelse\n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let rec mulByDigit i l = match i with\n| 1 -> l\n| _ -> bigAdd (mulByDigit (i-1) l) l", "bad": "let rec mulByDigit i l = match i with\n| 0 -> l\n| _ -> bigAdd (mulByDigit i-1) l", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match i with\n| 0 -> l\n| _ -> bigAdd (mulByDigit i-1) l"}
{"fix": "let rec mulByDigit i l = match i with\n| 1 -> l\n| _ -> bigAdd (mulByDigit (i-1) l) l", "bad": "let rec mulByDigit i l = match i with\n| 1 -> l\n| _ -> bigAdd (mulByDigit i-1) l", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match i with\n| 1 -> l\n| _ -> bigAdd (mulByDigit i-1) l"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet (place, acc) = a in\n(place+1, bigAdd ((mulByDigit x l1)@(clone 0 place)) acc) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = (bigAdd (mulByDigit x l1) a in\nlet base = [] in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = (bigAdd (mulByDigit x l1) a in\nlet base = [] in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet (place, acc) = a in\n(place+1, bigAdd ((mulByDigit x l1)@(clone 0 place)) acc) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = (bigAdd (mulByDigit x l1) a) in\nlet base = [] in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = (bigAdd (mulByDigit x l1) a) in\nlet base = [] in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet (place, acc) = a in\n(place+1, bigAdd ((mulByDigit x l1)@(clone 0 place)) acc) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet (place, acc) = a in\n(place+1, (bigAdd(mulByDigit x l1)@clone 0 place) acc) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet (place, acc) = a in\n(place+1, (bigAdd(mulByDigit x l1)@clone 0 place) acc) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet (place, acc) = a in\n(place+1, bigAdd ((mulByDigit x l1)@(clone 0 place)) acc) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet (place, acc) = a in\n(place+1, (bigAdd(mulByDigit x l1)@clone (0 place)) acc) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet (place, acc) = a in\n(place+1, (bigAdd(mulByDigit x l1)@clone (0 place)) acc) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet (place, acc) = a in\n(place+1, bigAdd ((mulByDigit x l1)@(clone 0 place)) acc) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet (place, acc) = a in\n(place+1, bigAdd(mulByDigit x l1)@clone (0 place) acc) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet (place, acc) = a in\n(place+1, bigAdd(mulByDigit x l1)@clone (0 place) acc) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digits n digitList = \nif n = 0 then digitList\nelse digits (n/10) ((n mod 10)::digitList)", "bad": "let rec digitsOfInt n = \nif n <= 0 then []\nelse if n mod 10 = 0 then 0::digitsOfInt (n/10)\nelse if ((n-1) mod 10) = 0 then (1::digitsOfInt ((n-1)/10))", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n <= 0 then []\nelse if n mod 10 = 0 then 0::digitsOfInt (n/10)\nelse if ((n-1) mod 10) = 0 then (1::digitsOfInt ((n-1)/10))"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digits n digitList = \nif n = 0 then digitList\nelse digits (n/10) ((n mod 10)::digitList)", "bad": "let rec digitsOfInt n = \nif n <= 0 then []\nelse if n mod 10 = 0 then 0::digitsOfInt (n/10)\nelse if ((n-1) mod 10) = 0 then (1::(digitsOfInt ((n-1)/10)))", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n <= 0 then []\nelse if n mod 10 = 0 then 0::digitsOfInt (n/10)\nelse if ((n-1) mod 10) = 0 then (1::(digitsOfInt ((n-1)/10)))"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digits n digitList = \nif n = 0 then digitList\nelse digits (n/10) ((n mod 10)::digitList) in\nmatch n with\n| 0 -> [0]\n| _ -> digits n []", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digits n digitList = \nif n = 0 then digitList\nelse digits (n/10) ((n mod 10)::digitList)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse\nlet rec digits n digitList = \nif n = 0 then digitList\nelse digits (n/10) ((n mod 10)::digitList)"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digits n digitList = \nif n = 0 then digitList\nelse digits (n/10) ((n mod 10)::digitList) in\nmatch n with\n| 0 -> [0]\n| _ -> digits n []", "bad": ") in\nmatch n with\n| 0 -> [0]\n| _ -> digits n []", "annotated": ") in\nmatch n with\n| 0 -> [0]\n| _ -> digits n []"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digits n digitList = \nif n = 0 then digitList\nelse digits (n/10) ((n mod 10)::digitList) in\nmatch n with\n| 0 -> [0]\n| _ -> digits n []", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digits n digitList = \nif n = 0 then digitList\nelse digits (n/10) ((n mod 10)::digitList)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse\nlet rec digits n digitList = \nif n = 0 then digitList\nelse digits (n/10) ((n mod 10)::digitList)"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digits n digitList = \nif n = 0 then digitList\nelse digits (n/10) ((n mod 10)::digitList) in\nmatch n with\n| 0 -> [0]\n| _ -> digits n []", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digits n digitList = \nif n = 0 then digitList\nelse digits (n/10) ((n mod 10)::digitList)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse\nlet rec digits n digitList = \nif n = 0 then digitList\nelse digits (n/10) ((n mod 10)::digitList)"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digits n digitList = \nif n = 0 then digitList\nelse digits (n/10) ((n mod 10)::digitList) in\nmatch n with\n| 0 -> [0]\n| _ -> digits n []", "bad": ") in\nmatch n with\n| 0 -> [0]\n| _ -> digits n []", "annotated": ") in\nmatch n with\n| 0 -> [0]\n| _ -> digits n []"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)", "bad": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| (h::t) -> if h = (k,'a) then 'a else assoc (d,k,t)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  \nmatch l with\n| []     -> d\n| (h::t) -> if h = (k,'a) then 'a else assoc (d,k,t)"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)", "bad": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)", "bad": "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)", "bad": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| (h::t) -> if h = (k * 'a) then 'a else assoc (d,k,t)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  \nmatch l with\n| []     -> d\n| (h::t) -> if h = (k * 'a) then 'a else assoc (d,k,t)"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)", "bad": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)", "bad": "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)", "bad": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| (h::t) -> if h = [k,'a] then 'a else assoc (d,k,t)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  \nmatch l with\n| []     -> d\n| (h::t) -> if h = [k,'a] then 'a else assoc (d,k,t)"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)", "bad": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)", "bad": "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)", "bad": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| (('a,'b)::t) -> if 'a = k then 'b else assoc (d,k,t)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  \nmatch l with\n| []     -> d\n| (('a,'b)::t) -> if 'a = k then 'b else assoc (d,k,t)"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)", "bad": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)", "bad": "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)", "bad": "let fixpoint (f,b) = wwhile (let a = (f b, b = f b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let a = (f b, b  ->  f b),b)"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)", "bad": "let fixpoint (f,b) = wwhile ((f b, b = f b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((f b, b  ->  f b),b)"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = wwhile (let g x = let bb = f x in (bb, bb = x) in g, b)", "bad": "let fixpoint (f,b) = wwhile (let g = let bb = f b in (bb, bb = b) in g, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g = let bb = f b in (bb, bb  ->  b) in g, b)"}
{"fix": "let rec exprToString e = match e with\n| VarX -> x", "bad": "let rec exprToString e = match e with\n| VarX x -> Printf.printf \"%s\" x", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX x -> Printf.printf \"%s\" x"}
{"fix": "let rec build (rand, depth) = \nif depth = 0 then \nmatch rand mod 2 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand mod 5 with\n| 2 -> buildSine(build (rand, depth-1))\n| 3 -> buildCosine(build (rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "bad": "let rec build (rand, depth) = \nif depth = 0 then \nmatch rand (i,j) mod 2 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand (i,j) mod 5 with\n| 2 -> buildSine(build (rand, depth-1))\n| 3 -> buildCosine(build (rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0 then \nmatch rand (i,j) mod 2 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand (i,j) mod 5 with\n| 2 -> buildSine(build (rand, depth-1))\n| 3 -> buildCosine(build (rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))"}
{"fix": "let rec build (rand, depth) = \nif depth = 0 then \nmatch rand mod 2 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand mod 5 with\n| 2 -> buildSine(build (rand, depth-1))\n| 3 -> buildCosine(build (rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "bad": "let rec build (rand, depth) = \nif depth = 0 then \nmatch rand mod 2 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand mod 5 with\n| 2 -> buildSine(build (rand, depth-1))\n| 3 -> buildCosine(build (rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0 then \nmatch rand mod 2 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand mod 5 with\n| 2 -> buildSine(build (rand, depth-1))\n| 3 -> buildCosine(build (rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))"}
{"fix": "let sqsum xs = \nlet rec f a x = match x with\n| []     -> a\n| (h::t) -> f (a+(h*h)) t in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = match x with\n| [] -> a\n| (h::t) -> f (a+(h*h)) t in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = match x with\n| [] -> a\n| (h::t) -> f (a+(h*h)) t in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet rec f a x = match x with\n| []     -> a\n| (h::t) -> f (a+(h*h)) t in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = sqsum []", "annotated": "let _ = sqsum []"}
{"fix": "let sqsum xs = \nlet rec f a x = match x with\n| []     -> a\n| (h::t) -> f (a+(h*h)) t in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = sqsum [1;2;3;4]", "annotated": "let _ = sqsum [1;2;3;4]"}
{"fix": "let sqsum xs = \nlet rec f a x = match x with\n| []     -> a\n| (h::t) -> f (a+(h*h)) t in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = sqsum [(-1); (-2); (-3); (-4)]", "annotated": "let _ = sqsum [(-1); (-2); (-3); (-4)]"}
{"fix": "let sqsum xs = \nlet rec f a x = match x with\n| []     -> a\n| (h::t) -> f (a+(h*h)) t in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = match x with\n| []     -> a\n| (h::t) -> sqsum (a+(h*h)) t in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = match x with\n| []     -> a\n| (h::t) -> sqsum (a+(h*h)) t in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet rec f a x = match x with\n| []     -> a\n| (h::t) -> f (a+(h*h)) t in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = match x with\n| []     -> a\n| (h::t) -> f (a+(h*h)) t in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = match x with\n| []     -> a\n| (h::t) -> f (a+(h*h)) t in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet rec f a x = match x with\n| []     -> a\n| (h::t) -> f (a+(h*h)) t in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = match x with\n| []     -> a\n| (h::t) -> f a+(h*h) t in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = match x with\n| []     -> a\n| (h::t) -> f a+(h*h) t in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet rec f a x = match x with\n| []     -> a\n| (h::t) -> f (a+(h*h)) t in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = match x with\n| []     -> a\n| (h::t) -> f (a+(h*h)) t in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = match x with\n| []     -> a\n| (h::t) -> f (a+(h*h)) t in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = (a + (x*x)) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a + x*x", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a + x*x"}
{"fix": "let sqsum xs = \nlet f a x = (a + (x*x)) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let base = 0 in\nList.fold_left f base xs", "annotated": "let base = 0 in\nList.fold_left f base xs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fs in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fs in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x 'a in\nlet base = fs in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x 'a in\nlet base = fs in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 3 in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 3 in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 3 in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 3 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x 'a in\nlet base = 'a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x 'a in\nlet base = 'a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 3 in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 3 in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 3 in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 3 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 3 in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 3 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = 'a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = 'a in\nList.fold_left f base fs"}
{"fix": "let pipe fs num = \nlet f a x = x a in\nlet base = num in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = b in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = b in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fun 'a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun 'a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fun 'a -> fs 'a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun 'a -> fs 'a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fun a -> fs a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun a -> fs a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = base in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = base in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fs 'a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fs 'a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = List.hd fs in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = List.hd fs in\nList.fold_left f base fs"}
{"fix": "let pipe = fun x -> fun2 (fun1 x)", "bad": "let pipe = fun x -> fun (fun y)", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun (fun y)"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = _ in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = _ in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = 'a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = 'a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = 'b in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = 'b in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = int in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = int in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = [] in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe = fun x -> fun2 (fun1 x)", "bad": "let pipe = let base = x in fun x -> fun2 (fun1 base)", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  = let base  ->  x in fun x -> fun2 (fun1 base)"}
{"fix": "let pipe = fun x -> fun2 (fun1 x)", "bad": "let _ = pipe 3", "annotated": "let _ = pipe 3"}
{"fix": "let pipe = fun x -> fun2 (fun1 x)", "bad": "let pipe = let base = fun x in fun x -> fun2 (fun1 base)", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  = let base  ->  fun x in fun x -> fun2 (fun1 base)"}
{"fix": "let pipe = fun x -> fun2 (fun1 x)", "bad": "let _ = pipe 3", "annotated": "let _ = pipe 3"}
{"fix": "let pipe = fun x -> fun2 (fun1 x)", "bad": "let pipe = let base =  in fun x -> fun2 (fun1 base)", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  = let base  ->   in fun x -> fun2 (fun1 base)"}
{"fix": "let pipe = fun x -> fun2 (fun1 x)", "bad": "let _ = pipe 3", "annotated": "let _ = pipe 3"}
{"fix": "let pipe = fun x -> fun2 (fun1 x)", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fun p = p in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun p = p in\nList.fold_left f base fs"}
{"fix": "let pipe = fun x -> fun2 (fun1 x)", "bad": "let pipe = fun x -> fun2 (fun1 base)", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 (fun1 base)"}
{"fix": "let pipe = fun x -> fun2 (fun1 x)", "bad": "let _ = pipe 3", "annotated": "let _ = pipe 3"}
{"fix": "let pipe = fun x -> fun2 (fun1 x)", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fun p = p in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun p = p in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = p -> p in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = p -> p in\nList.fold_left f base fs"}
{"fix": "let _ = pipe fun1 fun2 3", "bad": "let _ = pipe fun1 fun2", "annotated": "let _ = pipe fun1 fun2"}
{"fix": "let _ = pipe fun1 fun2 3", "bad": "let _ = pipe fun1 fun2 3", "annotated": "let _ = pipe fun1 fun2 3"}
{"fix": "let pipe = fun x -> fun2 (fun1 x)", "bad": "let pipe = fun2 fun1", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun2 fun1"}
{"fix": "let pipe = fun x -> fun2 (fun1 x)", "bad": "let pipe = fun x -> fun2 fun1", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 fun1"}
{"fix": "let pipe = fun x -> fun2 (fun1 x)", "bad": "let pipe = fun x -> fun2 fun1 x", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 fun1 x"}
{"fix": "let pipe = fun x -> fun2 (fun1 x)", "bad": "let pipe = fun x -> fun2 x -> (fun1 x)", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 x -> (fun1 x)"}
{"fix": "let pipe = fun x -> fun2 (fun1 x)", "bad": "let pipe = fun x -> fun2 x (fun1 x)", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 x (fun1 x)"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let rec pipe fs = \nmatch fs with\n| [] -> 0\n| (h::t) -> h (pipe t)", "bad": "let rec pipe fs = \nlet fsrev = List.rev fs in\nmatch fsrev with\n| [] -> x -> x\n| (h::t) -> h (pipe t)", "annotated": "let rec pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet fsrev = List.rev fs in\nmatch fsrev with\n| [] -> x -> x\n| (h::t) -> h (pipe t)"}
{"fix": "let rec pipe fs = \nmatch fs with\n| [] -> 0\n| (h::t) -> h (pipe t)", "bad": "let rec pipe fs = \nlet fsrev = List.rev fs in\nmatch fsrev with\n| [x] -> x \n| (h::t) -> h (pipe t)", "annotated": "let rec pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet fsrev = List.rev fs in\nmatch fsrev with\n| [x] -> x \n| (h::t) -> h (pipe t)"}
{"fix": "let rec pipe fs = \nmatch fs with\n| [] -> 0\n| (h::t) -> h (pipe t)", "bad": "let rec pipe fs = \nmatch fs with\n| [x] -> x \n| (h::t) -> h (pipe t)", "annotated": "let rec pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nmatch fs with\n| [x] -> x \n| (h::t) -> h (pipe t)"}
{"fix": "let rec pipe fs = \nmatch fs with\n| [] -> 0\n| (h::t) -> h (pipe t)", "bad": "let rec pipe fs = \nmatch fs with\n| [x] -> x \n| (h::t) -> h (pipe t)", "annotated": "let rec pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nmatch fs with\n| [x] -> x \n| (h::t) -> h (pipe t)"}
{"fix": "let rec pipe fs = \nmatch fs with\n| [] -> 0\n| (h::t) -> h (pipe t)", "bad": "let rec pipe fs = \nmatch fs with\n| [] -> x \n| (h::t) -> h (pipe t)", "annotated": "let rec pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nmatch fs with\n| [] -> x \n| (h::t) -> h (pipe t)"}
{"fix": "let rec pipe fs = \nmatch fs with\n| [] -> fun x -> x\n| (h::t) -> h (pipe t)", "bad": "let rec pipe fs = \nmatch fs with\n| [] -> fun\n| (h::t) -> h (pipe t)", "annotated": "let rec pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nmatch fs with\n| [] -> fun\n| (h::t) -> h (pipe t)"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun y -> y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x (a _) in\nlet base = fun y -> y in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x (a _) in\nlet base = fun y -> y in\nList.fold_left f base fs"}
{"fix": "let stringOfList f l = sepConcat \"; \" (List.map f l)", "bad": "let stringOfList f l = List.map f sepConcat l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map f sepConcat l"}
{"fix": "let stringOfList f l = sepConcat \"; \" (List.map f l)", "bad": "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "annotated": "let _ = stringOfList string_of_int [1;2;3;4;5;6]"}
{"fix": "let stringOfList f l = sepConcat \"; \" (List.map f l)", "bad": "let _ = stringOfList (fun x -> x) [\"foo\"]", "annotated": "let _ = stringOfList (fun x -> x) [\"foo\"]"}
{"fix": "let stringOfList f l = sepConcat \"; \" (List.map f l)", "bad": "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "annotated": "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"}
{"fix": "let stringOfList f l = sepConcat \"; \" (List.map f l)", "bad": "let stringOfList f l = sepConcat (List.map f)", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat (List.map f)"}
{"fix": "let stringOfList f l = sepConcat \"; \" (List.map f l)", "bad": "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "annotated": "let _ = stringOfList string_of_int [1;2;3;4;5;6]"}
{"fix": "let stringOfList f l = sepConcat \"; \" (List.map f l)", "bad": "let _ = stringOfList (fun x -> x) [\"foo\"]", "annotated": "let _ = stringOfList (fun x -> x) [\"foo\"]"}
{"fix": "let stringOfList f l = sepConcat \"; \" (List.map f l)", "bad": "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "annotated": "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"}
{"fix": "let stringOfList f l = sepConcat \"; \" (List.map f l)", "bad": "let stringOfList f l = sepConcat \"; \" (List.map f)", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat \"; \" (List.map f)"}
{"fix": "let stringOfList f l = sepConcat \"; \" (List.map f l)", "bad": "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "annotated": "let _ = stringOfList string_of_int [1;2;3;4;5;6]"}
{"fix": "let stringOfList f l = sepConcat \"; \" (List.map f l)", "bad": "let _ = stringOfList (fun x -> x) [\"foo\"]", "annotated": "let _ = stringOfList (fun x -> x) [\"foo\"]"}
{"fix": "let stringOfList f l = sepConcat \"; \" (List.map f l)", "bad": "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "annotated": "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"}
{"fix": "let _ = padZero [9;9] [1;2]", "bad": "let _ padZero [9;9] [1;2]", "annotated": "let _ padZero [9;9] [1;2]"}
{"fix": "let pipe fs p = \nlet f a x = x a in\nlet base = p in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = let p = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = let p = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs p = \nlet f a x = x a in\nlet base = p in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = let p = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = let p = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet prevN (n1, n2) = n1 in\nlet prev = prevN a in\nlet sumlist (p1, p2) = p2 in\nlet sum = sumlist a in\nlet add (m,n) = m + n in\nlet digit = (add x) + prev in\nif digit > 10 then (1, (digit-10)::sum) else (0, (digit)::sum) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet prevN (n1, n2) in\nlet prev = prevN a in\nlet sumlist (p1, p2) = p2 in\nlet sum = sumlist a in\nlet add (m,n) = m + n in\nlet digit = (add x) + prev in\nif digit > 10 then (1, (digit-10)::sum) else (0, (digit)::sum) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet prevN (n1, n2) in\nlet prev = prevN a in\nlet sumlist (p1, p2) = p2 in\nlet sum = sumlist a in\nlet add (m,n) = m + n in\nlet digit = (add x) + prev in\nif digit > 10 then (1, (digit-10)::sum) else (0, (digit)::sum) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let _ = bigMul [1] [0]", "bad": "let _ bigMul [1] [0]", "annotated": "let _ bigMul [1] [0]"}
{"fix": "let rec digitsOfInt n =\nif n < 0 then []\nelse n :: digitsOfInt n", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse a :: [] -> digitsOfInt n :: []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse a :: [] -> digitsOfInt n :: []"}
{"fix": "let rec digitsOfInt n =\nif n < 0 then []\nelse n :: digitsOfInt n", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse a :: [] -> digitsOfInt n :: []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse a :: [] -> digitsOfInt n :: []"}
{"fix": "let rec digitsOfInt n =\nif n < 0 then []\nelse n :: digitsOfInt n", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse a :: [] -> digitsOfInt n :: []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse a :: [] -> digitsOfInt n :: []"}
{"fix": "let rec digitsOfInt n =\nif n < 0 then []\nelse n :: digitsOfInt n", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse a :: [] -> a :: digitsOfInt n", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse a :: [] -> a :: digitsOfInt n"}
{"fix": "let rec digitsOfInt n =\nif n < 0 then []\nelse n :: digitsOfInt n", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse a :: digitsOfInt n", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse a :: digitsOfInt n"}
{"fix": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n/10)", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse n%10", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse n%10"}
{"fix": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n/10)", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse n mod 10", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse n mod 10"}
{"fix": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n/10)", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse h:: digitsOfInt n mod 10", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse h:: digitsOfInt n mod 10"}
{"fix": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n/10)", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt n mod 10", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse digitsOfInt n mod 10"}
{"fix": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n/10)", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n/10) mod 10 :: []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse digitsOfInt (n/10) mod 10 :: []"}
{"fix": "let _ = digitsOfInt 98*-1", "bad": "let _ = digitsOfInt 98", "annotated": "let _ = digitsOfInt 98"}
{"fix": "let digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digit n acc =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n", "bad": "let _ = digitsOfInt -9", "annotated": "let _ = digitsOfInt -9"}
{"fix": "let digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digit n acc =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n", "bad": "let _ = digitsOfInt ~-9", "annotated": "let _ = digitsOfInt ~-9"}
{"fix": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []", "bad": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \ndigit [] n", "annotated": "let digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \ndigit [] n"}
{"fix": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []", "bad": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nn [] digit", "annotated": "let digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nn [] digit"}
{"fix": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []", "bad": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \ndigit [] digit", "annotated": "let digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \ndigit [] digit"}
{"fix": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []", "bad": "let digitsOfInt n = \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []", "annotated": "let digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse\n(*let rec digit acc n =\nif n < 10 then n::acc\nelse digit ((n mod 10)::acc) (n/10) in\ndigit [] n*)\nlet rec digit n acc = \nif n < 10 then n::acc\nelse digit (n/10) (n mod 10::acc) in \nmatch n with\n| 0 -> [0]\n| _ -> digit n []"}
{"fix": "let _ = additivePersistence 9876", "bad": "let additivePersistence n =\nif n < 10 then 0  \nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then 1 + addTimes x\nelse 1", "annotated": "let additivePersistence : int -> int = fun  n  -> \nif n < 10 then 0  \nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then 1 + addTimes x\nelse 1"}
{"fix": "let _ = additivePersistence 9876", "bad": "let additivePersistence n =\nif n < 10 then 0  \nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then 1 + addTimes x\nelse 1 in\naddTimes n", "annotated": "let additivePersistence : int -> int = fun  n  -> \nif n < 10 then 0  \nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then 1 + addTimes x\nelse 1 in\naddTimes n"}
{"fix": "let rec digitalRoot n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10)", "bad": "let rec digitalRoot n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10)", "annotated": "let rec digitalRoot : int -> int = fun  n  ->  \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot(n/10)"}
{"fix": "let _ = digitalRoot 9876", "bad": "let digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digits(n/10)", "annotated": "let digitalRoot : int -> int = fun  n  ->  \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digits(n/10)"}
{"fix": "let _ = digitalRoot 9876", "bad": "let digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot (n/10)", "annotated": "let digitalRoot : int -> int = fun  n  ->  \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot (n/10)"}
{"fix": "let _ = digitalRoot 9876", "bad": "let digitalRoot n = \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot (n/10)", "annotated": "let digitalRoot : int -> int = fun  n  ->  \nif n <= 0 then 0\nelse (n mod 10) + digitalRoot (n/10)"}
{"fix": "let digitalRoot n =\nif n < 10 then 0\nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then 1 + addTimes x\nelse 1 in\naddTimes n", "bad": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digits (n/10) in\nlet x = digits n in \nif x > 9 then digitalRoot x\nelse x in digitalRoot n", "annotated": "let rec digitalRoot : int -> int = fun  n  ->  \nlet rec digits n = \nif n <= 0 then 0\nelse (n mod 10) + digits (n/10) in\nlet x = digits n in \nif x > 9 then digitalRoot x\nelse x in digitalRoot n"}
{"fix": "let digitalRoot n =\nif n < 10 then 0\nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then 1 + addTimes x\nelse 1 in\naddTimes n", "bad": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in \nif x > 9 then digitalRoot x\nelse x in digitalRoot n", "annotated": "let rec digitalRoot : int -> int = fun  n  ->  \nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in \nif x > 9 then digitalRoot x\nelse x in digitalRoot n"}
{"fix": "let digitalRoot n =\nif n < 10 then 0\nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then 1 + addTimes x\nelse 1 in\naddTimes n", "bad": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in \nif x > 9 then digitalRoot x\nelse 1 in digitalRoot x", "annotated": "let rec digitalRoot : int -> int = fun  n  ->  \nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in \nif x > 9 then digitalRoot x\nelse 1 in digitalRoot x"}
{"fix": "let digitalRoot n =\nif n < 10 then 0\nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then 1 + addTimes x\nelse 1 in\naddTimes n", "bad": "let digitalRoot n =\nif n < 10 then 0\nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then 1 + addTimes x\nelse 1 in\naddTimes n", "annotated": "let digitalRoot : int -> int = fun  n  -> \nif n < 10 then 0\nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then 1 + addTimes x\nelse 1 in\naddTimes n"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l = match l with\n| [] -> []\n| hd::l' -> 1 + listReverse l'", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> []\n| hd::l' -> 1 + listReverse l'"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l = match l with\n| [] -> 0\n| hd::l' -> 1 + listReverse l'", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> 0\n| hd::l' -> 1 + listReverse l'"}
{"fix": "let _ = listReverse [1; 2; 3; 4; 9]", "bad": "let rec listReverse l = match l with\n| [] -> 0\n| _::tl -> 1 + listReverse tl", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> 0\n| _::tl -> 1 + listReverse tl"}
{"fix": "let _ = listReverse [1; 2; 3; 4; 9]", "bad": "let rec listReverse l = match l with\n| [] -> []\n| _::tl -> listReverse _ + tl", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> []\n| _::tl -> listReverse _ + tl"}
{"fix": "let _ = listReverse [1; 2; 3; 4; 9]", "bad": "let rec listReverse l = match l with\n| [] -> []\n| _::tl -> listReverse tl + tl", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> []\n| _::tl -> listReverse tl + tl"}
{"fix": "let _ = listReverse [1; 2; 3; 4; 9]", "bad": "let rec listReverse l = match l with\n| 0 -> []\n| _::tl -> listReverse tl + tl", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| 0 -> []\n| _::tl -> listReverse tl + tl"}
{"fix": "let _ = listReverse [1; 2; 3; 4; 9]", "bad": "let rec listReverse l = match l with\n| [] -> []\n| _::tl -> listReverse tl + tl", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> []\n| _::tl -> listReverse tl + tl"}
{"fix": "let _ = listReverse [1; 2; 3; 4; 9]", "bad": "let rec listReverse l = match l with\n| [] -> []\n| _::tl -> listReverse tl", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> []\n| _::tl -> listReverse tl"}
{"fix": "let _ = listReverse [1; 2; 3; 4; 9]", "bad": "let listReverse l = \nlet rec reverseHelper tl l = match l with\n| [] -> []\n| _::tl -> reverseHelper tl l", "annotated": "let listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec reverseHelper tl l = match l with\n| [] -> []\n| _::tl -> reverseHelper tl l"}
{"fix": "let _ = listReverse [1; 2; 3; 4; 9]", "bad": "let listReverse l = \nlet rec reverseHelper l tl = match l with\n| [] -> []\n| _::t -> reverseHelper t l", "annotated": "let listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec reverseHelper l tl = match l with\n| [] -> []\n| _::t -> reverseHelper t l"}
{"fix": "let _ = listReverse [1; 2; 3; 4; 9]", "bad": "let rec listReverse l =\nmatch l with\n| [] -> []\n| hd::l -> listReverse l", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nmatch l with\n| [] -> []\n| hd::l -> listReverse l"}
{"fix": "let _ = listReverse [1; 2; 3; 4; 9]", "bad": "let listReverse l = \nlet rec reverseHelper acc = \nif [] then acc\nelse reverseHelper (h::acc) t in\nreverseHelper [] l", "annotated": "let listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec reverseHelper acc = \nif [] then acc\nelse reverseHelper (h::acc) t in\nreverseHelper [] l"}
{"fix": "let _ = listReverse [1; 2; 3; 4; 9]", "bad": "let listReverse l = \nlet rec reverseHelper acc = \n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l", "annotated": "let listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec reverseHelper acc = \n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l"}
{"fix": "let _ = listReverse [1; 2; 3; 4; 9]", "bad": "let listReverse l = \nlet rec reverseHelper acc = match acc with \n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l", "annotated": "let listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec reverseHelper acc = match acc with \n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l"}
{"fix": "let _ = listReverse [1; 2; 3; 4; 9]", "bad": "let listReverse l = \nlet rec reverseHelper acc = function\n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l", "annotated": "let listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec reverseHelper acc = function\n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l"}
{"fix": "let _ = palindrome \"malayalam\"", "bad": "let palindrome w = \nif explode w = listReverse w then true\nelse false", "annotated": "let palindrome : string -> bool = fun  w  ->  \nif explode w = listReverse w then true\nelse false"}
{"fix": "let _ = palindrome \"malayalam\"", "bad": "let palindrome w = \nif explode w = listReverse (explode w) then true\nelse false", "annotated": "let palindrome : string -> bool = fun  w  ->  \nif explode w = listReverse (explode w) then true\nelse false"}
{"fix": "let _ = palindrome \"_\"", "bad": "let _ = palindrome \"\"", "annotated": "let _ = palindrome \"\""}
{"fix": "let _ = listReverse [1; 2; 3; 4; 9]", "bad": "let listReverse l = \nlet rec reverseHelper acc = function \n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l", "annotated": "let listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec reverseHelper acc = function \n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l"}
{"fix": "let _ = listReverse [1; 2; 3; 4; 9]", "bad": "let listReverse l = \n(*let rec reverseHelper acc = function \n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l *)\nlet rec reverseHelper ln lo =\nmatch ln with\n| [] -> lo\n| h::t -> reverseHelper t (h::lo) in\nreverseHelper l []", "annotated": "let listReverse : 'a list -> 'a list = fun  l  ->  \n(*let rec reverseHelper acc = function \n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l *)\nlet rec reverseHelper ln lo =\nmatch ln with\n| [] -> lo\n| h::t -> reverseHelper t (h::lo) in\nreverseHelper l []"}
{"fix": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = [] in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a*a + x in\nlet base = [] in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = a in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a*a + x in\nlet base = a in\nList.fold_left f base xs"}
{"fix": "let pipe fs = \nlet f a x = fun y -> y |> a |> x in\nlet base = fun y -> y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun inner -> y |> a |> x in\nlet base = fun y -> y in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun inner -> y |> a |> x in\nlet base = fun y -> y in\nList.fold_left f base fs"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep^a in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep^a t in\nlet base = h in\nlet l = sl in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep^a t in\nlet base = h in\nlet l = sl in\nList.fold_left f base l"}
{"fix": "let stringOfList f l = List.map f l", "bad": "let stringOfList f l = in List.map f sepConcat \" \" l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  in List.map f sepConcat \" \" l"}
{"fix": "let stringOfList f l = sepConcat \"[\" (List.map f l)", "bad": "let stringOfList f l = sepConcat \"[\" List.map f l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat \"[\" List.map f l"}
{"fix": "let stringOfList f l = sepConcat \"; \" (List.map f l)", "bad": "let stringOfList f l = sepConcat \"; \" List.map f l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat \"; \" List.map f l"}
{"fix": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 then true\nelse false", "bad": "let padZero l1 l2 = \nlet f a l = a+1 l in \nlet base = a\nin List.fold_left f base", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet f a l = a+1 l in \nlet base = a\nin List.fold_left f base"}
{"fix": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 then true\nelse false", "bad": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) acc l1", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet length1 = List.fold_left (fun acc x -> acc + 1) acc l1"}
{"fix": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 then true\nelse false", "bad": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) acc l1", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet length1 = List.fold_left (fun acc x -> acc + 1) acc l1"}
{"fix": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 then true\nelse false", "bad": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) acc l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) acc l2 in\nif length1 < length2 then true\nelse false", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet length1 = List.fold_left (fun acc x -> acc + 1) acc l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) acc l2 in\nif length1 < length2 then true\nelse false"}
{"fix": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 = length2 \nthen (l1,l2)\nelse \nif length1 < length2\nthen (List.append (clone 0 (length2 - length1)) l1, l2)\nelse (l1, (List.append (clone 0 (length1 - length2)) l2))", "bad": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 \nthen clone (length2-length1) 0 \nelse if length2 < length1\nthen clone (length1-length2) 0", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 \nthen clone (length2-length1) 0 \nelse if length2 < length1\nthen clone (length1-length2) 0"}
{"fix": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 = length2 \nthen (l1,l2)\nelse \nif length1 < length2\nthen (List.append (clone 0 (length2 - length1)) l1, l2)\nelse (l1, (List.append (clone 0 (length1 - length2)) l2))", "bad": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 \nthen clone (length2 - length1) 0 \nelse if length2 < length1\nthen clone (length1-length2) 0", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 \nthen clone (length2 - length1) 0 \nelse if length2 < length1\nthen clone (length1-length2) 0"}
{"fix": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 = length2 \nthen (l1,l2)\nelse \nif length1 < length2\nthen (List.append (clone 0 (length2 - length1)) l1, l2)\nelse (l1, (List.append (clone 0 (length1 - length2)) l2))", "bad": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 \nthen clone (length2 - length1) 0 \nelse if length2 < length1\nthen clone (length1 - length2) 0", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 \nthen clone (length2 - length1) 0 \nelse if length2 < length1\nthen clone (length1 - length2) 0"}
{"fix": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 = length2 \nthen (l1,l2)\nelse \nif length1 < length2\nthen (List.append (clone 0 (length2 - length1)) l1, l2)\nelse (l1, (List.append (clone 0 (length1 - length2)) l2))", "bad": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 \nthen clone 0 (length2 - length1) \nelse if length2 < length1\nthen clone 0 (length1 - length2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 \nthen clone 0 (length2 - length1) \nelse if length2 < length1\nthen clone 0 (length1 - length2)"}
{"fix": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 = length2 \nthen (l1,l2)\nelse \nif length1 < length2\nthen (List.append (clone 0 (length2 - length1)) l1, l2)\nelse (l1, (List.append (clone 0 (length1 - length2)) l2))", "bad": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 \nthen let pad1 = clone 0 (length2 - length1) in\nelse if length2 < length1\nthen let pad2 = clone 0 (length1 - length2) in\nList.append pad1 l1", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 \nthen let pad1 = clone 0 (length2 - length1) in\nelse if length2 < length1\nthen let pad2 = clone 0 (length1 - length2) in\nList.append pad1 l1"}
{"fix": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 = length2 \nthen (l1,l2)\nelse \nif length1 < length2\nthen (List.append (clone 0 (length2 - length1)) l1, l2)\nelse (l1, (List.append (clone 0 (length1 - length2)) l2))", "bad": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 \nthen let pad1 = clone 0 (length2 - length1) in\nelse if length2 < length1\nthen let pad2 = clone 0 (length1 - length2) in\nList.append pad1 l1", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 \nthen let pad1 = clone 0 (length2 - length1) in\nelse if length2 < length1\nthen let pad2 = clone 0 (length1 - length2) in\nList.append pad1 l1"}
{"fix": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 = length2 \nthen (l1,l2)\nelse \nif length1 < length2\nthen (List.append (clone 0 (length2 - length1)) l1, l2)\nelse (l1, (List.append (clone 0 (length1 - length2)) l2))", "bad": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 \nthen let pad1 = clone 0 (length2 - length1)\nelse if length2 < length1\nthen let pad2 = clone 0 (length1 - length2) in\nList.append pad1 l1", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 \nthen let pad1 = clone 0 (length2 - length1)\nelse if length2 < length1\nthen let pad2 = clone 0 (length1 - length2) in\nList.append pad1 l1"}
{"fix": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 = length2 \nthen (l1,l2)\nelse \nif length1 < length2\nthen (List.append (clone 0 (length2 - length1)) l1, l2)\nelse (l1, (List.append (clone 0 (length1 - length2)) l2))", "bad": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 \nthen let pad1 = clone 0 (length2 - length1)\nelse if length2 < length1\nthen let pad2 = clone 0 (length1 - length2) in\nList.append pad1 l1", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 \nthen let pad1 = clone 0 (length2 - length1)\nelse if length2 < length1\nthen let pad2 = clone 0 (length1 - length2) in\nList.append pad1 l1"}
{"fix": "let rec removeZero l = match l with\n| [] -> l\n| x::l' -> \nif x=0 \nthen removeZero l'\nelse l", "bad": "let rec removeZero l = match l with\n| [] -> 0\n| x::l' -> if x = 0\nthen List.fold_left (fun acc x -> acc+1) 0 l", "annotated": "let rec removeZero : int list -> int list = fun  l  ->  match l with\n| [] -> 0\n| x::l' -> if x = 0\nthen List.fold_left (fun acc x -> acc+1) 0 l"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet (carry, acc) = a in\nlet (fact, dig)  = x in\nlet prod = mulByDigit dig l1 @ clone 0 carry in\nlet result = bigAdd prod acc in\n(carry+1, result) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet (carry, acc) = a in\nlet (fact, dig)  = x in\nlet prod = mulByDigit dig l1 @ clone 0 carry in\nlet result = bigAdd prod acc in\n(i+1, result) in\nlet base =  in\nlet args = in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet (carry, acc) = a in\nlet (fact, dig)  = x in\nlet prod = mulByDigit dig l1 @ clone 0 carry in\nlet result = bigAdd prod acc in\n(i+1, result) in\nlet base =  in\nlet args = in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet (carry, acc) = a in\nlet (fact, dig)  = x in\nlet prod = mulByDigit dig l1 @ clone 0 carry in\nlet result = bigAdd prod acc in\n(carry+1, result) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet (carry, acc) = a in\nlet (fact, dig)  = x in\nlet prod = mulByDigit dig l1 @ clone 0 carry in\nlet result = bigAdd prod acc in\n(i+1, result) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet (carry, acc) = a in\nlet (fact, dig)  = x in\nlet prod = mulByDigit dig l1 @ clone 0 carry in\nlet result = bigAdd prod acc in\n(i+1, result) in\nlet base =  (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList (List.tl xs)", "bad": "let rec sumList xs = match xs with [] -> 0 | f::b -> f + sumList List.tl xs", "annotated": "let rec sumList : int list -> int = fun  xs  ->  match xs with [] -> 0 | f::b -> f + sumList List.tl xs"}
{"fix": "let rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt n)", "bad": "let rec digitsOfInt n = if n<0 [] else match n with f::b -> f", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  if n<0 [] else match n with f::b -> f"}
{"fix": "let rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt n)", "bad": "let rec digitsOfInt n = if n<0 then [] else match n with f::b -> f", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  if n<0 then [] else match n with f::b -> f"}
{"fix": "let rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt n)", "bad": "let rec digitsOfInt n = if n<0 then [] else (n mod 10)::digitsOfInt n*10", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  if n<0 then [] else (n mod 10)::digitsOfInt n*10"}
{"fix": "let rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt n)", "bad": "let rec digitsOfInt n = if n<0 then [] else (n mod 10)::(digitsOfInt n*10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  if n<0 then [] else (n mod 10)::(digitsOfInt n*10)"}
{"fix": "let rec persistenceHelper q = let x = sumList q in (if x<10 then 1 else 1+persistenceHelper (digits x))", "bad": "let rec persistenceHelper q = let x = sumList q in", "annotated": "let rec persistenceHelper q = let x = sumList q in"}
{"fix": "let _ = additivePersistence 9876", "bad": "let _ = additivePersistence -9876", "annotated": "let _ = additivePersistence -9876"}
{"fix": "let _ = additivePersistence 9", "bad": "let _ = additivePersistence -9876", "annotated": "let _ = additivePersistence -9876"}
{"fix": "let _ = digitalRoot (-45)", "bad": "let _ = digitalRoot -4", "annotated": "let _ = digitalRoot -4"}
{"fix": "let _ = digitalRoot (-45)", "bad": "let _ = digitalRoot -434", "annotated": "let _ = digitalRoot -434"}
{"fix": "let _ = digitalRoot 459", "bad": "let _ = digitalRoot -459", "annotated": "let _ = digitalRoot -459"}
{"fix": "let palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true else false", "bad": "let palindrome w = let x = listReverse (explode w) in if(x=(explode (w))) then true esle false", "annotated": "let palindrome : string -> bool = fun  w = let x = listReverse (explode w) in if(x -> (explode (w))) then true esle false"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen' then seen' else h::seen' in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen' then seen' else h::seen' in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile ((let func x = if (f x)= x then (x,false) else (f x,true) ),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let func x = if (f x) ->  x then (x,false) else (f x,true) ),b)"}
{"fix": "et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile ((let func x = if (f x)= x then (x,false) else (f x,true)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let func x = if (f x) ->  x then (x,false) else (f x,true)),b)"}
{"fix": "et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile ((let func x = (if (f x)= x then (x,false) else (f x,true))),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let func x = (if (f x) ->  x then (x,false) else (f x,true))),b)"}
{"fix": "et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile ((let func x = (if (f x)= x then (x,false) else ((f x),true))),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let func x = (if (f x) ->  x then (x,false) else ((f x),true))),b)"}
{"fix": "et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile ((let func x = (if ((f x)= x) then (x,false) else (f x,true))),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let func x = (if ((f x) ->  x) then (x,false) else (f x,true))),b)"}
{"fix": "et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile (((if ((f x)= x) then (x,false) else (f x,true))),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (((if ((f x) ->  x) then (x,false) else (f x,true))),b)"}
{"fix": "et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile ((let func x = (if ((f x)= x) then (x,false) else (f x,true)) in func x),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let func x = (if ((f x) ->  x) then (x,false) else (f x,true)) in func x),b)"}
{"fix": "et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile ((let func x = (if ((f x)= x) then (x,false) else (f x,true)) in func),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let func x = (if ((f x) ->  x) then (x,false) else (f x,true)) in func),b)"}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = match e with VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ex -> \"sin(pi*\"^ exprToString ex ^\")\"\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times ex1 ex2 -> ex1^\"*\"^ex2\n| Thresh ex1 ex2 ex3 ex4 -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ex -> \"sin(pi*\"^ exprToString ex ^\")\"\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times ex1 ex2 -> ex1^\"*\"^ex2\n| Thresh ex1 ex2 ex3 ex4 -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\""}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = match e with VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ex -> \"sin(pi*\"^ exprToString ex ^\")\"\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> ex1^\"*\"^ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ex -> \"sin(pi*\"^ exprToString ex ^\")\"\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> ex1^\"*\"^ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\""}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = match e with VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ex -> \"sin(pi*\"^ exprToString ex ^\")\"\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ex -> \"sin(pi*\"^ exprToString ex ^\")\"\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\""}
{"fix": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "bad": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*. exprToString ex )\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*. exprToString ex )\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\""}
{"fix": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "bad": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*. eval ex )\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*. eval ex )\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\""}
{"fix": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "bad": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*. eval ex x y )\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*. eval ex x y )\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\""}
{"fix": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "bad": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval ex x y )\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval ex x y )\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\""}
{"fix": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "bad": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval ex x y )", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval ex x y )"}
{"fix": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "bad": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval ex x y )", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval ex x y )"}
{"fix": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "bad": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval ex x y )", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval ex x y )"}
{"fix": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "bad": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex x y) )", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex x y) )"}
{"fix": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "bad": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )"}
{"fix": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)", "bad": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\""}
{"fix": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)", "bad": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((exprToString (ex1,x,y)+.exprToString (ex2,x,y))/.2)\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((exprToString (ex1,x,y)+.exprToString (ex2,x,y))/.2)\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\""}
{"fix": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)", "bad": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2)\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2)\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\""}
{"fix": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)", "bad": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/2)\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/2)\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\""}
{"fix": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)", "bad": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\""}
{"fix": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)", "bad": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\""}
{"fix": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)", "bad": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\""}
{"fix": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)", "bad": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) -> (eval (ex1,x,y)<eval (ex2,x,y) ? eval (ex3,x,y): eval (ex4,x,y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) -> (eval (ex1,x,y)<eval (ex2,x,y) ? eval (ex3,x,y): eval (ex4,x,y))"}
{"fix": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)", "bad": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) -> (eval (ex1,x,y)<eval (ex2,x,y)? eval (ex3,x,y): eval (ex4,x,y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) -> (eval (ex1,x,y)<eval (ex2,x,y)? eval (ex3,x,y): eval (ex4,x,y))"}
{"fix": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)", "bad": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) -> (eval (ex1,x,y)<eval (ex2,x,y)?eval (ex3,x,y): eval (ex4,x,y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) -> (eval (ex1,x,y)<eval (ex2,x,y)?eval (ex3,x,y): eval (ex4,x,y))"}
{"fix": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)", "bad": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) -> (eval(ex1,x,y)<eval(ex2,x,y) ? eval(ex3,x,y):eval(ex4,x,y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) -> (eval(ex1,x,y)<eval(ex2,x,y) ? eval(ex3,x,y):eval(ex4,x,y))"}
{"fix": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)", "bad": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y) then eval(ex3,x,y) else eval(ex4,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y) then eval(ex3,x,y) else eval(ex4,x,y)"}
{"fix": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)", "bad": ")", "annotated": ")"}
{"fix": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)", "bad": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  (eval(ex1,x,y)<eval(ex2,x,y)) ? eval(ex3,x,y):eval(ex4,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  (eval(ex1,x,y)<eval(ex2,x,y)) ? eval(ex3,x,y):eval(ex4,x,y)"}
{"fix": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)", "bad": ")", "annotated": ")"}
{"fix": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)", "bad": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  (eval(ex1,x,y)<eval(ex2,x,y)) ? eval(ex3,x,y) : eval(ex4,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  (eval(ex1,x,y)<eval(ex2,x,y)) ? eval(ex3,x,y) : eval(ex4,x,y)"}
{"fix": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)", "bad": ")", "annotated": ")"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)"}
{"fix": "let _ = eval (sampleExpr,0.5,0.2)", "bad": "let _ = eval (sampleExpr1,0.5,0.2)", "annotated": "let _ = eval (sampleExpr1,0.5,0.2)"}
{"fix": " rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)", "bad": "let _ = eval (sampleExpr,0.5,0.2)", "annotated": "let _ = eval (sampleExpr,0.5,0.2)"}
{"fix": "let rec assoc (d,k,l) = match l with []-> d\n| (str,key)::ls-> if k=str then key\nelse \nassoc (d,k,ls)", "bad": "let rec build (rand, depth) = if depth= 0 then (let case = rand(0,1)) \nelse let case = rand(0,6)in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = if depth= 0 then (let case  ->  rand(0,1)) \nelse let case = rand(0,6)in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}
{"fix": "let rec assoc (d,k,l) = match l with []-> d\n| (str,key)::ls-> if k=str then key\nelse \nassoc (d,k,ls)", "bad": "let rec build (rand, depth) = if depth= 0 then (let case = rand(0,1)) else let case = rand(0,6)in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = if depth= 0 then (let case = rand(0,1)) else let case  ->  rand(0,6)in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}
{"fix": "let rec assoc (d,k,l) = match l with []-> d\n| (str,key)::ls-> if k=str then key\nelse \nassoc (d,k,ls)", "bad": "let rec build (rand, depth) = (if depth= 0 then (let case = rand(0,1)) else let case = rand(0,6)) in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = (if depth= 0 then (let case = rand(0,1)) else let case  ->  rand(0,6)) in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}
{"fix": "let rec assoc (d,k,l) = match l with []-> d\n| (str,key)::ls-> if k=str then key\nelse \nassoc (d,k,ls)", "bad": "let rec build (rand, depth) = if depth= 0 then let case = rand(0,1) in  else let case = rand(0,6) in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = if depth= 0 then let case = rand(0,1) in  else let case  ->  rand(0,6) in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}
{"fix": "let rec assoc (d,k,l) = match l with []-> d\n| (str,key)::ls-> if k=str then key\nelse \nassoc (d,k,ls)", "bad": "let rec build (rand, depth) = if depth= 0 then (let case = rand(0,1) in)  else let case = rand(0,6) in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = if depth= 0 then (let case = rand(0,1) in)  else let case  ->  rand(0,6) in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}
{"fix": "let rec assoc (d,k,l) = match l with []-> d\n| (str,key)::ls-> if k=str then key\nelse \nassoc (d,k,ls)", "bad": "let rec build (rand, depth) = let case = 0 in if depth= 0 then ( case = rand(0,1) in", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case = 0 in if depth= 0 then ( case  ->  rand(0,1) in"}
{"fix": "let rec assoc (d,k,l) = match l with []-> d\n| (str,key)::ls-> if k=str then key\nelse \nassoc (d,k,ls)", "bad": ")  else let case = rand(0,6) in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "annotated": ")  else let case = rand(0,6) in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}
{"fix": "let rec assoc (d,k,l) = match l with []-> d\n| (str,key)::ls-> if k=str then key\nelse \nassoc (d,k,ls)", "bad": "let rec build (rand, depth) = let case = 0 in if depth= 0 then case = rand(0,1) in  else let case = rand(0,6) in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case = 0 in if depth= 0 then case = rand(0,1) in  else let case  ->  rand(0,6) in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}
{"fix": "let rec assoc (d,k,l) = match l with []-> d\n| (str,key)::ls-> if k=str then key\nelse \nassoc (d,k,ls)", "bad": "let rec build (rand, depth) = let case = 0 in if depth= 0 then case = rand(0,1)  else let case = rand(0,6) in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case = 0 in if depth= 0 then case = rand(0,1)  else let case  ->  rand(0,6) in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}
{"fix": "let rec assoc (d,k,l) = match l with []-> d\n| (str,key)::ls-> if k=str then key\nelse \nassoc (d,k,ls)", "bad": "let rec build (rand, depth) = let case = 0 in if depth= 0 then case = rand(0,1)  else let case = rand(0,6) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case = 0 in if depth= 0 then case = rand(0,1)  else let case  ->  rand(0,6) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}
{"fix": "let rec assoc (d,k,l) = match l with []-> d\n| (str,key)::ls-> if k=str then key\nelse \nassoc (d,k,ls)", "bad": "let rec build (rand, depth) = if depth= 0 then let case = rand(0,1) else let case = rand(0,6) in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = if depth= 0 then let case = rand(0,1) else let case  ->  rand(0,6) in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}
{"fix": "let rec assoc (d,k,l) = match l with []-> d\n| (str,key)::ls-> if k=str then key\nelse \nassoc (d,k,ls)", "bad": "let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case = rand(0,6) in if depth= 0 then let case  ->  rand(0,1) in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}
{"fix": "let rec assoc (d,k,l) = match l with []-> d\n| (str,key)::ls-> if k=str then key\nelse \nassoc (d,k,ls)", "bad": "let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case = rand(0,6) in if depth= 0 then let case  ->  rand(0,1) in\nmatch case with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}
{"fix": "let rec build (rand, depth) = let case = rand(0,6)", "bad": "let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case = rand(0,6) in if depth= 0 then let case  ->  rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}
{"fix": "let rec build (rand, depth) = let case = rand(0,6)", "bad": "let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case = rand(0,6) in if depth= 0 then let case  ->  rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}
{"fix": "let rec build (rand, depth) = let case = rand(0,6)", "bad": "let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case = rand(0,6) in if depth= 0 then let case  ->  rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}
{"fix": "let rec build (rand, depth) = let case = rand(0,6)", "bad": "let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> VarX\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case = rand(0,6) in if depth= 0 then let case  ->  rand(0,1) in\nmatch case with\n| 0 -> VarX\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}
{"fix": "let rec build (rand, depth) = let case = rand(0,6)", "bad": "let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case = rand(0,6) in if depth= 0 then let case  ->  rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}
{"fix": "let rec build (rand, depth) = let case = rand(0,6)", "bad": "let rec build (rand, depth) = let case = rand(0,6) in \nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case  ->  rand(0,6) in \nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}
{"fix": "let rec build (rand, depth) = if depth=0 then(\nmatch rand(0,5) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))\nelse\nmatch rand(0,0) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec build (rand, depth) = let case = rand(0,6)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let case  ->  rand(0,6)"}
{"fix": "let rec build (rand, depth) = if depth=0 then(\nmatch rand(0,5) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))\nelse\nmatch rand(0,0) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "annotated": "let if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}
{"fix": "let rec build (rand, depth) = if depth=0 then(\nmatch rand(0,5) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))\nelse\nmatch rand(0,0) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec build (rand, depth) = if depth=0 then(\nmatch rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))\nelse\nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = if depth -> 0 then(\nmatch rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))\nelse\nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"}
{"fix": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)\n| FiboPlus (ex1,ex2,ex3,ex4,ex5) -> ((eval (ex1,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y)+.eval (ex4,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y)+.eval (ex4,x,y)+.eval (ex5,x,y)))\n| TheThing (ex1,ex2,ex3) -> ((eval (ex1,x,y)*.sin(pi*. eval (ex2,x,y))*.cos(pi*. eval (ex3,x,y)))/.2.)", "bad": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)\n| FiboPlus (ex1,ex2,ex3,ex4,ex5) -> ((eval (ex1,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y)+.eval (ex4,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y)+.eval (ex4,x,y)+.eval (ex5,x,y)))\n| TheThing (ex1,ex2,ex3) -> ((eval (ex1,x,y)*.sin(pi*. eval (ex2,x,y))*.cos(pi*. eval (ex3,x,y)))/.2.)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> cos(pi*. eval (ex,x,y) )\n| Average (ex1,ex2) -> ((eval (ex1,x,y)+.eval (ex2,x,y))/.2.)\n| Times (ex1,ex2) -> eval (ex1,x,y)*.eval (ex2,x,y)\n| Thresh (ex1,ex2,ex3,ex4) ->  if (eval(ex1,x,y)<eval(ex2,x,y)) then eval(ex3,x,y) else eval(ex4,x,y)\n| FiboPlus (ex1,ex2,ex3,ex4,ex5) -> ((eval (ex1,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y)+.eval (ex4,x,y))*.(eval (ex1,x,y)+.eval (ex2,x,y)+.eval (ex3,x,y)+.eval (ex4,x,y)+.eval (ex5,x,y)))\n| TheThing (ex1,ex2,ex3) -> ((eval (ex1,x,y)*.sin(pi*. eval (ex2,x,y))*.cos(pi*. eval (ex3,x,y)))/.2.)"}
{"fix": "let rec build (rand, depth) = if depth>0 then(\nmatch rand(0,8) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))\n| 7 -> buildSixtyNine(build (rand,depth-1))\n| 8 -> buildTheThing(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))\nelse\nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec build (rand, depth) = if depth>0 then(\nmatch rand(0,8) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))\n| 7 -> buildSixtyNine(build (rand,depth-1))\n| 8 -> buildTheThing(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))\nelse\nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  if depth>0 then(\nmatch rand(0,8) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))\n| 7 -> buildSixtyNine(build (rand,depth-1))\n| 8 -> buildTheThing(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))\nelse\nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"}
{"fix": "let pipe fs = \nlet f a x = x(a) in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x(a) in\nlet base = 'a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x(a) in\nlet base = 'a in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = x(fs) in\nlet base = a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x(fs) in\nlet base = a in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = x(fs) in\nlet base = _ in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x(fs) in\nlet base = _ in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = x(fs) in\nlet base = 'a->'a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x(fs) in\nlet base = 'a->'a in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = x(fs) in\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x(fs) in\nlet base = 0 in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = x(fs) in\nlet base = fs in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x(fs) in\nlet base = fs in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = x(fs) in\nlet base = a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x(fs) in\nlet base = a in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = a+x(fs) in\nlet base = a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a+x(fs) in\nlet base = a in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = x(a) in\nlet base =  in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x(a) in\nlet base =  in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = x(a) in\nlet base =  a'-> fs in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x(a) in\nlet base =  a'-> fs in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = x(a) in\nlet base =  'a-> fs in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x(a) in\nlet base =  'a-> fs in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = x(a) in\nlet base =  'a-> fs in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x(a) in\nlet base =  'a-> fs in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = x(a) in\nlet base =  'a -> fs in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x(a) in\nlet base =  'a -> fs in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = x(a) in\nlet base = fs in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x(a) in\nlet base = fs in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = x(a) in\nlet base = fs->fs in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x(a) in\nlet base = fs->fs in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = x(a) in\nlet base = fs(fs) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x(a) in\nlet base = fs(fs) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =  x in\nlet base = fun q->q in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  in\nlet base = fun q->q in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  in\nlet base = fun q->q in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =  x(a) in\nlet base = (fun q->q) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  a(x) in\nlet base = (fun q->q) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  a(x) in\nlet base = (fun q->q) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =  x(a) in\nlet base = (fun q->q) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  a(x) in\nlet base = (fun q->q) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  a(x) in\nlet base = (fun q->q) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x(a) in\nlet base = (fun q->q) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  f x(a) in\nlet base = (fun q->q) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  f x(a) in\nlet base = (fun q->q) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun w -> x(a) in\nlet base = (fun q->q) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x -> a in\nlet base = (fun q->q) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x -> a in\nlet base = (fun q->q) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun w -> x(a) in\nlet base = (fun a->a) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun w -> x(a) in\nlet base = (fun a->q) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun w -> x(a) in\nlet base = (fun a->q) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a  in\nlet base = fun a -> a in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = (fun a->a) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = (fun a->a) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a  in\nlet base = fun a -> a in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a -> a x in\nlet base = (fun a->a) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a -> a x in\nlet base = (fun a->a) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a  in\nlet base = fun a -> a in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a -> a x in\nlet base = (fun 'a->'a) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a -> a x in\nlet base = (fun 'a->'a) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a  in\nlet base = fun a -> a in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  match x with x:xs in\nlet base = (fun a->a) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  match x with x:xs in\nlet base = (fun a->a) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a  in\nlet base = fun a -> a in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  match x with x:fs in\nlet base = (fun a->a) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  match x with x:fs in\nlet base = (fun a->a) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a  in\nlet base = fun a -> a in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  match fs with x::xs in\nlet base = (fun a->a) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  match fs with x::xs in\nlet base = (fun a->a) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a  in\nlet base = fun a -> a in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a  in\nlet base = a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a  in\nlet base = a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a  in\nlet base = fun a -> a in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a  in\nlet base = fun s -> a s in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a  in\nlet base = fun s -> a s in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun w -> x(a(w))   in\nlet base = fun a -> a in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a(x)   in\nlet base = fun a -> a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a(x)   in\nlet base = fun a -> a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun w -> x(a(w))   in\nlet base = fun a -> a in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x   in\nlet base = fun a -> a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x   in\nlet base = fun a -> a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun w -> x(a(w))   in\nlet base = fun a -> a in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x   in\nlet base =  a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x   in\nlet base =  a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun w -> x(a(w))   in\nlet base = fun a -> a in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x   in\nlet base =  x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x   in\nlet base =  x in\nList.fold_left f base fs"}
{"fix": "let stringOfList f l = \"[\"^(sepConcat \"; \" (List.map f l))^\"]\"", "bad": "let stringOfList f l = \"[\"^(sepConcat \"; \"(List.map f \"\" l))^\"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\"^(sepConcat \"; \"(List.map f \"\" l))^\"]\""}
{"fix": "let stringOfList f l = \"[\"^(sepConcat \"; \" (List.map f l))^\"]\"", "bad": "let stringOfList f l = \"[\"^(sepConcat \"; \" (List.map f \"\" l))^\"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\"^(sepConcat \"; \" (List.map f \"\" l))^\"]\""}
{"fix": "let rec clone x n = if n<1 then [] \nelse \nlet rec helper acc f x = match x with \n| 0 -> acc\n| _ -> helper (f::acc) f (x-1)\nin helper [] x n", "bad": "let rec clone x n = if n<1 then return [] \nelse \nlet rec helper acc f x = match x with \n| 0 -> acc\n| _ -> helper (f::acc) f x-1\nin helper [] x n", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  if n<1 then return [] \nelse \nlet rec helper acc f x = match x with \n| 0 -> acc\n| _ -> helper (f::acc) f x-1\nin helper [] x n"}
{"fix": "let rec clone x n = if n<1 then [] \nelse \nlet rec helper acc f x = match x with \n| 0 -> acc\n| _ -> helper (f::acc) f (x-1)\nin helper [] x n", "bad": "let rec clone x n = if n<1 then [] \nelse \nlet rec helper acc f x = match x with \n| 0 -> acc\n| _ -> helper (f::acc) f x-1\nin helper [] x n", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  if n<1 then [] \nelse \nlet rec helper acc f x = match x with \n| 0 -> acc\n| _ -> helper (f::acc) f x-1\nin helper [] x n"}
{"fix": "let padZero l1 l2 = let x = (List.length l1 - List.length l2) in \nif x!=0 then\nif x<0 then\n(((clone 0 (abs x))@l1),l2)\nelse \n(l1,((clone 0 (abs x))@l2))\nelse \n(l1,l2)", "bad": "let padZero l1 l2 = let x = (List.length l1 - List.length l2) in \nif x then\nif x<0 then\n(((clone 0 (abs x))@l1),l2)\nelse \n(l1,((clone 0 (abs x))@l2))\nelse \n(l1,l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let x  ->  (List.length l1 - List.length l2) in \nif x then\nif x<0 then\n(((clone 0 (abs x))@l1),l2)\nelse \n(l1,((clone 0 (abs x))@l2))\nelse \n(l1,l2)"}
{"fix": "let rec removeZero l = match l with\n| x::xs -> if x=0 then removeZero xs\nelse xs\n| _ -> l", "bad": "let rec removeZero l = match l with\n| x:xs -> if x=0 then removeZero xs\nelse xs\n| _ -> l", "annotated": "let rec removeZero : int list -> int list = fun  l  ->  match l with\n| x:xs -> if x=0 then removeZero xs\nelse xs\n| _ -> l"}
{"fix": "let _ =List.combine (clone 7 7)(List.combine [0;0;0;1;0;0;2][0;0;0;1;0;0;2])", "bad": "let _ =List.combine ((clone 7 7)(List.combine [0;0;0;1;0;0;2][0;0;0;1;0;0;2]) )", "annotated": "let _ =List.combine ((clone 7 7)(List.combine [0;0;0;1;0;0;2][0;0;0;1;0;0;2]) )"}
{"fix": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d,(b,c)) -> let sum= b+c in \nif sum<10 then \nmatch a with \n| [] -> sum::a\n| x'::xs' -> \nif (x'=(-1)) then\nif (sum=9) then\n-1::0::xs'\nelse\n(sum+1)::xs'\nelse \nsum::a\nelse\nmatch a with \n| [] -> -1::(sum mod 10)::a\n| x'::xs' -> \nif (x'=(-1)) then\n-1::(sum mod 10)::a\nelse \n-1::(sum mod 10)::a\n\nin\nlet base = [] in\nlet args = List.combine (clone (List.length l1) (List.length l1)) (List.combine (List.rev l1) (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (d,(b,c)) -> let sum= b+c in \nif sum<10 then \nmatch a with \n| [] -> sum::a\n| x'::xs' -> \nif (x'=(-1)) then\nif (sum=9) then\n-1::0::xs'\nelse\n(sum+1)::xs'\nelse \nsum::a\nelse\nmatch a with \n| [] -> -1::(sum mod 10)::a\n| x'::xs' -> \nif (x'=(-1)) then\n-1::(sum mod 10)::a\nelse \n-1::(sum mod 10)::a\n\nin\nlet base = [] in\nlet args = List.combine (clone (List.length l1) (List.length l1)) (List.combine (List.rev l1) (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d,(b,c)) -> let sum= b+c in \nif sum<10 then \nmatch a with \n| [] -> sum::a\n| x'::xs' -> \nif (x'=(-1)) then\nif (sum=9) then\n-1::0::xs'\nelse\n(sum+1)::xs'\nelse \nsum::a\nelse\nmatch a with \n| [] -> -1::(sum mod 10)::a\n| x'::xs' -> \nif (x'=(-1)) then\n-1::(sum mod 10)::a\nelse \n-1::(sum mod 10)::a\n\nin\nlet base = [] in\nlet args = List.combine (clone (List.length l1) (List.length l1)) (List.combine (List.rev l1) (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (d,(b,c)) -> let sum= b+c in \nif sum<10 then \nmatch a with \n| [] -> sum::a\n| x'::xs' -> \nif (x'=(-1)) then\nif (sum=9) then\n-1::0::xs'\nelse\n(sum+1)::xs'\nelse \nsum::a\nelse\nmatch a with \n| [] -> -1::(sum mod 10)::a\n| x'::xs' -> \nif (x'=(-1)) then\n-1::(sum mod 10)::a\nelse \n-1::(sum mod 10)::a\n\nin\nlet base = [] in\nlet args = List.combine (clone (List.length l1) (List.length l1)) (List.combine (List.rev l1) (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (b,c) -> let sum= b+c in \nif sum<10 then \nmatch a with \n| (len,[]) -> (len,[sum])\n| (len,x'::xs') -> \nif (x'=(-1)) then\nif (sum=9) then\n(len,-1::0::xs')\nelse\n(len,(sum+1)::xs')\nelse \n(len,sum::x'::xs')\nelse\nmatch a with \n| (len,[]) -> (len,-1::[(sum mod 10)])\n| (len,x'::xs') -> \nif (x'=(-1)) then\n(len,-1::((sum mod 10)+1)::xs')\nelse \n(len,-1::(sum mod 10)::x'::xs')\n\nin\nlet base = (List.length l1,[]) in\nlet args = (List.combine (List.rev l1) (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d,(b,c)) -> let sum= b+c in \nif sum<10 then \nmatch a with \n| [] -> sum::a\n| x'::xs' -> \nif (x'=(-1)) then\nif (sum=9) then\n-1::0::xs'\nelse\n(sum+1)::xs'\nelse \nsum::a\nelse\nmatch a with \n| [] -> -1::(sum mod 10)::a\n| x'::xs' -> \nif (x'=(-1)) then\n-1::(sum mod 10)::a\nelse \n-1::(sum mod 10)::a\n\nin\nlet base = (List.length l1,[]) in\nlet args = List.combine (clone (List.length l1) (List.length l1)) (List.combine (List.rev l1) (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (d,(b,c)) -> let sum= b+c in \nif sum<10 then \nmatch a with \n| [] -> sum::a\n| x'::xs' -> \nif (x'=(-1)) then\nif (sum=9) then\n-1::0::xs'\nelse\n(sum+1)::xs'\nelse \nsum::a\nelse\nmatch a with \n| [] -> -1::(sum mod 10)::a\n| x'::xs' -> \nif (x'=(-1)) then\n-1::(sum mod 10)::a\nelse \n-1::(sum mod 10)::a\n\nin\nlet base = (List.length l1,[]) in\nlet args = List.combine (clone (List.length l1) (List.length l1)) (List.combine (List.rev l1) (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (b,c) -> let sum= b+c in \nif sum<10 then \nmatch a with \n| (len,[]) -> (len,[sum])\n| (len,x'::xs') -> \nif (x'=(-1)) then\nif (sum=9) then\n(len,-1::0::xs')\nelse\n(len,(sum+1)::xs')\nelse \n(len,sum::x'::xs')\nelse\nmatch a with \n| (len,[]) -> (len,-1::[(sum mod 10)])\n| (len,x'::xs') -> \nif (x'=(-1)) then\n(len,-1::((sum mod 10)+1)::xs')\nelse \n(len,-1::(sum mod 10)::x'::xs')\n\nin\nlet base = (List.length l1,[]) in\nlet args = (List.combine (List.rev l1) (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (b,c) -> let sum= b+c in \nif sum<10 then \nmatch a with \n| (len,[]) -> (len,[sum])\n| (len,x'::xs') -> \nif (x'=(-1)) then\nif (sum=9) then\n(len,-1::0::xs')\nelse\n(len,(sum+1)::xs')\nelse \n(len,sum::a)\nelse\nmatch a with \n| (len,[]) -> (len,-1::[(sum mod 10)])\n| (len,x'::xs') -> \nif (x'=(-1)) then\n-1::((sum mod 10)+1)::a\nelse \n(len,-1::(sum mod 10)::x'::xs')\n\nin\nlet base = (List.length l1,[]) in\nlet args = (List.combine (List.rev l1) (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (b,c) -> let sum= b+c in \nif sum<10 then \nmatch a with \n| (len,[]) -> (len,[sum])\n| (len,x'::xs') -> \nif (x'=(-1)) then\nif (sum=9) then\n(len,-1::0::xs')\nelse\n(len,(sum+1)::xs')\nelse \n(len,sum::a)\nelse\nmatch a with \n| (len,[]) -> (len,-1::[(sum mod 10)])\n| (len,x'::xs') -> \nif (x'=(-1)) then\n-1::((sum mod 10)+1)::a\nelse \n(len,-1::(sum mod 10)::x'::xs')\n\nin\nlet base = (List.length l1,[]) in\nlet args = (List.combine (List.rev l1) (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (b,c) -> let sum= b+c in \nif sum<10 then \nmatch a with \n| (len,[]) -> (len,[sum])\n| (len,x'::xs') -> \nif (x'=(-1)) then\nif (sum=9) then\n(len,-1::0::xs')\nelse\n(len,(sum+1)::xs')\nelse \n(len,sum::x'::xs')\nelse\nmatch a with \n| (len,[]) -> (len,-1::[(sum mod 10)])\n| (len,x'::xs') -> \nif (x'=(-1)) then\n(len,-1::((sum mod 10)+1)::xs')\nelse \n(len,-1::(sum mod 10)::x'::xs')\n\nin\nlet base = (List.length l1,[]) in\nlet args = (List.combine (List.rev l1) (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (b,c) -> let sum= b+c in \nif sum<10 then \nmatch a with \n| (len,[]) -> (len,[sum])\n| (len,x'::xs') -> \nif (x'=(-1)) then\nif (sum=9) then\n(len,-1::0::xs')\nelse\n(len,(sum+1)::xs')\nelse \n(len,sum::x'::xs')\nelse\nmatch a with \n| (len,[]) -> (len,-1::[(sum mod 10)])\n| (len,x'::xs') -> \nif (x'=(-1)) then\n-1::((sum mod 10)+1)::a\nelse \n(len,-1::(sum mod 10)::x'::xs')\n\nin\nlet base = (List.length l1,[]) in\nlet args = (List.combine (List.rev l1) (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (b,c) -> let sum= b+c in \nif sum<10 then \nmatch a with \n| (len,[]) -> (len,[sum])\n| (len,x'::xs') -> \nif (x'=(-1)) then\nif (sum=9) then\n(len,-1::0::xs')\nelse\n(len,(sum+1)::xs')\nelse \n(len,sum::x'::xs')\nelse\nmatch a with \n| (len,[]) -> (len,-1::[(sum mod 10)])\n| (len,x'::xs') -> \nif (x'=(-1)) then\n-1::((sum mod 10)+1)::a\nelse \n(len,-1::(sum mod 10)::x'::xs')\n\nin\nlet base = (List.length l1,[]) in\nlet args = (List.combine (List.rev l1) (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let rec mulByDigit i l = let lre = List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 (num::xs') xs\nelse\nhelper 1 (((num/10) mod 10)::(num mod 10)::xs') xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 (num::accum) xs\nelse\nhelper 1 (((num/10) mod 10)::(num mod 10)::accum) xs\nin helper 0 [] lre", "bad": "let rec mulByDigit i l = let lrev = List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 num::xs' xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::xs' xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 num::accum xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::accum::xs", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l = let lrev  ->  List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 num::xs' xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::xs' xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 num::accum xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::accum::xs"}
{"fix": "let rec mulByDigit i l = let lre = List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 (num::xs') xs\nelse\nhelper 1 (((num/10) mod 10)::(num mod 10)::xs') xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 (num::accum) xs\nelse\nhelper 1 (((num/10) mod 10)::(num mod 10)::accum) xs\nin helper 0 [] lre", "bad": "let rec mulByDigit i l = let lre = List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 num::xs' xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::xs' xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 num::accum xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::accum xs\nin helper 0 [] lre", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l = let lre  ->  List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 num::xs' xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::xs' xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 num::accum xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::accum xs\nin helper 0 [] lre"}
{"fix": "let rec mulByDigit i l = let lre = List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 (num::xs') xs\nelse\nhelper 1 (((num/10) mod 10)::(num mod 10)::xs') xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 (num::accum) xs\nelse\nhelper 1 (((num/10) mod 10)::(num mod 10)::accum) xs\nin helper 0 [] lre", "bad": "let rec mulByDigit i l = let lre = List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 num::xs' xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::xs' xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 num::accum xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::accum xs\nin helper 0 [] lre", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l = let lre  ->  List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 num::xs' xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::xs' xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 num::accum xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::accum xs\nin helper 0 [] lre"}
{"fix": "let rec mulByDigit i l = let lre = List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 (num::xs') xs\nelse\nhelper 1 (((num/10) mod 10)::(num mod 10)::xs') xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 (num::accum) xs\nelse\nhelper 1 (((num/10) mod 10)::(num mod 10)::accum) xs\nin helper 0 [] lre", "bad": "let rec mulByDigit i l = let lre = List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 (num::xs') xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::xs' xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 num::accum xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::accum xs\nin helper 0 [] lre", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l = let lre  ->  List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 (num::xs') xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::xs' xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 num::accum xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::accum xs\nin helper 0 [] lre"}
{"fix": "let _ = digitsOfInt 0", "bad": "let_ = digitsOfInt 0", "annotated": "let_ = digitsOfInt 0"}
{"fix": "let rec additivePersistence n = \nlet newList = digitsOfInt n in 1 + 2", "bad": "let rec additivePersistence n = \nlet newList = digitsOfInt n", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet newList = digitsOfInt n"}
{"fix": "let _ = digitalRoot 9876", "bad": "let _ = digitalRoot2 9876", "annotated": "let _ = digitalRoot2 9876"}
{"fix": "let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nlet count = 2 in\nif(sum < 10) then count\nelse 1 + additivePersistence2 sum", "bad": "let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nlet count 2 in = \nif(sum < 10) then count\nelse 1 + additivePersistence2 sum", "annotated": "let rec additivePersistence : int -> int = fun 2 n  ->  \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nlet count 2 in = \nif(sum < 10) then count\nelse 1 + additivePersistence2 sum"}
{"fix": "let rec assoc (d,k,l) = failwith \"to be written\"", "bad": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' = true then wwhile (f b')\nelse c'", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet (b', c') = f b in\nif c' = true then wwhile (f b')\nelse c'"}
{"fix": "let fixpoint (f,b) = wwhile ((f b),b)", "bad": "(\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "(\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' = true then wwhile (f,b')\nelse b'", "bad": "let fixpoint (f,b) = wwhile ((f (neg b)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((f (neg b)),b)"}
{"fix": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' = true then wwhile (f,b')\nelse b'", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = wwhile ( (f b),b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(eval(e1,x,y))", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi * eval(e1,x,y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi * eval(e1,x,y))"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(eval(e1,x,y))", "bad": "eval(Sine(VarY), 11.0 ,0)", "annotated": "eval(Sine(VarY), 11.0 ,0)"}
{"fix": "let _ = eval (Times(Sine(VarX),Cosine(Average(VarX,VarY))), 0.5, 0.2)", "bad": "let _ = eval ((Times(Sine(VarX),Cosine(Average(VarX,VarY))))), 0.5, 0.2", "annotated": "let _ = eval ((Times(Sine(VarX),Cosine(Average(VarX,VarY))))), 0.5, 0.2"}
{"fix": "let _ = eval (Times(Sine(VarX),Cosine(Average(VarX,VarY))), 0.5, 0.2)", "bad": ")", "annotated": ")"}
{"fix": "let _ = eval (Times(Sine(VarX),Cosine(Average(VarX,VarY))), 0.5, 0.2)", "bad": ")", "annotated": ")"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> begin let ans = sin(pi *. eval(e1,x,y)); Printf.printf \"sine is \"; end\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.printf \"sine is \"\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.printf \"sine is \"\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> begin let ans = sin(pi *. eval(e1,x,y)); Printf.printf \"sine is \"; end\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.sprintf \"sine is \"\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.sprintf \"sine is \"\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> begin let ans = sin(pi *. eval(e1,x,y)); Printf.printf \"sine is \"; end\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.printf \"sine is \"\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)) in Printf.printf \"sine is \"\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)); Printf.printf \"sine is \"; \n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> let ans = sin(pi *. eval(e1,x,y)); Printf.printf \"sine is \"; \n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> if(1) then begin let ans = sin(pi *. eval(e1,x,y)); Printf.printf \"sine is \"; end\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> if(1) then begin let ans = sin(pi *. eval(e1,x,y)); Printf.printf \"sine is \"; end\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> if(1) then begin sin(pi *. eval(e1,x,y)); Printf.printf \"sine is \"; end\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> if(1) then begin sin(pi *. eval(e1,x,y)); Printf.printf \"sine is \"; end\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> if(true) then begin let ans = sin(pi *. eval(e1,x,y)); Printf.printf \"sine is \"; end\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> if(true) then begin let ans = sin(pi *. eval(e1,x,y)); Printf.printf \"sine is \"; end\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> if(true) then let ans = sin(pi *. eval(e1,x,y)); Printf.printf \"sine is \";\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> if(true) then let ans = sin(pi *. eval(e1,x,y)); Printf.printf \"sine is \";\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> sin(pi *. eval(e1,x,y))\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> if(true) then begin let ans = sin(pi *. eval(e1,x,y)); Printf.printf \"sine is \"; end else 1.0\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine(e1) -> if(true) then begin let ans = sin(pi *. eval(e1,x,y)); Printf.printf \"sine is \"; end else 1.0\n| Cosine(e1) -> cos(pi *. eval(e1, x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y)) /. 2.0\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(a, b, a_less, b_less) -> \nif(eval(a, x, y) < eval(b, x, y)) then \nbegin  \nPrintf.printf \"hi\";\neval(a_less, x, y);\nend\nelse \nbegin\nPrintf.printf \"bye\";\neval(b_less, x, y);\nend"}
{"fix": "let _ = build(makeRand(2,3), 2)", "bad": "let _ = build(rand(2,3), 2)", "annotated": "let _ = build(rand(2,3), 2)"}
{"fix": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "bad": "let _ = let rand = makeRand(1,3) in \nlet x = rand(1,3) in build(rand 1)", "annotated": "let _ = let rand = makeRand(1,3) in \nlet x = rand(1,3) in build(rand 1)"}
{"fix": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki, vi) :: t -> \nif ki = k then vi\nelse assoc (d, k, t)", "bad": "let _ = let rand = makeRand(1,3) in \nlet x = rand(1,3) in build(rand, 1)", "annotated": "let _ = let rand = makeRand(1,3) in \nlet x = rand(1,3) in build(rand, 1)"}
{"fix": "let rec build (rand, depth) = match (rand,depth)  with\n|(_,0) -> if((rand mod 2) == 0) then buildY()\nelse buildX()\n|(_,_) -> buildX()", "bad": "let rec build (rand, depth) = match (r,d)  with\n|(_,0) -> if((r mod 2) == 0) then buildY()\nelse buildX()\n|(_,_) -> buildX()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (r,d)  with\n|(_,0) -> if((r mod 2) == 0) then buildY()\nelse buildX()\n|(_,_) -> buildX()"}
{"fix": "let rec build (rand, depth) = match (rand,depth)  with\n|(_,0) -> if((rand mod 2) == 0) then buildY()\nelse buildX()\n|(_,_) -> buildX()", "bad": "let rec build (rand, depth) = match (rand,depth)  with\n|(_,0) -> if((r mod 2) == 0) then buildY()\nelse buildX()\n|(_,_) -> buildX()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth)  with\n|(_,0) -> if((r mod 2) == 0) then buildY()\nelse buildX()\n|(_,_) -> buildX()"}
{"fix": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )", "bad": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( (build(rand*3), depth - 1), build((rand +1), depth - 1) )\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))\nelse if (rand mod 5 == 0) then\nbuild(rand + 3 ,depth -1)\nelse \nbuild(rand + 1, depth - 1)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( (build(rand*3), depth - 1), build((rand +1), depth - 1) )\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))\nelse if (rand mod 5 == 0) then\nbuild(rand + 3 ,depth -1)\nelse \nbuild(rand + 1, depth - 1)"}
{"fix": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )", "bad": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( (build(rand), depth - 1), build((rand +1), depth - 1) )\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))\nelse if (rand mod 5 == 0) then\nbuild(rand + 3 ,depth -1)\nelse \nbuild(rand + 1, depth - 1)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( (build(rand), depth - 1), build((rand +1), depth - 1) )\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))\nelse if (rand mod 5 == 0) then\nbuild(rand + 3 ,depth -1)\nelse \nbuild(rand + 1, depth - 1)"}
{"fix": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )", "bad": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n(*| (_, 2) -> buildTimes( (build(rand), depth - 1), build((rand +1), depth - 1) )*)\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))\nelse if (rand mod 5 == 0) then\nbuild(rand + 3 ,depth -1)\nelse \nbuild(rand + 1, depth - 1)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n(*| (_, 2) -> buildTimes( (build(rand), depth - 1), build((rand +1), depth - 1) )*)\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))\nelse if (rand mod 5 == 0) then\nbuild(rand + 3 ,depth -1)\nelse \nbuild(rand + 1, depth - 1)"}
{"fix": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )", "bad": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( (build(rand), depth - 1), build((rand +1), depth - 1) )", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( (build(rand), depth - 1), build((rand +1), depth - 1) )"}
{"fix": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )\n\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), build(rand, depth - 1))\nelse \nbuild(rand + 1, depth - 1)", "bad": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )\n\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))\nelse if (rand mod 5 == 0) then\nbuild(rand + 3 ,depth -1)\nelse \nbuild(rand + 1, depth - 1)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )\n\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)))\nelse if (rand mod 5 == 0) then\nbuild(rand + 3 ,depth -1)\nelse \nbuild(rand + 1, depth - 1)"}
{"fix": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )\n\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), build(rand, depth - 1))\nelse \nbuild(rand + 1, depth - 1)", "bad": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )\n\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), \nbuild(rand, depth - 1);\nelse if (rand mod 5 == 0) then\nbuild(rand + 3 ,depth -1)\nelse \nbuild(rand + 1, depth - 1)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )\n\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), \nbuild(rand, depth - 1);\nelse if (rand mod 5 == 0) then\nbuild(rand + 3 ,depth -1)\nelse \nbuild(rand + 1, depth - 1)"}
{"fix": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )\n\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), build(rand, depth - 1))\nelse \nbuild(rand + 1, depth - 1)", "bad": "let rec build (rand, depth) = match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )\n\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), build(rand, depth - 1)); \nelse \nbuild(rand + 1, depth - 1)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth)  with\n| (_,0) -> \nif((rand mod 2) == 0) then buildY()\nelse buildX()\n| (_,1) ->\nif( (rand mod 3) == 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine(build(rand, depth - 1))\n| (_, 2) -> buildTimes( build((rand), depth - 1), build((rand +1), depth - 1) )\n\n| (_, _) ->\nif(depth > 10 && ((rand mod 7) == 0)) then \nbuildTimes(buildAverage(build(rand + 3, depth - 1), build(rand - 1, depth - 1)), build(rand, depth - 1)); \nelse \nbuild(rand + 1, depth - 1)"}
{"fix": "let rec build (rand, depth) = match depth with \n| 0 -> buildX() \n| 1 ->  let x = rand(1, 2) in \nif (x > 1) then buildCosine( build(rand, depth - 1) )\nelse buildSine( build(rand, depth - 1))\n| _ -> buildCosine( build(rand, depth - 1) )", "bad": "let rec build (rand, depth) = match depth with \n| 0 -> buildX() \n| 1 ->  let x = rand(_, _) in \nif (x > 1) then buildCosine( build(rand, depth - 1) )\nelse buildSine( build(rand, depth - 1))\n| _ -> buildCosine( build(rand, depth - 1) )", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with \n| 0 -> buildX() \n| 1 ->  let x = rand(_, _) in \nif (x > 1) then buildCosine( build(rand, depth - 1) )\nelse buildSine( build(rand, depth - 1))\n| _ -> buildCosine( build(rand, depth - 1) )"}
{"fix": "let rec build (rand, depth) = match depth with\n| 0 -> let z = 2 in rand(1,z)", "bad": "let rec build (rand, depth) = match rand with\n| (x* y-> z) -> buildX()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match rand with\n| (x* y-> z) -> buildX()"}
{"fix": "let rec build (rand, depth) = match depth with\n| 0 -> let z = 2 in rand(1,z)", "bad": "let rec build (rand, depth) = match depth with |\n| 0 -> let z = 2 in rand", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with |\n| 0 -> let z = 2 in rand"}
{"fix": "let rec build (rand, depth) = match depth with\n| 0 -> let z = 2 in rand(1,z)", "bad": "let rec build (rand, depth) = match depth with |\n| 0 -> let z = 2 in rand(1,z)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with |\n| 0 -> let z = 2 in rand(1,z)"}
{"fix": "let rec build (rand, depth) = match depth with\n| 0 -> let z = rand in\nif( z > 1) then buildX()\nelse buildY()", "bad": "let rec build (rand, depth) = match depth with\n| 0 -> let z = rand in rand in \nif( z > 1) then buildX()\nelse buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n| 0 -> let z = rand in rand in \nif( z > 1) then buildX()\nelse buildY()"}
{"fix": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildSine( build( rand, depth - 1))\nelse buildCosine( build(rand, depth - 1))\n| _ -> buildX()", "bad": "let rec build (rand, depth) = match depth with |\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildSine( build( rand, depth - 1))\nelse buildCosine( build(rand, depth - 1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with |\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildSine( build( rand, depth - 1))\nelse buildCosine( build(rand, depth - 1))"}
{"fix": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n| 2 -> let num = rand(1, 3) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| 3 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuild(rand, depth - 1))", "bad": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n| 2 -> let num = rand(1, 3) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| 3 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n| 0 -> let num = rand(1,5) in \nif( num > 3) then buildX()\nelse buildY()\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n| 2 -> let num = rand(1, 3) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n| 3 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)))"}
{"fix": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n\n| _ -> let num = rand(1, 3) in build(rand, depth - num )", "bad": "let rec build (rand, depth) = match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n\n| _ -> let num = rand(1, 3) in build(rand, depth num )", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n| 0 -> let num = rand(1,10) in \nif( num > 3) then buildX()\nelse buildY()\n\n| 1 -> let num = rand(1, 10) in \nif( num mod 2 = 0) then buildSine( build(rand, depth - 1) )\nelse buildCosine( build(rand, depth - 1) )\n\n| 2 -> let num = rand(1, 30) in\nif( num mod 2 == 0) then\nbuildTimes( buildSine(build((rand), depth - 1)), build((rand), depth - 1) )\nelse \nbuildTimes( buildCosine(build((rand), depth - 1)), build((rand), depth - 1) )\n\n| 3 -> let num = rand (1, 50) in \nif (num mod 2 = 0) then \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildCosine(build(rand, depth - 1)))\nelse \nbuildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n| 4 -> buildTimes( build(rand, depth - 1), build(rand, depth - 1))\n\n| 5 -> let num = rand(1, 10) in\nif(num = 1) then \nbuildSine(buildSine(buildSine( build(rand, depth - 1))))\nelse if(num = 2) then \nbuildCosine(buildCosine(buildCosine( build(rand, depth - 1))))\nelse if (num = 3) then\nbuildSine(buildCosine( build(rand, depth - 1)))\nelse buildCosine(buildSine( build(rand, depth - 1)))\n| 6 -> buildAverage( build(rand, depth - 1), build(rand, depth - 1))\n\n| 7 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1)) \n\n| 8 -> buildTimes(buildAverage(build(rand, depth - 1), build(rand, depth - 1)), \nbuildSine(build(rand, depth - 1)))\n\n\n| _ -> let num = rand(1, 3) in build(rand, depth num )"}
{"fix": "let g1 () = failwith \"to be implemented\"", "bad": "let rec build (rand, depth) = \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n| 1 | 2 -> buildSine(build(rand, depth - 1))\n| 3 | 4 -> buildCosine(build(rand, depth - 1))\n| 5 | 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 7 | 8 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif(depth = 0) then\nlet num = rand(1, 10) in\nif( num > 4) then buildX()\nelse buildY()\nelse \nlet num = rand(1, 10) in match num with\n| 1 | 2 -> buildSine(build(rand, depth - 1))\n| 3 | 4 -> buildCosine(build(rand, depth - 1))\n| 5 | 6 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 7 | 8 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 9 -> buildThresh( build(rand, depth - 1), build(rand, depth - 1),\nbuild(rand, depth - 1), build(rand, depth - 1))\n| _ -> build(rand, depth - 1)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile (let g x = let xx = f x in (xx, xx != b) in g,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g x = let xx = f x in (xx, xx ! ->  b) in g,b)"}
{"fix": "let sqsum xs = \nlet f a x = x * x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = match x with\n| [] -> a\n| h:: t -> (h*h) + sqsum t in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = match x with\n| [] -> a\n| h:: t -> (h*h) + sqsum t in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = x * x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = match x with\n| [] -> a\n| h:: t -> (h*h) + f base t", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = match x with\n| [] -> a\n| h:: t -> (h*h) + f base t"}
{"fix": "let sqsum xs = \nlet f a x = x * x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let base = 0 in\nList.fold_left f base xs", "annotated": "let base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = x * x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = match x with\n| [] -> a\n| h:: t -> (h*h) + f base t in \nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = match x with\n| [] -> a\n| h:: t -> (h*h) + f base t in \nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = x * x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = match x with\n| [] -> a\n| h:: t -> (h*h) + List.fold_left f base t in \nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = match x with\n| [] -> a\n| h:: t -> (h*h) + List.fold_left f base t in \nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = x * x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = fun x -> x * x in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = fun x -> x * x in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = x * x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = fun _ x -> x * x in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = fun _ x -> x * x in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = x * x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = fun a x -> x * x in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = fun a x -> x * x in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = g a x = x * x + a in\nlet base = 0 in\nList.fold_left g base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = g a x = x * x + a in\nlet base = 0 in\nList.fold_left g base xs"}
{"fix": "let sqsumL xs = \nlet rec helper acc rest = match rest with\n| [] -> acc * acc\n| h :: t -> h + helper (acc + h) t\nin helper 0 xs", "bad": "let sqsumL xs = \nlet rec helper acc rest = match xs with\n| [] -> []\n| h :: t -> h", "annotated": "let sqsum : int list -> int  = fun L xs  ->  \nlet rec helper acc rest = match xs with\n| [] -> []\n| h :: t -> h"}
{"fix": "let sqsumL xs = \nlet rec helper acc rest = match rest with\n| [] -> acc * acc\n| h :: t -> h + helper (acc + h) t\nin helper 0 xs", "bad": "let sqsumL xs = \nlet rec helper acc xs = match xs with\n| [] -> acc * acc\n| h :: t -> h + helper (acc + h) t", "annotated": "let sqsum : int list -> int  = fun L xs  ->  \nlet rec helper acc xs = match xs with\n| [] -> acc * acc\n| h :: t -> h + helper (acc + h) t"}
{"fix": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x =  failwith \"TBD\"", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  failwith \"TBD\""}
{"fix": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let base = a in\nList.fold_left f base fs", "annotated": "let base = a in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x =  failwith \"TBD\" in\nlet base = a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  failwith \"TBD\" in\nlet base = a in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x =  failwith \"TBD\" in\nlet base = a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  failwith \"TBD\" in\nlet base = a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =  a x in\nlet base = fun x -> x in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  a (f x) in\nlet base = fun x -> x in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  a (f x) in\nlet base = fun x -> x in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =  a x in\nlet base = fun x -> x in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  a (x) in\nlet base = fun x -> x in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  a (x) in\nlet base = fun x -> x in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =  a x in\nlet base = fun x -> x in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  a x in\nlet base = fun x -> x in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  a x in\nlet base = fun x -> x in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =  fun x' = a x in\nlet base = fun x -> x in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  let existing = a in \nlet next x in \nexisting(next) in\nlet base = fun x -> x in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  let existing = a in \nlet next x in \nexisting(next) in\nlet base = fun x -> x in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =  fun x' = a x in\nlet base = fun x -> x in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  let existing = a in \nlet next = x in \nexisting(next) in\nlet base = fun x -> x in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  let existing = a in \nlet next = x in \nexisting(next) in\nlet base = fun x -> x in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =  fun x' -> a x in\nlet base = fun x -> x in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  fun x' = a x in\nlet base = fun x -> x in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  fun x' = a x in\nlet base = fun x -> x in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =  fun x' -> a x in\nlet base = fun x -> x in \nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x =  fun x' -> a x in\nlet base = fun x -> x in \nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x)] 3", "annotated": "let _ = pipe [(fun x -> x+x)] 3"}
{"fix": "let pipe fs = \nlet f a x =  fun x' -> (a x) in\nlet base = fun x -> x in \nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x =  a (f x) in\nlet base = fun x -> x in \nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x =  failwith \"hi\" in\nlet base = fun x -> x in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  fun y -> fun x -> a in\nlet base = fun x -> x in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  fun y -> fun x -> a in\nlet base = fun x -> x in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =  let g x = a x in\nlet base = fun x -> x in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  let g a = let xx = f x in g in\nlet base = fun x -> x in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  let g a = let xx = f x in g in\nlet base = fun x -> x in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =  let g x = a x in\nlet base = fun x -> x in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  let g x = a x in\nlet base = fun x -> x in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  let g x = a x in\nlet base = fun x -> x in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =  fun a -> fun x ->  a x in\nlet base = fun x -> x in \nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x =  fun g -> a x in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  let f g = fun x -> f (a x) in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  let f g = fun x -> f (a x) in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =  fun g -> a x in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x =  fun g -> a x in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  let g y = a (g x) in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  let g y = a (g x) in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let _ = sepConcat \"hi\" []", "bad": "let _ = sepConcat sep []", "annotated": "let _ = sepConcat sep []"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base = sep in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = if x = \"a\" then x :: a in\nlet base = sep in\nlet l = t in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = if x = \"a\" then x :: a in\nlet base = sep in\nlet l = t in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base = sep in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = if x = \"a\" then x :: a \nelse a in\nlet base = sep in\nlet l = t in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = if x = \"a\" then x :: a \nelse a in\nlet base = sep in\nlet l = t in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ a in\nlet base = sep in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = if x = \"a\" then a ^ x in\nlet base = sep in\nlet l = t in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = if x = \"a\" then a ^ x in\nlet base = sep in\nlet l = t in\nList.fold_left f base l"}
{"fix": "let rec fold_l f acc xs = match xs with \n| [] -> acc \n| h :: t -> fold_l f (f acc h) t", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = if a = \"a\" then a ^ x  ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = if a = \"a\" then a ^ x  ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}
{"fix": "let stringOfList f l = List.map (sepConcat f) l", "bad": "let stringOfList f l = List.map sepConcat f l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map sepConcat f l"}
{"fix": "let stringOfList f l = List.map (f sepConcat ) l", "bad": "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "annotated": "let _ = stringOfList string_of_int [1;2;3;4;5;6]"}
{"fix": "let stringOfList f l = List.map (f sepConcat ) l", "bad": "let _ = stringOfList (fun x -> x) [\"foo\"]", "annotated": "let _ = stringOfList (fun x -> x) [\"foo\"]"}
{"fix": "let stringOfList f l = List.map (f sepConcat ) l", "bad": "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "annotated": "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nlet carry = \nmatch a with\n| (x,y) -> x in\nmatch x with \n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = padZero l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = padZero l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args =  in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet (index, result) = a in\nlet (list1,list2) = x in\nmatch list2 with\n| [] -> []\n| h::t ->\nlet resList = mulByDigit h list1 in\nlet newIndex = (index + 1) in \nlet newRes = bigAdd result (mulByDigit (int_of_float (10.0 ** (float (newIndex -1)))) resList) in\n(newIndex, newRes)\nin\nlet base = (0, []) in\nlet args = ((List.rev l1),(List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet (index, result) = a in\nlet (list1,list2) = x in\nmatch list2 with\n| [] -> []\n| h::t ->\nlet resList = mulByDigit h list1 in\nlet newIndex = (index + 1) in \nlet newRes = bigAdd result (mulByDigit (int_of_float (10.0 ** (float (newIndex -1)))) resList) in\n(newIndex, newRes)\nin\nlet base = (0, []) in\nlet args = ((List.rev l1),(List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"hi\" in\nlet base = failwith \"to be implemented\" in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = x in carry in\nlet base = failwith \"to be implemented\" in\nlet args =  List.rev List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet carry = x in carry in\nlet base = failwith \"to be implemented\" in\nlet args =  List.rev List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"hi\" in\nlet base = failwith \"to be implemented\" in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = x in carry in\nlet base = failwith \"to be implemented\" in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet carry = x in carry in\nlet base = failwith \"to be implemented\" in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"hi\" in\nlet base = failwith \"to be implemented\" in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \n1", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \n1"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"hi\" in\nlet base = failwith \"to be implemented\" in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let base = failwith \"to be implemented\" in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let base = failwith \"to be implemented\" in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"hi\" in\nlet base = failwith \"to be implemented\" in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nx", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nx"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"hi\" in\nlet base = failwith \"to be implemented\" in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let base = failwith \"to be implemented\" in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let base = failwith \"to be implemented\" in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"hi\" in\nlet base = failwith \"to be implemented\" in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = x"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"hi\" in\nlet base = failwith \"to be implemented\" in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let base = failwith \"to be implemented\" in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let base = failwith \"to be implemented\" in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"hi\" in\nlet base = failwith \"to be implemented\" in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = failwith \"to be implemented\" in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = x in\nlet base = failwith \"to be implemented\" in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nlet carry = \nmatch a with\n| (x,y) -> x in\nmatch x with \n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n|(x, y) -> x in\nlet base = (0, []) in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n|(x, y) -> x in\nlet base = (0, []) in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nlet carry = \nmatch a with\n| (x,y) -> x in\nmatch x with \n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n|(x, y) -> x in\nlet base = (0, []) in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n|(x, y) -> x in\nlet base = (0, []) in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nlet carry = \nmatch a with\n| (x,y) -> x in\nmatch x with \n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n|(x, y) -> x in carry in\nlet base = (0, []) in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n|(x, y) -> x in carry in\nlet base = (0, []) in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nlet carry = \nmatch a with\n| (x,y) -> x in\nmatch x with \n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = [] in\nlet base = (0, []) in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = [] in\nlet base = (0, []) in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (x,y) -> x in\nmatch x with\n|(add1, add2) -> let newCarry = (carry + add1 + add2) mod 10 in\nlet num = (carry + add1 + add2) / 10 in\nmatch a with \n|(x,y) -> (newCarry, num :: y) in\nlet base = (0, []) in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nlet carry = match a with\n| (x,y) -> x in\nmatch x with \n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in carry in \nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =\nlet carry = match a with\n| (x,y) -> x in\nmatch x with \n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in carry in \nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (x,y) -> x in\nmatch x with\n|(add1, add2) -> let newCarry = (carry + add1 + add2) mod 10 in\nlet num = (carry + add1 + add2) / 10 in\nmatch a with \n|(x,y) -> (newCarry, num :: y) in\nlet base = (0, []) in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (x,y) -> x in\nmatch x with\n|(add1, add2) -> let newCarry = (carry + add1 + add2) mod 10 in\nlet num = (carry + add1 + add2) / 10 in\nmatch a with \n|(x,y) -> (newCarry, num :: y in\nlet base = (0, []) in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (x,y) -> x in\nmatch x with\n|(add1, add2) -> let newCarry = (carry + add1 + add2) mod 10 in\nlet num = (carry + add1 + add2) / 10 in\nmatch a with \n|(x,y) -> (newCarry, num :: y in\nlet base = (0, []) in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (c,_) -> c in\nmatch x with\n|(add1, add2) -> let newCarry = (carry + add1 + add2) / 10 in\nlet num = (carry + add1 + add2) mod 10 in\nmatch a with \n|(x,y) -> (newCarry, num :: y) in\nlet base = (0, []) in\nlet args =  List.rev (List.combine (0::l1) (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (c,_) -> c in\nmatch x with\n|(add1, add2) -> let newCarry = (carry + add1 + add2) / 10 in\nlet num = (carry + add1 + add2) mod 10 in\nmatch a with \n|(x,y) -> (newCarry, num :: y) in\nlet base = (newCarry, []) in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (c,_) -> c in\nmatch x with\n|(add1, add2) -> let newCarry = (carry + add1 + add2) / 10 in\nlet num = (carry + add1 + add2) mod 10 in\nmatch a with \n|(x,y) -> (newCarry, num :: y) in\nlet base = (newCarry, []) in\nlet args =  List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"tbd\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 =\nlet g =\nlet f b x = ((mulByDigit x l1)@(clone 0 (List.length b)))::b in\nlet base = [] in\nlet args = List.rev l2 in\nlet (_,res) = (List.fold_left f base args) in\nres\nin\nList.fold_left bigAdd [] g", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  -> \nlet g =\nlet f b x = ((mulByDigit x l1)@(clone 0 (List.length b)))::b in\nlet base = [] in\nlet args = List.rev l2 in\nlet (_,res) = (List.fold_left f base args) in\nres\nin\nList.fold_left bigAdd [] g"}
{"fix": "let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"tbd\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet (index, result) = a in\nlet (list1,list2) = x in\nmatch list2 with\n| [] -> []\n| h::t ->\nlet resList = mulByDigit h list1 in\nlet newIndex = (index + 1) in \nlet newRes = bigAdd result (mulByDigit (int_of_float (10.0 ** (float (newIndex -1)))) resList) in\n(newIndex, newRes)\nin\nlet base = (0, []) in\nlet args = ((List.rev l1),(List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet (index, result) = a in\nlet (list1,list2) = x in\nmatch list2 with\n| [] -> []\n| h::t ->\nlet resList = mulByDigit h list1 in\nlet newIndex = (index + 1) in \nlet newRes = bigAdd result (mulByDigit (int_of_float (10.0 ** (float (newIndex -1)))) resList) in\n(newIndex, newRes)\nin\nlet base = (0, []) in\nlet args = ((List.rev l1),(List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = match a with\n|(num, prod) -> (num + 1, bigAdd ((mulByDigit x (List.rev l1)) @ clone 0 num) prod) in\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = match a with\n|(num, prod) -> (num + 1, bigAdd ((mulByDigit x List.rev l1) @ clone 0 num) prod) in\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match a with\n|(num, prod) -> (num + 1, bigAdd ((mulByDigit x List.rev l1) @ clone 0 num) prod) in\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let _ = padZero [1;2;3] []", "bad": "let _ padZero [1;2;3] []", "annotated": "let _ padZero [1;2;3] []"}
{"fix": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x); (fun x -> x + 1)] 3", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x); (fun y -> x = 2); fun x -> x + 1] 3", "annotated": "let _ = pipe : ('a -> 'a) list -> ('a -> 'a) = fun  [(fun x -> x + 3);(fun x-> x + x); (fun y -> x  ->  2); fun x -> x + 1] 3"}
{"fix": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x); (fun x -> x + 1)] 3", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x); (fun y -> x = 2); (fun x -> x + 1)] 3", "annotated": "let _ = pipe : ('a -> 'a) list -> ('a -> 'a) = fun  [(fun x -> x + 3);(fun x-> x + x); (fun y -> x  ->  2); (fun x -> x + 1)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base =  fun y ->  y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base =  fun y ->  in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base =  fun y ->  in\nList.fold_left f base fs"}
{"fix": "let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"", "bad": "let stringOfList f l = \"[\" ^ sepConcat \";\" List.map f l ^ \"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\" ^ sepConcat \";\" List.map f l ^ \"]\""}
{"fix": "let rec clone x n = \nlet rec helper a x n =\nif x <= 0 then []\nelse \nlet a' = x::a in\nhelper a' x (n-1)\nin helper [] x n", "bad": "let rec clone x n = \nlet helper a x n =\nif x <= 0 then []\nelse \nlet a' = x::a in\nhelper a' x (n-1)\nin helper [] x n", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nlet helper a x n =\nif x <= 0 then []\nelse \nlet a' = x::a in\nhelper a' x (n-1)\nin helper [] x n"}
{"fix": "let _ = padZero [9;9] [1;0;0;2]", "bad": "let padZero l1 l2 = \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif length1 > length2 then \n(l1, List.append (clone 0 (length1 - length2)) l2)\nelse if length2 > length1 then \n(List.append (clone 0 (length1 - length2)) l1, l2)\nelse (l1,l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nif length1 > length2 then \n(l1, List.append (clone 0 (length1 - length2)) l2)\nelse if length2 > length1 then \n(List.append (clone 0 (length1 - length2)) l1, l2)\nelse (l1,l2)"}
{"fix": "let _ = bigAdd [9;9] [1;0;0;2]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = 0 in\nlet args = \nlet rec pair list1 list2 = match (list1, list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| ([], []) -> []\nin pair l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = 0 in\nlet args = \nlet rec pair list1 list2 = match (list1, list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| ([], []) -> []\nin pair l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let _ = bigAdd [9;9] [1;0;0;2]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = 0 in\nlet args = \nlet rec pair list1 list2 = match (list1, list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> []\nin pair l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = 0 in\nlet args = \nlet rec pair list1 list2 = match (list1, list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> []\nin pair l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let _ = bigAdd [9;9] [1;0;0;2]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z)if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair list1 list2 = \nmatch (List.rev list1, List.rev list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> []\nin pair l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z)if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair list1 list2 = \nmatch (List.rev list1, List.rev list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> []\nin pair l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let _ = bigAdd [9;9] [1;0;0;2]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair list1 list2 = \nmatch (List.rev list1, List.rev list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> []\nin pair l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair list1 list2 = \nmatch (List.rev list1, List.rev list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> []\nin pair l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let _ = mulByDigit 9 [9;9;9;9]", "bad": "let rec mulByDigit i l =\nlet rec helper a i l = match l with\n| [] -> a\n| h::t -> let a' = h*i::a in\nhelper a' i t\nin helper [] i l", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  -> \nlet rec helper a i l = match l with\n| [] -> a\n| h::t -> let a' = h*i::a in\nhelper a' i t\nin helper [] i l"}
{"fix": "let _ = mulByDigit 9 [9;9;9;9]", "bad": "let rec mulByDigit i l =\nlet rec helper acc carry i l = match l with\n| [] -> acc\n| h::t -> let x = (h*i + carry) in \nlet n = if x > 9 then x mod 10 else x in\nlet carry' = if x > 9 then x - 10 else 0 in\nlet acc' = n::acc in\nhelper acc' carry' i t\nin helper [] 0 i (List.rev l)", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  -> \nlet rec helper acc carry i l = match l with\n| [] -> acc\n| h::t -> let x = (h*i + carry) in \nlet n = if x > 9 then x mod 10 else x in\nlet carry' = if x > 9 then x - 10 else 0 in\nlet acc' = n::acc in\nhelper acc' carry' i t\nin helper [] 0 i (List.rev l)"}
{"fix": "let _ = bigAdd [9;9] [1;0;0;2]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair acc list1 list2 = \nmatch (list1, list2) with\n| (h1::t1, h2::t2) -> pair ((h1,h2)::acc) t1 t2\n| (_ , _) -> acc\nin pair [(0,0)] (List.rev l1) (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair acc list1 list2 = \nmatch (list1, list2) with\n| (h1::t1, h2::t2) -> pair ((h1,h2)::acc) t1 t2\n| (_ , _) -> acc\nin pair [(0,0)] (List.rev l1) (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  bigAdd a x in\nlet base = [] in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \n(let placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1)) in\nbuildZeros [] place in \nlet acc' = List.append (mulByDigit h l2) placeHolders) in\ndigitProducts acc' (place+1) t l2", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \n(let placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1)) in\nbuildZeros [] place in \nlet acc' = List.append (mulByDigit h l2) placeHolders) in\ndigitProducts acc' (place+1) t l2"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  bigAdd a x in\nlet base = [] in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": ") in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": ") in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  bigAdd a x in\nlet base = [] in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \n(let placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in\nbuildZeros [] place) in \nlet acc' = List.append (mulByDigit h l2) placeHolders) in\ndigitProducts acc' (place+1) t l2) in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \n(let placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in\nbuildZeros [] place) in \nlet acc' = List.append (mulByDigit h l2) placeHolders) in\ndigitProducts acc' (place+1) t l2) in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  bigAdd a x in\nlet base = [] in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \n(let placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in\nbuildZeros [] place) in \nlet acc' = List.append (mulByDigit h l2) placeHolders in\ndigitProducts acc' (place+1) t l2)) in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \n(let placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in\nbuildZeros [] place) in \nlet acc' = List.append (mulByDigit h l2) placeHolders in\ndigitProducts acc' (place+1) t l2)) in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  bigAdd a x in\nlet base = [] in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \n(let placeHolders = \n(let rec buildZeros a places = if places = 0 then a else buildZeros (0::a) (places-1) in buildZeros [] place) in \nlet acc' = List.append (mulByDigit h l2) placeHolders in\ndigitProducts acc' (place+1) t l2)) in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \n(let placeHolders = \n(let rec buildZeros a places = if places = 0 then a else buildZeros (0::a) (places-1) in buildZeros [] place) in \nlet acc' = List.append (mulByDigit h l2) placeHolders in\ndigitProducts acc' (place+1) t l2)) in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  bigAdd a x in\nlet base = [] in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet acc' = List.append (mulByDigit h l2) placeHolders in\ndigitProducts acc' (place+1) t l2) in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet acc' = List.append (mulByDigit h l2) placeHolders in\ndigitProducts acc' (place+1) t l2) in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  bigAdd a x in\nlet base = [] in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = List.append (mulByDigit h l2) placeHolders in\ndigitProducts a::acc (place+1) t l2) in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = List.append (mulByDigit h l2) placeHolders in\ndigitProducts a::acc (place+1) t l2) in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  bigAdd a x in\nlet base = [] in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = List.append (mulByDigit h l2) placeHolders in\ndigitProducts a::acc (place+1) t l2+) in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = List.append (mulByDigit h l2) placeHolders in\ndigitProducts a::acc (place+1) t l2+) in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  bigAdd a x in\nlet base = [] in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = List.append (mulByDigit h l2) placeHolders in\ndigitProducts a::acc (place+1) t l2) \nin\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = List.append (mulByDigit h l2) placeHolders in\ndigitProducts a::acc (place+1) t l2) \nin\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  bigAdd a x in\nlet base = [] in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = List.append (mulByDigit h l2) placeHolders in\ndigitProducts a::acc (place+1) t l2", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = List.append (mulByDigit h l2) placeHolders in\ndigitProducts a::acc (place+1) t l2"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  bigAdd a x in\nlet base = [] in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": ") \nin\nlet (_, res) = List.fold_left f base args in\nres", "annotated": ") \nin\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  bigAdd a x in\nlet base = [] in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = List.append (mulByDigit h l2) placeHolders in\ndigitProducts a::acc (place+1) t) \nin\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = List.append (mulByDigit h l2) placeHolders in\ndigitProducts a::acc (place+1) t) \nin\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  bigAdd a x in\nlet base = [] in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts a::acc (place+1) t l2) \nin\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \n(let rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts a::acc (place+1) t l2) \nin\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  bigAdd a x in\nlet base = [] in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts a::acc (place+1) t l2 in\ndigitsProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts a::acc (place+1) t l2 in\ndigitsProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  bigAdd a x in\nlet base = [] in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitsProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitsProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  bigAdd a x in\nlet base = [] in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = a in\nlet base = failwith \"to be implemented\" in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  match a with \n| (_, z) -> (0, bigAdd z x) in\nlet base = (0, []) in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x =  match a with \n| (_, z) -> (0, bigAdd z x)\n| _ -> (0, 0) in\nlet base = [] in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x =  match a with \n| (_, z) -> (0, bigAdd z x)\n| _ -> (0, 0) in\nlet base = [] in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  match a with \n| (_, z) -> (0, bigAdd z x) in\nlet base = (0, []) in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x =  match a with \n| (_, z) -> (0, bigAdd z x)\n| _ -> (0, []) in\nlet base = [] in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x =  match a with \n| (_, z) -> (0, bigAdd z x)\n| _ -> (0, []) in\nlet base = [] in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  match a with \n| (_, z) -> (0, bigAdd z x) in\nlet base = (0, []) in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x =  match a with \n| (_, z) -> (0, bigAdd z x)\n| _ -> (0, []) in\nlet base = (0, []) in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x =  match a with \n| (_, z) -> (0, bigAdd z x)\n| _ -> (0, []) in\nlet base = (0, []) in\nlet args = \nlet rec digitProducts acc place l1 l2 = match l1 with\n| [] -> acc\n| h::t -> \nlet placeHolders = \n(let rec buildZeros a places = \nif places = 0 then a else buildZeros (0::a) (places-1) in \nbuildZeros [] place) in \nlet a = \n(List.append (mulByDigit h l2) placeHolders) in\ndigitProducts (a::acc) (place+1) t l2 in\ndigitProducts [] 0 l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = let ass y -> y in\nass y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = function y -> y in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = function y -> y in\nList.fold_left f base fs"}
{"fix": "let _ = pipe [] 3", "bad": "let pipe fs = \nlet f a x =  fun b -> x (a b) in\nlet base = fun b -> b in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  fun b -> x (a b) in\nlet base = fun b -> b in\nList.fold_left f base fs"}
{"fix": "let digitsOfInt n = \nlet explodeNum n =\nif (n > 0)\nthen (n mod 10) :: (digitsOfInt (n/10))\nelse []\nin listReverse (explodeNum n)", "bad": "let digitsOfInt n = \nlet explodeNum =\nif (n > 0)\nthen (n mod 10) :: (digitsOfInt (n/10))\nelse []\nin listReverse explodeNum n", "annotated": "let digitsOfInt n = \nlet explodeNum =\nif (n > 0)\nthen (n mod 10) :: (digitsOfInt (n/10))\nelse []\nin listReverse explodeNum n"}
{"fix": "let digitsOfInt n = \nlet explodeNum n =\nif (n > 0)\nthen (n mod 10) :: (digitsOfInt (n/10))\nelse []\nin listReverse (explodeNum n)", "bad": "let digitsOfInt n = \nlet explodeNum =\nif (n > 0)\nthen (n mod 10) :: (digitsOfInt (n/10))\nelse []\nin listReverse (explodeNum n)", "annotated": "let digitsOfInt n = \nlet explodeNum =\nif (n > 0)\nthen (n mod 10) :: (digitsOfInt (n/10))\nelse []\nin listReverse (explodeNum n)"}
{"fix": "let listReverse l = \nlet rec r e a =\nmatch a with\n| [] -> []\n| (x::l') -> x :: e :: r e l'\nin r [] l", "bad": "let rec listReverse l = \nmatch l with\n| [] -> []\n| (x::l') -> (listReverse l') :: x :: []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> []\n| (x::l') -> (listReverse l') :: x :: []"}
{"fix": "let listReverse l = \nlet rec rev o = function\n| [] -> o\n| h::t -> rev (h::o) t\nin rev [] l", "bad": "let listReverse l = \nlet rec rev [] o = o\n| (hd::tl) -> rev tl (hd::o)\nin rev l []", "annotated": "let listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec rev [] o = o\n| (hd::tl) -> rev tl (hd::o)\nin rev l []"}
{"fix": "let listReverse l = \nlet rec rev o = function\n| [] -> o\n| h::t -> rev (h::o) t\nin rev [] l", "bad": "let listReverse l = \nlet rec rev o = \n| [] -> o\n| h::t -> rev (h::o) t\nin rev [] l", "annotated": "let listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec rev o = \n| [] -> o\n| h::t -> rev (h::o) t\nin rev [] l"}
{"fix": "let listReverse l = \nlet rec rev o = function\n| [] -> o\n| h::t -> rev (h::o) t\nin rev [] l", "bad": "let listReverse l = \nlet rec rev o = fun\n| [] -> o\n| h::t -> rev (h::o) t\nin rev [] l", "annotated": "let listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec rev o = fun\n| [] -> o\n| h::t -> rev (h::o) t\nin rev [] l"}
{"fix": "let digitsOfInt n =\nlet rec digits o a = \nif (a > 0)\nthen digitsOfInt ((a mod 10)::o) (a/10)\nelse []\nin digits [] n", "bad": "let digitsOfInt n =\nlet rec digits o a = \nif (a > 0)\nthen (digitsOfInt ((a mod 10)::o) (a/10))\nelse []\nin digits [] n;\n\nlet _ = digitsOfInt 3124", "annotated": "let digitsOfInt : int -> int list = fun  n  -> \nlet rec digits o a = \nif (a > 0)\nthen (digitsOfInt ((a mod 10)::o) (a/10))\nelse []\nin digits [] n;\n\nlet _ = digitsOfInt 3124"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d,k,t)", "bad": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k i else assoc (d,k,t)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with\n| [] -> d\n| (s,i)::t -> if s = k i else assoc (d,k,t)"}
{"fix": "let fixpoint (f,b) = wwhile (f,b)", "bad": "let fixpoint (f,b) = wwhile (fixpoint(f,b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (fixpoint(f,b),b)"}
{"fix": "let fixpoint (f,b) = let helper x = \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper,b)", "bad": "let fixpoint (f,b) = wwhile (if b = f b then b else f(b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (if b  ->  f b then b else f(b),b)"}
{"fix": "let fixpoint (f,b) = let helper x = \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper,b)", "bad": "let fixpoint (f,b) = wwhile (if b = f b then b else f b,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (if b  ->  f b then b else f b,b)"}
{"fix": "let fixpoint (f,b) = let helper x = \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper,b)", "bad": "let fixpoint (f,b) = wwhile (if b = (f b) then b else (f b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (if b  ->  (f b) then b else (f b),b)"}
{"fix": "let fixpoint (f,b) = let helper x = \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper,b)", "bad": "let fixpoint (f,b) = wwhile (if b = (f b) then (b,false) else ((f b),true),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (if b  ->  (f b) then (b,false) else ((f b),true),b)"}
{"fix": "let fixpoint (f,b) = let helper x = \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper,b)", "bad": "let fixpoint (f,b) = wwhile (if x = f x then (b, false) else (b, true),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (if x  ->  f x then (b, false) else (b, true),b)"}
{"fix": "let fixpoint (f,b) = let helper x = \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper,b)", "bad": "let fixpoint (f,b) = wwhile (if x = f x then (x, false) else (x, true),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (if x  ->  f x then (x, false) else (x, true),b)"}
{"fix": "let fixpoint (f,b) = let helper x = \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper,b)", "bad": "let fixpoint (f,b) = wwhile (if b = f b then (b, false) else (b, true),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (if b  ->  f b then (b, false) else (b, true),b)"}
{"fix": "let fixpoint (f,b) = let helper x = \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper,b)", "bad": "let fixpoint (f,b) = wwhile ((if b = f b then (b, false) else (b, true)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((if b  ->  f b then (b, false) else (b, true)),b)"}
{"fix": "let fixpoint (f,b) = let helper x = \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper,b)", "bad": "let fixpoint (f,b) = let helper x = \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper b,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let helper x  ->  \nif b = f b then (b, false) else (b, true) \nin\nwwhile (helper b,b)"}
{"fix": "let fixpoint (f,b) = let helper x = \nif b = (f b) then (b, false) else (f b, true) in\nwwhile (helper,b)", "bad": "et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = wwhile ((if b = (f b) then (b, false) else (f b, true)),b)", "bad": "et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile ((if x = (f x) then (x, false) else (f x, true)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((if x  ->  (f x) then (x, false) else (f x, true)),b)"}
{"fix": "et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "l", "annotated": "l"}
{"fix": "et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile (x->(if x = (f x) then (x, false) else (f x, true)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (x->(if x  ->  (f x) then (x, false) else (f x, true)),b)"}
{"fix": "et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "l", "annotated": "l"}
{"fix": "et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = let helper x = \nif x = (f x) then (x, false) else (f x, true) in\nwwhile (helper,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let helper x  ->  \nif x = (f x) then (x, false) else (f x, true) in\nwwhile (helper,b)"}
{"fix": "et g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "l", "annotated": "l"}
{"fix": "let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e    -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e  -> \"cos (pi*\" ^ exprToString e ^ \")\"\n| Average e1 e2 -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin (pi*\" + exprToString e", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin (pi*\" + exprToString e"}
{"fix": "let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e    -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e  -> \"cos (pi*\" ^ exprToString e ^ \")\"\n| Average e1 e2 -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin (pi*\" ^ exprToString e", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin (pi*\" ^ exprToString e"}
{"fix": "let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e    -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e  -> \"cos (pi*\" ^ exprToString e ^ \")\"\n| Average (e1,e2) -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1,e2) -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\" ^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"", "bad": "let rec exprToString e = match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e    -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e  -> \"cos (pi*\" ^ exprToString e ^ \")\"\n| Average (e1,e2) -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e    -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e  -> \"cos (pi*\" ^ exprToString e ^ \")\"\n| Average (e1,e2) -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\""}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d,k,t)", "bad": "let rec eval (e,x,y) = match e with\n| buildX()\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)\n| Times (e1,e2)\t        -> eval (e1,x,y) * eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)", "annotated": "let rec eval (e,x,y) = match e with\n| buildX()\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)\n| Times (e1,e2)\t        -> eval (e1,x,y) * eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d,k,t)", "bad": ") e", "annotated": ") e"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d,k,t)", "bad": "let rec eval (e,x,y) = match e with\n| buildX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)\n| Times (e1,e2)\t        -> eval (e1,x,y) * eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)", "annotated": "let rec eval (e,x,y) = match e with\n| buildX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)\n| Times (e1,e2)\t        -> eval (e1,x,y) * eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d,k,t)", "bad": ") e", "annotated": ") e"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d,k,t)", "bad": "let rec eval (e,x,y) = match e with\n| buildX\t                -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)\n| Times (e1,e2)\t        -> eval (e1,x,y) * eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)", "annotated": "let rec eval (e,x,y) = match e with\n| buildX\t                -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)\n| Times (e1,e2)\t        -> eval (e1,x,y) * eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d,k,t)", "bad": ") e", "annotated": ") e"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d,k,t)", "bad": "let rec eval (e,x,y) = match e with\n| buildX                -> x\n| buildY\t        -> y \n| Sine e1\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)\n| Times (e1,e2)\t        -> eval (e1,x,y) * eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)", "annotated": "let rec eval (e,x,y) = match e with\n| buildX                -> x\n| buildY\t        -> y \n| Sine e1\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)\n| Times (e1,e2)\t        -> eval (e1,x,y) * eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d,k,t)", "bad": ") e", "annotated": ") e"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d,k,t)", "bad": "let rec eval (e,x,y) = match e with\n| buildX                -> x\n| buildY\t        -> y \n| buildSine(e1)\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)\n| Times (e1,e2)\t        -> eval (e1,x,y) * eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)", "annotated": "let rec eval (e,x,y) = match e with\n| buildX                -> x\n| buildY\t        -> y \n| buildSine(e1)\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)\n| Times (e1,e2)\t        -> eval (e1,x,y) * eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d,k,t)", "bad": ") e", "annotated": ") e"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d,k,t)", "bad": "let rec eval (e,x,y) = match e with\n| buildX                -> x\n| buildY\t        -> y \n| buildSine e1\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)\n| Times (e1,e2)\t        -> eval (e1,x,y) * eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)", "annotated": "let rec eval (e,x,y) = match e with\n| buildX                -> x\n| buildY\t        -> y \n| buildSine e1\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) + eval (e1,x,y))/2)\n| Times (e1,e2)\t        -> eval (e1,x,y) * eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d,k,t)", "bad": ") e", "annotated": ") e"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)", "bad": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)", "bad": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<.eval (e2,x,y) then eval (e3,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<.eval (e2,x,y) then eval (e3,x,y)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)", "bad": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<.eval (e2,x,y) then eval (e3,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<.eval (e2,x,y) then eval (e3,x,y)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)", "bad": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<.eval (e2,x,y) then eval (e3,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<.eval (e2,x,y) then eval (e3,x,y)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)", "bad": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)", "bad": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> eval (e1,x,y)<eval (e2,x,y)?eval (e3,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> eval (e1,x,y)<eval (e2,x,y)?eval (e3,x,y)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)", "bad": "):(eval(e4,x,y))", "annotated": "):(eval(e4,x,y))"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)", "bad": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> eval (e1,x,y)<eval (e2,x,y)?(eval (e3,x,y)):(eval(e4,x,y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> eval (e1,x,y)<eval (e2,x,y)?(eval (e3,x,y)):(eval(e4,x,y))"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)", "bad": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> (eval (e1,x,y)<eval (e2,x,y))?(eval (e3,x,y)):(eval(e4,x,y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> (eval (e1,x,y)<eval (e2,x,y))?(eval (e3,x,y)):(eval(e4,x,y))"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)", "bad": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<.eval (e2,x,y) then eval (e3,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<.eval (e2,x,y) then eval (e3,x,y)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)", "bad": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  -> if eval (e1,x,y)<eval (e2,x,y) then eval (e3,x,y)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)\n| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)>=eval (e2,x,y)->  eval (e4,x,y)", "bad": "let rec eval (e,x,y) = match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX\t\t        -> x\n| VarY\t\t        -> y \n| Sine e1\t        -> sin(pi*.eval (e1,x,y))\n| Cosine e1\t\t-> cos(pi*.eval (e1,x,y))\n| Average (e1,e2)       -> ((eval (e1,x,y) +. eval (e1,x,y))/.2.0)\n| Times (e1,e2)\t        -> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh (e1,e2,e3,e4)  when eval (e1,x,y)<eval (e2,x,y)->  eval (e3,x,y)"}
{"fix": "let rec build (rand, depth) = \nlet e = build(rand,depth') in\nif depth > 0 then match rand 0 4 with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildTimes(e,e,e,e)\nelse match rand 0 1 with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec build (rand, depth) = match rand (depth>0?(rand 0 1):(rand 2 6)) with\n| 0 -> buildX()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match rand (depth>0?(rand 0 1):(rand 2 6)) with\n| 0 -> buildX()"}
{"fix": "let rec build (rand, depth) = \nlet e = build(rand,depth') in\nif depth > 0 then match rand 0 4 with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildTimes(e,e,e,e)\nelse match rand 0 1 with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec build (rand, depth) = match (depth>0?(rand 0 1):(rand 2 6)) with\n| 0 -> buildX()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (depth>0?(rand 0 1):(rand 2 6)) with\n| 0 -> buildX()"}
{"fix": "let rec build (rand, depth) = \nlet e = build(rand,depth') in\nif depth > 0 then match rand 0 4 with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildTimes(e,e,e,e)\nelse match rand 0 1 with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec build (rand, depth) = match rand (depth>0?0:2) (depth>0?1:6) with\n| 0 -> buildX()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match rand (depth>0?0:2) (depth>0?1:6) with\n| 0 -> buildX()"}
{"fix": "let rec build (rand, depth) = \nlet e = build(rand,depth') in\nif depth > 0 then match rand 0 4 with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildTimes(e,e,e,e)\nelse match rand 0 1 with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec build (rand, depth) = if depth > 0 then match rand 0 4 with\n| 0 -> buildX()\nelse match rand 0 1 with\n| 0 -> buildX()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  if depth > 0 then match rand 0 4 with\n| 0 -> buildX()\nelse match rand 0 1 with\n| 0 -> buildX()"}
{"fix": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand 0 4 with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand 0 1 with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 0 then match rand 0 4 with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildTimes(e,e,e,e)\nelse match rand 0 1 with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet e = build(rand,depth-1) in\nif depth > 0 then match rand 0 4 with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildTimes(e,e,e,e)\nelse match rand 0 1 with\n| 0 -> buildX()\n| 1 -> buildY()"}
{"fix": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand 0 4 with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand 0 1 with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 0 then match rand 0 4 with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand 0 1 with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet e = build(rand,depth-1) in\nif depth > 0 then match rand 0 4 with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand 0 1 with\n| 0 -> buildX()\n| 1 -> buildY()"}
{"fix": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match (rand (0 4)) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0 1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet e = build(rand,depth-1) in\nif depth > 1 then match (rand (0 4)) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0 1) with\n| 0 -> buildX()\n| 1 -> buildY()"}
{"fix": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match (rand(0 4)) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0 1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet e = build(rand,depth-1) in\nif depth > 1 then match (rand(0 4)) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0 1) with\n| 0 -> buildX()\n| 1 -> buildY()"}
{"fix": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"}
{"fix": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let _ = build(rand,2)", "annotated": "let _ = build(rand,2)"}
{"fix": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "bad": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"}
{"fix": "let rand = makeRand(10,39)", "bad": "let rand = makeRand(10,39) in \nbuild (rand, 8);\n\n(* g1,g2,g3,c1,c2,c3 : unit -> int * int * int\n* these functions should return the parameters needed to create your \n* top three color / grayscale pictures.\n* they should return (depth,seed1,seed2)\n*)\n\nlet g1 () = (8,54765,10000)", "annotated": "let rand = makeRand(10,39) in \nbuild (rand, 8);\n\n(* g1,g2,g3,c1,c2,c3 : unit -> int * int * int\n* these functions should return the parameters needed to create your \n* top three color / grayscale pictures.\n* they should return (depth,seed1,seed2)\n*)\n\nlet g1 () = (8,54765,10000)"}
{"fix": "let rand = makeRand(10,39)", "bad": "let rand = makeRand(10,39) in \nlet _ = build (rand, 8);\n\n(* g1,g2,g3,c1,c2,c3 : unit -> int * int * int\n* these functions should return the parameters needed to create your \n* top three color / grayscale pictures.\n* they should return (depth,seed1,seed2)\n*)\n\nlet g1 () = (8,54765,10000)", "annotated": "let rand = makeRand(10,39) in \nlet _ = build (rand, 8);\n\n(* g1,g2,g3,c1,c2,c3 : unit -> int * int * int\n* these functions should return the parameters needed to create your \n* top three color / grayscale pictures.\n* they should return (depth,seed1,seed2)\n*)\n\nlet g1 () = (8,54765,10000)"}
{"fix": "let rand = makeRand(10,12)", "bad": "let rec build (rand, depth) = \nif depth > 1 then match rand (0,16) with\n| 0        ->  buildX()\n| 1\t   -> buildY()\n| 3|4      -> buildSine(build(rand,depth-1))\n| 5|6      -> buildCosine(build(rand,depth-1))\n| 7|8|9    -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 10|11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 13|14|15 -> buildThresh(build(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1))\n| 16|17    -> buildDivide(build(rand,depth-1),build(rand,depth-1))\n| _        -> buildMultDiv(build(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1))\n\nelse match rand (0,2) with\n| 0 -> buildX()\n| _ -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 1 then match rand (0,16) with\n| 0        ->  buildX()\n| 1\t   -> buildY()\n| 3|4      -> buildSine(build(rand,depth-1))\n| 5|6      -> buildCosine(build(rand,depth-1))\n| 7|8|9    -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 10|11|12 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 13|14|15 -> buildThresh(build(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1))\n| 16|17    -> buildDivide(build(rand,depth-1),build(rand,depth-1))\n| _        -> buildMultDiv(build(rand,depth-1),\nbuild(rand,depth-1),\nbuild(rand,depth-1))\n\nelse match rand (0,2) with\n| 0 -> buildX()\n| _ -> buildY()"}
{"fix": "let _ = eval_fn (Square VarX) (2.,2.)", "bad": "let _ = eval_fn (Square 5) (1,1)", "annotated": "let _ = eval_fn (Square 5) (1,1)"}
{"fix": "let _ = eval_fn (Square VarX) (2.,2.)", "bad": "let _ = eval_fn (Square VarX) (1,1)", "annotated": "let _ = eval_fn (Square VarX) (1,1)"}
{"fix": "let _ = eval_fn (Square VarX) (2.,2.)", "bad": "let _ = eval_fn (Square VarX) (1.,1.)", "annotated": "let _ = eval_fn (Square VarX) (1.,1.)"}
{"fix": "let _ = eval (Square VarX,0.9,0.9)", "bad": "let _ = eval (Square VarX,0.5,0.25)", "annotated": "let _ = eval (Square VarX,0.5,0.25)"}
{"fix": "let _ = eval_fn (Square VarX) (2.,1.)", "bad": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nFormat.sprintf(\"%d\" !rv)", "annotated": "let eval : expr * float * float -> float = fun _fn e (x,y)  ->  \nlet rv = eval (e,x,y) in\nFormat.sprintf(\"%d\" !rv)"}
{"fix": "let _ = eval_fn (Square VarX) (2.,1.)", "bad": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nFormat.sprintf \"%d\" !rv", "annotated": "let eval : expr * float * float -> float = fun _fn e (x,y)  ->  \nlet rv = eval (e,x,y) in\nFormat.sprintf \"%d\" !rv"}
{"fix": "let _ = eval_fn (Square VarX) (2.,1.)", "bad": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nFormat.sprintf \"%f\" !rv", "annotated": "let eval : expr * float * float -> float = fun _fn e (x,y)  ->  \nlet rv = eval (e,x,y) in\nFormat.sprintf \"%f\" !rv"}
{"fix": "let _ = eval_fn (Square VarX) (2.,1.)", "bad": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\n\nlet _ = eval_fn (Square VarX) (2.,1.)", "annotated": "let eval : expr * float * float -> float = fun _fn e (x,y)  ->  \nlet rv = eval (e,x,y) in\n\nlet _ = eval_fn (Square VarX) (2.,1.)"}
{"fix": "let _ = eval_fn (Square VarX) (2.,1.)", "bad": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y)", "annotated": "let eval : expr * float * float -> float = fun _fn e (x,y)  ->  \nlet rv = eval (e,x,y)"}
{"fix": "let _ = eval_fn (Square VarX) (2.,1.)", "bad": "let eval_fn e (x,y) = \nlet _ = eval (e,x,y)", "annotated": "let eval : expr * float * float -> float = fun _fn e (x,y)  ->  \nlet _ = eval (e,x,y)"}
{"fix": "let _ = eval_fn (Square VarX) (2.,1.)", "bad": "let eval_fn e (x,y) =  eval (e,x,y)", "annotated": "let eval : expr * float * float -> float = fun _fn e (x,y)  ->   eval (e,x,y)"}
{"fix": "let sqsum xs = \nlet f a x = a**2. +. x in\nlet base = 0. in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a**2 + x in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a**2 + x in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a**2. +. x in\nlet base = 0. in\nList.fold_left f base xs", "bad": "let _ = sqsum []", "annotated": "let _ = sqsum []"}
{"fix": "let sqsum xs = \nlet f a x = a**2. +. x in\nlet base = 0. in\nList.fold_left f base xs", "bad": "let _ = sqsum [1;2;3;4]", "annotated": "let _ = sqsum [1;2;3;4]"}
{"fix": "let sqsum xs = \nlet f a x = a**2. +. x in\nlet base = 0. in\nList.fold_left f base xs", "bad": "let _ = sqsum [(-1); (-2); (-3); (-4)]", "annotated": "let _ = sqsum [(-1); (-2); (-3); (-4)]"}
{"fix": "let sqsum xs = \nlet f a x = a**2. +. x in\nlet base = 0. in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a**2. + x in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a**2. + x in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a**2. +. x in\nlet base = 0. in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a**2. +. x in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a**2. +. x in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let pipe fs = \nlet f a x = x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = x' in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = x' in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = (f s = s) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = (f s = s) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a (x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a (x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (a x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (a x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a -> x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a -> x in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (x) in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x in\nlet base = () in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x in\nlet base = x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x in\nlet base = x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x in\nlet base = base in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x in\nlet base = base in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x in\nlet base = fun x y -> x y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = fun x y -> x y in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = fun x y -> x y in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun y -> a (x y) in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = fun x y -> x y in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = fun x y -> x y in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun y -> a (x y) in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun y -> a (x y) in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun y -> a (x y) in\nlet base = fun x -> y in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun y -> a (x y) in\nlet base = fun x -> y in\nList.fold_left f base fs"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = \"\" in\nlet l = l in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = \"\" in\nlet l = l in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = if a != \"\" then a ^ sep ^ x else x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = (fun x -> match x with\n| sep ^ y -> y\n| _ -> x) in\nlet l = sl in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = (fun x -> match x with\n| sep ^ y -> y\n| _ -> x) in\nlet l = sl in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = (^) h in\nlet l = t in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = (^) h in\nlet l = t in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sep ^ x in\nlet base = (^) h in\nlet l = t in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sep ^ x in\nlet base = (^) h in\nlet l = t in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sep ^ x in\nlet base = fun x-> h ^ x in\nlet l = t in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sep ^ x in\nlet base = fun x-> h ^ x in\nlet l = t in\nList.fold_left f base l"}
{"fix": "let rec clone x n =\nif n > 0 then\nx :: clone x (n-1)\nelse\n[]", "bad": "let rec clone x n =\nif n > 0 then\nx :: clone x n-1\nelse\n[]", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  -> \nif n > 0 then\nx :: clone x n-1\nelse\n[]"}
{"fix": "let padZero l1 l2 = if (List.length l1) > (List.length l2) then\n(l1,(clone 0 ((List.length l1) - (List.length l2)))::l2)\nelse\n((clone 0 ((List.length l2) - (List.length l1)))::l1,l2)", "bad": "let _ = padZero [9;9] [1;0;0;2]", "annotated": "let _ = padZero [9;9] [1;0;0;2]"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> (b,(d+e)::c) \nin\nlet base = ([], [0]) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> (b,((d+e)::c) \nin\nlet base = ([], [0]) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> (b,((d+e)::c) \nin\nlet base = ([], [0]) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e)/10,(d+e+b) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e)/10,(d+e+h) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e)/10,(d+e+h) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine [0;0;9;9] [1;0;0;2]) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine (0::l1) (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine (0::l1) 0::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((b,c),(d,e)) -> ((d+e+b)/10,(d+e+b) mod 10::c) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine (0::l1) 0::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let rec mulByDigit i l = if i > 0\nthen\nmulByDigit (i-1) (bigAdd l l)\nelse\n0", "bad": "let rec mulByDigit i l = mulByDigit i-1 bigAdd l l", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  mulByDigit i-1 bigAdd l l"}
{"fix": "let rec mulByDigit i l = if i > 0\nthen\nmulByDigit (i-1) (bigAdd l l)\nelse\n0", "bad": "let rec mulByDigit i l = mulByDigit (i-1) bigAdd l l", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  mulByDigit (i-1) bigAdd l l"}
{"fix": "let rec mulByDigit i l = if i > 0\nthen\nmulByDigit (i-1) (bigAdd l l)\nelse\n0", "bad": "let rec mulByDigit i l = if i > 0\nthen\nmulByDigit (i-1) bigAdd l l\nelse\n0", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  if i > 0\nthen\nmulByDigit (i-1) bigAdd l l\nelse\n0"}
{"fix": "let bigMul l1 l2 = \nlet f a x = match (a,x) with\n| ((b,c),d) -> (b+1,(mulByDigit d l1)::(clone 0 b))\nin\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = match (a,x) with\n| ((b,c),d) -> d \nin\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match (a,x) with\n| ((b,c),d) -> d \nin\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]", "bad": "let bigMul l1 l2 = \nlet f a x = match (a,x) with\n| ((b,c),d) -> (b+1,List.append (mulByDigit d l1) (clone 0 b))\nin\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match (a,x) with\n| ((b,c),d) -> (b+1,List.append (mulByDigit d l1) (clone 0 b))\nin\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]", "bad": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "annotated": "let _ = bigMul [9;9;9;9] [9;9;9;9]"}
{"fix": "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]", "bad": "let _ = bigMul [4;0] [1;0]", "annotated": "let _ = bigMul [4;0] [1;0]"}
{"fix": "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]", "bad": "let _ = bigMul [4;0] [1;1]", "annotated": "let _ = bigMul [4;0] [1;1]"}
{"fix": "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]", "bad": "let bigMul l1 l2 = \nlet f a x = match (a,x) with\n| ((b,c),d) -> (b+1,bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)\nin\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match (a,x) with\n| ((b,c),d) -> (b+1,bigAdd (List.append (mulByDigit d l1) (clone 0 b)) c)\nin\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]", "bad": "let _ = bigMul [4;0] [1;1]", "annotated": "let _ = bigMul [4;0] [1;1]"}
{"fix": "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]", "bad": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "annotated": "let _ = bigMul [9;9;9;9] [9;9;9;9]"}
{"fix": "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]", "bad": "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]", "annotated": "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]"}
{"fix": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs", "bad": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + sumList List.tl", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + sumList List.tl"}
{"fix": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs", "bad": "let rec sumList xs = \nmatch xs with\n| _ -> List.hd xs + sumList List.tl\n| [] -> []", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| _ -> List.hd xs + sumList List.tl\n| [] -> []"}
{"fix": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs", "bad": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + List.tl sumList", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + List.tl sumList"}
{"fix": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| (x::xs') -> x", "bad": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + 2", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + 2"}
{"fix": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| (x::xs') -> x", "bad": "let rec sumList xs = \nmatch xs with\n| _ -> List.hd xs + 2\n| [] -> []", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| _ -> List.hd xs + 2\n| [] -> []"}
{"fix": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| (x::xs') -> x", "bad": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + (sumList List.tl xs)", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + (sumList List.tl xs)"}
{"fix": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| (x::xs') -> x", "bad": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + sumList List.tl xs", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + sumList List.tl xs"}
{"fix": "let _ = sumList []", "bad": "let _ = sumList [1; 2; 3; 4]", "annotated": "let _ = sumList [1; 2; 3; 4]"}
{"fix": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "bad": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| List.hd xs -> x", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> []\n| List.hd xs -> x"}
{"fix": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "bad": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| List.hd xs -> 1", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> []\n| List.hd xs -> 1"}
{"fix": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "bad": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| List.hd xs -> 1", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> []\n| List.hd xs -> 1"}
{"fix": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "bad": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| xs -> List.hd xs + sumList List.tl xs", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> []\n| xs -> List.hd xs + sumList List.tl xs"}
{"fix": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "bad": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> List.hd xs + sumList List.tl xs", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> 0\n| xs -> List.hd xs + sumList List.tl xs"}
{"fix": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "bad": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs))", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs))"}
{"fix": "let _ = sumList [1; 3; 5; 7; 9; 11]", "bad": "let _ = sumList [1; 3; 5; 7; 9; 11]\n(* uncomment and run AFTER you have implemented sumList\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n*)\nList.hd 55", "annotated": "let _ = sumList [1; 3; 5; 7; 9; 11]\n(* uncomment and run AFTER you have implemented sumList\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n*)\nList.hd 55"}
{"fix": "let rec digitsOfInt n = \nmatch n with\n| n -> 5", "bad": "let rec digitsOfInt n = \nmatch n with\n| n <= 0 -> []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nmatch n with\n| n <= 0 -> []"}
{"fix": "let rec digitsOfInt n = \nmatch n with\n| n -> 5", "bad": "let rec digitsOfInt n = \nmatch n with\n| n (<=) 0 -> []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nmatch n with\n| n (<=) 0 -> []"}
{"fix": "let rec digitsOfInt n = \nmatch n with\n| n -> 5", "bad": "let rec digitsOfInt n = \nmatch n with\n| n < 0 -> []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nmatch n with\n| n < 0 -> []"}
{"fix": "let rec digitsOfInt n = \nmatch n with\n| n -> 5", "bad": "let rec digitsOfInt n = \nmatch n with\n| (n < 0) -> []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nmatch n with\n| (n < 0) -> []"}
{"fix": "let rec digitsOfInt n = \nmatch n with\n| n -> 5", "bad": "let rec digitsOfInt n = \nmatch n with\n| (n < 0) -> []\n| n -> 5", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nmatch n with\n| (n < 0) -> []\n| n -> 5"}
{"fix": "let rec digitsOfInt n = \nmatch n with\n| n -> n :: []", "bad": "let rec digitsOfInt n = \nmatch n with\n| n -> 5\n| (n < 0) -> []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nmatch n with\n| n -> 5\n| (n < 0) -> []"}
{"fix": "let rec digitsOfInt n = \nmatch n with\n| n -> n :: []", "bad": "let rec digitsOfInt n = \nmatch n with\n| n -> 5\n| n < 0 -> []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nmatch n with\n| n -> 5\n| n < 0 -> []"}
{"fix": "let rec digitsOfInt n = \nmatch n with\n| n -> n :: []", "bad": "let rec digitsOfInt n = \nmatch n with\n| n -> 5\n| 0 -> []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nmatch n with\n| n -> 5\n| 0 -> []"}
{"fix": "let rec digitsOfInt n = \nmatch n with\n| (n::ns) -> n :: ns", "bad": "let rec digitsOfInt n = \nmatch n with\n| 0 -> [] :: ns\n| n -> n :: ns", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nmatch n with\n| 0 -> [] :: ns\n| n -> n :: ns"}
{"fix": "let rec digitsOfInt n = \nmatch n with\n| (n::ns) -> n :: ns", "bad": "let rec digitsOfInt n = \nmatch n with\n| n -> n :: ns", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nmatch n with\n| n -> n :: ns"}
{"fix": "let rec digitsOfInt n = \nmatch n with\n| n::ns -> (n::ns)", "bad": "let rec digitsOfInt n = \nmatch n with\n| n -> (n::ns)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nmatch n with\n| n -> (n::ns)"}
{"fix": "let ns = []", "bad": "let _ = digitsOfInt 3124", "annotated": "let _ = digitsOfInt 3124"}
{"fix": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> List.hd ((n mod 10)::ns)", "bad": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| n -> List.hd (n mod 10)::ns", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet ns = [] in \nmatch n with\n| n -> List.hd (n mod 10)::ns"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet ns = [] in \nmatch n with\n| 0 -> 0\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))::ns", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet ns = [] in \nmatch n with\n| 0 -> 0\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))::ns"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((digitsOfInt (n / 10))::((n mod 10)::ns))", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((digitsOfInt (n / 10))::((n mod 10)::ns))"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> (digitsOfInt (n / 10))::((n mod 10)::ns)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> (digitsOfInt (n / 10))::((n mod 10)::ns)"}
{"fix": "let _ = digitsOfInt 3124", "bad": ")", "annotated": ")"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> (digitsOfInt (n / 10))::((n mod 10)::ns)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> (digitsOfInt (n / 10))::((n mod 10)::ns)"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> (digitsOfInt (n / 10))::(n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> (digitsOfInt (n / 10))::(n mod 10)"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> (digitsOfInt (n / 10))::(n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> (digitsOfInt (n / 10))::(n mod 10)"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))"}
{"fix": "digitsOfInt (-1)", "bad": "digitsOfInt -5", "annotated": "digitsOfInt -5"}
{"fix": "digitsOfInt (-1)", "bad": "digitsOfInt (-5)", "annotated": "digitsOfInt (-5)"}
{"fix": "let rec additivePersistence n =", "bad": "let rec additivePersistence n =", "annotated": "let rec additivePersistence n ="}
{"fix": "let rec additivePersistence n =", "bad": "let rec digitalRoot n = \nsumList digitsOfInt n", "annotated": "let rec digitalRoot : int -> int = fun  n  ->  \nsumList digitsOfInt n"}
{"fix": "let rec additivePersistence n =", "bad": "let rec additivePersistence n =", "annotated": "let rec additivePersistence n ="}
{"fix": "let rec additivePersistence n =", "bad": "let rec digitalRoot n = \nsumList (digitsOfInt n)", "annotated": "let rec digitalRoot : int -> int = fun  n  ->  \nsumList (digitsOfInt n)"}
{"fix": "digitalRoot 9876", "bad": "let rec digitalRoot n = \nsumList (digitsOfInt n)", "annotated": "let rec digitalRoot : int -> int = fun  n  ->  \nsumList (digitsOfInt n)"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l = \nlet l' = [] in\nmatch l with\n| [] -> l'\n| h::t -> (List.hd l)::(listReverse (List.tl l))", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nlet l' = [] in\nmatch l with\n| [] -> l'\n| h::t -> (List.hd l)::(listReverse (List.tl l))"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l = \nlet rec lr l' =\nmatch l with\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] listReverse", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec lr l' =\nmatch l with\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] listReverse"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l = \nlet rec lr l' = function\nmatch l with\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] listReverse", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec lr l' = function\nmatch l with\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] listReverse"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l = \nlet rec lr l' = function\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] listReverse", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec lr l' = function\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] listReverse"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let listReverse l = \nlet rec lr l' = function\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] listReverse", "annotated": "let listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec lr l' = function\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] listReverse"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let listReverse l = \nlet rec lr l' = function\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] l", "annotated": "let listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec lr l' = function\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] l"}
{"fix": "let palindrome w = \nexplode w = listReverse (explode w )", "bad": "palindrome \"hello\"", "annotated": "palindrome \"hello\""}
{"fix": "additivePersistence 98765", "bad": "additivePersistence 1111", "annotated": "additivePersistence 1111"}
{"fix": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: (listReverse ( digitsOfInt (n / 10))) )", "bad": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: listReverse ((( digitsOfInt (n / 10) ) )", "annotated": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: listReverse ((( digitsOfInt (n / 10) ) )"}
{"fix": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: (listReverse ( digitsOfInt (n / 10))) )", "bad": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: listReverse ( digitsOfInt (n / 10) )", "annotated": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: listReverse ( digitsOfInt (n / 10) )"}
{"fix": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: (listReverse ( digitsOfInt (n / 10))) )", "bad": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: listReverse ( digitsOfInt (n / 10) )", "annotated": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: listReverse ( digitsOfInt (n / 10) )"}
{"fix": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: (listReverse ( digitsOfInt (n / 10))) )", "bad": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: listReverse ( digitsOfInt (n / 10) ) )", "annotated": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: listReverse ( digitsOfInt (n / 10) ) )"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10) :: []) )", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10) :: []) )"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)) ) :: []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)) ) :: []"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)) )", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)) )"}
{"fix": "let rec digitsOfInt n =\nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse let rev = listReverse ns' in\n((n mod 10) ::  ( digitsOfInt (n / 10)) )", "bad": "let listReverse l = \nlet rec lr l' = function\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] l", "annotated": "let listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec lr l' = function\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] l"}
{"fix": "let rec digitsOfInt n =\nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse let listReverse ns in\n((n mod 10) ::  ( digitsOfInt (n / 10)) )", "bad": "let rec digitsOfInt n =\nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse let rev = listReverse ns in\n((n mod 10) ::  ( digitsOfInt (n / 10)) )", "annotated": "let rec digitsOfInt n =\nlet ns = [] in \nmatch n with\n| 0 -> ns\n| n -> \nif n < 0\nthen []\nelse let rev = listReverse ns in\n((n mod 10) ::  ( digitsOfInt (n / 10)) )"}
{"fix": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "bad": "let rec digitsOfInt n = \nlet this = function\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))\nin this listReverse n", "annotated": "let rec digitsOfInt n = \nlet this = function\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))\nin this listReverse n"}
{"fix": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "bad": "let rec digitsOfInt n = \nlet this = function\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))\nin this listReverse n", "annotated": "let rec digitsOfInt n = \nlet this = function\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))\nin this listReverse n"}
{"fix": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| xs -> (List.hd xs + (sumList (List.tl xs)))", "bad": "let rec digitsOfInt n = \nlet this = \nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))\nin this listReverse n", "annotated": "let rec digitsOfInt n = \nlet this = \nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))\nin this listReverse n"}
{"fix": "let rec digitsOfInt n = \nlet xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( digitsOfInt (n / 10)))\nin listReverse (xxx n)", "bad": "let digitsOfInt n = \nlet xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))\nin listReverse (xxx n)", "annotated": "let digitsOfInt n = \nlet xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) ::  ( digitsOfInt (n / 10)))\nin listReverse (xxx n)"}
{"fix": "let rec digitsOfInt n = \nlet xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( digitsOfInt (n / 10)))\nin listReverse (xxx n)", "bad": "let digitsOfInt n = \nlet xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( xxx (n / 10)))\nin listReverse (xxx n)", "annotated": "let digitsOfInt n = \nlet xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( xxx (n / 10)))\nin listReverse (xxx n)"}
{"fix": "let rec digitsOfInt n = \nlet xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( digitsOfInt (n / 10)))\nin listReverse (xxx n)", "bad": "let digitsOfInt n = \nlet rec xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( xxx (n / 10)))\nin listReverse (xxx n)", "annotated": "let digitsOfInt n = \nlet rec xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( xxx (n / 10)))\nin listReverse (xxx n)"}
{"fix": "let rec digitsOfInt n = \nlet xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( digitsOfInt (n / 10)))\nin listReverse (xxx n)", "bad": "let rec digitsOfInt n = \nlet xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( digitsOfInt (n / 10)))\nin listReverse (xxx n)", "annotated": "let rec digitsOfInt n = \nlet xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( digitsOfInt (n / 10)))\nin listReverse (xxx n)"}
{"fix": "let rec digitsOfInt n = \nlet xxx =\nmatch n with\n| 0 -> []\n| n -> \nif n < 0\nthen []\nelse ((n mod 10) :: ( digitsOfInt (n / 10)))\nin listReverse (xxx n)", "bad": "let listReverse l = \nlet rec lr l' = function\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] l", "annotated": "let listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec lr l' = function\n| [] -> l'\n| h::t -> lr (h::l') t in\nlr [] l"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))\n\nremoveDuplicates [1;6;2;4;12;2;13;6;9]", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))\n\nremoveDuplicates [1;6;2;4;12;2;13;6;9]"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nif List.mem seen' seen = false\nthen seen' :: seen", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nif List.mem seen' seen = false\nthen seen' :: seen"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nif List.mem seen' seen = false\nthen seen' :: seen", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nif List.mem seen' seen = false\nthen seen' :: seen"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nif List.mem seen' seen = false\nthen seen' :: seen", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nif List.mem seen' seen = false\nthen seen' :: seen"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nif (List.mem seen' seen = false)\nthen seen' :: seen", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nif (List.mem seen' seen = false)\nthen seen' :: seen"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nif (List.mem seen' seen = false)\nthen seen' :: seen", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nif (List.mem seen' seen = false)\nthen seen' :: seen"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nif (List.mem seen' seen = false)\nthen (seen' :: seen)", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nif (List.mem seen' seen = false)\nthen (seen' :: seen)"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "if 1 < 2\nthen 12", "annotated": "if 1 < 2\nthen 12"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = t\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = t\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = t\nhelper (seen',rest'); \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = t\nhelper (seen',rest'); \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = t\nhelper (seen',rest')", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = t\nhelper (seen',rest')"}
{"fix": "let rec wwhile (f,b) =\nlet f' = f b in \nmatch f' with\n| (b', false) -> b'\n| (b', true) -> wwhile (f, b')", "bad": "let rec wwhile (f,b) =\nlet b' =\nmatch x' with\n| (b', false) -> b'\n| (b', true) -> wwhile (f, b')\nin f b", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> \nlet b' =\nmatch x' with\n| (b', false) -> b'\n| (b', true) -> wwhile (f, b')\nin f b"}
{"fix": "let rec wwhile (f,b) =\nlet f' = f b in \nmatch f' with\n| (b', false) -> b'\n| (b', true) -> wwhile (f, b')", "bad": "let rec wwhile (f,b) =\nlet b' =\nmatch b' with\n| (b', false) -> b'\n| (b', true) -> wwhile (f, b')\nin f b", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> \nlet b' =\nmatch b' with\n| (b', false) -> b'\n| (b', true) -> wwhile (f, b')\nin f b"}
{"fix": "let rec wwhile (f,b) =\nlet f' = f b in \nmatch f' with\n| (b', false) -> b'\n| (b', true) -> wwhile (f, b')", "bad": "let fixpoint (f,b) = wwhile ((let f x = let xx = x*x*x in (xx, xx < 100),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f x = let xx  ->  x*x*x in (xx, xx < 100),b)"}
{"fix": "let rec wwhile (f,b) =\nlet f' = f b in \nmatch f' with\n| (b', false) -> b'\n| (b', true) -> wwhile (f, b')", "bad": "let fixpoint (f,b) = wwhile ((let f x = let xx = x*x*x in (xx, xx < 100)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f x = let xx  ->  x*x*x in (xx, xx < 100)),b)"}
{"fix": "let fixpoint (f,b) = wwhile (\n(let f' f b = let g f b =  g(b) in (b , b = g'),b))", "bad": "let fixpoint (f,b) = wwhile (\n(let f' f b =\nlet f b = let g' = g(b) in (b , b = g')\n),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (\n(let f' f b =\nlet f b = let g' = g(b) in (b , b = g')\n),b)"}
{"fix": "let fixpoint (f,b) = wwhile (\n(let f' f b = let g f b =  g(b) in (b , b = g'),b))", "bad": "let fixpoint (f,b) = wwhile (\n(let f' f b =\nlet f b = let g' = g(b) in (b , b = g')", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (\n(let f' f b =\nlet f b = let g' = g(b) in (b , b = g')"}
{"fix": "let fixpoint (f,b) = wwhile (\n(let f' f b = let g f b =  g(b) in (b , b = g'),b))", "bad": "let fixpoint (f,b) = wwhile (\n(let f' f b = let f b = let g' = g(b) in (b , b = g')),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (\n(let f' f b = let f b = let g' = g(b) in (b , b = g')),b)"}
{"fix": "let fixpoint (f,b) = wwhile (\n(let f' f b = let g f b =  g(b) in (b , b = g'),b))", "bad": "let fixpoint (f,b) = wwhile (\n(let f' f b = let g f b =  g(b) in (b , b = g')),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (\n(let f' f b = let g f b =  g(b) in (b , b = g')),b)"}
{"fix": "let fixpoint (f,b) = wwhile (\n(let f' f b = let g f b =  g(b) in (b , b = g'),b))", "bad": "let fixpoint (f,b) = wwhile (\n(let f' f b = let g f b =  g(b) in (b , b = g'),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (\n(let f' f b = let g f b =  g(b) in (b , b = g'),b)"}
{"fix": "let fixpoint (f,b) = wwhile (let whilesFun f' b' = let fOfB = f(b) in (b , b = fOfB) in whilesFun (f, b), b)", "bad": "let fixpoint (f,b) = wwhile (\n(let whilesFun = let fOfB = f(b) in (b , b = fOfB),b))", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (\n(let whilesFun = let fOfB = f(b) in (b , b = fOfB),b))"}
{"fix": "let fixpoint (f,b) = wwhile (let whilesFun f' b' = let fOfB = f(b) in (b , b = fOfB) in whilesFun (f, b), b)", "bad": "let fixpoint (f,b) = wwhile ((let whilesFun = let fOfB = f(b) in (b , b = fOfB)), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let whilesFun = let fOfB = f(b) in (b , b  ->  fOfB)), b)"}
{"fix": "let fixpoint (f,b) = wwhile (let whilesFun f' b' = let fOfB = f(b) in (b , b = fOfB) in whilesFun (f, b), b)", "bad": "let fixpoint (f,b) = wwhile (let whilesFun = let fOfB = f(b) in (b , b = fOfB), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let whilesFun = let fOfB = f(b) in (b , b  ->  fOfB), b)"}
{"fix": "let fixpoint (f,b) = wwhile (let whilesFun f' b' = let fOfB = f(b) in (b , b = fOfB) in whilesFun (f, b), b)", "bad": "let fixpoint (f,b) = wwhile (let whilesFun = let fOfB = f(b) in (b , b = fOfB)), b", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let whilesFun = let fOfB = f(b) in (b , b  ->  fOfB)), b"}
{"fix": "let fixpoint (f,b) = wwhile (let whilesFun f' b' = let fOfB = f(b) in (b , b = fOfB) in whilesFun (f, b), b)", "bad": "let fixpoint (f,b) = wwhile ((let whilesFun = let fOfB = f(b) in (b , b = fOfB)), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let whilesFun = let fOfB = f(b) in (b , b  ->  fOfB)), b)"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| (k', d') :: t ->\nif k = k'\nthen d'\nelse assoc (d, k, t)", "bad": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b' , b' = fOfB) in whilesFun (f, b)), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b' , b'  ->  fOfB) in whilesFun (f, b)), b)"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| (k', d') :: t ->\nif k = k'\nthen d'\nelse assoc (d, k, t)", "bad": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f'(b') in (b' , b' = fOfB) in whilesFun (f, b)), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f'(b') in (b' , b'  ->  fOfB) in whilesFun (f, b)), b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b' , b' = fOfB) in whilesFun f), b)", "bad": "let fixpoint (f,b) = wwhile ((let whilesFun f' = let fOfB = f'(b') in (b' , b' = fOfB) in whilesFun f), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let whilesFun f' = let fOfB = f'(b') in (b' , b'  ->  fOfB) in whilesFun f), b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun (f)), b)", "bad": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun f), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b', fOfB  ->  b') in whilesFun f), b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x))", "bad": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB b' = f' (b') in (b', fOfB = b') in whilesFun (f)), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let whilesFun f' b' = let fOfB b' = f' (b') in (b', fOfB  ->  b') in whilesFun (f)), b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = (b', f' (b') = b') in whilesFun (f)), b)", "bad": "let fixpoint (f,b) = wwhile ((let whilesFun f' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun (f)), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let whilesFun f' = let fOfB = f' (b') in (b', fOfB  ->  b') in whilesFun (f)), b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = (b', f' (b') = b') in whilesFun (f)), b)", "bad": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun (f)), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b', fOfB  ->  b') in whilesFun (f)), b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x))", "bad": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' b in (fOfB, fOfB = b') in whilesFun (f)), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' b in (fOfB, fOfB  ->  b') in whilesFun (f)), b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x))", "bad": "let fixpoint (f,b) = wwhile ((let whilesFun f' = let fOfB = f' b in (fOfB, fOfB = b) in whilesFun (f)), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let whilesFun f' = let fOfB = f' b in (fOfB, fOfB  ->  b) in whilesFun (f)), b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x))", "bad": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' b') in (fOfB, fOfB = b') in whilesFun (f)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' b') in (fOfB, fOfB  ->  b') in whilesFun (f)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x))", "bad": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (fOfB, fOfB = b') in whilesFun (f)), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (fOfB, fOfB  ->  b') in whilesFun (f)), b)"}
{"fix": "let rec exprToString e = match e with\n| VarX -> e", "bad": "let rec exprToString e = match e with\n| VarX -> x", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> x"}
{"fix": "let rec exprToString e = match e with\n| VarX -> e", "bad": "let rec exprToString e = match e with\n| VarX -> e", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> e"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"", "bad": "exprToString VarX", "annotated": "exprToString VarX"}
{"fix": "exprToString VarX", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"Sin(\" ^ (exprToString e1) ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"Sin(\" ^ (exprToString e1) ^ \")\""}
{"fix": "exprToString (VarX, VarY)", "bad": "exprToString (Sine VarX)", "annotated": "exprToString (Sine VarX)"}
{"fix": "exprToString (Sine VarX)", "bad": "exprToString (Sine (Sine VarX))", "annotated": "exprToString (Sine (Sine VarX))"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\" ^ (exprToString e1) ^ \")\"\n| Cosine e1 -> \"cos(pi*\" ^ (exprToString e1) ^ \")\"\n| Average (e1, e2) -> \"((\" ^ (exprToString e1) ^ \"+\" ^ (exprToString e2) ^ \")\" ^ \"/2)\"", "bad": "exprToString (Average(VarX,VarY))", "annotated": "exprToString (Average(VarX,VarY))"}
{"fix": "exprToString (Sine (Cosine VarX))", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\" ^ (exprToString e1) ^ \")\"\n| Cosine e1 -> \"cos(pi*\" ^ (exprToString e1) ^ \")\"\n| Average (e1, e2) -> \"((\" ^ (exprToString e1) ^ \"+\" ^ (exprToString e2) ^ \")\" ^ \"/2)\"\n| Times (e1, e2) -> (exprToString e1) ^ \"*\" ^ (exprToString e2)", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\" ^ (exprToString e1) ^ \")\"\n| Cosine e1 -> \"cos(pi*\" ^ (exprToString e1) ^ \")\"\n| Average (e1, e2) -> \"((\" ^ (exprToString e1) ^ \"+\" ^ (exprToString e2) ^ \")\" ^ \"/2)\"\n| Times (e1, e2) -> (exprToString e1) ^ \"*\" ^ (exprToString e2)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x"}
{"fix": "eval ((VarX * VarY), 1, 2)", "bad": "eval", "annotated": "eval"}
{"fix": "eval (Times (VarX,VarY), 1, 2)", "bad": "eval (Times(VarX,VarY), 1, 2)", "annotated": "eval (Times(VarX,VarY), 1, 2)"}
{"fix": "eval ((Sine (VarY)), 0.2, 0.3)", "bad": "eval (Sine (VarX,VarY), 0.2, 0.3)", "annotated": "eval (Sine (VarX,VarY), 0.2, 0.3)"}
{"fix": "eval ((Sine (VarY)), 0.2, 0.3)", "bad": "eval ((Sine (VarX,VarY)), 0.2, 0.3)", "annotated": "eval ((Sine (VarX,VarY)), 0.2, 0.3)"}
{"fix": "eval ((Sine (VarY)), 0.2, 0.3)", "bad": "eval ((Sine (VarX, VarY)), 0.2, 0.3)", "annotated": "eval ((Sine (VarX, VarY)), 0.2, 0.3)"}
{"fix": "eval ((Sine (VarY)), 0.2, 0.3)", "bad": "eval ((Sine (VarX)), 0.2, 0.3)", "annotated": "eval ((Sine (VarX)), 0.2, 0.3)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1, x, y))\n| Cosine e1 -> cos(pi *. eval (e1, x, y))\n| Average (e1, e2) -> (eval (e1, x, y) +. eval (e2, x, y)) /. 2.0\n| Times (e1, e2) -> (eval (e1, x, y) *. eval (e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif ((eval (e1, x, y)) < (eval (e1, x, y))\nthen x\nelse y", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1, x, y))\n| Cosine e1 -> cos(pi *. eval (e1, x, y))\n| Average (e1, e2) -> (eval (e1, x, y) +. eval (e2, x, y)) /. 2.0\n| Times (e1, e2) -> (eval (e1, x, y) *. eval (e2, x, y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1, x, y))\n| Cosine e1 -> cos(pi *. eval (e1, x, y))\n| Average (e1, e2) -> (eval (e1, x, y) +. eval (e2, x, y)) /. 2.0\n| Times (e1, e2) -> (eval (e1, x, y) *. eval (e2, x, y))"}
{"fix": "eval ((Sine (VarX)), 1.0, 0.3)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1, x, y))\n| Cosine e1 -> cos(pi *. eval (e1, x, y))\n| Average (e1, e2) -> (eval (e1, x, y) +. eval (e2, x, y)) /. 2.0\n| Times (e1, e2) -> (eval (e1, x, y) *. eval (e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif (eval (e1, x, y)) < (eval (e1, x, y))\nthen x\nelse y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1, x, y))\n| Cosine e1 -> cos(pi *. eval (e1, x, y))\n| Average (e1, e2) -> (eval (e1, x, y) +. eval (e2, x, y)) /. 2.0\n| Times (e1, e2) -> (eval (e1, x, y) *. eval (e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif (eval (e1, x, y)) < (eval (e1, x, y))\nthen x\nelse y"}
{"fix": "let sqsum xs = \nlet f a x = x * x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = x * x +  in\nlet base = a in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = x * x +  in\nlet base = a in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = x * x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = x * x in\nlet base = a in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = x * x in\nlet base = a in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = base + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = base + (x * x) in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = f base (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = f base (x * x) in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = a in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a + (x * x) in\nlet base = a in\nList.fold_left f base xs"}
{"fix": "let pipe fs = \nlet f a x = x a in\n(* Should this be able to hand strings or other types? *)\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\n(* Should this be able to hand strings or other types? *)\nlet base = 0\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\n(* Should this be able to hand strings or other types? *)\nlet base = 0\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\n(* Should this be able to hand strings or other types? *)\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\n(* Should this be able to hand strings or other types? *)\nlet base = 0\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\n(* Should this be able to hand strings or other types? *)\nlet base = 0\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\n(* Should this be able to hand strings or other types? *)\nlet base = 0 in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\n(* Should this be able to hand strings or other types? *)\nlet base = 0 in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\n(* Should this be able to hand strings or other types? *)\nlet base = 0 in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\n(* Should this be able to hand strings or other types? *)\nlet base = 0 in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\n(* Should this be able to hand strings or other types? *)\nlet base = 0 in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\n(* Should this be able to hand strings or other types? *)\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x f in\n(* Should this be able to hand strings or other types? *)\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x f in\n(* Should this be able to hand strings or other types? *)\nlet base = 0 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = pipe in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\n(* Should this be able to hand strings or other types? *)\nlet base = x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\n(* Should this be able to hand strings or other types? *)\nlet base = x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = pipe in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = pipe in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = pipe in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = base in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = base in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = [] in\nlet l = sl in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = [] in\nlet l = sl in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = \"\" in\nlet l = h :: t in\nList.fold_left f base l", "bad": "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "annotated": "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]"}
{"fix": "let _ = sepConcat \"X\" [\"hello\"]", "bad": "let _ = sepConcat \"X\" [\"hello\"]\n\n*", "annotated": "let _ = sepConcat \"X\" [\"hello\"]\n\n*"}
{"fix": "let stringOfList f l = \nList.map (sepConcat \"; \") l", "bad": "let stringOfList f l = \nList.map sepConcat (\"; \")", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \nList.map sepConcat (\"; \")"}
{"fix": "let stringOfList f l = \nList.map (sepConcat \"; \") l", "bad": "let stringOfList f l = \nList.map sepConcat (\"; \" l)", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \nList.map sepConcat (\"; \" l)"}
{"fix": "let stringOfList f l = \nList.map (sepConcat \"; \") l", "bad": "let stringOfList f l = \nList.map sepConcat \"; \" l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \nList.map sepConcat \"; \" l"}
{"fix": "let stringOfList f l = \nsepConcat \"; \" (List.map f l)", "bad": "let stringOfList f l = \nList.map (sepConcat \"; \") l l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \nList.map (sepConcat \"; \") l l"}
{"fix": "let stringOfList f l = \nsepConcat \"; \" (List.map f l)", "bad": "let stringOfList f l = \nList.map (sepConcat \"; \" l) l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \nList.map (sepConcat \"; \" l) l"}
{"fix": "let stringOfList f l = \nsepConcat \"; \" (List.map f l)", "bad": "let stringOfList f l = \nList.map (sepConcat (\"; \" l)) l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \nList.map (sepConcat (\"; \" l)) l"}
{"fix": "let stringOfList f l = \nsepConcat \"; \" (List.map f l)", "bad": "let stringOfList f l = \nList.map (sepConcat (\"; \" l))", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \nList.map (sepConcat (\"; \" l))"}
{"fix": "let stringOfList f l = \nsepConcat \"; \" (List.map f l)", "bad": "let stringOfList f l = \nList.map (sepConcat \"; \" l)", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \nList.map (sepConcat \"; \" l)"}
{"fix": "let stringOfList f l = \nsepConcat \"; \" (List.map f l)", "bad": "let stringOfList f l = \nsepConcat \"; \" List.map f l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \nsepConcat \"; \" List.map f l"}
{"fix": "let stringOfList f l = \n\"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"", "bad": "let stringOfList f l = \n\"[\" ^ sepConcat \"; \" (List.map f l) \"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \n\"[\" ^ sepConcat \"; \" (List.map f l) \"]\""}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fs in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fs in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = () in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = _ in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = _ in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fun x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs\n\npipe [] 3", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs\n\npipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs\n\npipe [] 3", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs\n\npipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = function e -> e in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fun ee in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun ee in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = function e -> e in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fun e in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun e in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = function e -> e in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fun in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = function e -> e in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = function e in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = function e in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x (a) in\nlet base = [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = [] in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = [] in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 3 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fs in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fs in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 3 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = base in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = base in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 3 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = base' in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = base' in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base =  Nil in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base =  Nil in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = let x a = a in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = let x a = a in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a -> a in\nlet base = fun x -> a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a -> a in\nlet base = fun x -> a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x -> fun a -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x -> x x in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x -> x x in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x -> fun a -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a -> x x in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a -> x x in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x -> fun a -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = fun x -> fun a -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun x -> fun a -> x (a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x -> fun a -> x in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x -> fun a -> x in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x a -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a -> fun x -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a -> fun x -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x a -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun (x a) -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun (x a) -> a in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x -> x in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = let x a = a in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = let x a = a in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x -> x in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x -> x in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x -> x in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x a in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x -> x in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x a", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x a"}
{"fix": "let pipe fs = \nlet f a x = x(a) in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x(a) in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a x -> a in\nlet base =  in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a x -> a in\nlet base =  in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x(a) in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a x -> a in\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a x -> a in\nlet base = 0 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x(a) in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x a -> a in\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x a -> a in\nlet base = 0 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x(a) in\nlet base = let f x = x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x(a) in\nlet base = let f x = x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x(a) in\nlet base = fun x -> b in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x(a) in\nlet base = fun x -> b in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = let a = x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = let a = x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = let a = x in x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = let a = x in x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = let a = x in a(a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = let a = x in a(a) in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = let a = x in a(x) in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = let a = x in a(x) in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = let a = x in x(x) in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = let a = x in x(x) in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x -> fun a -> x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x -> fun a in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x -> fun a in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x -> fun a -> x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x -> fun a -> x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x -> x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x -> x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x -> fun a -> x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a -> fun a -> x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a -> fun a -> a(a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a -> fun a -> a(a) in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a -> fun a -> x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a -> fun a -> x(x) in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a -> fun a -> x(x) in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a -> fun x -> f x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a -> fun x -> f x a in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a -> fun x -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a -> fun x -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a -> fun x -> x (a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a -> fun x -> x (a) in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x -> (x a)  in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x -> (x a)  in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x -> (x a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x -> (x a) in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x -> (x (a)) in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x -> (x (a)) in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x - in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x - in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x  in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x  in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x in\nlet base = a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x in\nlet base = a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x in\nlet base = f x\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x in\nlet base = f x\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x in\nlet base = f x in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x in\nlet base = f x in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x in\nlet base = fun x -> fun a -> a in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x in\nlet base = fun x -> fun a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x in\nlet base = fun x -> fun a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x(x) in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x(x) in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a(x) in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a(x) in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let rec padZero l1 l2 = \n(clone 0 (List.length l1 - List.length l2)) @ l2", "bad": "let rec padZero l1 l2 = \n(clone 0 List.len l1 - l2)", "annotated": "let rec padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \n(clone 0 List.len l1 - l2)"}
{"fix": "let rec padZero l1 l2 = \n(clone 0 (List.length l1 - List.length l2)) @ l2", "bad": "let rec padZero l1 l2 = \n(clone 0 (List.len l1 - l2)) @ smaller", "annotated": "let rec padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \n(clone 0 (List.len l1 - l2)) @ smaller"}
{"fix": "let rec padZero l1 l2 = \n(clone 0 (List.length l1 - List.length l2)) @ l2", "bad": "let rec padZero l1 l2 = \n(clone 0 (List.length l1 - l2)) @ smaller", "annotated": "let rec padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \n(clone 0 (List.length l1 - l2)) @ smaller"}
{"fix": "let rec padZero l1 l2 = \n(clone 0 (List.length l1 - List.length l2)) @ l2", "bad": "let rec padZero l1 l2 = \n(clone 0 (List.length l1 - l2)) @ l2", "annotated": "let rec padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \n(clone 0 (List.length l1 - l2)) @ l2"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = let a = x(a) in \nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = let a = x(a) in \nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = let a = x a in \nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = let a = x a in \nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x' -> a x in \nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = let x' = x' (x a) in \nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = let x' = x' (x a) in \nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x' -> a x in \nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = let x' = x' (x a) in x' x a in \nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = let x' = x' (x a) in x' x a in \nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x' -> x (a x') in \nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun x' -> x (a x') in \nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x' -> x' (a x) in \nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x' -> x' (a x) in \nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x' -> x (a x') in \nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x' -> x' (x a) in \nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x' -> x' (x a) in \nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let rec padZero l1 l2 = \nif List.length l1 > List.length l2\nthen (l1, (clone 0 (List.length l1 - List.length l2)) @ l2)\nelse (clone 0 (List.length l2 - List.length l1) @ l1, l2)", "bad": "let rec padZero l1 l2 = \nif List.length l1 > List.length l2\nthen (l1, (clone 0 (List.length l1 - List.length l2)) @ l2)\nelse (clone 0 (List.length l2 - List.length l1) @ l1, l2)\n\npadZero [9;9] [8;8;8]", "annotated": "let rec padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 > List.length l2\nthen (l1, (clone 0 (List.length l1 - List.length l2)) @ l2)\nelse (clone 0 (List.length l2 - List.length l1) @ l1, l2)\n\npadZero [9;9] [8;8;8]"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = (l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = (l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base =  [0], [0]in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = (0, 0) in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = (0, 0) in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base =  [0], [0]in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [0] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [0] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base =  [0], [0]in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base =  [0], [0]in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [a] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [a] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base =  [0], [0]in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base =  [0], [0]in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [0, 0] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [0, 0] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base =  [0], [0]in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [_, _] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [_, _] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base =  [0], [0]in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [,] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [,] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base =  [0], [0]in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [(), ()] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [(), ()] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base =  [0], [0]in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base =  res in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base =  res in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let pipe fs = \nlet f a x = fun x'-> x (a x') in \nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x' x a -> x (a x') in \nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x' x a -> x (a x') in \nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x'-> x (a x') in \nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x' a-> x (a x') in \nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x' a-> x (a x') in \nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10, (sum mod 10) :: a)\nin\nlet base =  0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10, (sum mod 10) :: a)\nin\nlet base =  0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10, (sum mod 10) :: a)\nin\nlet base =  0 [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10, (sum mod 10) :: a)\nin\nlet base =  0 [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10, (sum mod 10) :: a)\nin\nlet base =  0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10, (sum mod 10) :: a)\nin\nlet base =  0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10, (sum mod 10) :: a)\nin\nlet base =  (0, [0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10, (sum mod 10) :: a)\nin\nlet base =  (0, [0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10, (sum mod 10) :: a)\nin\nlet base = [0], [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10, (sum mod 10) :: a)\nin\nlet base = [0], [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10, ((sum mod 10) :: a))\nin\nlet base = 0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10, ((sum mod 10) :: a))\nin\nlet base = 0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10, (sum mod 10) :: a)\nin\nlet base = 0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10, (sum mod 10) :: a)\nin\nlet base = 0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s)\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \n( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a\nin\nlet base = 0, [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \n( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a\nin\nlet base = 0, [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s)\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (s, t) = x in \n( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a\nin\nlet base = 0, [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (s, t) = x in \n( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a\nin\nlet base = 0, [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s)\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (s, t) = x in \n( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a\nin\nlet base = 0, [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (s, t) = x in \n( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a\nin\nlet base = 0, [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s)\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (s, t) = x in \n( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a\nin\nlet base = 0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (s, t) = x in \n( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a\nin\nlet base = 0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s)\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (s, t) = x in \n( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a\nin\nlet base = [0, 0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (s, t) = x in \n( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a\nin\nlet base = [0, 0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s)\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a\nin\nlet base = 0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a\nin\nlet base = 0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s)\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) ) :: a\nin\nlet base = 0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) ) :: a\nin\nlet base = 0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s)\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) ) :: a\nin\nlet base = 0, [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) ) :: a\nin\nlet base = 0, [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s)\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) ) :: a\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) ) :: a\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (List.len s == List.len x)\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (List.len s == List.len x)\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (List.lenth s == List.length x)\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (List.lenth s == List.length x)\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (List.length s == List.length x)\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (List.length s == List.length x)\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (List.length s = List.length x)\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (List.length s = List.length x)\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ((List.length s) = (List.length x))\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ((List.length s) = (List.length x))\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ((List.length s) = (List.length (x)))\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ((List.length s) = (List.length (x)))\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ((List.length a) = (List.length x))\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ((List.length a) = (List.length x))\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ((List.length s) = (List.length x))\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ((List.length s) = (List.length x))\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ((List.length x) = (List.length s))\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ((List.length x) = (List.length s))\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ((h :: t) x = [])\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ((h :: t) x = [])\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (x = [])\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (x = [])\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (x = [(,)])\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (x = [(,)])\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (x = [(), ()])\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (x = [(), ()])\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (List.length x = 5)\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (List.length x = 5)\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (List.length a = 5)\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (List.length a = 5)\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (List.length s = 5)\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (List.length s = 5)\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (s = [])\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (s = [])\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (s != [])\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (s != [])\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (s != [])\nthen c :: s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (s != [])\nthen c :: s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (s = [])\nthen c :: s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (s = [])\nthen c :: s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (s)\nthen c :: s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (s)\nthen c :: s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch s with\n| [] -> c :: s\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch s with\n| [] -> c :: s\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch s with\n| [] -> (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch s with\n| [] -> (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch s with\n| [] -> ((c + x' + x'') :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch s with\n| [] -> ((c + x' + x'') :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch s with\n| [] -> ((c + x' + x'' + 0) :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch s with\n| [] -> ((c + x' + x'' + 0) :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch s with\n| [] -> ((c + 0) :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch s with\n| [] -> ((c + 0) :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> ((c + 0) :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> ((c + 0) :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> ((c) :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> ((c) :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = (List.length s) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = (List.length a) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = (List.length a) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = (List.length s) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = (List.length x) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = (List.length x) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = (List.length s) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length x) = (List.length x) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length x) = (List.length x) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = (List.length l1) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = (List.length a) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = (List.length a) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let rec mulByDigit i l = \nif i > 0\nthen bigAdd l (mulByDigit (i - 1) l)\nelse [0]", "bad": "let rec mulByDigit i l = \nif i > 0\nthen bigAdd l (mulByDigit (i - 1) l)\nelse bigAdd [0]", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nif i > 0\nthen bigAdd l (mulByDigit (i - 1) l)\nelse bigAdd [0]"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = (1, []) in\nlet args = (List.rev l2), l1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = failwith \"to be implemented\" in\nlet base = (1, []) in\nlet args = (List.rev l2), l1 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet i' l' = a in\nmatch i with\n[] -> a\n| h :: t -> mulByDigit h l' :: a", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (i, l) = x in\nlet i' l' = a in\nmatch i with\n[] -> a\n| h :: t -> mulByDigit h l' :: a"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet i' l' = a in\nmatch i with\n[] -> a\n| h :: t -> (mulByDigit h l') :: a", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (i, l) = x in\nlet i' l' = a in\nmatch i with\n[] -> a\n| h :: t -> (mulByDigit h l') :: a"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet i' l' = a in\nmatch i with\n[] -> a\n| h :: t -> (mulByDigit h l'), t", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (i, l) = x in\nlet i' l' = a in\nmatch i with\n[] -> a\n| h :: t -> (mulByDigit h l'), t"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet i' l' = a in\nmatch i with\n[] -> a\n| h :: t -> ((mulByDigit h l'), t)", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (i, l) = x in\nlet i' l' = a in\nmatch i with\n[] -> a\n| h :: t -> ((mulByDigit h l'), t)"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet i' l' = a in\nmatch i with\n[] -> \n| h :: t -> bigAdd( (mulByDigit h l'), l')", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (i, l) = x in\nlet i' l' = a in\nmatch i with\n[] -> \n| h :: t -> bigAdd( (mulByDigit h l'), l')"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet i' l' = a in\nmatch i with\n[] -> l'\n| h :: t -> bigAdd( (mulByDigit h l'), l')", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (i, l) = x in\nlet i' l' = a in\nmatch i with\n[] -> l'\n| h :: t -> bigAdd( (mulByDigit h l'), l')"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet i' l' = a in\nmatch i with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l'), l')", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (i, l) = x in\nlet i' l' = a in\nmatch i with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l'), l')"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet i', l' = a in\nmatch i with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l'), l')", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (i, l) = x in\nlet i', l' = a in\nmatch i with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l'), l')"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l'), l')", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l'), l')"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i' with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l'), l')", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i' with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l'), l')"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i' with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l'), l')", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i' with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l'), l')"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let base = (1, l1) in\nlet args = (List.rev l2), l1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let base = (1, l1) in\nlet args = (List.rev l2), l1 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l'), l')", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l'), l')"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l') l')", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l') l')"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l') l') in\nlet base = (1, l1) in\nlet args = (List.rev l2), l1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l') l') in\nlet base = (1, l1) in\nlet args = (List.rev l2), l1 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l'), l') in\nlet base = (1, l1) in\nlet args = (List.rev l2), l1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l'), l') in\nlet base = (1, l1) in\nlet args = (List.rev l2), l1 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l') l') in\nlet base = (1, l1) in\nlet args = (List.rev l2), l1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l') l') in\nlet base = (1, l1) in\nlet args = (List.rev l2), l1 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i' with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l') l') in\nlet base = (1, l1) in\nlet args = (List.rev l2), l1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i' with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l') l') in\nlet base = (1, l1) in\nlet args = (List.rev l2), l1 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i' with\n| [] -> l'\n| h :: t -> t, bigAdd( (mulByDigit h l') l') in\nlet base = (1, l1) in\nlet args = (List.rev l2), l1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i' with\n| [] -> l'\n| h :: t -> t, bigAdd( (mulByDigit h l') l') in\nlet base = (1, l1) in\nlet args = (List.rev l2), l1 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1, a')\n| h :: t -> bigAdd (mulByDigit (h l1')) a' in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1, a')\n| h :: t -> bigAdd (mulByDigit (h l1')) a' in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1, a')\n| h :: t -> bigAdd ((mulByDigit (h l1')) a)' in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1, a')\n| h :: t -> bigAdd ((mulByDigit (h l1')) a)' in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1, a')\n| h :: t -> bigAdd ((mulByDigit (h l1')) a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1, a')\n| h :: t -> bigAdd ((mulByDigit (h l1')) a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1, a')\n| h :: t -> bigAdd (mulByDigit (h l1') a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1, a')\n| h :: t -> bigAdd (mulByDigit (h l1') a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = x in\nmatch a with\n| [] -> (l1, a')\n| h :: t -> bigAdd (mulByDigit (h l1') a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \n\nlet f a x = let (l1', a') = x in\nmatch a with\n| [] -> (l1, a')\n| h :: t -> bigAdd (mulByDigit (h l1') a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = x in\nmatch a with\n| [] -> (l1, a')\n| h :: t -> bigAdd (mulByDigit (h l1') a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \n\nlet f a x = let (l1', a') = x in\nmatch a with\n| [] -> (l1, a')\n| h :: t -> bigAdd (mulByDigit (h l1') a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = x in\nmatch a with\n| [] -> (l1', a')\n| h :: t -> bigAdd (mulByDigit (h l1') a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \n\nlet f a x = let (l1', a') = x in\nmatch a with\n| [] -> (l1', a')\n| h :: t -> bigAdd (mulByDigit (h l1') a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> bigAdd (mulByDigit (h l1') a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> bigAdd (mulByDigit (h l1') a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> bigAdd (mulByDigit (h l1') a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> bigAdd (mulByDigit (h l1') a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> bigAdd (mulByDigit h (l1') a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> bigAdd (mulByDigit h (l1') a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> bigAdd (mulByDigit h (l1')) a'", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> bigAdd (mulByDigit h (l1')) a'"}
{"fix": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> li', bigAdd (mulByDigit h (l1')) a'", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> li', bigAdd (mulByDigit h (l1')) a'"}
{"fix": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> li', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> li', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "annotated": "let _ = bigMul [9;9;9;9] [9;9;9;9]"}
{"fix": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]", "annotated": "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]"}
{"fix": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "annotated": "let _ = bigMul [9;9;9;9] [9;9;9;9]"}
{"fix": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "annotated": "let _ = bigMul [9;9;9;9] [9;9;9;9]"}
{"fix": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]", "annotated": "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]"}
{"fix": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "annotated": "let _ = bigMul [9;9;9;9] [9;9;9;9]"}
{"fix": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, 0) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, 0) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, [0]) in\nlet args = (List.hd (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, [0]) in\nlet args = (List.hd (List.rev List.hd l2)) in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, [0]) in\nlet args = (List.hd (List.rev List.hd l2)) in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, []) in\nlet args = (List.hd (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "annotated": "let _ = bigMul [9;9;9;9] [9;9;9;9]"}
{"fix": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, []) in\nlet args = (List.hd (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]", "annotated": "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]"}
{"fix": "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n| _ -> 0\nin\nhelper d k l", "bad": "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki tt\n| _ -> 0\nin\nhelper d k l", "annotated": "let assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki tt\n| _ -> 0\nin\nhelper d k l"}
{"fix": "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n| _ -> 0\nin\nhelper d k l", "bad": "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n| _ -> 0", "annotated": "let assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n| _ -> 0"}
{"fix": "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n| _ -> 0\nin\nhelper d k l", "bad": "| _ -> 0", "annotated": "| _ -> 0"}
{"fix": "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n| _ -> 0\nin\nhelper d k l", "bad": "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n| _ -> 0", "annotated": "let assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n| _ -> 0"}
{"fix": "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n| _ -> 0\nin\nhelper d k l", "bad": "| _ -> 0\nin\nhelper d k l", "annotated": "| _ -> 0\nin\nhelper d k l"}
{"fix": "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n| _ -> 0\nin\nhelper d k l", "bad": "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n| _ -> 0", "annotated": "let assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n| _ -> 0"}
{"fix": "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n| _ -> 0\nin\nhelper d k l", "bad": "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n| _ -> 0", "annotated": "let assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n| _ -> 0"}
{"fix": "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n| _ -> 0\nin\nhelper d k l", "bad": "in\nhelper d k l", "annotated": "in\nhelper d k l"}
{"fix": "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n\n| _ -> 0\nin\nhelper d k l", "bad": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n\n| _ -> 0\nin\nhelper d k l", "bad": "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n\n| _ -> 0\nin\nhelper d k l", "bad": "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t", "annotated": "let assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t"}
{"fix": "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n\n| _ -> 0\nin\nhelper d k l", "bad": "| _ -> 0\nin\nhelper d k l", "annotated": "| _ -> 0\nin\nhelper d k l"}
{"fix": "let assoc (d,k,l) = \nmatch l with\n| h::t -> h", "bad": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let assoc (d,k,l) = \nmatch l with\n| h::t -> h", "bad": "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then d\nelse assoc(d,k,t)\n| _-> d", "bad": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then d\nelse assoc(d,k,t)\n| _-> d", "bad": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then d\nelse assoc(d,k,t)\n| _-> d", "bad": "let assoc (d,k,l) = \nmatch l with\n| h::t ->\nlet rec helper di ki li = \nlet (name,age) = li in\nif name = ki then di\nelse \nmatch li with\n| h::t -> helper di ki t\n| _-> di\nin\nhelper d k h", "annotated": "let assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  \nmatch l with\n| h::t ->\nlet rec helper di ki li = \nlet (name,age) = li in\nif name = ki then di\nelse \nmatch li with\n| h::t -> helper di ki t\n| _-> di\nin\nhelper d k h"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then d\nelse assoc(d,k,t)\n| _-> d", "bad": "let assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then d\nelse assoc(d,k,t)\n| _-> d\n\nin\nhelper d k h", "annotated": "let assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then d\nelse assoc(d,k,t)\n| _-> d\n\nin\nhelper d k h"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then d\nelse assoc(d,k,t)\n| _-> d", "bad": "let assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then d\nelse assoc(d,k,t)\n| _-> d\n\nin\nhelper d k h", "annotated": "let assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then d\nelse assoc(d,k,t)\n| _-> d\n\nin\nhelper d k h"}
{"fix": "let rec wwhile (f,b) = let func = f b in\nlet (value,boo) = func in\nif boo then wwhile (f,value)\nelse value", "bad": "let rec wwhile (f,b) = let func = f b in\nlet (value,boo) = func in\nif boo then wwhile (func, boo)\nelse value", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b) = let func  ->  f b in\nlet (value,boo) = func in\nif boo then wwhile (func, boo)\nelse value"}
{"fix": "let rec wwhile (f,b) = let func = f b in\nlet (value,boo) = func in\nif boo then wwhile (f,value)\nelse value", "bad": "let rec wwhile (f,b) = let func = f b in\nlet (value,boo) = func in\nif boo then wwhile (func)\nelse value", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b) = let func  ->  f b in\nlet (value,boo) = func in\nif boo then wwhile (func)\nelse value"}
{"fix": "let rec wwhile (f,b) = let func = f b in\nlet (value,boo) = func in\nif boo then wwhile (f,value)\nelse value", "bad": "let rec wwhile (f,b) = let func = f b in\nlet (value,boo) = func in\nif boo then wwhile (f)\nelse value", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b) = let func  ->  f b in\nlet (value,boo) = func in\nif boo then wwhile (f)\nelse value"}
{"fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "bad": "let fixpoint (f,b) = wwhile (let xx = x*x*x in (xx, xx < 100),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let xx  ->  x*x*x in (xx, xx < 100),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "bad": "let fixpoint (f,b) = wwhile (let xx = f b in (xx, xx = b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let xx = f b in (xx, xx  ->  b),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "bad": "let fixpoint (f,b) = wwhile ((f b, xx = b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((f b, xx  ->  b),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "bad": "let fixpoint (f,b) = wwhile ((let xx = f b, xx = b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let xx = f b, xx  ->  b),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "bad": "let fixpoint (f,b) = wwhile ((let xx = (f b), xx = b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let xx = (f b), xx  ->  b),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "bad": "let fixpoint (f,b) = wwhile ((f b, xx = b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((f b, xx  ->  b),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "bad": "let fixpoint (f,b) = wwhile (((let xx = f b), xx = b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (((let xx = f b), xx  ->  b),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "bad": "let fixpoint (f,b) = wwhile (((let xx = (f b), xx = b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (((let xx = (f b), xx  ->  b),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "bad": "let fixpoint (f,b) = wwhile ((let xx = (f b), xx = b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let xx = (f b), xx  ->  b),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "bad": "let fixpoint (f,b) = wwhile (let xx = x*x*x in (xx, xx < 100),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let xx  ->  x*x*x in (xx, xx < 100),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "bad": "let fixpoint (f,b) = wwhile (let xx = b*b*b in (xx, xx < 100),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let xx  ->  b*b*b in (xx, xx < 100),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "bad": "let fixpoint (f,b) = wwhile (let f x = let xx = x*x*x in (xx, xx < 100),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let f x = let xx  ->  x*x*x in (xx, xx < 100),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "bad": "let fixpoint (f,b) = wwhile (let f b = let xx = x*x*x in (xx, xx < 100),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let f b = let xx  ->  x*x*x in (xx, xx < 100),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "bad": "let fixpoint (f,b) = wwhile (let xx = x*x*x in (xx, xx < 100),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let xx  ->  x*x*x in (xx, xx < 100),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "bad": "let fixpoint (f,b) = wwhile ((b*b*b, b*b*b < 100),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((b*b*b, b*b*b < 100),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "bad": "let fixpoint (f,b) = wwhile ((b*b*b, b < 100),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((b*b*b, b < 100),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "bad": "let fixpoint (f,b) = wwhile ((f b, false),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((f b, false),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "bad": "let fixpoint (f,b) = wwhile ((let f b = let xx = f b in (xx, xx = b)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f b = let xx = f b in (xx, xx  ->  b)),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "bad": "let fixpoint (f,b) = wwhile ((let f b = let xx = b*b*b in (xx, xx = b)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f b = let xx = b*b*b in (xx, xx  ->  b)),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "bad": "let fixpoint (f,b) = wwhile ((let f b = let xx = b*b*b in (xx, xx = b)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f b = let xx = b*b*b in (xx, xx  ->  b)),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "bad": "let fixpoint (f,b) = wwhile ((let f b = let xx = b*b*b in xx, xx = b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f b = let xx = b*b*b in xx, xx  ->  b),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let d x = let xx = f x in (xx, xx = b) in d),b)", "bad": "let fixpoint (f,b) = wwhile ((let d x = let xx = f x in (xx, xx = b) in d b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let d x = let xx = f x in (xx, xx  ->  b) in d b),b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile ((let g x = let xx = f x in (xx, xx = b) in g),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g x = let xx = f x in (xx, xx  ->  b) in g),b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile ((let g x = let xx = f x in (xx, xx = b) in g),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g x = let xx = f x in (xx, xx  ->  b) in g),b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile ((let g x = let xx = (f x) in (xx, xx = b) in g),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g x = let xx = (f x) in (xx, xx  ->  b) in g),b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile ((let g x = (f x, x = fx) in g,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g x = (f x, x  ->  fx) in g,b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile ((let g x = (f x, x = fx) in g),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g x = (f x, x  ->  fx) in g),b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile ((let g x = (f x, x = f x) in g),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g x = (f x, x  ->  f x) in g),b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile ((let g x = let d = f x in (d, x = d) in g),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g x = let d = f x in (d, x  ->  d) in g),b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile ((let g x = let d = (f b) in (d, x = d) in g),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g x = let d = (f b) in (d, x  ->  d) in g),b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile ((let g x = let d = let (f b) in (d, x != d) in g),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g x = let d = let (f b) in (d, x ! ->  d) in g),b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile ((let g x = let d = (f b) in (d, x != d) in g),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g x = let d = (f b) in (d, x ! ->  d) in g),b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile ((let g x = let d = (f x) in (d, x = d) in g),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g x = let d = (f x) in (d, x  ->  d) in g),b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile ((let g x = let d = (f x) in (d, x = d) in g),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g x = let d = (f x) in (d, x  ->  d) in g),b)"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d", "bad": "let _ = fixpoint (collatz, 9001)", "annotated": "let _ = fixpoint (collatz, 9001)"}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4", "annotated": "^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4"}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = match e with \nVarX = \"x\"\n|VarY = \"y\"\n|Sine(e) = \"sin (pi*\"^exprToString e^\")\"\n|Cosine(e) = \"cos (pi*\"^exprToString e^\")\"\n|Average(e1,e2) = \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) = exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) = \"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with \nVarX = \"x\"\n|VarY = \"y\"\n|Sine(e) = \"sin (pi*\"^exprToString e^\")\"\n|Cosine(e) = \"cos (pi*\"^exprToString e^\")\"\n|Average(e1,e2) = \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) = exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) = \"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4"}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = match e with \n|VarX = \"x\"\n|VarY = \"y\"\n|Sine(e) = \"sin (pi*\"^exprToString e^\")\"\n|Cosine(e) = \"cos (pi*\"^exprToString e^\")\"\n|Average(e1,e2) = \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) = exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) = \"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with \n|VarX = \"x\"\n|VarY = \"y\"\n|Sine(e) = \"sin (pi*\"^exprToString e^\")\"\n|Cosine(e) = \"cos (pi*\"^exprToString e^\")\"\n|Average(e1,e2) = \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) = exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) = \"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4"}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = match e with \n|VarX = x\n|VarY = \"y\"\n|Sine(e) = \"sin (pi*\"^exprToString e^\")\"\n|Cosine(e) = \"cos (pi*\"^exprToString e^\")\"\n|Average(e1,e2) = \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) = exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) = \"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with \n|VarX = x\n|VarY = \"y\"\n|Sine(e) = \"sin (pi*\"^exprToString e^\")\"\n|Cosine(e) = \"cos (pi*\"^exprToString e^\")\"\n|Average(e1,e2) = \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) = exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) = \"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4"}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = \nmatch e with \n|VarX = \"x\"\n|VarY = \"y\"\n|Sine(e) = \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) = \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) = \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) = exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) = \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nmatch e with \n|VarX = \"x\"\n|VarY = \"y\"\n|Sine(e) = \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) = \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) = \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) = exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) = \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4"}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = \nmatch e with \n|VarX e = \"x\"\n|VarY e = \"y\"\n|Sine(e) = \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) = \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) = \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) = exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) = \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nmatch e with \n|VarX e = \"x\"\n|VarY e = \"y\"\n|Sine(e) = \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) = \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) = \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) = exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) = \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4"}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString ex = \nmatch ex with \n|VarX e = \"x\"\n|VarY e = \"y\"\n|Sine(e) = \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) = \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) = \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) = exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) = \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4", "annotated": "let rec exprToString : expr -> string = fun  ex  ->  \nmatch ex with \n|VarX e = \"x\"\n|VarY e = \"y\"\n|Sine(e) = \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) = \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) = \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) = exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) = \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4"}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString ex = \nmatch ex with \n|VarX e = \"x\"\n|VarY e = \"y\"\n|Sine(e) = \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) = \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) = \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) = exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) = \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4", "annotated": "let rec exprToString : expr -> string = fun  ex  ->  \nmatch ex with \n|VarX e = \"x\"\n|VarY e = \"y\"\n|Sine(e) = \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) = \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) = \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) = exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) = \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4"}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString ex = \nmatch ex with \n(*|VarX = \"x\"\n|VarY = \"y\"*)\n|Sine(e) = \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) = \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) = \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) = exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) = \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4", "annotated": "let rec exprToString : expr -> string = fun  ex  ->  \nmatch ex with \n(*|VarX = \"x\"\n|VarY = \"y\"*)\n|Sine(e) = \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) = \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) = \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) = exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) = \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4"}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString ex = \nmatch ex with \n|VarX = (\"x\")\n|VarY = \"y\"\n|Sine(e) = \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) = \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) = \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) = exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) = \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4", "annotated": "let rec exprToString : expr -> string = fun  ex  ->  \nmatch ex with \n|VarX = (\"x\")\n|VarY = \"y\"\n|Sine(e) = \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) = \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) = \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) = exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) = \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4"}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString ex = \nmatch ex with \n|VarX -> (\"x\")\n|VarY -> \"y\"\n|Sine(e) -> \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) -> \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) -> \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) -> exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4", "annotated": "let rec exprToString : expr -> string = fun  ex  ->  \nmatch ex with \n|VarX -> (\"x\")\n|VarY -> \"y\"\n|Sine(e) -> \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) -> \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) -> \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) -> exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)"}
{"fix": "let rec build (rand, depth) = \nif depth=0 then buildX() else\nlet randNum = rand 0 5 in\nlet depth = depth - 1 in\nmatch randNum with \n|0 -> buildSine(build(makeRand(5,16), depth))\n|1 -> buildCosine(build(rand, depth))\n|2 -> buildTimes(build(rand, depth),build(rand, depth))\n|3 -> buildAverage(build(rand, depth),build(rand, depth))\n|_ -> buildY()", "bad": "let random = makeRand(5,16) in\nlet _ = build(random,5)", "annotated": "let random = makeRand(5,16) in\nlet _ = build(random,5)"}
{"fix": "let rec build (rand, depth) = \nif depth=0 then buildX() else\nlet randNum = rand 0 5 in\nlet depth = depth - 1 in\nmatch randNum with \n|0 -> buildSine(build(makeRand(5,16), depth))\n|1 -> buildCosine(build(rand, depth))\n|2 -> buildTimes(build(rand, depth),build(rand, depth))\n|3 -> buildAverage(build(rand, depth),build(rand, depth))\n|_ -> buildY()", "bad": "let random = makeRand(5,16) in\nlet _ = build(random,5)", "annotated": "let random = makeRand(5,16) in\nlet _ = build(random,5)"}
{"fix": "let rec build (rand, depth) = \nif depth=0 then buildX() else\nlet randNum = rand 0 5 in\nlet depth = depth - 1 in\nmatch randNum with \n|0 -> buildSine(build(makeRand(5,16), depth))\n|1 -> buildCosine(build(rand, depth))\n|2 -> buildTimes(build(rand, depth),build(rand, depth))\n|3 -> buildAverage(build(rand, depth),build(rand, depth))\n|_ -> buildY()", "bad": "let random = makeRand(5,16) in\nlet _ = build(random,5)", "annotated": "let random = makeRand(5,16) in\nlet _ = build(random,5)"}
{"fix": "let rec build (rand, depth) = \nif depth=0 then buildX() else\nlet randNum = rand 0 5 in\nlet depth = depth - 1 in\nmatch randNum with \n|0 -> buildSine(build(makeRand(5,16), depth))\n|1 -> buildCosine(build(rand, depth))\n|2 -> buildTimes(build(rand, depth),build(rand, depth))\n|3 -> buildAverage(build(rand, depth),build(rand, depth))\n|_ -> buildY()", "bad": "let random = makeRand(5,16) in\nbuild(random,5)", "annotated": "let random = makeRand(5,16) in\nbuild(random,5)"}
{"fix": "let rec build (rand, depth) = \nif depth=0 then buildX() else\nlet randNum = rand 0 5 in\nlet depth = depth - 1 in\nmatch randNum with \n|0 -> buildSine(build(makeRand(5,16), depth))\n|1 -> buildCosine(build(rand, depth))\n|2 -> buildTimes(build(rand, depth),build(rand, depth))\n|3 -> buildAverage(build(rand, depth),build(rand, depth))\n|_ -> buildY()", "bad": "Let _ = let random = makeRand(5,16) in\nbuild(random,5)", "annotated": "Let _ = let random = makeRand(5,16) in\nbuild(random,5)"}
{"fix": "let rec build (rand, depth) = \nif depth=0 then buildX() else\nlet randNum = rand 0 5 in\nlet depth = depth - 1 in\nmatch randNum with \n|0 -> buildSine(build(makeRand(5,16), depth))\n|1 -> buildCosine(build(rand, depth))\n|2 -> buildTimes(build(rand, depth),build(rand, depth))\n|3 -> buildAverage(build(rand, depth),build(rand, depth))\n|_ -> buildY()", "bad": "let _ = let random = makeRand(5,16) in\nbuild(random,5)", "annotated": "let _ = let random = makeRand(5,16) in\nbuild(random,5)"}
{"fix": "let rec build (rand, depth) = \nif depth=0 then buildX() else\nlet randNum = rand 0 5 in\nlet depth = depth - 1 in\nmatch randNum with \n|0 -> buildSine(build(makeRand(5,16), depth))\n|1 -> buildCosine(build(rand, depth))\n|2 -> buildTimes(build(rand, depth),build(rand, depth))\n|3 -> buildAverage(build(rand, depth),build(rand, depth))\n|_ -> buildY()", "bad": "let rec build (rand, depth) = \nif depth=0 then buildX() else\nlet randNum = rand 0 5 in\nlet depth = depth - 1 in\nmatch randNum with \n|0 -> buildSine(build(rand, depth))\n|1 -> buildCosine(build(rand, depth))\n|2 -> buildTimes(build(rand, depth),build(rand, depth))\n|3 -> buildAverage(build(rand, depth),build(rand, depth))\n|_ -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth=0 then buildX() else\nlet randNum = rand 0 5 in\nlet depth = depth - 1 in\nmatch randNum with \n|0 -> buildSine(build(rand, depth))\n|1 -> buildCosine(build(rand, depth))\n|2 -> buildTimes(build(rand, depth),build(rand, depth))\n|3 -> buildAverage(build(rand, depth),build(rand, depth))\n|_ -> buildY()"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d", "bad": "let rec build (rand, depth) = \nif depth=0 then buildX() else\nlet randNum = rand 0 5 in\nlet depth = depth - 1 in\nmatch randNum with \n|0 -> buildSine(build(makeRand(5,16), depth))\n|1 -> buildCosine(build(makeRand(5,16), depth))\n|2 -> buildTimes(build(makeRand(5,16), depth),build(makeRand(5,16), depth))\n|3 -> buildAverage(build(makeRand(5,16), depth),build(makeRand(5,16), depth))\n|_ -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth=0 then buildX() else\nlet randNum = rand 0 5 in\nlet depth = depth - 1 in\nmatch randNum with \n|0 -> buildSine(build(makeRand(5,16), depth))\n|1 -> buildCosine(build(makeRand(5,16), depth))\n|2 -> buildTimes(build(makeRand(5,16), depth),build(makeRand(5,16), depth))\n|3 -> buildAverage(build(makeRand(5,16), depth),build(makeRand(5,16), depth))\n|_ -> buildY()"}
{"fix": "let rec exprToString ex = \nmatch ex with \n|VarX -> \"x\"\n|VarY -> \"y\"\n|Sine(e) -> \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) -> \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) -> \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) -> exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"\n|MyExpr1 (e1,e2,e3) -> \"(sqrt(\"^exprToString e1^\")*sqrt(\"^exprToString e2^\")*\"^exprToString e3^\")\"\n|MyExpr2 (e) -> \"halve(\"^exprToString^\")\"", "bad": "let rec exprToString ex = \nmatch ex with \n|VarX -> \"x\"\n|VarY -> \"y\"\n|Sine(e) -> \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) -> \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) -> \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) -> exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"\n|MyExpr1 (e1,e2,e3) -> \"(sqrt(\"^exprToString e1^\")*sqrt(\"^exprToString e2^\")*\"^exprToString e3^\")\"", "annotated": "let rec exprToString : expr -> string = fun  ex  ->  \nmatch ex with \n|VarX -> \"x\"\n|VarY -> \"y\"\n|Sine(e) -> \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) -> \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) -> \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) -> exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"\n|MyExpr1 (e1,e2,e3) -> \"(sqrt(\"^exprToString e1^\")*sqrt(\"^exprToString e2^\")*\"^exprToString e3^\")\""}
{"fix": "let sampleExpr1 = MyExpr2(MyExpr1(Varx,VarY,Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))))", "bad": "let rec exprToString ex = \nmatch ex with \n|VarX -> \"x\"\n|VarY -> \"y\"\n|Sine(e) -> \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) -> \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) -> \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) -> exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"\n|MyExpr1 (e1,e2,e3) -> \"(sqrt(\"^exprToString e1^\")*sqrt(\"^exprToString e2^\")*\"^exprToString e3^\")\"\n|MyExpr2 (e) -> \"halve(\"^exprToString e^\")\"", "annotated": "let rec exprToString : expr -> string = fun  ex  ->  \nmatch ex with \n|VarX -> \"x\"\n|VarY -> \"y\"\n|Sine(e) -> \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) -> \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) -> \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) -> exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"\n|MyExpr1 (e1,e2,e3) -> \"(sqrt(\"^exprToString e1^\")*sqrt(\"^exprToString e2^\")*\"^exprToString e3^\")\"\n|MyExpr2 (e) -> \"halve(\"^exprToString e^\")\""}
{"fix": "let rec eval (e,x,y) = \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)\n|MyExpr1(e1,e2,e3) -> cos(pi*.eval (e1,x,y))*.sin(pi*.eval (e2,x,y))*.eval(e3,x,y)\n|MyExpr2(e) -> sin(pi*.eval (e,x,y)*.0.5)", "bad": "let rec eval (e,x,y) = \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)\n|MyExpr1(e1,e2,e3) -> cos(pi*.eval (e1,x,y))*.sin(pi*.eval (e2,x,y))*.eval(e3,x,y)\n|MyExpr2(e) -> Sine(eval (e,x,y)*.0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)\n|MyExpr1(e1,e2,e3) -> cos(pi*.eval (e1,x,y))*.sin(pi*.eval (e2,x,y))*.eval(e3,x,y)\n|MyExpr2(e) -> Sine(eval (e,x,y)*.0.5)"}
{"fix": "let rec eval (e,x,y) = \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)\n|MyExpr1(e1,e2,e3) -> cos(pi*.eval (e1,x,y))*.sin(pi*.eval (e2,x,y))*.eval(e3,x,y)\n|MyExpr2(e) -> sin(pi*.eval (e,x,y)*.0.5)", "bad": "let rec eval (e,x,y) = \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)\n|MyExpr1(e1,e2,e3) -> cos(pi*.eval (e1,x,y))*.sin(pi*.eval (e2,x,y))*.eval(e3,x,y)\n|MyExpr2(e) -> sin(pi*.eval (e,x,y)*.0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)\n|MyExpr1(e1,e2,e3) -> cos(pi*.eval (e1,x,y))*.sin(pi*.eval (e2,x,y))*.eval(e3,x,y)\n|MyExpr2(e) -> sin(pi*.eval (e,x,y)*.0.5)"}
{"fix": "let sqsum xs = \nlet f a x = a + x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = ( +. ) in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = ( +. ) in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a + x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = ( +. ) in\nlet base = 0. in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = ( +. ) in\nlet base = 0. in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a + x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = ( +. ) in\nlet base = 0. in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = ( +. ) in\nlet base = 0. in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a + x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = ( + ) in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = ( + ) in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let pipe fs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = List.map f x in\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = List.map f x in\nlet base = 0 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = List.map x in\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = List.map x in\nlet base = 0 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = List.map x -> x in\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = List.map x -> x in\nlet base = 0 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = List.map x in\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = List.map x in\nlet base = 0 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = List.map x in\nlet base = 3 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = List.map x in\nlet base = 3 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = x a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = x a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x in\nlet base = x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x in\nlet base = x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x in\nlet base = x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x in\nlet base = x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fs in\nlet base = fs in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = fs in\nlet base = fs in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x in\nlet base = x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x in\nlet base = x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fs in\nlet base = fs in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = base in\nlet base = base in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = base in\nlet base = base in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fs in\nlet base = fs in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = base in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = base in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fs in\nlet base = fs in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = f x a in\nlet base = f x a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = f x a in\nlet base = f x a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fs in\nlet base = fs in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = f x a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = f x a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fs in\nlet base = fs in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a' in\nlet base = a' in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a' in\nlet base = a' in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x -> x  in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = fun x -> x  in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = f a x in\nlet base = 3 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = f a x in\nlet base = 3 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x -> x  in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = pipe a x in\nlet base = 3 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = pipe a x in\nlet base = 3 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x -> x  in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = pipe a x in\nlet base = 3 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = pipe a x in\nlet base = 3 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x -> x  in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = pipe fs in\nlet base = 3 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = pipe fs in\nlet base = 3 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x -> x  in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = pipe base  in\nlet base = 3 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = pipe base  in\nlet base = 3 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x -> x  in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = pipe fs  in\nlet base = 3 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = pipe fs  in\nlet base = 3 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x  in\nlet base = fun a -> a in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x  in\nlet base = fun a -> a in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a -> x  in\nlet base = fun a -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a -> x  in\nlet base = fun a -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a -> a  in\nlet base = fun a -> a in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x  in\nlet base = fun a -> a in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a -> x  in\nlet base = fun a -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a -> x  in\nlet base = fun a -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = pipe [] in\nlet base = pipe [] in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = pipe [] in\nlet base = pipe [] in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = pipe [] in\nlet base = pipe [] in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = pipe [] in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = pipe [] in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = pipe [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x -> a in\nlet base = pipe [] in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x -> a in\nlet base = pipe [] in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = pipe [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a -> x in\nlet base = pipe [] in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a -> x in\nlet base = pipe [] in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = pipe [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x -> a in\nlet base = pipe [] in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x -> a in\nlet base = pipe [] in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = pipe [] in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = pipe [] in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = pipe [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x a in\nlet base = pipe [] in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x a in\nlet base = pipe [] in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = pipe [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = pipe [] in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = pipe [] in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = x a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = x a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fs in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fs in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x a-> a in\nlet base = fun p -> p in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = fun p -> p in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = fun p -> p in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x a-> a in\nlet base = fun p -> p in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x a-> a in\nlet base = fun p -> p in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x a-> x in\nlet base = fun p -> p in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x a-> x in\nlet base = fun p -> p in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun x a -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun d x -> g in\nlet base = fun p -> p in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun d x -> g in\nlet base = fun p -> p in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x a -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun d x -> a in\nlet base = fun p -> p in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun d x -> a in\nlet base = fun p -> p in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x a -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x a -> d in\nlet base = fun p -> p in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x a -> d in\nlet base = fun p -> p in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x a -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x a -> fun x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x a -> fun x a in\nlet base = fun p -> p in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x a -> x a in\nlet base = pipe [] in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = fun x a -> x a in\nlet base = pipe [] in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun x a -> fun d -> d in\nlet base = fun p -> p in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = fun a x -> fun d -> d", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a x -> fun d -> d"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let base = fun p -> p in\nList.fold_left f base fs", "annotated": "let base = fun p -> p in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = x a", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let base = fun p -> p in\nList.fold_left f base fs", "annotated": "let base = fun p -> p in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = a x", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let base = fun p -> p in\nList.fold_left f base fs", "annotated": "let base = fun p -> p in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = fun a x -> a x", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a x -> a x"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let base = fun p -> p in\nList.fold_left f base fs", "annotated": "let base = fun p -> p in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = a x", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let base = fun p -> p in\nList.fold_left f base fs", "annotated": "let base = fun p -> p in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = a x", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let base = (fun p -> p) in\nList.fold_left f base fs", "annotated": "let base = (fun p -> p) in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = fun p -> p", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun p -> p"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let base = pipe [] in\nList.fold_left f base fs", "annotated": "let base = pipe [] in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = fun p -> p", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun p -> p"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let base = pipe [] in\nList.fold_left f base fs", "annotated": "let base = pipe [] in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = x", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let base = pipe [] in\nList.fold_left f base fs", "annotated": "let base = pipe [] in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = a", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let base = pipe [] in\nList.fold_left f base fs", "annotated": "let base = pipe [] in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let base = pipe [] in\nList.fold_left f base fs", "annotated": "let base = pipe [] in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let base = pipe [] in\nList.fold_left f base fs", "annotated": "let base = pipe [] in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a x -> a x", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a x -> a x"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let base = fun d -> d in\nList.fold_left f base fs", "annotated": "let base = fun d -> d in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a x -> x a", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a x -> x a"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let base = fun d -> d in\nList.fold_left f base fs", "annotated": "let base = fun d -> d in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x a", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x a"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let base = fun d -> d in\nList.fold_left f base fs", "annotated": "let base = fun d -> d in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a x", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a x"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let base = fun d -> d in\nList.fold_left f base fs", "annotated": "let base = fun d -> d in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun d -> x a", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun d -> x a"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let base = fun d -> d in\nList.fold_left f base fs", "annotated": "let base = fun d -> d in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun d -> a x", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun d -> a x"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let base = fun d -> d in\nList.fold_left f base fs", "annotated": "let base = fun d -> d in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun p -> a x", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun p -> a x"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let base = fun d -> d in\nList.fold_left f base fs", "annotated": "let base = fun d -> d in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let base = fun d -> d in\nList.fold_left f base fs", "annotated": "let base = fun d -> d in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = fun d -> d in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = fun d -> d in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a x -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a x -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a x -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun b a x -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = fun b a x -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun b a x -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = fun x -> x in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x -> x in\nlet base = fun d -> d in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x -> x in\nlet base = fun d -> d in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a  in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x a -> fun x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x a -> fun x a in\nlet base = fun d -> d in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a  in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x a -> fun d in\nlet base = fun d -> d in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x a -> fun d in\nlet base = fun d -> d in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun d -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x a -> fun x in\nlet base = fun d -> d in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x a -> fun x in\nlet base = fun d -> d in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a ->  x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a -> fun x -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a -> fun x -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a ->  x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a -> fun x -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a -> fun x -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x ->  a x in\nlet base = fun d-> d in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = fun x ->  a x in\nlet base = fun d-> d in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun x ->  a x in\nlet base = fun d-> d in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun p a -> a x  in\nlet base = fun d-> d in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = fun p a -> a x  in\nlet base = fun d-> d in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun p a -> a x  in\nlet base = fun d-> d in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun a x -> x in\nlet base = fun d-> d in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = fun a x -> x in\nlet base = fun d-> d in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun a x -> x in\nlet base = fun d-> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a x  in\nlet base = fun d-> d in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a x  in\nlet base = fun d-> d in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a -> a in\nlet base = fun d-> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a x -> a in\nlet base = fun d-> d in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a x -> a in\nlet base = fun d-> d in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun d ->  x a in\nlet base = fun d-> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun d -> a in\nlet base = fun d-> d in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun d -> a in\nlet base = fun d-> d in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun p -> fun s a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = fun d -> d in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = fun d -> d in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun p -> fun s a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun d x -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun d x -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun p -> fun s a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun p -> fun s a x -> a x", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun p -> fun s a x -> a x"}
{"fix": "let pipe fs = \nlet f a x = fun p -> fun s a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let base = fun d -> d in\nList.fold_left f base fs", "annotated": "let base = fun d -> d in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun p -> fun s a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun p -> fun s a x -> x a", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun p -> fun s a x -> x a"}
{"fix": "let pipe fs = \nlet f a x = fun p -> fun s a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let base = fun d -> d in\nList.fold_left f base fs", "annotated": "let base = fun d -> d in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun p -> fun s a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun p -> fun s a -> x a", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun p -> fun s a -> x a"}
{"fix": "let pipe fs = \nlet f a x = fun p -> fun s a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let base = fun d -> d in\nList.fold_left f base fs", "annotated": "let base = fun d -> d in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun p -> fun s a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun p -> fun s a -> x a", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun p -> fun s a -> x a"}
{"fix": "let pipe fs = \nlet f a x = fun p -> fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = fun p -> fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun b (fun a -> x a) -> b in\nlet base = fun d -> d in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun b (fun a -> x a) -> b in\nlet base = fun d -> d in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun b (a -> x a) -> b in\nlet base = fun d -> d in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun b (a -> x a) -> b in\nlet base = fun d -> d in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a -> a x in\nlet base = fun d -> d in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a d -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a x -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a x -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a -> fun x -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a -> fun x -> x a in\nlet base = fun d -> d in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x  in\nlet base = fun p -> p in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x  in\nlet base = let p -> p in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x  in\nlet base = let p -> p in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x  in\nlet base = fun p -> p in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x  in\nlet base = fun p -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x  in\nlet base = fun p -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x  in\nlet base = fun p -> p in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x  in\nlet base = fun p -> p in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x  in\nlet base = fun p -> p in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x  in\nlet base = fun p -> p in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x  in\nlet base = fun p -> p in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x  in\nlet base = fun p -> p in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun x -> x in\nlet base = fun p -> p in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x -> a in\nlet base = fun p -> p in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x -> a in\nlet base = fun p -> p in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x in\nlet base = fun p -> p in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = List.rev x in\nlet base = fun p -> p in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = List.rev x in\nlet base = fun p -> p in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)", "bad": "let pipe fs = \nlet f a x = x in\nlet base = fun p -> p in\nList.fold_left f base List.rev fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x in\nlet base = fun p -> p in\nList.fold_left f base List.rev fs"}
{"fix": "let pipe fs = \nlet f a x = x in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)", "bad": "let pipe fs = \nlet f a x = x in\nlet base = fun p -> p in\nList.fold_left f base List.rev fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x in\nlet base = fun p -> p in\nList.fold_left f base List.rev fs"}
{"fix": "let pipe fs = \nlet f a x = x in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)", "bad": "let pipe fs = \nlet f a x = x in fun x-> x in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x in fun x-> x in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)"}
{"fix": "let pipe fs = \nlet f a x = x a  in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)", "bad": "let pipe fs = \nlet f a x = x fs in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x fs in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)"}
{"fix": "let pipe fs = \nlet f a x = fun d-> x a d in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)", "bad": "let pipe fs = \nlet f a x = fun d-> a x d in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun d-> a x d in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)"}
{"fix": "let pipe fs = \nlet f a x = x in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)", "bad": "let pipe fs = \nlet f a x = x in\nlet base = fun p -> x p in\nList.fold_left f base (List.rev fs)", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x in\nlet base = fun p -> x p in\nList.fold_left f base (List.rev fs)"}
{"fix": "let pipe fs = \nlet f a x = x in\nlet base = fun p -> p in\nList.fold_left f base (List.rev fs)", "bad": "let pipe fs = \nlet f a x = x in\nlet base = fun p ->a  p in\nList.fold_left f base (List.rev fs)", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x in\nlet base = fun p ->a  p in\nList.fold_left f base (List.rev fs)"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun a' -> a' in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = fun a' -> a' in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = fun a' -> a' in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun a' -> a' in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (a x) in\nlet base = fun a' -> a' in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (a x) in\nlet base = fun a' -> a' in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun p' -> a x  in\nlet base = fun a' -> a' in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun p' -> a  in\nlet base = fun a' -> a' in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun p' -> a  in\nlet base = fun a' -> a' in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =  fun p -> a x in\nlet base = pipe [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  a x in\nlet base = pipe [] in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  a x in\nlet base = pipe [] in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun p -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =   in\nlet base = p -> p in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =   in\nlet base = p -> p in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun p -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun p -> a x in\nlet base = p -> p in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun p -> a x in\nlet base = p -> p in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun p -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun p -> x a in\nlet base = p -> p in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun p -> x a in\nlet base = p -> p in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun l -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun l -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun l -> fun x -> a in\nlet base = fun p -> p in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun l -> fun x -> a in\nlet base = fun p -> p in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun l -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun l -> fun x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun l -> fun x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun l -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun l -> fun x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun l -> fun x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun l -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun l -> fun x -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun l -> fun x -> x a in\nlet base = fun p -> p in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun l -> x (a l) in\nlet base = fun p -> p in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun l -> l(x a) in\nlet base = fun p -> p in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun l -> l(x a) in\nlet base = fun p -> p in\nList.fold_left f base fs"}
{"fix": "let stringOfList f l = \"[\"^ sepConcat \"; \" (List.map f l) ^\"]\"", "bad": "let stringOfList f l = List.map f (sepConcat l);\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6]", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map f (sepConcat l);\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6]"}
{"fix": "let stringOfList f l = \"[\"^ sepConcat \"; \" (List.map f l) ^\"]\"", "bad": "let stringOfList f l = \"[\"^ List.map f (sepConcat l) ^\"]\";\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6]", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\"^ List.map f (sepConcat l) ^\"]\";\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6]"}
{"fix": "let stringOfList f l = \"[\"^ sepConcat \"; \" (List.map f l) ^\"]\"", "bad": "let stringOfList f l = \"[\"^ List.map f (sepConcat l) ^\"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\"^ List.map f (sepConcat l) ^\"]\""}
{"fix": "let stringOfList f l = \"[\"^ sepConcat \"; \" (List.map f l) ^\"]\"", "bad": "let stringOfList f l = \"[\"^ List.map f (sepConcat \"; \" l) ^\"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\"^ List.map f (sepConcat \"; \" l) ^\"]\""}
{"fix": "let rec clone x n = \nif n < 1 then \n[]\nelse \nx::(clone x (n-1))", "bad": "let rec clone x n = \nif n > 0 then \nx @ clone x n-1\nelse \n[]", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif n > 0 then \nx @ clone x n-1\nelse \n[]"}
{"fix": "let rec clone x n = \nif n < 1 then \n[]\nelse \nx::(clone x (n-1))", "bad": "let rec clone x n = \nif n > 0 then \nx @ (clone x n-1)\nelse \n[]", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif n > 0 then \nx @ (clone x n-1)\nelse \n[]"}
{"fix": "let rec clone x n = \nif n < 1 then \n[]\nelse \nx::(clone x (n-1))", "bad": "let rec clone x n = \nif n < 1 then \n[]\nelse \nx::(clone x n-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif n < 1 then \n[]\nelse \nx::(clone x n-1)"}
{"fix": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet x = List.length l1 - List.length l2 in \nlet list_p = clone 0 x in \n(l1,list_p@l2)\nelse if List.length l1 < List.length l2 then\nlet x = List.length l2 - List.length l1 in \nlet list_p = clone 0 x in \n(list_p@l1,l2)\nelse\n(l1,l2)", "bad": "let padZero l1 l2 = \nif List.length l1 == List.length l2 then\n(l1)@(l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 == List.length l2 then\n(l1)@(l2)"}
{"fix": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet x = List.length l1 - List.length l2 in \nlet list_p = clone 0 x in \n(l1,list_p@l2)\nelse if List.length l1 < List.length l2 then\nlet x = List.length l2 - List.length l1 in \nlet list_p = clone 0 x in \n(list_p@l1,l2)\nelse\n(l1,l2)", "bad": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then\nl1 @ l2", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 = List.length l2 then\nl1 @ l2"}
{"fix": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet x = List.length l1 - List.length l2 in \nlet list_p = clone 0 x in \n(l1,list_p@l2)\nelse if List.length l1 < List.length l2 then\nlet x = List.length l2 - List.length l1 in \nlet list_p = clone 0 x in \n(list_p@l1,l2)\nelse\n(l1,l2)", "bad": "let padZero l1 l2 = \nif List.length l1 == List.length l2 then\nl1 @ l2", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 == List.length l2 then\nl1 @ l2"}
{"fix": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet x = List.length l1 - List.length l2 in \nlet list_p = clone 0 x in \n(l1,list_p@l2)\nelse if List.length l1 < List.length l2 then\nlet x = List.length l2 - List.length l1 in \nlet list_p = clone 0 x in \n(list_p@l1,l2)\nelse\n(l1,l2)", "bad": "let padZero l1 l2 = \nif List.length l1 == List.length l2 then\n(l1 @ l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 == List.length l2 then\n(l1 @ l2)"}
{"fix": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet x = List.length l1 - List.length l2 in \nlet list_p = clone 0 x in \n(l1,list_p@l2)\nelse if List.length l1 < List.length l2 then\nlet x = List.length l2 - List.length l1 in \nlet list_p = clone 0 x in \n(list_p@l1,l2)\nelse\n(l1,l2)", "bad": "let padZero l1 l2 = \nif List.l1 > List.l2 then\nlet x = List.l1 - List.l2 in \nlet list_p = clone 0 x in \n(l1,list_p@l2)\nelse if List.l1 < List.l2 then\nlet x = List.l2 - List.l1 in \nlet list_p = clone 0 x in \n(list_p@l1,l2)\nelse\n(l1,l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.l1 > List.l2 then\nlet x = List.l1 - List.l2 in \nlet list_p = clone 0 x in \n(l1,list_p@l2)\nelse if List.l1 < List.l2 then\nlet x = List.l2 - List.l1 in \nlet list_p = clone 0 x in \n(list_p@l1,l2)\nelse\n(l1,l2)"}
{"fix": "let rec removeZero l = match l with\n| [] -> []\n| h::t ->\nif h == 0 then \nremoveZero t\nelse \nl", "bad": "let rec removeZero l = match l with\n| [] = []\n| h::t = \nif h == 0 then \nremoveZero t\nelse \nl", "annotated": "let rec removeZero : int list -> int list = fun  l  ->  match l with\n| [] = []\n| h::t = \nif h == 0 then \nremoveZero t\nelse \nl"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then (1, listy @ (initsum % 10))\nelse (0,listy@initsum)", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then (1, listy @ (initsum % 10))\nelse (0,listy@initsum)", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then (1, listy @ (initsum % 10))\nelse (0,listy@initsum)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then (1, listy @ (initsum % 10))\nelse (0,listy@initsum)", "bad": "let base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then \n(1, listy @ [initsum mod 10])\nelse \n(0,listy @ [initsum]) in\nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then (1, listy @ (initsum % 10))\nelse (0,listy @ initsum)", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then (1, listy @ (initsum % 10))\nelse (0,listy @ initsum)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then \n(1, listy @ [initsum mod 10])\nelse \n(0,listy @ [initsum]) in\nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then (1, listy @ (initsum % 10))\nelse (0,listy @ initsum)", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then (1, listy @ (initsum % 10))\nelse (0,listy @ initsum)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then \n(1, listy @ [initsum mod 10])\nelse \n(0,listy @ [initsum]) in\nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then (1, listy @ [initsum mod 10])\nelse (0,listy @ initsum)", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then (1, listy @ [initsum mod 10])\nelse (0,listy @ initsum)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then \n(1, listy @ [initsum mod 10])\nelse \n(0,listy @ [initsum]) in\nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then \n(1, listy @ [initsum mod 10])\nelse \n(0,listy @ [initsum]) in\nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then (1, listy @ [initsum mod 10])\nelse (0,listy @ [initsum])", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then (1, listy @ [initsum mod 10])\nelse (0,listy @ [initsum])"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then \n(1, listy @ [initsum mod 10])\nelse \n(0,listy @ [initsum]) in\nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then \n(1, listy @ [initsum mod 10])\nelse \n(0,listy @ [initsum]) in\nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then (1, listy @ [initsum mod 10])\nelse (0,listy @ [initsum])", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then (1, listy @ [initsum mod 10])\nelse (0,listy @ [initsum])"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then \n(1, listy @ [initsum mod 10])\nelse \n(0,listy @ [initsum]) in\nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then \n(1, listy @ [initsum mod 10])\nelse \n(0,listy @ [initsum]) in\nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then (1, listy @ [initsum mod 10])\nelse (0,listy @ initsum)", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then (1, listy @ [initsum mod 10])\nelse (0,listy @ initsum)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then \n(1, listy @ [initsum mod 10])\nelse \n(0,listy @ [initsum]) in\nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then \n(1, listy @ [initsum mod 10])\nelse \n(0,listy @ [initsum]) in\nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then \n(1, listy @ [initsum mod 10])\nelse \n(0,listy @ initsum) in\nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (carry, listy) = a in\nlet (num1, num2) = x in\nlet initsum = num1 + num2 + carry in\nif initsum > 9 then \n(1, listy @ [initsum mod 10])\nelse \n(0,listy @ initsum) in\nlet base = (0,[]) in\nlet args =  List.rev(List.combine l1 l2) @ [(0,0)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> \nlet initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-intKeep) mod 100 in\nlet v = List.rev(t) in \nhelpy p v carrying accList@[intKeep] in\nremoveZero(List.rev(helpy i l 0 [0;0]))", "bad": "let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numList with\n|[] -> accList\n|h::t -> let initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-initKeep) mod 100 in\nhelpy p List.rev(t) carrying accList@initKeep in\nremoveZero(list.rev(helpy i l 0 [0,0]))", "annotated": "let mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numList with\n|[] -> accList\n|h::t -> let initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-initKeep) mod 100 in\nhelpy p List.rev(t) carrying accList@initKeep in\nremoveZero(list.rev(helpy i l 0 [0,0]))"}
{"fix": "let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> \nlet initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-intKeep) mod 100 in\nlet v = List.rev(t) in \nhelpy p v carrying accList@[intKeep] in\nremoveZero(List.rev(helpy i l 0 [0;0]))", "bad": "let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> let initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-initKeep) mod 100 in\nhelpy p List.rev(t) carrying accList@initKeep in\nremoveZero(list.rev(helpy i l 0 [0,0]))", "annotated": "let mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> let initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-initKeep) mod 100 in\nhelpy p List.rev(t) carrying accList@initKeep in\nremoveZero(list.rev(helpy i l 0 [0,0]))"}
{"fix": "let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> \nlet initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-intKeep) mod 100 in\nlet v = List.rev(t) in \nhelpy p v carrying accList@[intKeep] in\nremoveZero(List.rev(helpy i l 0 [0;0]))", "bad": "let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> let initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-intKeep) mod 100 in\nhelpy p List.rev(t) carrying accList@initKeep in\nremoveZero(list.rev(helpy i l 0 [0,0]))", "annotated": "let mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> let initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-intKeep) mod 100 in\nhelpy p List.rev(t) carrying accList@initKeep in\nremoveZero(list.rev(helpy i l 0 [0,0]))"}
{"fix": "let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> \nlet initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-intKeep) mod 100 in\nlet v = List.rev(t) in \nhelpy p v carrying accList@[intKeep] in\nremoveZero(List.rev(helpy i l 0 [0;0]))", "bad": "let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> \nlet initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-intKeep) mod 100 in\nlet v = List.rev(t) in \nhelpy p v carrying accList@initKeep in\nremoveZero(list.rev(helpy i l 0 [0,0]))", "annotated": "let mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> \nlet initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-intKeep) mod 100 in\nlet v = List.rev(t) in \nhelpy p v carrying accList@initKeep in\nremoveZero(list.rev(helpy i l 0 [0,0]))"}
{"fix": "let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> \nlet initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-intKeep) mod 100 in\nlet v = List.rev(t) in \nhelpy p v carrying accList@[intKeep] in\nremoveZero(List.rev(helpy i l 0 [0;0]))", "bad": "let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> \nlet initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-intKeep) mod 100 in\nlet v = List.rev(t) in \nhelpy p v carrying accList@intKeep in\nremoveZero(list.rev(helpy i l 0 [0,0]))", "annotated": "let mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> \nlet initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-intKeep) mod 100 in\nlet v = List.rev(t) in \nhelpy p v carrying accList@intKeep in\nremoveZero(list.rev(helpy i l 0 [0,0]))"}
{"fix": "let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> \nlet initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-intKeep) mod 100 in\nlet v = List.rev(t) in \nhelpy p v carrying accList@[intKeep] in\nremoveZero(List.rev(helpy i l 0 [0;0]))", "bad": "let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> \nlet initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-intKeep) mod 100 in\nlet v = List.rev(t) in \nhelpy p v carrying accList@[intKeep] in\nremoveZero(list.rev(helpy i l 0 [0,0]))", "annotated": "let mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> \nlet initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-intKeep) mod 100 in\nlet v = List.rev(t) in \nhelpy p v carrying accList@[intKeep] in\nremoveZero(list.rev(helpy i l 0 [0,0]))"}
{"fix": "let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> \nlet initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-intKeep) mod 100 in\nlet v = List.rev(t) in \nhelpy p v carrying accList@[intKeep] in\nremoveZero(List.rev(helpy i l 0 [0;0]))", "bad": "let mulByDigit i l = \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> \nlet initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-intKeep) mod 100 in\nlet v = List.rev(t) in \nhelpy p v carrying accList@[intKeep] in\nremoveZero(List.rev(helpy i l 0 [0,0]))", "annotated": "let mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet rec helpy p q carry accList = \nlet numsList = List.rev(q) in match numsList with\n|[] -> accList\n|h::t -> \nlet initMul = (h*p) + carry in\nlet intKeep = initMul mod 10 in\nlet carrying = (initMul-intKeep) mod 100 in\nlet v = List.rev(t) in \nhelpy p v carrying accList@[intKeep] in\nremoveZero(List.rev(helpy i l 0 [0,0]))"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet (upper_mult, total) = a in\nlet newTotal = mulByDigit x upper_mult in\nlet updateTotal = bigAdd newTotal total in\n(upper_mult@[0],updateTotal) in\nlet base = (l1,[]) in\nlet args =  l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = in\nlet base =  in\nlet args =  in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = in\nlet base =  in\nlet args =  in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet (upper_mult, total) = a in\nlet newTotal = mulByDigit x upper_mult in\nlet updateTotal = bigAdd newTotal total in\n(upper_mult@[0],updateTotal) in\nlet base = (l1,[]) in\nlet args =  l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet (bottom_mult, total) = a in match a with\n|[] -> total\n|h::t -> \nlet newTotal = mulByDigit h x in\nlet updateTotal = bigAdd newTotal updateTotal in\n(t,updateTotal)", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet (bottom_mult, total) = a in match a with\n|[] -> total\n|h::t -> \nlet newTotal = mulByDigit h x in\nlet updateTotal = bigAdd newTotal updateTotal in\n(t,updateTotal)"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet (upper_mult, total) = a in\nlet newTotal = mulByDigit x upper_mult in\nlet updateTotal = bigAdd newTotal total in\n(upper_mult@[0],updateTotal) in\nlet base = (l1,[]) in\nlet args =  l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let base = (l1,[]) in\nlet args =  l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let base = (l1,[]) in\nlet args =  l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet (upper_mult, total) = a in\nlet newTotal = mulByDigit x upper_mult in\nlet updateTotal = bigAdd newTotal total in\n(upper_mult@[0],updateTotal) in\nlet base = (l1,[]) in\nlet args =  l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet (bottom_mult, total) = a in match bottom_mult with\n|[] -> total\n|h::t -> \nlet newTotal = mulByDigit h x in\nlet updateTotal = bigAdd newTotal updateTotal in\n(t,updateTotal)", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet (bottom_mult, total) = a in match bottom_mult with\n|[] -> total\n|h::t -> \nlet newTotal = mulByDigit h x in\nlet updateTotal = bigAdd newTotal updateTotal in\n(t,updateTotal)"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet (upper_mult, total) = a in\nlet newTotal = mulByDigit x upper_mult in\nlet updateTotal = bigAdd newTotal total in\n(upper_mult@[0],updateTotal) in\nlet base = (l1,[]) in\nlet args =  l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let base = (l1,[]) in\nlet args =  l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let base = (l1,[]) in\nlet args =  l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet (upper_mult, total) = a in\nlet newTotal = mulByDigit x upper_mult in\nlet updateTotal = bigAdd newTotal total in\n(upper_mult@[0],updateTotal) in\nlet base = (l1,[]) in\nlet args =  l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet (bottom_mult, total) = a in match bottom_mult with\n|[] -> total\n|h::t -> \nlet newTotal = mulByDigit h x in\nlet updateTotal = bigAdd newTotal total in\n(t,updateTotal)", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet (bottom_mult, total) = a in match bottom_mult with\n|[] -> total\n|h::t -> \nlet newTotal = mulByDigit h x in\nlet updateTotal = bigAdd newTotal total in\n(t,updateTotal)"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet (upper_mult, total) = a in\nlet newTotal = mulByDigit x upper_mult in\nlet updateTotal = bigAdd newTotal total in\n(upper_mult@[0],updateTotal) in\nlet base = (l1,[]) in\nlet args =  l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet (bottom_mult, total) = a in match bottom_mult with\n|[] -> total\n|h::t -> \nlet newTotal = mulByDigit h x in\nlet updateTotal = bigAdd newTotal total in\n(t,updateTotal) in\nlet base = (l1,[]) in\nlet args =  l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet (bottom_mult, total) = a in match bottom_mult with\n|[] -> total\n|h::t -> \nlet newTotal = mulByDigit h x in\nlet updateTotal = bigAdd newTotal total in\n(t,updateTotal) in\nlet base = (l1,[]) in\nlet args =  l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = fun x -> x a in\nlet base = fun x1->x1 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x -> x a in\nlet base = fun x1->x1 in\nList.fold_left f base fs"}
{"fix": "let stringOfList f l = List.map (f (sepConcat \" \" l))", "bad": "let stringOfList f l = List.map (f (sepconcat \" \" l))", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map (f (sepconcat \" \" l))"}
{"fix": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let stringOfList f l = sepConcat (\" \" List.map(f l))", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat (\" \" List.map(f l))"}
{"fix": "let stringOfList f l = sepConcat \" \" l", "bad": "let stringOfList f l = sepConcat (\" \" List.map(f l))", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat (\" \" List.map(f l))"}
{"fix": "let stringOfList f l = sepConcat \" \" l", "bad": "let stringOfList f l = sepConcat (\" \" (List.map(f l)))", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat (\" \" (List.map(f l)))"}
{"fix": "let rec clone x n = \nif (n <= 0) then []\nelse x::(clone x (n-1))", "bad": "let rec clone x n = \nif (n <= 0) then []\nelse x::(clone x n-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif (n <= 0) then []\nelse x::(clone x n-1)"}
{"fix": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (x,y) -> a::[(x+y) mod 10 in\nlet base = [] in\nlet args = failwith List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (x,y) -> a::[(x+y) mod 10 in\nlet base = [] in\nlet args = failwith List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (x,y) -> a::[(x+y) mod 10] in\nlet base = [] in\nlet args = failwith List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (x,y) -> a::[(x+y) mod 10] in\nlet base = [] in\nlet args = failwith List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (y,z) -> let sum = y+z in\nmatch a with \n| h::t -> ((sum+h)/10)::((sum+h)mod 10)::t\n| [] -> (sum/10)::[(sum mod 10)] in\nlet base = [] in\nlet args = failwith List.combine(l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (y,z) -> let sum = y+z in\nmatch a with \n| h::t -> ((sum+h)/10)::((sum+h)mod 10)::t\n| [] -> (sum/10)::[(sum mod 10)] in\nlet base = [] in\nlet args = failwith List.combine(l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (y,z) -> let sum = y+z in\nmatch a with \n| h::t -> ((sum+h)/10)::((sum+h)mod 10)::t\n| [] -> (sum/10)::[(sum mod 10)] in\nlet base = [] in\nlet args = List.combine(l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (y,z) -> let sum = y+z in\nmatch a with \n| h::t -> ((sum+h)/10)::((sum+h)mod 10)::t\n| [] -> (sum/10)::[(sum mod 10)] in\nlet base = [] in\nlet args = List.combine(l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (y,z) -> let sum = y+z in\nmatch a with \n| h::t -> ((sum+h)/10)::((sum+h)mod 10)::t\n| _ -> (sum/10)::[(sum mod 10)] in\nlet base = [] in\nlet args = List.rev(List.combine l1 l2) in\n(*let (_, res) =*) List.fold_left f base args (*in\nres*)\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (y,z) -> let sum = y+z in\nmatch a with \n| h::t -> ((sum+h)/10)::((sum+h)mod 10)::t\n| _ -> (sum/10)::[(sum mod 10)] in\nlet base = [] in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (y,z) -> let sum = y+z in\nmatch a with \n| h::t -> ((sum+h)/10)::((sum+h)mod 10)::t\n| _ -> (sum/10)::[(sum mod 10)] in\nlet base = [] in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let rec mulByDigit i l =  \nlet f a x = let mult = i*x in\nmatch a with \n|h::t -> ((h+mult)/10)::(h+mult) mod 10::t\n| _ -> mult/10::[mult mod 10] in\nlet base = [] in\nremoveZero (List.fold_left f base (List.rev l))", "bad": "let rec mulByDigit i l = match l with \nlet f a x = let mult = i*x in\nmatch a with \n|h::t -> ((h+mult)/10)::(h+mult) mod 10::t\n| _ -> mult/10::[mult mod 10] in\nlet base = [] in\nremoveZero (List.fold_left f base (List.rev l))", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match l with \nlet f a x = let mult = i*x in\nmatch a with \n|h::t -> ((h+mult)/10)::(h+mult) mod 10::t\n| _ -> mult/10::[mult mod 10] in\nlet base = [] in\nremoveZero (List.fold_left f base (List.rev l))"}
{"fix": "let bigMul l1 l2 = \nlet g =\nlet f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in\nlet base = [] in\nlet args = List.rev l2 in List.fold_left f base args in\nList.fold_left bigAdd [] g", "bad": "let bigMul l1 l2 = \nlet f a x = List.append((mulByDigit x l1) (clone 0 (List.length b)))::b in\nlet base = [] in\nlet args = List.rev l2 in List.fold_left f base args", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = List.append((mulByDigit x l1) (clone 0 (List.length b)))::b in\nlet base = [] in\nlet args = List.rev l2 in List.fold_left f base args"}
{"fix": "let bigMul l1 l2 = \nlet g =\nlet f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in\nlet base = [] in\nlet args = List.rev l2 in List.fold_left f base args in\nList.fold_left bigAdd [] g", "bad": "let bigMul l1 l2 = \nlet g =\nlet f a x = List.append((mulByDigit x l1) (clone 0 (List.length b)))::b in\nlet base = [] in\nlet args = List.rev l2 in List.fold_left f base args in\nList.fold_left bigAdd [] g", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet g =\nlet f a x = List.append((mulByDigit x l1) (clone 0 (List.length b)))::b in\nlet base = [] in\nlet args = List.rev l2 in List.fold_left f base args in\nList.fold_left bigAdd [] g"}
{"fix": "let bigMul l1 l2 = \nlet g =\nlet f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in\nlet base = [] in\nlet args = List.rev l2 in List.fold_left f base args in\nList.fold_left bigAdd [] g", "bad": "let bigMul l1 l2 = \nlet g =\nlet f a x = ((mulByDigit x l1)@(clone 0 (List.length b)))::b in\nlet base = [] in\nlet args = List.rev l2 in List.fold_left f base args in\nList.fold_left bigAdd [] g", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet g =\nlet f a x = ((mulByDigit x l1)@(clone 0 (List.length b)))::b in\nlet base = [] in\nlet args = List.rev l2 in List.fold_left f base args in\nList.fold_left bigAdd [] g"}
{"fix": "let _ = mulByDigit (-9) [9;9;9;9]", "bad": "let _ = mulByDigit -9 [9;9;9;9]", "annotated": "let _ = mulByDigit -9 [9;9;9;9]"}
{"fix": "let bigMul l1 l2 = \nlet f a x = match a with\n|(move,result) -> match x with\n|(fac,dig) -> let prod = mulByDigit dig (fac @ (clone 0 move)) in\n(move +1, bigAdd result prod) in \nlet base = (0,[]) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in \nlet (_,res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = match a with\n|(move,result) -> match x with\n|(fac,dig) -> let prod = mulByDigit dig (fac @ (clone 0 move)) in\n(move +1, bigAdd result prod) in \nlet base = (0,[]) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev 12) in \nlet (_,res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match a with\n|(move,result) -> match x with\n|(fac,dig) -> let prod = mulByDigit dig (fac @ (clone 0 move)) in\n(move +1, bigAdd result prod) in \nlet base = (0,[]) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev 12) in \nlet (_,res) = List.fold_left f base args in\nres"}
{"fix": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "bad": "let rec digitsOfInt n = match n with\nif( h % 2) = 0 \nthen [] \nelse tail", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  match n with\nif( h % 2) = 0 \nthen [] \nelse tail"}
{"fix": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "bad": "let rec digitsOfInt n = \nif( h % 2) = 0 \nthen [] \nelse tail", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif( h % 2) = 0 \nthen [] \nelse tail"}
{"fix": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "bad": "let rec digitsOfInt n = \nif( h mod 2) = 0 \nthen [] \nelse tail", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif( h mod 2) = 0 \nthen [] \nelse tail"}
{"fix": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "bad": "let rec digitsOfInt n = \nif( head mod 2) = 0 \nthen [] \nelse tail", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif( head mod 2) = 0 \nthen [] \nelse tail"}
{"fix": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "bad": "let rec digitsOfInt n = \nif( hd mod 2) = 0 \nthen [] \nelse tl", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif( hd mod 2) = 0 \nthen [] \nelse tl"}
{"fix": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "bad": "let rec digitsOfInt n = match n with\n|if( hd mod 2) = 0 \nthen [] \nelse tl", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  match n with\n|if( hd mod 2) = 0 \nthen [] \nelse tl"}
{"fix": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "bad": "let rec digitsOfInt n = match n with\n|if( n < 0) -> []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  match n with\n|if( n < 0) -> []"}
{"fix": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "bad": "let rec digitsOfInt n = match n with\n|( n < 0) -> []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  match n with\n|( n < 0) -> []"}
{"fix": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "bad": "let rec digitsOfInt n = match n with\n| n < 0 -> []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  match n with\n| n < 0 -> []"}
{"fix": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "bad": "let rec digitsOfInt n = match n with\n| (n < 0) -> []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  match n with\n| (n < 0) -> []"}
{"fix": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "bad": "let rec digitsOfInt n = \nif n < 0 -> []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 -> []"}
{"fix": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "bad": "let rec digitsOfInt n = \nif (n < 0) then []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif (n < 0) then []"}
{"fix": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "bad": "let rec digitsOfInt n = match n with\n| [] -> []\n| h::t -> if (n < 0) then []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  match n with\n| [] -> []\n| h::t -> if (n < 0) then []"}
{"fix": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "bad": "let rec digitsOfInt n = match n with\n| [] -> []\n| _ -> if n < 0 then []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  match n with\n| [] -> []\n| _ -> if n < 0 then []"}
{"fix": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "bad": "let rec digitsOfInt n = match n with\n| _ -> if n < 0 then []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  match n with\n| _ -> if n < 0 then []"}
{"fix": "let digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt(n/10)::[]", "bad": "let digitsOfInt n = \nif n < 0 \nthen []\nelse if n < 10\nthen n:: []\nelse\ndigitsOfInt (n mod 10)", "annotated": "let digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 \nthen []\nelse if n < 10\nthen n:: []\nelse\ndigitsOfInt (n mod 10)"}
{"fix": "let digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt(n/10)::[]", "bad": "let digitsOfInt n = \nif n < 0 \nthen []\nelse if n < 10\nthen n:: []\nelse\ndigitsOfInt (n / 10)", "annotated": "let digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 \nthen []\nelse if n < 10\nthen n:: []\nelse\ndigitsOfInt (n / 10)"}
{"fix": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt (n/10) @ (n mod 10)::[]", "bad": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt (n/10) ::[]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n <= 0 \nthen []\nelse\ndigitsOfInt (n/10) ::[]"}
{"fix": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "bad": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt (n/10)::[]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n <= 0 \nthen []\nelse\ndigitsOfInt (n/10)::[]"}
{"fix": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "bad": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt (n mod 10)::[]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n <= 0 \nthen []\nelse\ndigitsOfInt (n mod 10)::[]"}
{"fix": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "bad": "let rec digitsOfInt n = \nif n <= 0 \nthen []\nelse\ndigitsOfInt (n mod 10)::[]::[]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n <= 0 \nthen []\nelse\ndigitsOfInt (n mod 10)::[]::[]"}
{"fix": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "bad": "let rec digitsOfInt n = \nlet myList = []\nif n <= 0 \nthen []\nelse\ndigitsOfInt (n mod 10)::[]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = []\nif n <= 0 \nthen []\nelse\ndigitsOfInt (n mod 10)::[]"}
{"fix": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif n <= 0 \nthen []\nelse\ndigitsOfInt (n mod 10)::[]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif n <= 0 \nthen []\nelse\ndigitsOfInt (n mod 10)::[]"}
{"fix": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif n <= 0 \nthen []\nelse\ndigitsOfInt n mod 10::[]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif n <= 0 \nthen []\nelse\ndigitsOfInt n mod 10::[]"}
{"fix": "let rec sumList xs = match xs with\n| []-> 0\n| h::t -> h+sumList t", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif n <= 0 \nthen []\nelse\ndigitsOfInt (n mod 10) :: digitsOfInt(n / 10) :: []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif n <= 0 \nthen []\nelse\ndigitsOfInt (n mod 10) :: digitsOfInt(n / 10) :: []"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif n <= 0 \nthen []\nelse\nif n < 10\nthen [n]\nelse\ndigitsOfInt (n/10) @ n mod 10 :: []", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif n <= 0 \nthen []\nelse\nif n < 10\nthen [num]\nelse\ndigitsOfInt (n/10) @ n mod 10 :: []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif n <= 0 \nthen []\nelse\nif n < 10\nthen [num]\nelse\ndigitsOfInt (n/10) @ n mod 10 :: []"}
{"fix": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse(t)", "bad": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse(t) :: l", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n|[] -> [];\n|h::t -> listReverse(t) :: l"}
{"fix": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse(t)", "bad": "let _ = listReverse [1; 2; 3; 4]", "annotated": "let _ = listReverse [1; 2; 3; 4]"}
{"fix": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse t @ [h]", "bad": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> h:: [listReverse t]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n|[] -> [];\n|h::t -> h:: [listReverse t]"}
{"fix": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse t @ [h]", "bad": "let _ = listReverse [1; 2; 3; 4]", "annotated": "let _ = listReverse [1; 2; 3; 4]"}
{"fix": "let _ = digitsOfInt 352663", "bad": "let _ = digitsOfInt 3124", "annotated": "let _ = digitsOfInt 3124"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = x*x in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = failwith \"to be implemented\" in\nlet base = x*x in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = List.fold_left f a x in\nlet base = x*x in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = List.fold_left f a x in\nlet base = x*x in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = List.fold_left f a b in\nlet base = x*x in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = List.fold_left f a b in\nlet base = x*x in\nList.fold_left f base xs"}
{"fix": "let pipe fs = \nlet f a x = function g -> a x in\nlet base = function x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a (x) in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a (x) in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = function g -> a x in\nlet base = function x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a (x) in\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a (x) in\nlet base = 0 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = function g -> a x in\nlet base = function x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a (x) in\nlet base = a(0) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a (x) in\nlet base = a(0) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = function g -> a x in\nlet base = function x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a (x) in\nlet base = fs in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a (x) in\nlet base = fs in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = function g -> a x in\nlet base = function x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a (x) in\nlet base = match base with\n|0 -> 0\n|_ -> fs in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a (x) in\nlet base = match base with\n|0 -> 0\n|_ -> fs in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = function g -> a x in\nlet base = function x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a (x) in\nlet base = match x with\n|0 -> 0\n|_ -> fs in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a (x) in\nlet base = match x with\n|0 -> 0\n|_ -> fs in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = function g -> a x in\nlet base = function x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a (x) in\nlet base = match fs with\n|0 -> 0\n|_ -> fs in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a (x) in\nlet base = match fs with\n|0 -> 0\n|_ -> fs in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = function g -> a x in\nlet base = function x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a (x) in\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a (x) in\nlet base = 0 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = function g -> a x in\nlet base = function x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = f a x in\nlet base =  in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = f a x in\nlet base =  in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = function g -> a x in\nlet base = function x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base =  in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base =  in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = function g -> a x in\nlet base = function x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = f a x in\nlet base = x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = f a x in\nlet base = x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = function g -> a x in\nlet base = function x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = f a x in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = f a x in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = function g -> g in\nlet base = function x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = function g -> g a x in\nlet base = function x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = function g -> g a x in\nlet base = function x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = function g -> g in\nlet base = function x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = function g -> g x a in\nlet base = function x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = function g -> g x a in\nlet base = function x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = function g -> g in\nlet base = function x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = function g -> g(x a) in\nlet base = function x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = function g -> g(x a) in\nlet base = function x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = function g -> g in\nlet base = function x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = function g -> g(x) in\nlet base = function x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = function g -> g(x) in\nlet base = function x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = function g -> x in\nlet base = function x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = function g -> g (a(x)) in\nlet base = function x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = function g -> g (a(x)) in\nlet base = function x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = function g -> a( x g)  in\nlet base = function x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = function g -> g( a x) in\nlet base = function x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = function g -> g( a x) in\nlet base = function x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = function g -> x (a g)  in\nlet base = function b -> b in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = function g -> function x (a x)  in\nlet base = function b -> b in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = function g -> function x (a x)  in\nlet base = function b -> b in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = function g -> x (a g)  in\nlet base = function b -> b in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = function g -> function z (a x)  in\nlet base = function b -> b in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = function g -> function z (a x)  in\nlet base = function b -> b in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = function g -> x (a g)  in\nlet base = function b -> b in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = function g -> function z (a z)  in\nlet base = function b -> b in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = function g -> function z (a z)  in\nlet base = function b -> b in\nList.fold_left f base fs"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) < 2\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif x.length < 2\nthen a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif x.length < 2\nthen a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) < 2\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif sl.length < 2\nthen a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif sl.length < 2\nthen a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) < 2\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length < 2\nthen a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length < 2\nthen a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) < 2\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length = 2\nthen a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length = 2\nthen a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) < 2\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif t.length = 2\nthen a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif t.length = 2\nthen a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) < 2\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) = 2\nthen a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) = 2\nthen a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length() = 0\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(l) = 0\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(l) = 0\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) > 2\nthen a ^ x ^ sep\nelse x ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) > 2\nthen a ^ x ^ sep\nelse x ^ x in\nlet base = \"\" in\nlet l = sepConcat sep t in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) > 2\nthen a ^ x ^ sep\nelse x ^ x in\nlet base = \"\" in\nlet l = sepConcat sep t in\nList.fold_left f base l"}
{"fix": "let _ = sepConcat \"---\" [\"a\"]", "bad": "let _ = sepConcat \"---\" [a]", "annotated": "let _ = sepConcat \"---\" [a]"}
{"fix": "let stringOfList f l = sepConcat \";\" (List.map f l)", "bad": "let stringOfList f l = sepConcat \";\" List.map f l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat \";\" List.map f l"}
{"fix": "let stringOfList f l = \nlet string str = sepConcat \"; \" (List.map (f) l )\nin \"[\" ^str ^ \"]\"", "bad": "let stringOfList f l = let", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  let"}
{"fix": "let stringOfList f l = \nlet string str = sepConcat \"; \" (List.map (f) l )\nin \"[\" ^str ^ \"]\"", "bad": "val str = sepConcat \";\" (List.map (f) l )\nin \"[\" ^str ^ \"]\"", "annotated": "val str = sepConcat \";\" (List.map (f) l )\nin \"[\" ^str ^ \"]\""}
{"fix": "let stringOfList f l = \nlet string str = sepConcat \"; \" (List.map (f) l )\nin \"[\" ^str ^ \"]\"", "bad": "let stringOfList f l = let", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  let"}
{"fix": "let stringOfList f l = \nlet string str = sepConcat \"; \" (List.map (f) l )\nin \"[\" ^str ^ \"]\"", "bad": "val str = sepConcat \";\" (List.map (f) l )\nin \"[\" ^str ^ \"]\"", "annotated": "val str = sepConcat \";\" (List.map (f) l )\nin \"[\" ^str ^ \"]\""}
{"fix": "let stringOfList f l = \nlet string str = sepConcat \"; \" (List.map (f) l )\nin \"[\" ^str ^ \"]\"", "bad": "let stringOfList f l = \nlet string str = sepConcat \";\" (List.map (f) l )\nin \"[\" ^str ^ \"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \nlet string str = sepConcat \";\" (List.map (f) l )\nin \"[\" ^str ^ \"]\""}
{"fix": "let rec clone x n = \nif n < 1\nthen []\nelse x:: (clone x (n-1))", "bad": "let rec clone x n = \nif n =< 0\nthen []\nelse h::t ->\nx::clone x n-1", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif n =< 0\nthen []\nelse h::t ->\nx::clone x n-1"}
{"fix": "let rec clone x n = \nif n < 1\nthen []\nelse x:: (clone x (n-1))", "bad": "let rec clone x n = match n with\n|0 -> []\n|h::t ->\nx::clone x n-1", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with\n|0 -> []\n|h::t ->\nx::clone x n-1"}
{"fix": "let rec clone x n = \nif n < 1\nthen []\nelse x:: (clone x (n-1))", "bad": "let rec clone x n = \nif n =< 0\nthen []\nelse x::clone x n-1", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif n =< 0\nthen []\nelse x::clone x n-1"}
{"fix": "let rec clone x n = \nif n < 1\nthen []\nelse x:: (clone x (n-1))", "bad": "let rec clone x n = \nif n < 1\nthen []\nelse x::clone x n-1", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif n < 1\nthen []\nelse x::clone x n-1"}
{"fix": "let rec clone x n = \nif n < 1\nthen []\nelse x:: (clone x (n-1))", "bad": "let rec clone x n = \nif n < 1\nthen []\nelse x:: (clone x n-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif n < 1\nthen []\nelse x:: (clone x n-1)"}
{"fix": "let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen \"hi\"\nelse \"bye\"", "bad": "let padZero l1 l2 = \nlet int a = List.length(l1) - List.length(l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet int a = List.length(l1) - List.length(l2)"}
{"fix": "let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen \"hi\"\nelse \"bye\"", "bad": "let padZero l1 l2 = \nlet int a = List.length(l1) - List.length(l2) in\nif a > 0\nthen \"hi\"\nelse \"bye\"", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet int a = List.length(l1) - List.length(l2) in\nif a > 0\nthen \"hi\"\nelse \"bye\""}
{"fix": "let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1,(clone 0 a))\nelse (l1,l2)", "bad": "let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen l1 * (clone 0 a)\nelse \"bye\"", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen l1 * (clone 0 a)\nelse \"bye\""}
{"fix": "let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1,(clone 0 a))\nelse (l1,l2)", "bad": "let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen l1 * (clone 0 a)\nelse l1 * l2", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen l1 * (clone 0 a)\nelse l1 * l2"}
{"fix": "let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1,(clone 0 a))\nelse (l1,l2)", "bad": "let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1 * (clone 0 a))\nelse l1 * l2", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1 * (clone 0 a))\nelse l1 * l2"}
{"fix": "let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1,(clone 0 a))\nelse (l1,l2)", "bad": "let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1 * (clone 0 a))\nelse (l1 * l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1 * (clone 0 a))\nelse (l1 * l2)"}
{"fix": "let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1,(List.append (clone 0 a) l2))\nelse (l1,l2)", "bad": "let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1,(List.apend (clone 0 a) l2))\nelse (l1,l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1,(List.apend (clone 0 a) l2))\nelse (l1,l2)"}
{"fix": "let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1,(List.append (clone 0 a) l2))\nelse ((List.append (clone 0 (0-a)) l1), l2)", "bad": "let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1,(List.append (clone 0 a) l2))\nelse (List.append ( clone 0 (0 -a)) l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1,(List.append (clone 0 a) l2))\nelse (List.append ( clone 0 (0 -a)) l2)"}
{"fix": "let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1,(List.append (clone 0 a) l2))\nelse ((List.append (clone 0 (0-a)) l1), l2)", "bad": "let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1,(List.append (clone 0 a) l2))\nelse (List.append ( clone 0 (0 -a)), l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1,(List.append (clone 0 a) l2))\nelse (List.append ( clone 0 (0 -a)), l2)"}
{"fix": "let rec digitsOfInt n =\nmatch n < 0 with\n| true -> 0\n| false -> 1", "bad": "let rec digitsOfInt n =\nmatch n with\n| < 0 0\n| >= 0 1", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nmatch n with\n| < 0 0\n| >= 0 1"}
{"fix": "let rec digitsOfInt n =\nmatch n < 0 with\n| true -> 0\n| false -> 1", "bad": "let _ = digitsOfInt 3124", "annotated": "let _ = digitsOfInt 3124"}
{"fix": "let rec digitsOfInt n =\nmatch n < 0 with\n| true -> 0\n| false -> 1", "bad": "let _ = digitsOfInt 352663", "annotated": "let _ = digitsOfInt 352663"}
{"fix": "let rec digitsOfInt n =\nmatch n < 0 with\n| true -> 0\n| false -> 1", "bad": "let rec digitsOfInt n =\nmatch n with\n| <0 0\n| >=0 1", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nmatch n with\n| <0 0\n| >=0 1"}
{"fix": "let rec digitsOfInt n =\nmatch n < 0 with\n| true -> 0\n| false -> 1", "bad": "let _ = digitsOfInt 3124", "annotated": "let _ = digitsOfInt 3124"}
{"fix": "let rec digitsOfInt n =\nmatch n < 0 with\n| true -> 0\n| false -> 1", "bad": "let _ = digitsOfInt 352663", "annotated": "let _ = digitsOfInt 352663"}
{"fix": "let rec digitsOfInt n =\nmatch n < 0 with\n| true -> 0\n| false -> 1", "bad": "let rec digitsOfInt n =\nmatch n with\n| 1\n| _ 1", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nmatch n with\n| 1\n| _ 1"}
{"fix": "let rec digitsOfInt n =\nmatch n < 0 with\n| true -> 0\n| false -> 1", "bad": "let _ = digitsOfInt 3124", "annotated": "let _ = digitsOfInt 3124"}
{"fix": "let rec digitsOfInt n =\nmatch n < 0 with\n| true -> 0\n| false -> 1", "bad": "let _ = digitsOfInt 352663", "annotated": "let _ = digitsOfInt 352663"}
{"fix": "let rec digitsOfInt n =\nmatch n < 0 with\n| true -> 0\n| false -> 1", "bad": "let rec digitsOfInt n =\nmatch n with\n| 1 0\n| _ 1", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nmatch n with\n| 1 0\n| _ 1"}
{"fix": "let rec digitsOfInt n =\nmatch n < 0 with\n| true -> 0\n| false -> 1", "bad": "let _ = digitsOfInt 3124", "annotated": "let _ = digitsOfInt 3124"}
{"fix": "let rec digitsOfInt n =\nmatch n < 0 with\n| true -> 0\n| false -> 1", "bad": "let _ = digitsOfInt 352663", "annotated": "let _ = digitsOfInt 352663"}
{"fix": "let rec digitsOfInt n =\nmatch n < 0 with\n| true -> 0\n| false -> 1", "bad": "let rec digitsOfInt n =\nmatch n with\n| < 1 -> 0\n| >= 0 -> 1", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nmatch n with\n| < 1 -> 0\n| >= 0 -> 1"}
{"fix": "let rec digitsOfInt n =\nmatch n < 0 with\n| true -> 0\n| false -> 1", "bad": "let _ = digitsOfInt 3124", "annotated": "let _ = digitsOfInt 3124"}
{"fix": "let rec digitsOfInt n =\nmatch n < 0 with\n| true -> 0\n| false -> 1", "bad": "let _ = digitsOfInt 352663", "annotated": "let _ = digitsOfInt 352663"}
{"fix": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> []", "bad": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> 1", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nmatch n <= 0 with\n| true -> []\n| false -> 1"}
{"fix": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> []", "bad": "let _ = 100 >> 2", "annotated": "let _ = 100 >> 2"}
{"fix": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> digitsOfInt n div 10 :: [n mod 10]", "bad": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> (digitsOfInt n/10) @ [n%10]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nmatch n <= 0 with\n| true -> []\n| false -> (digitsOfInt n/10) @ [n%10]"}
{"fix": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> digitsOfInt n div 10 :: [n mod 10]", "bad": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> [digitsOfInt n/10] @ [n%10]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nmatch n <= 0 with\n| true -> []\n| false -> [digitsOfInt n/10] @ [n%10]"}
{"fix": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> digitsOfInt n div 10 :: [n mod 10]", "bad": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> digitsOfInt n/10 @ [n%10]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nmatch n <= 0 with\n| true -> []\n| false -> digitsOfInt n/10 @ [n%10]"}
{"fix": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> digitsOfInt n div 10 :: [n mod 10]", "bad": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> [n%10] @ digitsOfInt n/10", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nmatch n <= 0 with\n| true -> []\n| false -> [n%10] @ digitsOfInt n/10"}
{"fix": "let rec listReverse l =\nmatch l with\n| []\t    -> []\n| (_ :: h :: [])  -> h :: listReverse []", "bad": "let rec listReverse l =\nmatch l with\n| []\t    -> []\n| (t :: h :: [])  -> h :: listReverse t::[]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nmatch l with\n| []\t    -> []\n| (t :: h :: [])  -> h :: listReverse t::[]"}
{"fix": "let rec listReverse l =\nmatch l with\n| []\t    -> []\n| (_ :: h :: [])  -> h :: listReverse []", "bad": "let rec listReverse l =\nmatch l with\n| []\t    -> []\n| (t :: h :: [])  -> h :: listReverse t", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nmatch l with\n| []\t    -> []\n| (t :: h :: [])  -> h :: listReverse t"}
{"fix": "let _ = digitsOfInt 2401", "bad": "let _ = digitsOfInt -2401", "annotated": "let _ = digitsOfInt -2401"}
{"fix": "let _ = digitsOfInt (-1)", "bad": "let _ = digitsOfInt -2401", "annotated": "let _ = digitsOfInt -2401"}
{"fix": "let _ = digitsOfInt (-1)", "bad": "let _ = digitsOfInt -1", "annotated": "let _ = digitsOfInt -1"}
{"fix": "let _ = digitsOfInt 0", "bad": "let _ = digitsOfInt asr\n\n(* digits : int -> int list\n* (digits n) is the list of digits of n in the order in which they appear\n* in n\n* e.g. (digits 31243) is [3,1,2,4,3]\n*      (digits (-23422) is [2,3,4,2,2]\n*)\n\nlet digits n = digitsOfInt (abs n)", "annotated": "let _ = digitsOfInt asr\n\n(* digits : int -> int list\n* (digits n) is the list of digits of n in the order in which they appear\n* in n\n* e.g. (digits 31243) is [3,1,2,4,3]\n*      (digits (-23422) is [2,3,4,2,2]\n*)\n\nlet digits n = digitsOfInt (abs n)"}
{"fix": "let _ = digitsOfInt ~-21041", "bad": "let _ = digitsOfInt -21041", "annotated": "let _ = digitsOfInt -21041"}
{"fix": "let _ = palindrome \"malayalam\"", "bad": "let palindrome w = \nif (explode(w)) = (listReverse (explode(w)))\nthen true\nelse false", "annotated": "let palindrome : string -> bool = fun  w  ->  \nif (explode(w)) = (listReverse (explode(w)))\nthen true\nelse false"}
{"fix": "let rec wwhile (f,b) =\nmatch f(b-1) with\n| (_, false) -> b\n| (bb, true) -> wwhile(f, bb)", "bad": "xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "annotated": "xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "annotated": "xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}
{"fix": "ate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f, b) = wwhile (fun ff b -> (f(b), f(b) = f(b-1)) ,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f, b) = wwhile (fun ff b -> (f(b), f(b)  ->  f(b-1)) ,b)"}
{"fix": "ate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f, b) = wwhile (fun ff b -> (f(b), f(b) != f(b-1)) ,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f, b) = wwhile (fun ff b -> (f(b), f(b) ! ->  f(b-1)) ,b)"}
{"fix": "ate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let ff (b) =\n(f(b), f(b) != f(b-1)\nin\nlet fixpoint (f, b) = wwhile (ff ,b)", "annotated": "let ff (b) =\n(f(b), f(b) != f(b-1)\nin\nlet fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f, b)  ->  wwhile (ff ,b)"}
{"fix": "ate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let ff (b) =\n(f(b), f(b) != f(b-1))\nin\nlet fixpoint (f, b) = wwhile (ff ,b)", "annotated": "let ff (b) =\n(f(b), f(b) != f(b-1))\nin\nlet fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f, b)  ->  wwhile (ff ,b)"}
{"fix": "ate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let ff (b) =\n(f(b), f(b) != f(b-1))\nin\nlet fixpoint (f, b) = wwhile (ff, b)", "annotated": "let ff (b) =\n(f(b), f(b) != f(b-1))\nin\nlet fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f, b)  ->  wwhile (ff, b)"}
{"fix": "ate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f, b) = \nlet ff (b) =\n(f(b), f(b) != f(b-1))\nin\nwwhile (ff, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f, b)  ->  \nlet ff (b) =\n(f(b), f(b) != f(b-1))\nin\nwwhile (ff, b)"}
{"fix": "true || false", "bad": "ate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "ate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "true || false", "bad": "let collatz n =", "annotated": "let collatz n ="}
{"fix": "true || false", "bad": " match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "annotated": " match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1"}
{"fix": "true || false", "bad": "let _ = fixpoint (collatz, 1)", "annotated": "let _ = fixpoint (collatz, 1)"}
{"fix": "true || false", "bad": "let _ = fixpoint (collatz, 3)", "annotated": "let _ = fixpoint (collatz, 3)"}
{"fix": "true || false", "bad": "let _ = fixpoint (collatz, 48)", "annotated": "let _ = fixpoint (collatz, 48)"}
{"fix": "true || false", "bad": "let _ = fixpoint (collatz, 107)", "annotated": "let _ = fixpoint (collatz, 107)"}
{"fix": "true || false", "bad": "let _ = fixpoint (collatz, 9001)", "annotated": "let _ = fixpoint (collatz, 9001)"}
{"fix": "true || false", "bad": "*", "annotated": "*"}
{"fix": "true || false", "bad": ")", "annotated": ")"}
{"fix": "let _ = fixpoint (collatz, 3)", "bad": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || b != f(b-1))), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun (f, b) = wwhile((fun b -> (f(b), f(b) != b || b ! ->  f(b-1))), b)"}
{"fix": "let _ = fixpoint (collatz, 3)", "bad": "let g x = trunca", "annotated": "let g x = trunca"}
{"fix": "let _ = fixpoint (collatz, 3)", "bad": "te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let _ = fixpoint (collatz, 3)", "bad": "let collatz n =", "annotated": "let collatz n ="}
{"fix": "let _ = fixpoint (collatz, 3)", "bad": " match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "annotated": " match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1"}
{"fix": "let _ = fixpoint (collatz, 3)", "bad": "let _ = fixpoint (collatz, 1)", "annotated": "let _ = fixpoint (collatz, 1)"}
{"fix": "let _ = fixpoint (collatz, 3)", "bad": "let _ = fixpoint", "annotated": "let _ = fixpoint"}
{"fix": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || b != f b-1)), b)", "bad": "te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || b != f b-1)), b)", "bad": "let collatz n =", "annotated": "let collatz n ="}
{"fix": "te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let collatz n =", "annotated": "let collatz n ="}
{"fix": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)), b)", "bad": " match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "annotated": " match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1"}
{"fix": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)), b)", "bad": "let _ = fixpoint (collatz, 1)", "annotated": "let _ = fixpoint (collatz, 1)"}
{"fix": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)), b)", "bad": "let _ = fixpoint", "annotated": "let _ = fixpoint"}
{"fix": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)", "bad": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b))), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun (f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) ! ->  f(f(b))), b)"}
{"fix": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)", "bad": "let g x = trunca", "annotated": "let g x = trunca"}
{"fix": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)", "bad": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun (f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) ! ->  f(f(b)))) , b)"}
{"fix": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)", "bad": "let g x = trunca", "annotated": "let g x = trunca"}
{"fix": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)", "bad": "te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)", "bad": "let collatz n =", "annotated": "let collatz n ="}
{"fix": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)", "bad": " match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "annotated": " match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1"}
{"fix": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)", "bad": "let _ = fixpoint (collatz, 1)", "annotated": "let _ = fixpoint (collatz, 1)"}
{"fix": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)", "bad": "let _ = fixpoint", "annotated": "let _ = fixpoint"}
{"fix": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)", "bad": " (collatz, 3)", "annotated": " (collatz, 3)"}
{"fix": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)", "bad": "let _ = fixpoint", "annotated": "let _ = fixpoint"}
{"fix": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)", "bad": " (collatz, 48)", "annotated": " (collatz, 48)"}
{"fix": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)", "bad": "let _ = fixpoint (collatz, 107)", "annotated": "let _ = fixpoint (collatz, 107)"}
{"fix": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)", "bad": "let _ = fixpoint (collatz, 9001)", "annotated": "let _ = fixpoint (collatz, 9001)"}
{"fix": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)", "bad": "*", "annotated": "*"}
{"fix": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)", "bad": ")", "annotated": ")"}
{"fix": "exp 2.", "bad": "exp 2", "annotated": "exp 2"}
{"fix": "exp 2.", "bad": "let _ = fixpoint (", "annotated": "let _ = fixpoint ("}
{"fix": "let _ = fixpoint (exp, -1)", "bad": "let _ = fixpoint (exp, 1)", "annotated": "let _ = fixpoint (exp, 1)"}
{"fix": "let _ = fixpoint (exp, -1)", "bad": "let _ = fixpoint", "annotated": "let _ = fixpoint"}
{"fix": "let _ = fixpoint (exp, -1)", "bad": "let _ = fixpoint (exp, 1.)", "annotated": "let _ = fixpoint (exp, 1.)"}
{"fix": "let _ = fixpoint (exp, -1)", "bad": "let _ = fixpoint", "annotated": "let _ = fixpoint"}
{"fix": "let _ = fixpoint ((fun b -> b ** 2), 0.)", "bad": "let _ = fixpoint (exp, 0)", "annotated": "let _ = fixpoint (exp, 0)"}
{"fix": "let _ = fixpoint ((fun b -> b ** 2), 0.)", "bad": "let _ = fixpoint", "annotated": "let _ = fixpoint"}
{"fix": "let _ = fixpoint ((fun b -> b ** 2), 0.)", "bad": "let _ = fixpoint (exp, 0.)", "annotated": "let _ = fixpoint (exp, 0.)"}
{"fix": "let _ = fixpoint ((fun b -> b ** 2), 0.)", "bad": "let _ = fixpoint", "annotated": "let _ = fixpoint"}
{"fix": "0. ** 2", "bad": "let _ = fixpoint ((fun b -> b ** 2.), 0.)", "annotated": "let _ = fixpoint ((fun b -> b ** 2.), 0.)"}
{"fix": "0. ** 2", "bad": "let _ = fixpoint", "annotated": "let _ = fixpoint"}
{"fix": "1. != 1.", "bad": "let _ = fixpoint ((fun b -> b ** 2.), 1.)", "annotated": "let _ = fixpoint ((fun b -> b ** 2.), 1.)"}
{"fix": "1. != 1.", "bad": "let _ = fixpoint", "annotated": "let _ = fixpoint"}
{"fix": "(1. = 1.)", "bad": "!(1. = 1.)", "annotated": "!(1. = 1.)"}
{"fix": "(1. = 1.)", "bad": "let _ = fixpoint (", "annotated": "let _ = fixpoint ("}
{"fix": "te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint(f, b) = wwhile((fun b -> (f(b), not (f(b) = b) || not (f(b) != f(f(b))))) , b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun (f, b) = wwhile((fun b -> (f(b), not (f(b) = b) || not (f(b) ! ->  f(f(b))))) , b)"}
{"fix": "te (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let g x = trunca", "annotated": "let g x = trunca"}
{"fix": " ((fun b -> b ** 4.), 0.)", "bad": "let _ = fixpoint ((fun b -> b ** 2.), 1.)", "annotated": "let _ = fixpoint ((fun b -> b ** 2.), 1.)"}
{"fix": " ((fun b -> b ** 4.), 0.)", "bad": "let _ = fixpoint", "annotated": "let _ = fixpoint"}
{"fix": " ((fun b -> b ** 4.), 0.)", "bad": "let _ = fixpoint ((fun b -> b ** 2.), 0.)", "annotated": "let _ = fixpoint ((fun b -> b ** 2.), 0.)"}
{"fix": " ((fun b -> b ** 4.), 0.)", "bad": "let _ = fixpoint ((fun b -> b ** 2.), 1.)", "annotated": "let _ = fixpoint ((fun b -> b ** 2.), 1.)"}
{"fix": " ((fun b -> b ** 4.), 0.)", "bad": "let _ = fixpoint", "annotated": "let _ = fixpoint"}
{"fix": " (sqrt, 12489124)", "bad": "let _ = fixpoint ((fun b -> b ** 2.), 0.)", "annotated": "let _ = fixpoint ((fun b -> b ** 2.), 0.)"}
{"fix": " (sqrt, 12489124)", "bad": "let _ = fixpoint ((fun b -> b ** 2.), 1.)", "annotated": "let _ = fixpoint ((fun b -> b ** 2.), 1.)"}
{"fix": " (sqrt, 12489124)", "bad": "let _ = fixpoint ((fun b -> b ** 4.), 0.)", "annotated": "let _ = fixpoint ((fun b -> b ** 4.), 0.)"}
{"fix": " (sqrt, 12489124)", "bad": "let _ = fixpoint ((fun b -> b ** 4.), 1.)", "annotated": "let _ = fixpoint ((fun b -> b ** 4.), 1.)"}
{"fix": " (sqrt, 12489124)", "bad": "let _ = fixpoint (sqrt, 10.)", "annotated": "let _ = fixpoint (sqrt, 10.)"}
{"fix": " (sqrt, 12489124)", "bad": "let _ = fixpoint", "annotated": "let _ = fixpoint"}
{"fix": "let rec exprToString e = \nmatch e with\n| VarX _\t    -> \"x\"\n| VarY _\t    -> \"y\"\n| Sine x\t    -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine x\t    -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Average (x,y)     -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^\")/2)\"\n| Times (x,y)       -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (a,b,c,d)  -> \n\"(\" ^ exprToString(a) ^ \"<\" exprToString(y) ^ \"?\" ^ \nexprToString(c) ^ \":\" ^ exprToString(d)", "bad": "let rec exprToString e = \nmatch e with\n| VarX _ -> \"x\"\n| VarY _ -> \"y\"\n| Sine x -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Average (x,y) -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^\")/2)\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nmatch e with\n| VarX _ -> \"x\"\n| VarY _ -> \"y\"\n| Sine x -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Average (x,y) -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^\")/2)\""}
{"fix": "let rec exprToString e = \nmatch e with\n| VarX\t\t    -> \"x\"\n| VarY\t\t    -> \"y\"\n| Sine x\t    -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine x\t    -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Average (x,y)     -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^\")/2)\"\n| Times (x,y)       -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (a,b,c,d)  -> \n\"(\" ^ exprToString(a) ^ \"<\" ^ exprToString(b) ^ \"?\" ^ \nexprToString(c) ^ \":\" ^ exprToString(d)", "bad": "let rec exprToString e = \nmatch e with\n| VarX _\t    -> \"x\"\n| VarY _\t    -> \"y\"\n| Sine x\t    -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine x\t    -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Average (x,y)     -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^\")/2)\"\n| Times (x,y)       -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (a,b,c,d)  -> \n\"(\" ^ exprToString(a) ^ \"<\" ^ exprToString(y) ^ \"?\" ^ \nexprToString(c) ^ \":\" ^ exprToString(d)", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nmatch e with\n| VarX _\t    -> \"x\"\n| VarY _\t    -> \"y\"\n| Sine x\t    -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine x\t    -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Average (x,y)     -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^\")/2)\"\n| Times (x,y)       -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (a,b,c,d)  -> \n\"(\" ^ exprToString(a) ^ \"<\" ^ exprToString(y) ^ \"?\" ^ \nexprToString(c) ^ \":\" ^ exprToString(d)"}
{"fix": "let rec exprToString e = \nmatch e with\n| VarX\t\t    -> \"x\"\n| VarY\t\t    -> \"y\"\n| Sine x\t    -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine x\t    -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Average (x,y)     -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^\")/2)\"\n| Times (x,y)       -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (a,b,c,d)  -> \n\"(\" ^ exprToString(a) ^ \"<\" ^ exprToString(b) ^ \"?\" ^ \nexprToString(c) ^ \":\" ^ exprToString(d)", "bad": "let rec exprToString e = \nmatch e with\n| VarX _\t    -> \"x\"\n| VarY _\t    -> \"y\"\n| Sine x\t    -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine x\t    -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Average (x,y)     -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^\")/2)\"\n| Times (x,y)       -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (a,b,c,d)  -> \n\"(\" ^ exprToString(a) ^ \"<\" ^ exprToString(b) ^ \"?\" ^ \nexprToString(c) ^ \":\" ^ exprToString(d)", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nmatch e with\n| VarX _\t    -> \"x\"\n| VarY _\t    -> \"y\"\n| Sine x\t    -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine x\t    -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Average (x,y)     -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^\")/2)\"\n| Times (x,y)       -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (a,b,c,d)  -> \n\"(\" ^ exprToString(a) ^ \"<\" ^ exprToString(b) ^ \"?\" ^ \nexprToString(c) ^ \":\" ^ exprToString(d)"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi * eval (a,x,y))\n| Cosine a -> cos (pi * eval (a,x,y))\n| Average (a,b) -> (eval(a,x,y) + eval(b,x,y)) /. 2.\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  -> \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi * eval (a,x,y))\n| Cosine a -> cos (pi * eval (a,x,y))\n| Average (a,b) -> (eval(a,x,y) + eval(b,x,y)) /. 2.\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi *. eval (a,x,y))\n| Cosine a -> cos (pi *. eval (a,x,y))\n| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  -> \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi *. eval (a,x,y))\n| Cosine a -> cos (pi *. eval (a,x,y))\n| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)"}
{"fix": "let _ = eval (mySampleExpr3, 1.,2.)", "bad": "let _ = eval (mySampleExpr3, 1,2)", "annotated": "let _ = eval (mySampleExpr3, 1,2)"}
{"fix": "let _ = eval (mySampleExpr3, 1.,2.)", "bad": "let _ = eval (mySampleExpr3, 14,14)", "annotated": "let _ = eval (mySampleExpr3, 14,14)"}
{"fix": "let _ = eval (mySampleExpr3, 1.,2.)", "bad": "let _ = eval (mySampleExpr3, 1203,12)", "annotated": "let _ = eval (mySampleExpr3, 1203,12)"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (fun a -> a) in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (fun a -> a) in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (fun a -> a) in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 3 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = base in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = base in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x(a) in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs"}
{"fix": "let pipe fs b = \nlet f a x = x(a) in\nlet base = b in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x(a) in\nlet base =  in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x(a) in\nlet base =  in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x(a) in\nlet base = fun x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x(a) in\nlet base = fun x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x(a) in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x(a) in\nlet base = rec x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x(a) in\nlet base = rec x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x(a) in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x(a) in\nlet base = x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x(a) in\nlet base = x in\nList.fold_left f base fs"}
{"fix": "let pipe fs b = \nlet f a x = x(a) in\nlet base = b in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs b = \nlet f a x = x(a) in\nlet base = b in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs b = \nlet f a x = x(a) in\nlet base = b in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let _ = pipe []", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = x(a) in\nlet base = \"\" in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = x(a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x(a) in\nlet base = a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x(a) in\nlet base = a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x(a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x(a) in\nlet base = _ in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x(a) in\nlet base = _ in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x(a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x(a) in\nlet base = fun x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x(a) in\nlet base = fun x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x(a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x(a) in\nlet base = (fun x) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x(a) in\nlet base = (fun x) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x(a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x(a) in\nlet base =  in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x(a) in\nlet base =  in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base =  in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base =  in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = function | a -> a in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = function | a -> a in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = int in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = int in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = function | a -> a in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = function in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = function in\nList.fold_left f base fs"}
{"fix": "let pipe fs = fun x' ->\nlet f a x = x a in\nlet base = x' in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = fun x' ->\nlet f a x = x a in\nlet base = x' in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = int a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = int a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = fun x' ->\nlet f a x = x a in\nlet base = x' in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = b of int in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = b of int in\nList.fold_left f base fs"}
{"fix": "let _ = stringOfList (fun x -> string_of_int(5*x)) [1;2;3;4;5;6]", "bad": "let _ = stringOfList (string_of_int fun x -> 5*x) [1;2;3;4;5;6]", "annotated": "let _ = stringOfList (string_of_int fun x -> 5*x) [1;2;3;4;5;6]"}
{"fix": "let rec clone x n = \nmatch n > 0 with\n| false -> []\n| true  -> x :: clone x (n-1)", "bad": "let rec clone x n = \nmatch n > 0 with\n| false -> []\n| true  -> [x] @ (clone x n-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nmatch n > 0 with\n| false -> []\n| true  -> [x] @ (clone x n-1)"}
{"fix": "let rec clone x n = \nmatch n > 0 with\n| false -> []\n| true  -> x :: clone x (n-1)", "bad": "let rec clone x n = \nmatch n > 0 with\n| false -> []\n| true  -> x :: (clone (x n-1))", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nmatch n > 0 with\n| false -> []\n| true  -> x :: (clone (x n-1))"}
{"fix": "let rec clone x n = \nmatch n > 0 with\n| false -> []\n| true  -> x :: clone x (n-1)", "bad": "let rec clone x n = \nmatch n > 0 with\n| false -> []\n| true  -> x :: clone x n-1", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nmatch n > 0 with\n| false -> []\n| true  -> x :: clone x n-1"}
{"fix": "let padZero l1 l2 = \nmatch List.length l1 = List.length l2 with\n| true -> (l1, l2)\n| false ->\nlet lendiff = List.length l1 - List.length l2 in\nmatch lendiff > 0 with\n| true  -> (l1, (clone 0 lendiff) @ l2)\n| false -> ((clone 0 (-lendiff)) @ l1, l2)", "bad": "let padZero l1 l2 = \nmatch List.length l1 = List.length l2 with\n| true -> (l1, l2)\n| false ->\nlet lendiff = List.length l1 - List.length l2 in\nmatch lendiff > 0 with\n| true  -> (l1, (clone 0 lendiff) @ l2)\n| false -> ((clone 0 -lendiff) @ l1, l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nmatch List.length l1 = List.length l2 with\n| true -> (l1, l2)\n| false ->\nlet lendiff = List.length l1 - List.length l2 in\nmatch lendiff > 0 with\n| true  -> (l1, (clone 0 lendiff) @ l2)\n| false -> ((clone 0 -lendiff) @ l1, l2)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = (x + y) / 10 :: a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = (x + y + a) / 10 in\nlet base = 0 in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a (x,y) = (x + y + a) / 10 in\nlet base = 0 in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = (x + y) / 10 :: a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = (x + y + a) / 10 in\nlet base = 0 in\nlet args = List.combine l1 l2 in\nList.fold_left f base args\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a (x,y) = (x + y + a) / 10 in\nlet base = 0 in\nlet args = List.combine l1 l2 in\nList.fold_left f base args\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = (x + y) / 10 :: a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = (x + y + a) / 10 in\nlet base = 0 in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a (x,y) = (x + y + a) / 10 in\nlet base = 0 in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = (x + y) / 10 :: a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = (x + y) / 10 :: a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a (x,y) = (x + y) / 10 :: a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = ((x + y) mod 10) :: a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = ((x + y) % 10) :: a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a (x,y) = ((x + y) % 10) :: a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = ((x + y) / 10) :: a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = ((x + y) % 10) :: a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a (x,y) = ((x + y) % 10) :: a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = \nmatch a with\n| [] -> (x + y) :: a \n| h :: t -> [x + y + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev(List.combine l1 l2) in\nlet (res) = List.fold_left f base args in\nres\nin \n(add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = \nmatch a with\n| [] -> (x + y) :: a \n| h :: t -> [x + y + h/10; h % 10] @ t\nin\nlet base = [] in\nlet args = List.rev(List.combine l1 l2) in\nlet (res) = List.fold_left f base args in\nres\nin \n(add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a (x,y) = \nmatch a with\n| [] -> (x + y) :: a \n| h :: t -> [x + y + h/10; h % 10] @ t\nin\nlet base = [] in\nlet args = List.rev(List.combine l1 l2) in\nlet (res) = List.fold_left f base args in\nres\nin \n(add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = \nmatch a with\n| [] -> (x + y) :: a \n| h :: t -> [x + y + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev((0,0) :: List.combine l1 l2) in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = \nmatch a with\n| [] -> (x + y) :: a \n| h :: t -> [x + y + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev((0,0) :: List.combine l1 l2) in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZeros (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a (x,y) = \nmatch a with\n| [] -> (x + y) :: a \n| h :: t -> [x + y + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev((0,0) :: List.combine l1 l2) in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZeros (add (padZero l1 l2))"}
{"fix": "let rec mulByDigit i l = \nlet f a x = \nmatch a with\n| [] -> (i * x) :: a \n| h :: t -> [i * x + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev(0 :: l) in\nList.fold_left f base args", "bad": "let rec mulByDigit i l = \nlet f a x = \nmatch a with\n| [] -> (i * x) :: a \n| h :: t -> [x * y + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev(0 :: l) in\nList.fold_left f base args", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet f a x = \nmatch a with\n| [] -> (i * x) :: a \n| h :: t -> [x * y + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev(0 :: l) in\nList.fold_left f base args"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = \nmatch a with\n| [] -> (x + y) :: a \n| h :: t -> [x + y + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev((0,0) :: List.combine l1 l2) in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a (x,y) = \nmatch a with\n| [] -> (x + y) :: a \n| h :: t -> [x + y + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev((0,0) :: List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a (x,y) = \nmatch a with\n| [] -> (x + y) :: a \n| h :: t -> [x + y + h/10; h mod 10] @ t\nin\nlet base = [] in\nlet args = List.rev((0,0) :: List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []  -> (mulByDigit x l2)\n| _   -> bigAdd a (mulByDigit x l2)\nin\nlet base = [] in\nlet args = List.rev l1 in\nlet (res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []      -> (mulByDigit x l2) :: a\n| h :: t  -> [bigAdd (mulByDigit x l2) h/10; h mod 10] @ t \nin\nlet base = [] in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nmatch a with\n| []      -> (mulByDigit x l2) :: a\n| h :: t  -> [bigAdd (mulByDigit x l2) h/10; h mod 10] @ t \nin\nlet base = [] in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []  -> (mulByDigit x l2)\n| _   -> bigAdd a (mulByDigit x l2)\nin\nlet base = [] in\nlet args = List.rev l1 in\nlet (res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []      -> (mulByDigit x l2) :: a\n| h :: t  -> [bigAdd (mulByDigit x l2) [h/10]; h mod 10] @ t \nin\nlet base = [] in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nmatch a with\n| []      -> (mulByDigit x l2) :: a\n| h :: t  -> [bigAdd (mulByDigit x l2) [h/10]; h mod 10] @ t \nin\nlet base = [] in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []  -> (mulByDigit x l2)\n| _   -> bigAdd a (mulByDigit x l2)\nin\nlet base = [] in\nlet args = List.rev l1 in\nlet (res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []  -> (mulByDigit x l2)\n| _   -> bigAdd a (mulByDigit x l2)\nin\nlet base = [] in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nmatch a with\n| []  -> (mulByDigit x l2)\n| _   -> bigAdd a (mulByDigit x l2)\nin\nlet base = [] in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []  -> (mulByDigit x l2)\n| _   -> bigAdd (List.rev(0 :: (List.rev a))) (mulByDigit x l2)\nin\nlet base = [] in\nlet args = List.rev l1 in\nlet (res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nmatch a with\n| []  -> (mulByDigit x l2)\n| _   -> bigAdd List.rev(0 :: (List.rev a)) (mulByDigit x l2)\nin\nlet base = [] in\nlet args = List.rev l1 in\nlet (res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nmatch a with\n| []  -> (mulByDigit x l2)\n| _   -> bigAdd List.rev(0 :: (List.rev a)) (mulByDigit x l2)\nin\nlet base = [] in\nlet args = List.rev l1 in\nlet (res) = List.fold_left f base args in\nres"}
{"fix": "let test = mulByDigit 1 [1;0]", "bad": "let test = mulByDigit 1 [1;0]\nList.rev test", "annotated": "let test = mulByDigit 1 [1;0]\nList.rev test"}
{"fix": "let test = mulByDigit 1 [1;0]", "bad": "let test = mulByDigit 1 [1;0]\nList.rev test", "annotated": "let test = mulByDigit 1 [1;0]\nList.rev test"}
{"fix": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x::y -> x + sumList y", "bad": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| [x] -> x\n| [x::y] -> x + sumList y", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> 0\n| [x] -> x\n| [x::y] -> x + sumList y"}
{"fix": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x::y -> x + sumList y", "bad": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| [x::y] -> x + sumList y", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> 0\n| [x::y] -> x + sumList y"}
{"fix": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n / 10) @ [n mod 10]", "bad": "let rec digitsOfInt n =\nmatch n with\n| n < 0 -> []\n| n > 0 -> (n % 10)::digitsOfInt (n / 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nmatch n with\n| n < 0 -> []\n| n > 0 -> (n % 10)::digitsOfInt (n / 10)"}
{"fix": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n / 10) @ [n mod 10]", "bad": "let rec digitsOfInt n =\nmatch n with\n| n <= 0 -> []\n| n > 0 -> (n % 10)::digitsOfInt (n / 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nmatch n with\n| n <= 0 -> []\n| n > 0 -> (n % 10)::digitsOfInt (n / 10)"}
{"fix": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n / 10) @ [n mod 10]", "bad": "let rec digitsOfInt n =\nmatch n with\n| n <= 0 -> []\n| n < 10 -> [n]\n| n > 0 -> (n % 10)::digitsOfInt (n / 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nmatch n with\n| n <= 0 -> []\n| n < 10 -> [n]\n| n > 0 -> (n % 10)::digitsOfInt (n / 10)"}
{"fix": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n / 10) @ [n mod 10]", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse match n with\n| a -> [a]\n| a^b -> a::digitsOfInt b", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse match n with\n| a -> [a]\n| a^b -> a::digitsOfInt b"}
{"fix": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n / 10) @ [n mod 10]", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse match n with\n| a -> [a]\n| ab -> a::digitsOfInt b", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse match n with\n| a -> [a]\n| ab -> a::digitsOfInt b"}
{"fix": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n / 10) @ [n mod 10]", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n == 0 then 0\nelse digitsOfInt (n / 10) :: (n % 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse if n == 0 then 0\nelse digitsOfInt (n / 10) :: (n % 10)"}
{"fix": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n / 10) @ [n mod 10]", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n == 0 then []\nelse digitsOfInt (n / 10) :: (n % 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse if n == 0 then []\nelse digitsOfInt (n / 10) :: (n % 10)"}
{"fix": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n / 10) @ [n mod 10]", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n == 0 then 0\nelse  digitsOfInt (n / 10) @ [n % 10]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse if n == 0 then 0\nelse  digitsOfInt (n / 10) @ [n % 10]"}
{"fix": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n / 10) @ [n mod 10]", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n / 10) @ [n % 10]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse digitsOfInt (n / 10) @ [n % 10]"}
{"fix": "let rec additivePersistence n =\nlet sum = sumList (digitsOfInt n) in\nif (sum < 10) then 1\nelse\n1 + additivePersistence sum", "bad": "let rec additivePersistence n =\nlet sum = sumList digitsOfInt n in\nif (sum < 10) then 1\nelse\n1 + additivePersistance sum", "annotated": "let rec additivePersistence : int -> int = fun  n  -> \nlet sum = sumList digitsOfInt n in\nif (sum < 10) then 1\nelse\n1 + additivePersistance sum"}
{"fix": "let rec additivePersistence n =\nlet sum = sumList (digitsOfInt n) in\nif (sum < 10) then 1\nelse\n1 + additivePersistence sum", "bad": "let rec additivePersistence n =\nlet sum = sumList (digitsOfInt n) in\nif (sum < 10) then 1\nelse\n1 + additivePersistance sum", "annotated": "let rec additivePersistence : int -> int = fun  n  -> \nlet sum = sumList (digitsOfInt n) in\nif (sum < 10) then 1\nelse\n1 + additivePersistance sum"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> b :: listReverse a", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nmatch l with\n| [] -> []\n| a :: b -> b :: listReverse a"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> b :: listReverse [a]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nmatch l with\n| [] -> []\n| a :: b -> b :: listReverse [a]"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ a", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ a"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b :: a", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nmatch l with\n| [] -> []\n| a :: b -> listReverse b :: a"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ a", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ a"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: [b] -> listReverse [b] @ a", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nmatch l with\n| [] -> []\n| a :: [b] -> listReverse [b] @ a"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse (b) @ a", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nmatch l with\n| [] -> []\n| a :: b -> listReverse (b) @ a"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ a", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ a"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let palindrome w =\nlet wList = explode (w) in\nlet wReverse = listReverse (explode (w)) in\nif (true) then wList", "annotated": "let palindrome : string -> bool = fun  w  -> \nlet wList = explode (w) in\nlet wReverse = listReverse (explode (w)) in\nif (true) then wList"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l =\nmatch l with\n| [] -> []\n(*| a :: b -> listReverse b @ [a] ;;*)\n| [a] @ b -> b :: listReverse a", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nmatch l with\n| [] -> []\n(*| a :: b -> listReverse b @ [a] ;;*)\n| [a] @ b -> b :: listReverse a"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ [a]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ [a]"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n < 10 then [n]\nelse (n mod 10) :: digitsOfInt (n/10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse if n < 10 then [n]\nelse (n mod 10) :: digitsOfInt (n/10)"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n < 10 then [n]\nelse digitsOfInt (n/10) :: [n mod 10]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse if n < 10 then [n]\nelse digitsOfInt (n/10) :: [n mod 10]"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n > 10 then digitsOfInt (n / 10) :: [n mod 10]\nelse n", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse if n > 10 then digitsOfInt (n / 10) :: [n mod 10]\nelse n"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse if n > 10 then digitsOfInt(n mod 10)\nelse\nlet a = n mod 10 in\nlet b = n / 10 in\nif b = 0 then [n]\nelse a :: []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse if n = 0 then [0]\nelse if n > 10 then digitsOfInt(n mod 10)\nelse\nlet a = n mod 10 in\nlet b = n / 10 in\nif b = 0 then [n]\nelse a :: []"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse if n > 99 then digitsOfInt(n mod 10)\nelse\nlet a = n mod 10 in\nlet b = n / 10 in\nif b = 0 then [n]\nelse a :: digitsOfInt n", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse if n = 0 then [0]\nelse if n > 99 then digitsOfInt(n mod 10)\nelse\nlet a = n mod 10 in\nlet b = n / 10 in\nif b = 0 then [n]\nelse a :: digitsOfInt n"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n =\nlet s = string_of_int n in\nmatch s with\n| a -> [a]\n| a ^ b -> a :: digitsOfInt b", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nlet s = string_of_int n in\nmatch s with\n| a -> [a]\n| a ^ b -> a :: digitsOfInt b"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n =\nlet s = string_of_int n in\nmatch s with\n| a -> [a]\n| a ^ b -> a :: digitsOfInt b", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nlet s = string_of_int n in\nmatch s with\n| a -> [a]\n| a ^ b -> a :: digitsOfInt b"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse if n < 10 then [n]\nelse (n mod 10) :: digitsOfInt (n / 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse if n = 0 then [0]\nelse if n < 10 then [n]\nelse (n mod 10) :: digitsOfInt (n / 10)"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet a = n / 10 in\nlet b = n mod 10 in\nlet c = [a; b] in\nc", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse\nlet a = n / 10 in\nlet b = n mod 10 in\nlet c = [a; b] in\nc"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet a = n / 10 in\nlet b = n mod 10 in\nlet c = [a; b] in\nif a < 10 then c\nelse digitsOfInt (a / 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse\nlet a = n / 10 in\nlet b = n mod 10 in\nlet c = [a; b] in\nif a < 10 then c\nelse digitsOfInt (a / 10)"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ [a]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ [a]"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "match l with\n| [] -> []\n| a :: b -> let c = listReverse b in", "annotated": "match l with\n| [] -> []\n| a :: b -> let c = listReverse b in"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> let c = listReverse b in\nmatch c with\n| [] -> []\n| d :: e -> [d; a]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nmatch l with\n| [] -> []\n| a :: b -> let c = listReverse b in\nmatch c with\n| [] -> []\n| d :: e -> [d; a]"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> [listReverse b ; [a]]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nmatch l with\n| [] -> []\n| a :: b -> [listReverse b ; [a]]"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l =\nmatch l with\n| [] -> []\n| b :: [] -> b :: []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nmatch l with\n| [] -> []\n| b :: [] -> b :: []"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l =\nmatch l with\n| [] -> []\n| [a;b] -> 0", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nmatch l with\n| [] -> []\n| [a;b] -> 0"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l =\nmatch l with\n| [] -> []\n| [a;b] -> [a]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nmatch l with\n| [] -> []\n| [a;b] -> [a]"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l =\nlet last t =\nmatch t with\n| [] -> []\n| [a] -> a\n| a :: b -> last b\nin\nlast t :: listReverse l", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet last t =\nmatch t with\n| [] -> []\n| [a] -> a\n| a :: b -> last b\nin\nlast t :: listReverse l"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nmatch l with\n| [] -> []\n| a :: b -> listReverse b"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse [a]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nmatch l with\n| [] -> []\n| a :: b -> listReverse [a]"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l =\nlet last t = function\nmatch t with\n| [] -> []\n| [a] -> [a]\n| b :: c -> last c\nin last l", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet last t = function\nmatch t with\n| [] -> []\n| [a] -> [a]\n| b :: c -> last c\nin last l"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l =\nlet last t = function\n| [] -> []\n| [a] -> [a]\n| b :: c -> last c\nin last l", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet last t = function\n| [] -> []\n| [a] -> [a]\n| b :: c -> last c\nin last l"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l =\nlet rec last t =\nmatch t with\n| [] -> []\n| [a] -> [a]\n| b :: c -> last c\nin last l", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet rec last t =\nmatch t with\n| [] -> []\n| [a] -> [a]\n| b :: c -> last c\nin last l"}
{"fix": "let rec listReverse l =\nlet a = [] in\nlet get b = function\n| [] -> []\n| x :: xs -> x :: a\nin get l", "bad": "let rec listReverse l =\nlet a = [] in\nlet getHead b = function\nmatch b with\n| [] -> []\n| x :: xs ->\nx :: a\ngetHead xs\nin getHead l", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet a = [] in\nlet getHead b = function\nmatch b with\n| [] -> []\n| x :: xs ->\nx :: a\ngetHead xs\nin getHead l"}
{"fix": "let rec listReverse l =\nlet a = [] in\nlet get b = function\n| [] -> []\n| x :: xs -> x :: a\nin get l", "bad": "let rec listReverse l =\nlet a = [] in\nlet getHead b = function\n| [] -> []\n| x :: xs ->\nx :: a\ngetHead xs\nin getHead l", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet a = [] in\nlet getHead b = function\n| [] -> []\n| x :: xs ->\nx :: a\ngetHead xs\nin getHead l"}
{"fix": "let rec listReverse l =\nlet a = [] in\nlet get b = function\n| [] -> []\n| x :: xs -> x :: a\nin get l", "bad": "let rec listReverse l =\nlet a = [] in\nlet rec get a =\nmatch a with\n| [] -> []\n| x :: xs -> get xs :: [x]\nin get l", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet a = [] in\nlet rec get a =\nmatch a with\n| [] -> []\n| x :: xs -> get xs :: [x]\nin get l"}
{"fix": "let rec listReverse l =\nlet a = [] in\nlet get b = function\n| [] -> []\n| x :: xs -> x :: a\nin get l", "bad": "let rec listReverse l =\nlet a = [] in\nlet get a = function\n| [] -> []\n| x :: xs -> x :: a\nin get l", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet a = [] in\nlet get a = function\n| [] -> []\n| x :: xs -> x :: a\nin get l"}
{"fix": "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]", "bad": "let _ = listReverse [1; 2; 3; 4]", "annotated": "let _ = listReverse [1; 2; 3; 4]"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n =\nlet rec integers a b =\nmatch a with\n| [] -> b\n| x :: xs -> integers xs ((a mod 10)::b)\nin integers n []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nlet rec integers a b =\nmatch a with\n| [] -> b\n| x :: xs -> integers xs ((a mod 10)::b)\nin integers n []"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n =\nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse \nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n = 0 then [0]\nelse \nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []"}
{"fix": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse \nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []", "bad": "et _ = digitsOfInt 3124", "annotated": "et _ = digitsOfInt 3124"}
{"fix": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse \nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []", "bad": "let _ = digitsOfInt 3124", "annotated": "let _ = digitsOfInt 3124"}
{"fix": "let rec assoc (d,k,l) = match l with\n| []      ->\nd\n| h :: t  ->\nmatch h with\n| (s,l) ->\nif d = s then l\nelse assoc (d, k, t)", "bad": "let rec assoc (d,k,l) = match l with\n| []      ->\nd\n| h :: t  ->\nmatch h with\n| s * l ->\nif d = s then l\nelse assoc (d, k, t)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with\n| []      ->\nd\n| h :: t  ->\nmatch h with\n| s * l ->\nif d = s then l\nelse assoc (d, k, t)"}
{"fix": "let rec assoc (d,k,l) = match l with\n| []      ->\nd\n| h :: t  ->\nmatch h with\n| (s,l) ->\nif d = s then l\nelse assoc (d, k, t)", "bad": "let rec assoc (d,k,l) = match l with\n| []      ->\nd\n| h :: t  ->\nmatch h with\n| (s * l) ->\nif d = s then l\nelse assoc (d, k, t)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with\n| []      ->\nd\n| h :: t  ->\nmatch h with\n| (s * l) ->\nif d = s then l\nelse assoc (d, k, t)"}
{"fix": "let rec assoc (d,k,l) = match l with\n| []      ->\nd\n| h :: t  ->\nmatch h with\n| (s,l) ->\nif k = s then l\nelse assoc (d, k, t)", "bad": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let rec assoc (d,k,l) = match l with\n| []      ->\nd\n| h :: t  ->\nmatch h with\n| (s,l) ->\nif k = s then l\nelse assoc (d, k, t)", "bad": "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "bad": "let rec wwhile (f,b) =\nmatch (b',c')=(f b) in", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> \nmatch (b',c')=(f b) in"}
{"fix": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "bad": "let rec wwhile (f,b) =\nmatch (f b) in\n| (b',c') -> 0", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> \nmatch (f b) in\n| (b',c') -> 0"}
{"fix": "let fixpoint (f,b) =\nwwhile (f ? false : true,b)", "bad": "let fixpoint (f,b) =\nwwhile (f f b,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (f f b,b)"}
{"fix": "let fixpoint (f,b) =\nwwhile (f ? false : true,b)", "bad": "let fixpoint (f,b) =\nwwhile (,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (,b)"}
{"fix": "let fixpoint (f,b) =\nwwhile ((f b) b,b)", "bad": "let fixpoint (f,b) =\nwwhile (f b = b,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (f b = b,b)"}
{"fix": "let fixpoint (f,b) =\nwwhile ((f b) b,b)", "bad": "let fixpoint (f,b) =\nwwhile (fun x -> f x = b,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (fun x -> f x = b,b)"}
{"fix": "let fixpoint (f,b) =\nwwhile ((f b) b,b)", "bad": "let fixpoint (f,b) =\nwwhile (fun x -> (f x = b,b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (fun x -> (f x = b,b),b)"}
{"fix": "let fixpoint (f,b) =0", "bad": "*\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "*\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) =\nwwhile ((f b) b,b)", "bad": "*\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "*\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let rec assoc (d,k,l) =\nmatch l with\n| []      ->\nd\n| h :: t  ->\nmatch h with\n| (s,l) ->\nif k = s then l\nelse assoc (d, k, t)", "bad": "let fixpoint (f,b) =\nwwhile (equ f b,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (equ f b,b)"}
{"fix": "let rec assoc (d,k,l) =\nmatch l with\n| []      ->\nd\n| h :: t  ->\nmatch h with\n| (s,l) ->\nif k = s then l\nelse assoc (d, k, t)", "bad": "let fixpoint (f,b) =\nwwhile (if b=(f b) then true else false,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (if b=(f b) then true else false,b)"}
{"fix": "let rec assoc (d,k,l) =\nmatch l with\n| []      ->\nd\n| h :: t  ->\nmatch h with\n| (s,l) ->\nif k = s then l\nelse assoc (d, k, t)", "bad": "let fixpoint (f,b) =\nwwhile ((b,f b = b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile ((b,f b = b),b)"}
{"fix": "let rec assoc (d,k,l) =\nmatch l with\n| []      ->\nd\n| h :: t  ->\nmatch h with\n| (s,l) ->\nif k = s then l\nelse assoc (d, k, t)", "bad": "let fixpoint (f,b) =\nwwhile (fun b -> (b,f b = b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (fun b -> (b,f b = b),b)"}
{"fix": "let rec assoc (d,k,l) =\nmatch l with\n| []      ->\nd\n| h :: t  ->\nmatch h with\n| (s,l) ->\nif k = s then l\nelse assoc (d, k, t)", "bad": "let fixpoint (f,b) =\nwwhile (fun b -> (b,(f b) = b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (fun b -> (b,(f b) = b),b)"}
{"fix": "let rec assoc (d,k,l) =\nmatch l with\n| []      ->\nd\n| h :: t  ->\nmatch h with\n| (s,l) ->\nif k = s then l\nelse assoc (d, k, t)", "bad": "let fixpoint (f,b) =\nwwhile ((f b <> b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile ((f b <> b),b)"}
{"fix": "let rec assoc (d,k,l) =\nmatch l with\n| []      ->\nd\n| h :: t  ->\nmatch h with\n| (s,l) ->\nif k = s then l\nelse assoc (d, k, t)", "bad": "let fixpoint (f,b) =\nwwhile (fun b -> (f b <> b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (fun b -> (f b <> b),b)"}
{"fix": "let rec assoc (d,k,l) =\nmatch l with\n| []      ->\nd\n| h :: t  ->\nmatch h with\n| (s,l) ->\nif k = s then l\nelse assoc (d, k, t)", "bad": "let fixpoint (f,b) =\nwwhile (match (f,b) with | (b',c') -> (f b' <> b'),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (match (f,b) with | (b',c') -> (f b' <> b'),b)"}
{"fix": "let fixpoint (f,b) =\nwwhile (f,b)", "bad": "let fixpoint (f,b) =\nwwhile (not ((f b)=b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (not ((f b)=b),b)"}
{"fix": "let fixpoint (f,b) =\nwwhile (f,b)", "bad": "let fixpoint (f,b) =\nwwhile ((not f),((f b)=b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile ((not f),((f b)=b),b)"}
{"fix": "let fixpoint (f,b) =\nwwhile (f,b)", "bad": "let fixpoint (f,b) =\nwwhile (fun x -> not x,(f b)=b),b", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (fun x -> not x,(f b)=b),b"}
{"fix": "let fixpoint (f,b) =\nwwhile (f,b)", "bad": ")", "annotated": ")"}
{"fix": "let fixpoint (f,b) =\nwwhile (f,b)", "bad": "let fixpoint (f,b) =\nwwhile (x -> not x,(f b)=b),b", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (x -> not x,(f b)=b),b"}
{"fix": "let fixpoint (f,b) =\nwwhile (f,b)", "bad": ")", "annotated": ")"}
{"fix": "let fixpoint (f,b) =\nwwhile (f,b)", "bad": "let fixpoint (f,b) =\nwwhile ((x -> not x,(f b)=b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile ((x -> not x,(f b)=b),b)"}
{"fix": "let fixpoint (f,b) =\nwwhile (f,b)", "bad": "let fixpoint (f,b) =\nwwhile ((f,(f b)=b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile ((f,(f b)=b),b)"}
{"fix": "let fixpoint (f,b) =\nwwhile (f b,b)", "bad": "let fixpoint (f,b) =\nlet\nwwhile (fun f -> (f,(f b)=b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nlet\nwwhile (fun f -> (f,(f b)=b),b)"}
{"fix": "let fixpoint (f,b) =\nwwhile (f b,b)", "bad": "let fixpoint (f,b) =\nwwhile (fun f -> (f,(f b)=b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (fun f -> (f,(f b)=b),b)"}
{"fix": "let fixpoint (f,b) =\nwwhile (f b,b)", "bad": "let fixpoint (f,b) =\nwwhile ((f,(f b) = b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile ((f,(f b) = b),b)"}
{"fix": "let fixpoint (f,b) =\nwwhile (f b,b)", "bad": "let fixpoint (f,b) =\nwwhile (f -> (not f,(f b) = b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (f -> (not f,(f b) = b),b)"}
{"fix": "let fixpoint (f,b) =\nwwhile (f b,b)", "bad": "let fixpoint (f,b) =\nwwhile (let x -> not f in (x,(f b) = b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (let x -> not f in (x,(f b) = b),b)"}
{"fix": "let fixpoint (f,b) =\nwwhile (f b,b)", "bad": "let fixpoint (f,b) =\nwwhile (let x = not f in (x,(f b) = b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (let x = not f in (x,(f b) = b),b)"}
{"fix": "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (0,true) in func b,b)", "bad": "let fixpoint (f,b) =\nwwhile (fun x y -> (y,true) in func f b,b", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (fun x y -> (y,true) in func f b,b"}
{"fix": "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (0,true) in func b,b)", "bad": ")", "annotated": ")"}
{"fix": "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (0,true) in func b,b)", "bad": "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (0,true) in func f b,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (let func x = fun x -> (0,true) in func f b,b)"}
{"fix": "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (f b,(f b) = b) in func b,b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) =\nwwhile (let rec func x = fun x -> (f b,not ((f b) = b)) in func b,b)", "bad": "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (f b,(f b) = b) in func b,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (let func x = fun x -> (f b,(f b) = b) in func b,b)"}
{"fix": "let fixpoint (f,b) =\nwwhile (let rec func x = fun x -> (f b,not ((f b) = b)) in func b,b)", "bad": "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (f b,not ((f b) = b)) in func b,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (let func x = fun x -> (f b,not ((f b) = b)) in func b,b)"}
{"fix": "let fixpoint (f,b) =\nwwhile (let rec func x = fun x -> (f b,not ((f b) = b)) in func b,b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (f b,not ((f b) = b)) in func b,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (let func x = fun x -> (f b,not ((f b) = b)) in func b,b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) =\nwwhile (let _ = fun x -> (f b,not ((f b) = b)) in func b,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (let _ = fun x -> (f b,not ((f b) = b)) in func b,b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) =\nwwhile (fun x -> (f b,not ((f b) = b)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (fun x -> (f b,not ((f b) = b)),b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (f b,not ((f b) = b)) in func b,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (let func x = fun x -> (f b,not ((f b) = b)) in func b,b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (f b,not ((f b) = b)) in func b,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (let func x = fun x -> (f b,not ((f b) = b)) in func b,b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (f b,f b = b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (let func x = fun x -> (f b,f b = b),b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (f b,f b = b) in func,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (let func x = fun x -> (f b,f b = b) in func,b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (f x,f x = x),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (let func x = fun x -> (f x,f x = x),b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (f x,f x = x) in func,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (let func x = fun x -> (f x,f x = x) in func,b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) =\nwwhile (let func = fun x -> (f x,f x = x) in func,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (let func = fun x -> (f x,f x = x) in func,b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) =\nwwhile (let func = fun x -> (f x,f x <> x) in func,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (let func = fun x -> (f x,f x <> x) in func,b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e =\nmatch e with\nVarX\t\t\t\t      ->\n\"x\"\n| VarY\t\t\t\t\t->\n\"y\"\n| Sine    of\t\t\t\t->\n\"sin(\" ^ exprToString expr ^ \")\"\n| Cosine  of expr\t\t\t->\n\"cos(\" ^ exprToString expr ^ \")\"\n| Average of expr * expr\t\t->\n\"(\" ^ exprToString expr ^ \"+\" ^ exprToString expr ^ \")/2)\"\n| Times   of expr * expr\t\t->\n| Thresh  of expr * expr * expr * expr  ->", "annotated": "let rec exprToString : expr -> string = fun  e  -> \nmatch e with\nVarX\t\t\t\t      ->\n\"x\"\n| VarY\t\t\t\t\t->\n\"y\"\n| Sine    of\t\t\t\t->\n\"sin(\" ^ exprToString expr ^ \")\"\n| Cosine  of expr\t\t\t->\n\"cos(\" ^ exprToString expr ^ \")\"\n| Average of expr * expr\t\t->\n\"(\" ^ exprToString expr ^ \"+\" ^ exprToString expr ^ \")/2)\"\n| Times   of expr * expr\t\t->\n| Thresh  of expr * expr * expr * expr  ->"}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e =\nmatch e with\nVarX\t\t\t\t      ->\n\"x\"\n| VarY\t\t\t\t\t->\n\"y\"\n| Sine    of expr\t\t\t->\n\"sin(\" ^ exprToString expr ^ \")\"\n| Cosine  of expr\t\t\t->\n\"cos(\" ^ exprToString expr ^ \")\"\n| Average of expr * expr\t\t->\n\"(\" ^ exprToString expr ^ \"+\" ^ exprToString expr ^ \")/2)\"\n| Times   of expr * expr\t\t->\n| Thresh  of expr * expr * expr * expr  ->", "annotated": "let rec exprToString : expr -> string = fun  e  -> \nmatch e with\nVarX\t\t\t\t      ->\n\"x\"\n| VarY\t\t\t\t\t->\n\"y\"\n| Sine    of expr\t\t\t->\n\"sin(\" ^ exprToString expr ^ \")\"\n| Cosine  of expr\t\t\t->\n\"cos(\" ^ exprToString expr ^ \")\"\n| Average of expr * expr\t\t->\n\"(\" ^ exprToString expr ^ \"+\" ^ exprToString expr ^ \")/2)\"\n| Times   of expr * expr\t\t->\n| Thresh  of expr * expr * expr * expr  ->"}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e =\nmatch e with\nVarX\t\t\t\t      ->\n\"x\"\n| VarY\t\t\t\t\t->\n\"y\"\n| Sine    of expr\t\t\t->\n\"sin(\" ^ exprToString expr ^ \")\"\n| Cosine  of expr\t\t\t->\n\"cos(\" ^ exprToString expr ^ \")\"\n| Average of expr * expr\t\t->\n\"(\" ^ exprToString expr ^ \"+\" ^ exprToString expr ^ \")/2)\"\n| Times   of expr * expr\t\t->\n\"(\" ^ exprToString expr ^ \"*\" ^ exprToString expr ^ \")\"\n| Thresh  of expr * expr * expr * expr  ->\n\"(\" ^ expr ^ \"<\" ^ expr ^ \"?\" ^ expr ^ \":\" ^ expr ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  -> \nmatch e with\nVarX\t\t\t\t      ->\n\"x\"\n| VarY\t\t\t\t\t->\n\"y\"\n| Sine    of expr\t\t\t->\n\"sin(\" ^ exprToString expr ^ \")\"\n| Cosine  of expr\t\t\t->\n\"cos(\" ^ exprToString expr ^ \")\"\n| Average of expr * expr\t\t->\n\"(\" ^ exprToString expr ^ \"+\" ^ exprToString expr ^ \")/2)\"\n| Times   of expr * expr\t\t->\n\"(\" ^ exprToString expr ^ \"*\" ^ exprToString expr ^ \")\"\n| Thresh  of expr * expr * expr * expr  ->\n\"(\" ^ expr ^ \"<\" ^ expr ^ \"?\" ^ expr ^ \":\" ^ expr ^ \")\""}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e =\nmatch e with\nVarX\t\t\t\t      ->\n\"x\"\n| VarY\t\t\t\t\t->\n\"y\"\n| Sine of expr\t\t\t->\n\"sin(\" ^ exprToString expr ^ \")\"\n| Cosine  of expr\t\t\t->\n\"cos(\" ^ exprToString expr ^ \")\"\n| Average of expr * expr\t\t->\n\"(\" ^ exprToString expr ^ \"+\" ^ exprToString expr ^ \")/2)\"\n| Times   of expr * expr\t\t->\n\"(\" ^ exprToString expr ^ \"*\" ^ exprToString expr ^ \")\"\n| Thresh  of expr * expr * expr * expr  ->\n\"(\" ^ expr ^ \"<\" ^ expr ^ \"?\" ^ expr ^ \":\" ^ expr ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  -> \nmatch e with\nVarX\t\t\t\t      ->\n\"x\"\n| VarY\t\t\t\t\t->\n\"y\"\n| Sine of expr\t\t\t->\n\"sin(\" ^ exprToString expr ^ \")\"\n| Cosine  of expr\t\t\t->\n\"cos(\" ^ exprToString expr ^ \")\"\n| Average of expr * expr\t\t->\n\"(\" ^ exprToString expr ^ \"+\" ^ exprToString expr ^ \")/2)\"\n| Times   of expr * expr\t\t->\n\"(\" ^ exprToString expr ^ \"*\" ^ exprToString expr ^ \")\"\n| Thresh  of expr * expr * expr * expr  ->\n\"(\" ^ expr ^ \"<\" ^ expr ^ \"?\" ^ expr ^ \":\" ^ expr ^ \")\""}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e =\nmatch e with\nVarX\t\t\t\t      ->\n\"x\"\n| VarY\t\t\t\t\t->\n\"y\"\n| Sine expr\t\t\t->\n\"sin(\" ^ exprToString expr ^ \")\"\n| Cosine  of expr\t\t\t->\n\"cos(\" ^ exprToString expr ^ \")\"\n| Average of expr * expr\t\t->\n\"(\" ^ exprToString expr ^ \"+\" ^ exprToString expr ^ \")/2)\"\n| Times   of expr * expr\t\t->\n\"(\" ^ exprToString expr ^ \"*\" ^ exprToString expr ^ \")\"\n| Thresh  of expr * expr * expr * expr  ->\n\"(\" ^ expr ^ \"<\" ^ expr ^ \"?\" ^ expr ^ \":\" ^ expr ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  -> \nmatch e with\nVarX\t\t\t\t      ->\n\"x\"\n| VarY\t\t\t\t\t->\n\"y\"\n| Sine expr\t\t\t->\n\"sin(\" ^ exprToString expr ^ \")\"\n| Cosine  of expr\t\t\t->\n\"cos(\" ^ exprToString expr ^ \")\"\n| Average of expr * expr\t\t->\n\"(\" ^ exprToString expr ^ \"+\" ^ exprToString expr ^ \")/2)\"\n| Times   of expr * expr\t\t->\n\"(\" ^ exprToString expr ^ \"*\" ^ exprToString expr ^ \")\"\n| Thresh  of expr * expr * expr * expr  ->\n\"(\" ^ expr ^ \"<\" ^ expr ^ \"?\" ^ expr ^ \":\" ^ expr ^ \")\""}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e =\nmatch e with\nVarX\t\t\t\t      ->\n\"x\"\n| VarY\t\t\t\t\t->\n\"y\"\n| Sine    expr\t\t\t->\n\"sin(\" ^ exprToString expr ^ \")\"\n| Cosine  expr\t\t\t->\n\"cos(\" ^ exprToString expr ^ \")\"\n| Average expr * expr\t\t->\n\"(\" ^ exprToString expr ^ \"+\" ^ exprToString expr ^ \")/2)\"\n| Times   expr * expr\t\t->\n\"(\" ^ exprToString expr ^ \"*\" ^ exprToString expr ^ \")\"\n| Thresh  expr * expr * expr * expr  ->\n\"(\" ^ expr ^ \"<\" ^ expr ^ \"?\" ^ expr ^ \":\" ^ expr ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  -> \nmatch e with\nVarX\t\t\t\t      ->\n\"x\"\n| VarY\t\t\t\t\t->\n\"y\"\n| Sine    expr\t\t\t->\n\"sin(\" ^ exprToString expr ^ \")\"\n| Cosine  expr\t\t\t->\n\"cos(\" ^ exprToString expr ^ \")\"\n| Average expr * expr\t\t->\n\"(\" ^ exprToString expr ^ \"+\" ^ exprToString expr ^ \")/2)\"\n| Times   expr * expr\t\t->\n\"(\" ^ exprToString expr ^ \"*\" ^ exprToString expr ^ \")\"\n| Thresh  expr * expr * expr * expr  ->\n\"(\" ^ expr ^ \"<\" ^ expr ^ \"?\" ^ expr ^ \":\" ^ expr ^ \")\""}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e =\nmatch e with\nVarX\t\t\t\t  ->\n\"x\"\n| VarY\t\t\t\t    ->\n\"y\"\n| Sine    expr\t\t\t    ->\n\"sin(\" ^ exprToString expr ^ \")\"\n| Cosine  expr\t\t\t    ->\n\"cos(\" ^ exprToString expr ^ \")\"\n| Average (expr * expr)\t    ->\n\"(\" ^ exprToString expr ^ \"+\" ^ exprToString expr ^ \")/2)\"\n| Times   expr * expr\t\t    ->\n\"(\" ^ exprToString expr ^ \"*\" ^ exprToString expr ^ \")\"\n| Thresh  expr * expr * expr * expr ->\n\"(\" ^ expr ^ \"<\" ^ expr ^ \"?\" ^ expr ^ \":\" ^ expr ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  -> \nmatch e with\nVarX\t\t\t\t  ->\n\"x\"\n| VarY\t\t\t\t    ->\n\"y\"\n| Sine    expr\t\t\t    ->\n\"sin(\" ^ exprToString expr ^ \")\"\n| Cosine  expr\t\t\t    ->\n\"cos(\" ^ exprToString expr ^ \")\"\n| Average (expr * expr)\t    ->\n\"(\" ^ exprToString expr ^ \"+\" ^ exprToString expr ^ \")/2)\"\n| Times   expr * expr\t\t    ->\n\"(\" ^ exprToString expr ^ \"*\" ^ exprToString expr ^ \")\"\n| Thresh  expr * expr * expr * expr ->\n\"(\" ^ expr ^ \"<\" ^ expr ^ \"?\" ^ expr ^ \":\" ^ expr ^ \")\""}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e =\nmatch e with\nVarX\t\t\t\t  ->\n\"x\"\n| VarY\t\t\t\t    ->\n\"y\"\n| Sine    expr\t\t\t    ->\n\"sin(\" ^ exprToString expr ^ \")\"\n| Cosine  expr\t\t\t    ->\n\"cos(\" ^ exprToString expr ^ \")\"\n| Average (expr,expr)\t\t    ->\n\"(\" ^ exprToString expr ^ \"+\" ^ exprToString expr ^ \")/2)\"\n| Times   (expr,expr)\t\t    ->\n\"(\" ^ exprToString expr ^ \"*\" ^ exprToString expr ^ \")\"\n| Thresh  (expr,expr,expr,expr)     ->\n\"(\" ^ expr ^ \"<\" ^ expr ^ \"?\" ^ expr ^ \":\" ^ expr ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  -> \nmatch e with\nVarX\t\t\t\t  ->\n\"x\"\n| VarY\t\t\t\t    ->\n\"y\"\n| Sine    expr\t\t\t    ->\n\"sin(\" ^ exprToString expr ^ \")\"\n| Cosine  expr\t\t\t    ->\n\"cos(\" ^ exprToString expr ^ \")\"\n| Average (expr,expr)\t\t    ->\n\"(\" ^ exprToString expr ^ \"+\" ^ exprToString expr ^ \")/2)\"\n| Times   (expr,expr)\t\t    ->\n\"(\" ^ exprToString expr ^ \"*\" ^ exprToString expr ^ \")\"\n| Thresh  (expr,expr,expr,expr)     ->\n\"(\" ^ expr ^ \"<\" ^ expr ^ \"?\" ^ expr ^ \":\" ^ expr ^ \")\""}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e =\nmatch e with\nVarX\t\t\t\t  ->\n\"x\"\n| VarY\t\t\t\t    ->\n\"y\"\n| Sine    expr0\t\t\t    ->\n\"sin(\" ^ exprToString expr0 ^ \")\"\n| Cosine  expr0\t\t\t    ->\n\"cos(\" ^ exprToString expr0 ^ \")\"\n| Average (expr0,expr1)\t\t    ->\n\"(\" ^ exprToString expr0 ^ \"+\" ^ exprToString expr1 ^ \")/2)\"\n| Times   (expr0,expr1)\t\t    ->\n\"(\" ^ exprToString expr0 ^ \"*\" ^ exprToString expr1 ^ \")\"\n| Thresh  (expr0,expr1,expr2,expr3)     ->\n\"(\" ^ expr0 ^ \"<\" ^ expr1 ^ \"?\" ^ expr2 ^ \":\" ^ expr3 ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  -> \nmatch e with\nVarX\t\t\t\t  ->\n\"x\"\n| VarY\t\t\t\t    ->\n\"y\"\n| Sine    expr0\t\t\t    ->\n\"sin(\" ^ exprToString expr0 ^ \")\"\n| Cosine  expr0\t\t\t    ->\n\"cos(\" ^ exprToString expr0 ^ \")\"\n| Average (expr0,expr1)\t\t    ->\n\"(\" ^ exprToString expr0 ^ \"+\" ^ exprToString expr1 ^ \")/2)\"\n| Times   (expr0,expr1)\t\t    ->\n\"(\" ^ exprToString expr0 ^ \"*\" ^ exprToString expr1 ^ \")\"\n| Thresh  (expr0,expr1,expr2,expr3)     ->\n\"(\" ^ expr0 ^ \"<\" ^ expr1 ^ \"?\" ^ expr2 ^ \":\" ^ expr3 ^ \")\""}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e =\nmatch e with\nVarX\t\t\t\t  ->\n\"x\"\n| VarY\t\t\t\t    ->\n\"y\"\n| Sine    expr0\t\t\t    ->\n\"sin(\" ^ exprToString expr0 ^ \")\"\n| Cosine  expr0\t\t\t    ->\n\"cos(\" ^ exprToString expr0 ^ \")\"\n| Average (expr0,expr1)\t\t    ->\n\"(\" ^ exprToString expr0 ^ \"+\" ^ exprToString expr1 ^ \")/2)\"\n| Times   (expr0,expr1)\t\t    ->\n\"(\" ^ exprToString expr0 ^ \"*\" ^ exprToString expr1 ^ \")\"\n| Thresh  (expr0,expr1,expr2,expr3)     ->\n\"(\" ^ exprToString expr0 ^ \"<\" ^ exprToString expr1 ^ \"?\" ^ exprToString expr2 ^ \":\" ^ exprToString expr3 ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  -> \nmatch e with\nVarX\t\t\t\t  ->\n\"x\"\n| VarY\t\t\t\t    ->\n\"y\"\n| Sine    expr0\t\t\t    ->\n\"sin(\" ^ exprToString expr0 ^ \")\"\n| Cosine  expr0\t\t\t    ->\n\"cos(\" ^ exprToString expr0 ^ \")\"\n| Average (expr0,expr1)\t\t    ->\n\"(\" ^ exprToString expr0 ^ \"+\" ^ exprToString expr1 ^ \")/2)\"\n| Times   (expr0,expr1)\t\t    ->\n\"(\" ^ exprToString expr0 ^ \"*\" ^ exprToString expr1 ^ \")\"\n| Thresh  (expr0,expr1,expr2,expr3)     ->\n\"(\" ^ exprToString expr0 ^ \"<\" ^ exprToString expr1 ^ \"?\" ^ exprToString expr2 ^ \":\" ^ exprToString expr3 ^ \")\""}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) =\nmatch e with\nVarX\t\t\t\t  ->\nx\n| VarY\t\t\t\t    ->\ny\n| Sine    expr0\t\t\t    ->\nsin (eval (expr0,x,y))\n| Cosine  expr0\t\t\t    ->\ncos (eval (expr0,x,y))\n| Average (expr0,expr1)\t\t    ->\n(eval (expr0,x,y) +. eval (expr1,x,y)) /. 2.\n| Times (expr0,expr1)\t\t    ->\neval (expr0,x,y) *. eval (expr1,x,y)\n| Thresh  (expr0,expr1,expr2,expr3) ->\nmatch (eval (expr0,x,y) < eval (expr1,x,y)) with\ntrue  ->\neval (expr2,x,y)\n| false ->\neval (expr3,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  -> \nmatch e with\nVarX\t\t\t\t  ->\nx\n| VarY\t\t\t\t    ->\ny\n| Sine    expr0\t\t\t    ->\nsin (eval (expr0,x,y))\n| Cosine  expr0\t\t\t    ->\ncos (eval (expr0,x,y))\n| Average (expr0,expr1)\t\t    ->\n(eval (expr0,x,y) +. eval (expr1,x,y)) /. 2.\n| Times (expr0,expr1)\t\t    ->\neval (expr0,x,y) *. eval (expr1,x,y)\n| Thresh  (expr0,expr1,expr2,expr3) ->\nmatch (eval (expr0,x,y) < eval (expr1,x,y)) with\ntrue  ->\neval (expr2,x,y)\n| false ->\neval (expr3,x,y)"}
{"fix": "let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 -> buildX()\n| 1 -> buildY()\n)\n| _ ->\n(match rand (0,3) with\n0 ->\nbuildSine(build(rand,depth-1))\n| 1 ->\nbuildCosine(build(rand,depth-1))\n| 2 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n)", "bad": "let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 -> buildX()\n| 1 -> buildY()\n)\n| _ ->\n(match rand (0,4) with\n0 ->\nbuildSine(build(rand,depth-1))\n| 1 ->\nbuildCosine(build(rand,depth-1))\n| 2 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nmatch depth with\n0 ->\n(match rand (0,1) with\n0 -> buildX()\n| 1 -> buildY()\n)\n| _ ->\n(match rand (0,4) with\n0 ->\nbuildSine(build(rand,depth-1))\n| 1 ->\nbuildCosine(build(rand,depth-1))\n| 2 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n)"}
{"fix": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\n| Maximum  of expr * expr * expr\n| Absolute of expr", "bad": "let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 ->\nbuildX()\n| _ ->\nbuildY()\n)\n| _ ->\n(match rand (0,6) with\n0 ->\nbuildSine(build(rand,depth-1))\n| 1 ->\nbuildCosine(build(rand,depth-1))\n| 2 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 5 ->\nbuildMaximum(build(ran,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 6 ->\n)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nmatch depth with\n0 ->\n(match rand (0,1) with\n0 ->\nbuildX()\n| _ ->\nbuildY()\n)\n| _ ->\n(match rand (0,6) with\n0 ->\nbuildSine(build(rand,depth-1))\n| 1 ->\nbuildCosine(build(rand,depth-1))\n| 2 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 5 ->\nbuildMaximum(build(ran,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 6 ->\n)"}
{"fix": "let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 ->\nbuildX()\n| _ ->\nbuildY()\n)\n| _ ->\n(match rand (0,6) with\n0 ->\nbuildSine(build(rand,depth-1))\n| 1 ->\nbuildCosine(build(rand,depth-1))\n| 2 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 5 ->\nbuildMaximum(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ ->\nbuildAbsolute(build(rand,depth-1))\n)", "bad": "let rec build (rand, depth) =\nmatch depth with\n0 ->\n(match rand (0,1) with\n0 ->\nbuildX()\n| _ ->\nbuildY()\n)\n| _ ->\n(match rand (0,6) with\n0 ->\nbuildSine(build(rand,depth-1))\n| 1 ->\nbuildCosine(build(rand,depth-1))\n| 2 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 5 ->\nbuildMaximum(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 6 ->\nbuildAbsolute(build(rand,depth-1))\n)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nmatch depth with\n0 ->\n(match rand (0,1) with\n0 ->\nbuildX()\n| _ ->\nbuildY()\n)\n| _ ->\n(match rand (0,6) with\n0 ->\nbuildSine(build(rand,depth-1))\n| 1 ->\nbuildCosine(build(rand,depth-1))\n| 2 ->\nbuildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 ->\nbuildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 ->\nbuildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 5 ->\nbuildMaximum(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 6 ->\nbuildAbsolute(build(rand,depth-1))\n)"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let pipe fs n = \nlet f a x = x a in\nlet base n = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = f a x in\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = f a x in\nlet base = 0 in\nList.fold_left f base fs"}
{"fix": "let pipe fs n = \nlet f a x = x a in\nlet base n = 0 in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs n = \nlet f a x = x a in\nlet base n = 0 in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs n = \nlet f a x = x a in\nlet base n = 0 in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let pipe fs n = \nlet f a x = x a in\nlet base n = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = x in\nList.fold_left f base fs"}
{"fix": "let pipe fs n = \nlet f a x = x a in\nlet base n = 0 in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs n = \nlet f a x = x a in\nlet base n = 0 in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs n = \nlet f a x = x a in\nlet base n = 0 in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = \"\" in\nlet l =  in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = \"\" in\nlet l =  in\nList.fold_left f base l"}
{"fix": "let stringOfList f l = \"[ \" ^ sepConcat \"; \" l ^ \" ]\"", "bad": "let stringOfList f l = \"[ \" ^ sepConCat \"; \" l ^ \" ]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[ \" ^ sepConCat \"; \" l ^ \" ]\""}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = (0,0) in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = (0,0) in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (0, a + x) in\nlet base = (0,0) in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = (0, a + x) in\nlet base = (0,0) in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = (0,0) in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = (0,0) in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = l1 in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = l1 in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = (_, l1) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = (_, l1) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = (0, l1) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = (0, l1) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = in\nlet base = in\nlet args = in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = in\nlet base = in\nlet args = in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (a, a+x) in\nlet base = 0 in\nlet args = 1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = (a, a+x) in\nlet base = 0 in\nlet args = 1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (a, a+x) in\nlet base = 0 in\nlet args = [1] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = (a, a+x) in\nlet base = 0 in\nlet args = [1] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch a with \nah::at  ->\nmatch x with\nxh::xt  ->\nah+at\nin\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =\nmatch a with \nah::at  ->\nmatch x with\nxh::xt  ->\nah+at\nin\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch a with \nah::at  ->\nmatch x with\nxh::xt  ->\nah+xh\nin\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =\nmatch a with \nah::at  ->\nmatch x with\nxh::xt  ->\nah+xh\nin\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch x with \n(ah::at, bh::bt)  ->\n(1,(ah+bh)::a)\nin\nlet base = [] in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =\nmatch x with \n(ah::at, bh::bt)  ->\n(1,(ah+bh)::a)\nin\nlet base = [] in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch x with \n(ah::at, bh::bt)  ->\n(1,(ah+bh)::a)\nin\nlet base = (0, []) in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =\nmatch x with \n(ah::at, bh::bt)  ->\n(1,(ah+bh)::a)\nin\nlet base = (0, []) in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let padZero l1 l2 =\nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nmatch length1 >= length2 with\ntrue  ->\nlet n = length1 - length2 in\nlet zeroes = clone 0 n in\n(l1, List.append zeroes l2)\n\n| false ->\nlet n = length2 - length1 in\nlet zeroes = clone 0 n in\n(List.append zeroes l1, l2)", "bad": "let padZero l1 l2 =\nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nmatch length1 >= length2 with\ntrue  ->\nlet n = length1 - length2 in\nlet zeroes = clone 0 n in\n(l1, List.append (zeroes l2))\n\n| false ->\nlet n = length2 - length1 in\nlet zeroes = clone 0 n in\n(List.append (zeroes l1, l2))", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nmatch length1 >= length2 with\ntrue  ->\nlet n = length1 - length2 in\nlet zeroes = clone 0 n in\n(l1, List.append (zeroes l2))\n\n| false ->\nlet n = length2 - length1 in\nlet zeroes = clone 0 n in\n(List.append (zeroes l1, l2))"}
{"fix": "let padZero l1 l2 =\nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nmatch length1 >= length2 with\ntrue  ->\nlet n = length1 - length2 in\nlet zeroes = clone 0 n in\n(l1, List.append zeroes l2)\n\n| false ->\nlet n = length2 - length1 in\nlet zeroes = clone 0 n in\n(List.append zeroes l1, l2)", "bad": "let padZero l1 l2 =\nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nmatch length1 >= length2 with\ntrue  ->\nlet n = length1 - length2 in\nlet zeroes = clone 0 n in\n(l1, List.append (zeroes l2))\n\n| false ->\nlet n = length2 - length1 in\nlet zeroes = clone 0 n in\n(List.append (zeroes l1), l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nmatch length1 >= length2 with\ntrue  ->\nlet n = length1 - length2 in\nlet zeroes = clone 0 n in\n(l1, List.append (zeroes l2))\n\n| false ->\nlet n = length2 - length1 in\nlet zeroes = clone 0 n in\n(List.append (zeroes l1), l2)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\n(*\nlet f a x = (0,[]) in\nlet base = (l1, []) in\nlet args = l2 in*)\nlet (_, res) = (0,[0;0;0;0])(*List.fold_left f base args*) in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\n(*\nlet f a x = (0,[]) in\nlet base = (l1, []) in\nlet args = l2 in*)\nlet (_, res) = (0;[0;0;0;0])(*List.fold_left f base args*) in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\n(*\nlet f a x = (0,[]) in\nlet base = (l1, []) in\nlet args = l2 in*)\nlet (_, res) = (0;[0;0;0;0])(*List.fold_left f base args*) in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = (0,[0;0;0;0]) in\nlet base = (0,[0;0;0;0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = (0,[0;0;0;0]) in\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = (0,[0;0;0;0]) in\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = (0,[0;0;0;0]) in\nlet base = (0,[0;0;0;0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = (0,[0;0;0;0]) in\nlet base = (l1) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = (0,[0;0;0;0]) in\nlet base = (l1) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = (0,[0;0;0;0]) in\nlet base = (0,[0;0;0;0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = (0,[0;0;0;0]) in\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = (0,[0;0;0;0]) in\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = (0,[0;0;0;0]) in\nlet base = (0,l1) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = (0,[0;0;0;0]) in\nlet base = (0,[]) in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = (0,[0;0;0;0]) in\nlet base = (0,[]) in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =(*\nmatch a with\n[]  ->\n([],[])\n| h1::t1  ->*)\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = function  ->\nmatch a with\n[]  ->\n([],[])\n| h1::t1  ->\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = function  ->\nmatch a with\n[]  ->\n([],[])\n| h1::t1  ->\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =(*\nmatch a with\n[]  ->\n([],[])\n| h1::t1  ->*)\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = function\nmatch a with\n[]  ->\n([],[])\n| h1::t1  ->\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = function\nmatch a with\n[]  ->\n([],[])\n| h1::t1  ->\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =(*\nmatch a with\n[]  ->\n([],[])\n| h1::t1  ->*)\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = fun\nmatch a with\n[]  ->\n([],[])\n| h1::t1  ->\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = fun\nmatch a with\n[]  ->\n([],[])\n| h1::t1  ->\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =(*\nmatch a with\n[]  ->\n([],[])\n| h1::t1  ->*)\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n[]  ->\n([],[])\n| h1::t1  ->\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n[]  ->\n([],[])\n| h1::t1  ->\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1,_)  ->\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n[]  ->\n(l1,[0;0;0;0])\n| h1::t1  ->\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n[]  ->\n(l1,[0;0;0;0])\n| h1::t1  ->\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1,_)  ->\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\nh1::t1  ->\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x =\nmatch a with\nh1::t1  ->\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, rh::rt)  ->\n(t1,((h1+x+rh) mod 10)::rt)\nin\nlet base = (l1,[0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nPrintf.printf(%d, a)\nmatch a with\n(h1::t1, rh::rt)  ->\n(t1,((h1+x+rh) mod 10)::rt)\nin\nlet base = (l1,[0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x =\nPrintf.printf(%d, a)\nmatch a with\n(h1::t1, rh::rt)  ->\n(t1,((h1+x+rh) mod 10)::rt)\nin\nlet base = (l1,[0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, rh::rt)  ->\n(t1,(h1+x+rh)/10::((h1+x+rh) mod 10)::rt)\nin\nlet base = (l1,[0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, rh::rt)  ->\n(t1,(h1+x+rh)/10)::((h1+x+rh) mod 10)::rt", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, rh::rt)  ->\n(t1,(h1+x+rh)/10)::((h1+x+rh) mod 10)::rt"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, rh::rt)  ->\n(t1,(h1+x+rh)/10::((h1+x+rh) mod 10)::rt)\nin\nlet base = (l1,[0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": ")\nin\nlet base = (l1,[0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": ")\nin\nlet base = (l1,[0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\n(List.tl (List.rev (h1::t1)), (h1+x)/10::((h1+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\n(List.tl (List.rev (h1::t1)), (h1+x+rh)/10::((h1+x+rh) mod 10)::rt)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\n(List.tl List.rev h1::t1, (h1+x)/10::((h1+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\n(List.tl List.rev h1::t1, (h1+x+rh)/10::((h1+x+rh) mod 10)::rt)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\n(List.tl List.rev h1::t1, (h1+x)/10::((h1+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\n(List.tl List.rev h1::t1, (h1+x+rh)/10::((h1+x+rh) mod 10)::rt)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\nlet h2::t2 = List.rev (h1::t1) in\n(List.rev t2, (h2+x)/10::((h2+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\nlet h2::t2 = List.rev (h1::t1) in\n(List.rev t2, (h2+x+rh)/10::((h2+x+rh) mod 10)::rt)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\nlet h2::t2 = List.rev h1::t1 in\n(List.rev t2, (h2+x)/10::((h2+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\nlet h2::t2 = List.rev h1::t1 in\n(List.rev t2, (h2+x+rh)/10::((h2+x+rh) mod 10)::rt)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\nlet h2::t2 = List.rev h1::t1 in\n(List.rev t2, (h2+x)/10::((h2+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\nlet h2::t2 = List.rev h1::t1 in\n(List.rev t2, (h2+x+rh)/10::((h2+x+rh) mod 10)::rt)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\nlet h2::t2 = List.rev (h1::t1) in\n(List.rev t2, (h2+x)/10::((h2+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\nlet h2::t2 = List.rev (h1::t1) in\n(List.rev t2, (h2+x+rh)/10::((h2+x+rh) mod 10)::rt)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\nlet h2::t2 = List.rev h1::t1 in\n(List.rev t2, (h2+x)/10::((h2+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\nlet h2::t2 = List.rev h1::t1 in\n(List.rev t2, (h2+x+rh)/10::((h2+x+rh) mod 10)::rt)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\nlet h2::t2 = List.rev h1::t1 in\n(List.rev t2, (h2+x)/10::((h2+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\nlet h2::t2 = List.rev h1::t1 in\n(List.rev t2, (h2+x+rh)/10::((h2+x+rh) mod 10)::rt)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigMul l1 l2 = \nlet f a x = match a with\n(h1::t1, rh::rt)  ->\n(t1, bigAdd (mulByDigit h1 (rh::rt)) rt)\nin\nlet base = (List.rev l1, [0]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = match a with\n(h1::t1, rh::rt)  ->\n(t1, bigAdd (mulByDigit h1 rh::rt) rt)\nin\nlet base = (List.rev l1, [0]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match a with\n(h1::t1, rh::rt)  ->\n(t1, bigAdd (mulByDigit h1 rh::rt) rt)\nin\nlet base = (List.rev l1, [0]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = match a with\n(h1::t1, rh::rt)  ->\n(t1, bigAdd (mulByDigit h1 (rh::rt)) rt)\nin\nlet base = (List.rev l1, [0]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "annotated": "let _ = bigMul [9;9;9;9] [9;9;9;9]"}
{"fix": "let bigMul l1 l2 = \nlet f a x = match a with\n(h1::t1, r) ->\n(h1::t1, bigAdd (mulByDigit x (h1::t1)) r)\n| _\t      ->\n(* Should not get here *) ([], [])\nin\nlet base = (List.rev l1, [1]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = match a with\n(h1::t1, r) ->\n(h1::t1, bigAdd (mulByDigit x h1::t1) r)\n| _\t      ->\n(* Should not get here *) ([], [])\nin\nlet base = (List.rev l1, [1]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match a with\n(h1::t1, r) ->\n(h1::t1, bigAdd (mulByDigit x h1::t1) r)\n| _\t      ->\n(* Should not get here *) ([], [])\nin\nlet base = (List.rev l1, [1]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = match a with\n(h1::t1, r) ->\n(h1::t1, bigAdd (mulByDigit x (h1::t1)) r)\n| _\t      ->\n(* Should not get here *) ([], [])\nin\nlet base = (List.rev l1, [1]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let _ = bigMul [2] [1]", "annotated": "let _ = bigMul [2] [1]"}
{"fix": "let pipe fs n =\nlet f a x = x a in\nlet base = n in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = n in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = n in\nList.fold_left f base fs"}
{"fix": "let pipe fs n =\nlet f a x = x a in\nlet base = n in\nList.fold_left f base fs", "bad": "let pipe fs = fun\nlet f a x = x a in\nlet base = n in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  fun\nlet f a x = x a in\nlet base = n in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =\nmatch x with\n[]  ->\n\n| _   ->\nx a\nin\nlet base = n in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fun x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =\nmatch x with\n[]  ->\n1\n| _   ->\n0\n\nin\nlet base = f 0 [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =\nlet g b y n =\nmatch n with\n[]  ->\nn\n| _   ->\ny b\nin g a x\nin\nlet base = f 0 [] in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =\nlet g b y n =\nmatch n with\n[]  ->\nn\n| _   ->\ny b\nin g a x\nin\nlet base = f 0 [] in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =\nmatch a with\n[]  ->\n[]\n| _   ->\nx a\nin\nlet base = f [] (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =\nmatch x with\n[]  ->\n1\n| _   ->\nx a\nin\nlet base = f 0 [] in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =\nmatch x with\n[]  ->\n1\n| _   ->\nx a\nin\nlet base = f 0 [] in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =\nmatch a with\n[]  ->\n[]\n| _   ->\nx a\nin\nlet base = f [] (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =\nmatch x with\n[]  ->\n[]\n| _   ->\nx a\nin\nlet base = f 0 [] in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =\nmatch x with\n[]  ->\n[]\n| _   ->\nx a\nin\nlet base = f 0 [] in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =\nfun a x ->\nmatch x with\nx',y  ->\nx' a\nin\nlet base = f 0 [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =\nmatch x with\n[]  ->\n[]\n| _   ->\nx a\nin\nlet base = f 0 [] in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =\nmatch x with\n[]  ->\n[]\n| _   ->\nx a\nin\nlet base = f 0 [] in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =\nfun a x ->\nmatch x with\nx',y  ->\nx' a\nin\nlet base = f 0 [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =\nmatch x with\n[] ->\na\n| _  ->\nx a\nin\nlet base = f 0 [] in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =\nmatch x with\n[] ->\na\n| _  ->\nx a\nin\nlet base = f 0 [] in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =\nfun a x ->\nmatch x with\nx',y  ->\nx' a\nin\nlet base = f 0 [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =\nfun g b y z ->\nmatch y with\n[] ->\nz\n| _  ->\nb a\nin\nlet base = f 0 [] in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =\nfun g b y z ->\nmatch y with\n[] ->\nz\n| _  ->\nb a\nin\nlet base = f 0 [] in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =\nfun a x ->\nmatch x with\nx',y  ->\nx' a\nin\nlet base = f 0 [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =\nfun a x ->\nmatch x with\nx' y  ->\nmatch x' with\n[]  ->\ny\n| _   ->\nx' a\nin\nlet base = f 0 [] in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =\nfun a x ->\nmatch x with\nx' y  ->\nmatch x' with\n[]  ->\ny\n| _   ->\nx' a\nin\nlet base = f 0 [] in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =\nfun a x ->\nmatch x with\nx',y  ->\nx' a\nin\nlet base = f 0 [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =\nfun a x ->\nmatch x with\nx',y  ->\nmatch x' with\n[]  ->\ny\n| _   ->\nx' a\nin\nlet base = f 0 [] in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =\nfun a x ->\nmatch x with\nx',y  ->\nmatch x' with\n[]  ->\ny\n| _   ->\nx' a\nin\nlet base = f 0 [] in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =\nmatch x with\n[]  ->\n0\n| _   ->\n1\nin\nlet base = 0 in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x =\nmatch x with\n[]  ->\n0\n| _   ->\n1\nin\nlet base = 0 in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x =\nmatch x with\n[]  ->\n0\n| _   ->\n1\nin\nlet base = 0 in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let pipe fs = \nlet f a x =\nmatch x with\n[]  ->\n0\n| _   ->\n1\nin\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =\nmatch x with\n[]  ->\n0\n| _   ->\n1\nin\nlet base = [] in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =\nmatch x with\n[]  ->\n0\n| _   ->\n1\nin\nlet base = [] in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =\nx a\nin\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =\nmatch x with\n[]  ->\na\n| _   ->\nx a\nin\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =\nmatch x with\n[]  ->\na\n| _   ->\nx a\nin\nlet base = 0 in\nList.fold_left f base fs"}
{"fix": "let pipe fs n = \nlet f a x = x a in\nlet base = n in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =\nx\nin\nlet base = a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =\nx\nin\nlet base = a in\nList.fold_left f base fs"}
{"fix": "let pipe fs n = \nlet f a x = x a in\nlet base = n in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =\nx\nin\nlet base = f x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =\nx\nin\nlet base = f x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x y -> y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base =match fs with\n(fn,n)  -> n in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base =match fs with\n(fn,n)  -> n in\nList.fold_left f base fs"}
{"fix": "let pipe fs =\nlet f a x = fun fn -> fun x a -> fn in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let pipe fs =\nlet f a x = let fn = fun x a in fn in\nlet base = fun b -> b in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> \nlet f a x = let fn = fun x a in fn in\nlet base = fun b -> b in\nList.fold_left f base fs"}
{"fix": "let pipe fs =\nlet f a x = fun y -> x a in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let pipe fs =\nlet f a x = fun y -> x base in\nlet base = fun b -> b in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> \nlet f a x = fun y -> x base in\nlet base = fun b -> b in\nList.fold_left f base fs"}
{"fix": "let pipe fs =\nlet f a x = fun y -> fun z -> y z in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let pipe fs =\nlet f a x = match x with\nfun y -> y a in\nlet base = fun b -> b in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> \nlet f a x = match x with\nfun y -> y a in\nlet base = fun b -> b in\nList.fold_left f base fs"}
{"fix": "let pipe fs =\nlet f a x = fun y -> fun z -> y z in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let pipe fs =\nlet f a x = match x with\n(fun y) -> y a in\nlet base = fun b -> b in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> \nlet f a x = match x with\n(fun y) -> y a in\nlet base = fun b -> b in\nList.fold_left f base fs"}
{"fix": "let pipe fs =\nlet f a x = fun y -> fun z -> y z in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let pipe fs =\nlet f a x = match x with\n(function y) -> y a in\nlet base = fun b -> b in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> \nlet f a x = match x with\n(function y) -> y a in\nlet base = fun b -> b in\nList.fold_left f base fs"}
{"fix": "let pipe fs =\nlet f a x = fun y -> x a in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs =\nlet f a x = fun y -> x a in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs =\nlet f a x = fun y -> x a in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let pipe fs =\nlet f a x = fun y -> x a in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let pipe fs =\nlet f a x = fun y -> x a in\nlet base = b in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> \nlet f a x = fun y -> x a in\nlet base = b in\nList.fold_left f base fs"}
{"fix": "let pipe fs =\nlet f a x = fun y -> x a in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let pipe fs =\nlet f a x = fun y -> x a in\nlet base = fun b in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> \nlet f a x = fun y -> x a in\nlet base = fun b in\nList.fold_left f base fs"}
{"fix": "let pipe fs =\nlet f a x = fun y -> x a in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let pipe fs =\nlet f a x = fun y -> x a in\nlet base = fun b -> fun b in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> \nlet f a x = fun y -> x a in\nlet base = fun b -> fun b in\nList.fold_left f base fs"}
{"fix": "let pipe fs =\nlet f a x = let an = a in x an in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let pipe fs =\nlet f a x = fun y -> fun z -> z (fun r -> y) in\nlet base = fun b -> b in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> \nlet f a x = fun y -> fun z -> z (fun r -> y) in\nlet base = fun b -> b in\nList.fold_left f base fs"}
{"fix": "let pipe fs =\nlet f a x = let an = a in x an in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let pipe fs =\nlet f a x = fun y -> fun z -> z (fun r -> y) in\nlet base = fun b -> b in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> \nlet f a x = fun y -> fun z -> z (fun r -> y) in\nlet base = fun b -> b in\nList.fold_left f base fs"}
{"fix": "let pipe fs =\nlet f a x = let an = a in x an in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let pipe fs =\nlet f a x = fun y -> fun z -> z y in\nlet base = fun b -> b in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> \nlet f a x = fun y -> fun z -> z y in\nlet base = fun b -> b in\nList.fold_left f base fs"}
{"fix": "let pipe fs =\nlet f a x = let y = a in x y in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let pipe fs =\nlet f a x = let fun y z = fun xn -> fun an -> xn an in y in\nlet base = fun b -> b in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> \nlet f a x = let fun y z = fun xn -> fun an -> xn an in y in\nlet base = fun b -> b in\nList.fold_left f base fs"}
{"fix": "let pipe fs =\nlet f a x = let y = a in x y in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let pipe fs =\nlet f a x = let y z = fun xn -> xn a in y in\nlet base = fun b -> b in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> \nlet f a x = let y z = fun xn -> xn a in y in\nlet base = fun b -> b in\nList.fold_left f base fs"}
{"fix": "let pipe fs =\nlet f a x = let y = a in x y in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let pipe fs =\nlet f a x = let y z = fun xn -> xn a in y in\nlet base = fun b -> b in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> \nlet f a x = let y z = fun xn -> xn a in y in\nlet base = fun b -> b in\nList.fold_left f base fs"}
{"fix": "let pipe fs =\nlet f a x = let y = pipe x a in y in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let pipe fs =\nlet f a x = let y = pipe x a in x y in\nlet base = fun b -> b in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> \nlet f a x = let y = pipe x a in x y in\nlet base = fun b -> b in\nList.fold_left f base fs"}
{"fix": "let pipe fs =\nlet f a x = x(a) in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let pipe fs =\nlet f a x = f x(a) in\nlet base = fun b -> b in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> \nlet f a x = f x(a) in\nlet base = fun b -> b in\nList.fold_left f base fs"}
{"fix": "let pipe fs =\nlet f a x = fun y z -> z (x (a)) in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let pipe fs =\nlet f a x = fun c y z -> z (a (c)) in\nlet base = fun b -> b in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> \nlet f a x = fun c y z -> z (a (c)) in\nlet base = fun b -> b in\nList.fold_left f base fs"}
{"fix": "let pipe fs =\nlet f a x = fun y z -> z (x (a)) in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let pipe fs =\nlet f a x = fun y z -> z (a (c)) in\nlet base = fun b -> b in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> \nlet f a x = fun y z -> z (a (c)) in\nlet base = fun b -> b in\nList.fold_left f base fs"}
{"fix": "let pipe fs =\nlet f a x = fun c -> x (a) in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let pipe fs =\nlet f a x = fun c -> c (x (a)) in\nlet base = fun b -> b in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> \nlet f a x = fun c -> c (x (a)) in\nlet base = fun b -> b in\nList.fold_left f base fs"}
{"fix": "let pipe fs =\nlet f a x = fun c -> x c in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs =\nlet f a x = fun c -> fun d -> x c in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs =\nlet f a x = fun c -> fun d -> x c in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs =\nlet f a x = fun c -> fun d -> x c in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let pipe fs =\nlet f a x = fun c -> x (fun d -> a) in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs =\nlet f a x = fun c -> x (fun d -> a) in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs =\nlet f a x = fun c -> x (fun d -> a) in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let pipe fs =\nlet f a x = fun c -> x (fun d -> a) in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let pipe fs =\nlet f a x = fun c -> fun d -> d c in\nlet base = fun b -> b in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> \nlet f a x = fun c -> fun d -> d c in\nlet base = fun b -> b in\nList.fold_left f base fs"}
{"fix": "let pipe fs =\nlet f a x = fun c -> x (fun d -> a) in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs =\nlet f a x = fun c -> x (fun d -> a) in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs =\nlet f a x = fun c -> x (fun d -> a) in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let pipe fs =\nlet f a x = fun c -> x (fun d -> a) in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let pipe fs =\nlet f a x = fun c -> a in\nlet base = fun b -> b in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> \nlet f a x = fun c -> a in\nlet base = fun b -> b in\nList.fold_left f base fs"}
{"fix": "let pipe fs =\nlet f a x = fun c -> x (fun d -> a) in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs =\nlet f a x = fun c -> x (fun d -> a) in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs =\nlet f a x = fun c -> x (fun d -> a) in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let pipe fs =\nlet f a x = fun c -> x in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs =\nlet f a x = fun c -> x in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs =\nlet f a x = fun c -> x in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> k\n| (s,i)::xs -> if k = s then i else assoc (d,k,xs)", "bad": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> k\n| (s,i):xs -> if k = s then i else assoc (d,k,xs)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  \nmatch l with\n| [] -> k\n| (s,i):xs -> if k = s then i else assoc (d,k,xs)"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> k\n| (s,i)::xs -> if k = s then i else assoc (d,k,xs)", "bad": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> k\n| x:xs -> let x = (s,i) in\nif k = s then i else assoc (d,k,xs)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  \nmatch l with\n| [] -> k\n| x:xs -> let x = (s,i) in\nif k = s then i else assoc (d,k,xs)"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> k\n| (s,i)::xs -> if k = s then i else assoc (d,k,xs)", "bad": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> k\n| x::xs -> let x = (s,i) in\nif k = s then i else assoc (d,k,xs)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  \nmatch l with\n| [] -> k\n| x::xs -> let x = (s,i) in\nif k = s then i else assoc (d,k,xs)"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (s,i)::xs -> if k = s then i else assoc (d,k,xs)", "bad": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (s,i)::xs -> if k = s then i else assoc (d,k,xs)", "bad": "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let rec wwhile (f,b) = \nlet calc = f b in\nlet (b',c') = calc in\nif c' then wwhile (f,b') else b'", "bad": "let rec wwhile (f,b) = \nlet calc = f b in\nlet (b',c') = calc in\nif c' then f b' else b'", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet calc = f b in\nlet (b',c') = calc in\nif c' then f b' else b'"}
{"fix": "let rec wwhile (f,b) = \nlet calc = f b in\nlet (b',c') = calc in\nif c' then wwhile (f,b') else b'", "bad": "let rec wwhile (f,b) = \nlet calc = f b in\nlet (b',c') = calc in\nif c' then f (b') else b'", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet calc = f b in\nlet (b',c') = calc in\nif c' then f (b') else b'"}
{"fix": "let rec wwhile (f,b) = \nlet calc = f b in\nlet (b',c') = calc in\nif c' then wwhile (f,b') else b'", "bad": "let rec wwhile (f,b) = \nlet calc = f b in\nlet (b',c') = calc in\nif c' then (f b') else b'", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet calc = f b in\nlet (b',c') = calc in\nif c' then (f b') else b'"}
{"fix": "let fixpoint (f,b) = wwhile ((f),b)", "bad": " fixpoint (f,b) = wwhile ((f b),b)", "annotated": " fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((f b),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((f),b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = wwhile ((let f x = f x in f b),b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = wwhile ((fun x -> f b),b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = wwhile ((fun x -> f b),b)", "bad": "let fixpoint (f,b) = wwhile ((let f x = wwhile(f,x) in f b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f x  ->  wwhile(f,x) in f b),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let f x = f b in f),b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = wwhile ((fun x -> (f x,f x!=x)),b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = wwhile ((fun x -> (f x,f x!=x)),b)", "bad": "let fixpoint (f,b) = wwhile ((fun x -> (f x,f x!=b)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun x -> (f x,f x! -> b)),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((fun x -> (f x,f x!=x)),b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine x -> \"sin(pi*%s)\" x\n| Cosine x -> \"cos(pi*%s)\" x\n| Average x y -> \"((%s+%s)/2)\" x y\n| Times x y -> \"%s*%s\" x y\n| Thresh x y z a -> \"%s<%s?%s:%s\" x y z a", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\""}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine x -> \"sin(pi*%s)\" x\n| Cosine x -> \"cos(pi*%s)\" x\n| Average (x,y) -> \"((%s+%s)/2)\" x y\n| Times (x,y) -> \"%s*%s\" x y\n| Thresh (x,y,z,a) -> \"%s<%s?%s:%s\" x y z a", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine x -> \"sin(pi*%s)\" x\n| Cosine x -> \"cos(pi*%s)\" x\n| Average (x,y) -> \"((%s+%s)/2)\" x y\n| Times (x,y) -> \"%s*%s\" x y\n| Thresh (x,y,z,a) -> \"%s<%s?%s:%s\" x y z a"}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine x -> sprintf \"sin(pi*%s)\" x\n| Cosine x -> sprintf \"cos(pi*%s)\" x\n| Average (x,y) -> sprintf \"((%s+%s)/2)\" x y\n| Times (x,y) -> sprintf \"%s*%s\" x y\n| Thresh (x,y,z,a) -> sprintf \"%s<%s?%s:%s\" x y z a", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine x -> sprintf \"sin(pi*%s)\" x\n| Cosine x -> sprintf \"cos(pi*%s)\" x\n| Average (x,y) -> sprintf \"((%s+%s)/2)\" x y\n| Times (x,y) -> sprintf \"%s*%s\" x y\n| Thresh (x,y,z,a) -> sprintf \"%s<%s?%s:%s\" x y z a"}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = match e with\n| VarX -> Printf.sprintf \"x\"\n| VarY -> Printf.sprintf \"y\"\n| Sine x -> Printf.sprintf \"sin(pi*%s)\" x\n| Cosine x -> Printf.sprintf \"cos(pi*%s)\" x\n| Average (x,y) -> Printf.sprintf \"((%s+%s)/2)\" x y\n| Times (x,y) -> Printf.sprintf \"%s*%s\" x y\n| Thresh (x,y,z,a) -> Printf.sprintf \"%s<%s?%s:%s\" x y z a", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> Printf.sprintf \"x\"\n| VarY -> Printf.sprintf \"y\"\n| Sine x -> Printf.sprintf \"sin(pi*%s)\" x\n| Cosine x -> Printf.sprintf \"cos(pi*%s)\" x\n| Average (x,y) -> Printf.sprintf \"((%s+%s)/2)\" x y\n| Times (x,y) -> Printf.sprintf \"%s*%s\" x y\n| Thresh (x,y,z,a) -> Printf.sprintf \"%s<%s?%s:%s\" x y z a"}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\" ^ exprToString x ^ \"+\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (x,y,z,a) -> exprToString x ^ \"<\" ^ expToString y ^ \"?\" ^ exprToString z ^ \":\" ^ exprToString a", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\" ^ exprToString x ^ \"+\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (x,y,z,a) -> exprToString x ^ \"<\" ^ expToString y ^ \"?\" ^ exprToString z ^ \":\" ^ exprToString a"}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\" ^ exprToString x ^ \"+\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (x,y,z,a) -> exprToString x ^ \"<\" ^ exprToString y ^ \"?\" ^ exprToString z ^ \":\" ^ exprToString a", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\" ^ exprToString x ^ \"+\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (x,y,z,a) -> exprToString x ^ \"<\" ^ exprToString y ^ \"?\" ^ exprToString z ^ \":\" ^ exprToString a"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin(pi * eval(a,x,y))\n| Cosine a -> cos(pi * eval(a,x,y))\n| Average (a,b) -> (eval(a,x,y) + eval(b,x,y)) / 2\n| Times (a,b) -> eval(a,x,y) * eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin(pi * eval(a,x,y))\n| Cosine a -> cos(pi * eval(a,x,y))\n| Average (a,b) -> (eval(a,x,y) + eval(b,x,y)) / 2\n| Times (a,b) -> eval(a,x,y) * eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin(pi *. eval(a,x,y))\n| Cosine a -> cos(pi * eval(a,x,y))\n| Average (a,b) -> (eval(a,x,y) + eval(b,x,y)) / 2\n| Times (a,b) -> eval(a,x,y) * eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin(pi *. eval(a,x,y))\n| Cosine a -> cos(pi * eval(a,x,y))\n| Average (a,b) -> (eval(a,x,y) + eval(b,x,y)) / 2\n| Times (a,b) -> eval(a,x,y) * eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin(pi *. eval(a,x,y))\n| Cosine a -> cos(pi *. eval(a,x,y))\n| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin(pi *. eval(a,x,y))\n| Cosine a -> cos(pi *. eval(a,x,y))\n| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin(pi *. eval(a,x,y))\n| Cosine a -> cos(pi *. eval(a,x,y))\n| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin(pi *. eval(a,x,y))\n| Cosine a -> cos(pi *. eval(a,x,y))\n| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)"}
{"fix": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = match x with\n| []   -> a\n| h::t -> List.fold_left f (a + (h*h)) t in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = match x with\n| []   -> a\n| h::t -> List.fold_left f (a + (h*h)) t in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = sqsum []", "annotated": "let _ = sqsum []"}
{"fix": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = sqsum [1;2;3;4]", "annotated": "let _ = sqsum [1;2;3;4]"}
{"fix": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = sqsum [(-1); (-2); (-3); (-4)]", "annotated": "let _ = sqsum [(-1); (-2); (-3); (-4)]"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let padZero l1 l2 =\nlet diff = (List.length l1 - List.length l2) in\nif diff >= 0 then (l1, (clone 0 diff) @ l2)\nelse ((clone 0 (abs diff)) @ l1, l2)", "bad": "let padZero l1 l2 =\nlet diff = (List.length l1 - List.length l2) in\nif diff >= 0 then (l1, (clone 0 diff) @ l2)\nelse ((clone 0 -diff) @ l1, l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \nlet diff = (List.length l1 - List.length l2) in\nif diff >= 0 then (l1, (clone 0 diff) @ l2)\nelse ((clone 0 -diff) @ l1, l2)"}
{"fix": "let padZero l1 l2 =\nlet diff = (List.length l1 - List.length l2) in\nif diff >= 0 then (l1, (clone 0 diff) @ l2)\nelse ((clone 0 (abs diff)) @ l1, l2)", "bad": "let _ = padZero [9;9] [1;0;0;2]", "annotated": "let _ = padZero [9;9] [1;0;0;2]"}
{"fix": "let padZero l1 l2 =\nlet diff = (List.length l1 - List.length l2) in\nif diff >= 0 then (l1, (clone 0 diff) @ l2)\nelse ((clone 0 (abs diff)) @ l1, l2)", "bad": "let _ = padZero [1;0;0;2] [9;9]", "annotated": "let _ = padZero [1;0;0;2] [9;9]"}
{"fix": "let padZero l1 l2 =\nlet diff = (List.length l1 - List.length l2) in\nif diff >= 0 then (l1, (clone 0 diff) @ l2)\nelse ((clone 0 (abs diff)) @ l1, l2)", "bad": "let padZero l1 l2 =\nlet diff = (List.length l1 - List.length l2) in\nif diff >= 0 then (l1, (clone 0 diff) @ l2)\nelse ((clone 0 abs diff) @ l1, l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \nlet diff = (List.length l1 - List.length l2) in\nif diff >= 0 then (l1, (clone 0 diff) @ l2)\nelse ((clone 0 abs diff) @ l1, l2)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| []   -> \nif ((arg1 + arg2) > 9)\nthen [1] @ [(arg1 + arg2) mod 10] @ a\nelse ((arg1 + arg2)::a)\n| h::t -> \nif ((arg1 + arg2 + h) > 9)\nthen [1] @ [(arg1 + arg2 + h) mod 10] @ a\nelse ((arg1 + arg2 + h)::a)\nin\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| []   -> \nif ((arg1 + arg2) > 9)\nthen [1] @ [(arg1 + arg2) mod 10] @ a\nelse ((arg1 + arg2)::a)\n| h::t -> \nif ((arg1 + arg2 + h) > 9)\nthen [1] @ [(arg1 + arg2 + h) mod 10] @ a\nelse ((arg1 + arg2 + h)::a)\nin\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| []   -> \nif ((arg1 + arg2) > 9)\nthen [1] @ [(arg1 + arg2) mod 10] @ a\nelse ((arg1 + arg2)::a)\n| h::t -> \nif ((arg1 + arg2 + h) > 9)\nthen [1] @ [(arg1 + arg2 + h) mod 10] @ a\nelse ((arg1 + arg2 + h)::a)\nin\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| (0,[])   -> \nif ((arg1 + arg2) > 9)\nthen (1, [(arg1 + arg2) mod 10])\nelse (0,[arg1 + arg2])\n| (1,_::t) -> \nif ((arg1 + arg2 + 1) > 9)\nthen (1, [(arg1 + arg2 + 1) mod 10] @ t)\nelse (0, ((arg1 + arg2 + 1)::t))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_,res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| (0,[])   -> \nif ((arg1 + arg2) > 9)\nthen (1, [(arg1 + arg2) mod 10])\nelse (0,[arg1 + arg2])\n| (1,_::t) -> \nif ((arg1 + arg2 + h) > 9)\nthen (1, [(arg1 + arg2 + 1) mod 10] @ t)\nelse (0, ((arg1 + arg2 + 1)::t))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_,res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| (0,[])   -> \nif ((arg1 + arg2) > 9)\nthen (1, [(arg1 + arg2) mod 10])\nelse (0,[arg1 + arg2])\n| (1,_::t) -> \nif ((arg1 + arg2 + h) > 9)\nthen (1, [(arg1 + arg2 + 1) mod 10] @ t)\nelse (0, ((arg1 + arg2 + 1)::t))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_,res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| (0,[])   -> \nif ((arg1 + arg2) > 9)\nthen (1, [(arg1 + arg2) mod 10])\nelse (0,[arg1 + arg2])\n| (1, h::t) -> \nif ((arg1 + arg2 + 1) > 9)\nthen (1, [(arg1 + arg2 + 1) mod 10] @ t)\nelse (0, ((arg1 + arg2 + 1)::t))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_,res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| (0,[])   -> \nif ((arg1 + arg2) > 9)\nthen (1, [(arg1 + arg2) mod 10])\nelse (0,[arg1 + arg2])\n| (1, _) -> \nif ((arg1 + arg2 + 1) > 9)\nthen (1, [(arg1 + arg2 + 1) mod 10] @ t)\nelse (0, ((arg1 + arg2 + 1)::t))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_,res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| (0,[])   -> \nif ((arg1 + arg2) > 9)\nthen (1, [(arg1 + arg2) mod 10])\nelse (0,[arg1 + arg2])\n| (1, _) -> \nif ((arg1 + arg2 + 1) > 9)\nthen (1, [(arg1 + arg2 + 1) mod 10] @ t)\nelse (0, ((arg1 + arg2 + 1)::t))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_,res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| (0,[])   -> \nif ((arg1 + arg2) > 9)\nthen (1, [(arg1 + arg2) mod 10])\nelse (0,[arg1 + arg2])\n| (1, h::t) -> \nif ((arg1 + arg2 + 1) > 9)\nthen (1, [(arg1 + arg2 + 1) mod 10] @ t)\nelse (0, ((arg1 + arg2 + 1)::t))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_,res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| (0,[])   -> \nif ((arg1 + arg2) > 9)\nthen (1, [(arg1 + arg2) mod 10])\nelse (0,[arg1 + arg2])\n| (1, [h] @ [t]) -> \nif ((arg1 + arg2 + 1) > 9)\nthen (1, [(arg1 + arg2 + 1) mod 10] @ t)\nelse (0, ((arg1 + arg2 + 1)::t))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_,res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| (0,[])   -> \nif ((arg1 + arg2) > 9)\nthen (1, [(arg1 + arg2) mod 10])\nelse (0,[arg1 + arg2])\n| (1, [h] @ [t]) -> \nif ((arg1 + arg2 + 1) > 9)\nthen (1, [(arg1 + arg2 + 1) mod 10] @ t)\nelse (0, ((arg1 + arg2 + 1)::t))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_,res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| (0, acc) -> \nif ((arg1 + arg2) > 9)\nthen (1, ((arg1 + arg2) mod 10)::acc)\nelse (0,(arg1 + arg2)::acc)\n| (0, [])  ->\nif ((arg1 + arg2) > 9)\nthen (1, [(arg1 + arg2) mod 10])\nelse (0, [arg1 + arg2])\n| (_, acc) -> \nif ((arg1 + arg2 + 1) > 9)\nthen (1, ((arg1 + arg2 + 1) mod 10)::acc)\nelse (0, ((arg1 + arg2 + 1)::acc))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_,res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| (0,_)   -> \nif ((arg1 + arg2) > 9)\nthen (1, [(arg1 + arg2) mod 10])\nelse (0,[arg1 + arg2])\n| (_, _) -> \nif ((arg1 + arg2 + 1) > 9)\nthen (1, [(arg1 + arg2 + 1) mod 10] @ a)\nelse (0, ((arg1 + arg2 + 1)::a))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_,res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nmatch a with\n| (0,_)   -> \nif ((arg1 + arg2) > 9)\nthen (1, [(arg1 + arg2) mod 10])\nelse (0,[arg1 + arg2])\n| (_, _) -> \nif ((arg1 + arg2 + 1) > 9)\nthen (1, [(arg1 + arg2 + 1) mod 10] @ a)\nelse (0, ((arg1 + arg2 + 1)::a))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_,res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nlet (carry, acc) = a in \nif ((arg1 + arg2 + carry) > 9)\nthen (1, ((arg1 + arg2 + carry) mod 10)::acc)\nelse (0, ((arg1 + arg2 + carry)::acc))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (fin,res) = List.fold_left f base args in\nfin::res\nin \nremoveZero (add (padZero l1 l2))", "bad": "let mulByDigit i l = \nlet rec helper i' l' = \nmatch i' with\n| 1 -> l'\n| _ -> mulByDigit (i'-1) (bigAdd l l')", "annotated": "let mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet rec helper i' l' = \nmatch i' with\n| 1 -> l'\n| _ -> mulByDigit (i'-1) (bigAdd l l')"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nlet (carry, acc) = a in \nif ((arg1 + arg2 + carry) > 9)\nthen (1, ((arg1 + arg2 + carry) mod 10)::acc)\nelse (0, ((arg1 + arg2 + carry)::acc))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (fin,res) = List.fold_left f base args in\nfin::res\nin \nremoveZero (add (padZero l1 l2))", "bad": "let mulByDigit i l = \nlet rec helper i' l' = \nmatch i' with\n| 1 -> l'\n| _ -> helper (i'-1) (bigAdd l l')", "annotated": "let mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet rec helper i' l' = \nmatch i' with\n| 1 -> l'\n| _ -> helper (i'-1) (bigAdd l l')"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (arg1, arg2) = x in\nlet (carry, acc) = a in \nif ((arg1 + arg2 + carry) > 9)\nthen (1, ((arg1 + arg2 + carry) mod 10)::acc)\nelse (0, ((arg1 + arg2 + carry)::acc))\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (fin,res) = List.fold_left f base args in\nfin::res\nin \nremoveZero (add (padZero l1 l2))", "bad": "let mulByDigit i l = \nlet rec helper i l' = \nmatch i with\n| 1 -> l'\n| _ -> helper (i-1) (bigAdd l l')", "annotated": "let mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet rec helper i l' = \nmatch i with\n| 1 -> l'\n| _ -> helper (i-1) (bigAdd l l')"}
{"fix": "let bigMul l1 l2 = \nlet f a x = a in(*let (acc, l) = a in*)\n(*match l with\n| []   -> ([], [])\n| h::t -> let (first, second) = padZero [h] acc in\nlet f_rev = List.rev first in\n(0::acc, mulByDigit x f_rev) *)\nlet base = ([0], List.rev l1) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = let (acc, l) = a in\nmatch l with\n| []   -> ([], [])\n| h::t -> let (first, second) = padZero [h] acc in\nlet f_rev = List.rev first in\n(0::acc, (mulByDigit x f_rev))", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (acc, l) = a in\nmatch l with\n| []   -> ([], [])\n| h::t -> let (first, second) = padZero [h] acc in\nlet f_rev = List.rev first in\n(0::acc, (mulByDigit x f_rev))"}
{"fix": "let bigMul l1 l2 = \nlet f a x = a in(*let (acc, l) = a in*)\n(*match l with\n| []   -> ([], [])\n| h::t -> let (first, second) = padZero [h] acc in\nlet f_rev = List.rev first in\n(0::acc, mulByDigit x f_rev) *)\nlet base = ([0], List.rev l1) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let base = ([0], List.rev l1) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let base = ([0], List.rev l1) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = a in(*let (acc, l) = a in*)\n(*match l with\n| []   -> ([], [])\n| h::t -> let (first, second) = padZero [h] acc in\nlet f_rev = List.rev first in\n(0::acc, mulByDigit x f_rev) *)\nlet base = ([0], List.rev l1) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = let (acc, l) = a in\nmatch l with\n| []   -> ([], [])\n| h::t -> let (first, second) = padZero [h] acc in\nlet f_rev = List.rev first in\n(0::acc, [](*mulByDigit x f_rev*))", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (acc, l) = a in\nmatch l with\n| []   -> ([], [])\n| h::t -> let (first, second) = padZero [h] acc in\nlet f_rev = List.rev first in\n(0::acc, [](*mulByDigit x f_rev*))"}
{"fix": "let bigMul l1 l2 = \nlet f a x = a in(*let (acc, l) = a in*)\n(*match l with\n| []   -> ([], [])\n| h::t -> let (first, second) = padZero [h] acc in\nlet f_rev = List.rev first in\n(0::acc, mulByDigit x f_rev) *)\nlet base = ([0], List.rev l1) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let base = ([0], List.rev l1) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let base = ([0], List.rev l1) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = a in(*let (acc, l) = a in*)\n(*match l with\n| []   -> ([], [])\n| h::t -> let (first, second) = padZero [h] acc in\nlet f_rev = List.rev first in\n(0::acc, mulByDigit x f_rev) *)\nlet base = ([0], List.rev l1) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x =\nlet (acc, l) = a in\nlet h::t = l in\n([],[])", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x =\nlet (acc, l) = a in\nlet h::t = l in\n([],[])"}
{"fix": "let bigMul l1 l2 = \nlet f a x = a in(*let (acc, l) = a in*)\n(*match l with\n| []   -> ([], [])\n| h::t -> let (first, second) = padZero [h] acc in\nlet f_rev = List.rev first in\n(0::acc, mulByDigit x f_rev) *)\nlet base = ([0], List.rev l1) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let base = ([0], List.rev l1) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let base = ([0], List.rev l1) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = a in(*let (acc, l) = a in*)\n(*match l with\n| []   -> ([], [])\n| h::t -> let (first, second) = padZero [h] acc in\nlet f_rev = List.rev first in\n(0::acc, mulByDigit x f_rev) *)\nlet base = ([0], List.rev l1) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = ([], [])", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = ([], [])"}
{"fix": "let bigMul l1 l2 = \nlet f a x = a in(*let (acc, l) = a in*)\n(*match l with\n| []   -> ([], [])\n| h::t -> let (first, second) = padZero [h] acc in\nlet f_rev = List.rev first in\n(0::acc, mulByDigit x f_rev) *)\nlet base = ([0], List.rev l1) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let base = ([0], List.rev l1) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let base = ([0], List.rev l1) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = a in(*let (acc, l) = a in*)\n(*match l with\n| []   -> ([], [])\n| h::t -> let (first, second) = padZero [h] acc in\nlet f_rev = List.rev first in\n(0::acc, mulByDigit x f_rev) *)\nlet base = ([0], List.rev l1) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = (0, [])", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = (0, [])"}
{"fix": "let bigMul l1 l2 = \nlet f a x = a in(*let (acc, l) = a in*)\n(*match l with\n| []   -> ([], [])\n| h::t -> let (first, second) = padZero [h] acc in\nlet f_rev = List.rev first in\n(0::acc, mulByDigit x f_rev) *)\nlet base = ([0], List.rev l1) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let base = ([0], List.rev l1) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let base = ([0], List.rev l1) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = a in(*let (acc, l) = a in*)\n(*match l with\n| []   -> ([], [])\n| h::t -> let (first, second) = padZero [h] acc in\nlet f_rev = List.rev first in\n(0::acc, mulByDigit x f_rev) *)\nlet base = ([0], List.rev l1) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = a", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = a"}
{"fix": "let bigMul l1 l2 = \nlet f a x = a in(*let (acc, l) = a in*)\n(*match l with\n| []   -> ([], [])\n| h::t -> let (first, second) = padZero [h] acc in\nlet f_rev = List.rev first in\n(0::acc, mulByDigit x f_rev) *)\nlet base = ([0], List.rev l1) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let base = ([0], List.rev l1) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let base = ([0], List.rev l1) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet rec pow10 exp =\nmatch exp with\n| 0 -> 1\n| n -> 10 * (pow10 n-1) in\nlet padded_x = x * pow10 ((List.length padding) - 1) in\nmatch l with\n| []   -> \n([], [], acc)\n| h::t -> \nlet (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\n(0::padding, t, bigAdd acc (mulByDigit padded_x f_rev)) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet padded_x = x*10^((List.length padding) - 1) in\nmatch l with\n| []   -> \n([], [], acc)\n| h::t -> \nlet (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\n(0::padding, t, bigAdd acc (mulByDigit padded_x f_rev)) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet (padding, l, acc) = a in\nlet padded_x = x*10^((List.length padding) - 1) in\nmatch l with\n| []   -> \n([], [], acc)\n| h::t -> \nlet (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\n(0::padding, t, bigAdd acc (mulByDigit padded_x f_rev)) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet rec pow10 exp =\nmatch exp with\n| 0 -> 1\n| n -> 10 * (pow10 n-1) in\nlet padded_x = x * pow10 ((List.length padding) - 1) in\nmatch l with\n| []   -> \n([], [], acc)\n| h::t -> \nlet (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\n(0::padding, t, bigAdd acc (mulByDigit padded_x f_rev)) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet padded_x = x*10**((List.length padding) - 1) in\nmatch l with\n| []   -> \n([], [], acc)\n| h::t -> \nlet (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\n(0::padding, t, bigAdd acc (mulByDigit padded_x f_rev)) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet (padding, l, acc) = a in\nlet padded_x = x*10**((List.length padding) - 1) in\nmatch l with\n| []   -> \n([], [], acc)\n| h::t -> \nlet (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\n(0::padding, t, bigAdd acc (mulByDigit padded_x f_rev)) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet rec pow10 exp =\nmatch exp with\n| 0 -> 1\n| n -> 10 * (pow10 n-1) in\nlet padded_x = x * pow10 ((List.length padding) - 1) in\nmatch l with\n| []   -> \n([], [], acc)\n| h::t -> \nlet (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\n(0::padding, t, bigAdd acc (mulByDigit padded_x f_rev)) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet padded_x = x*10.**((List.length padding) - 1) in\nmatch l with\n| []   -> \n([], [], acc)\n| h::t -> \nlet (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\n(0::padding, t, bigAdd acc (mulByDigit padded_x f_rev)) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet (padding, l, acc) = a in\nlet padded_x = x*10.**((List.length padding) - 1) in\nmatch l with\n| []   -> \n([], [], acc)\n| h::t -> \nlet (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\n(0::padding, t, bigAdd acc (mulByDigit padded_x f_rev)) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet rec pow10 exp =\nmatch exp with\n| 0 -> 1\n| n -> 10 * (pow10 (n-1)) in\nlet padded_x = x * pow10 ((List.length padding) - 1) in\nlet rec helper padding l acc padded_x = \nmatch l with\n| []   ->\n[]\n| h::t ->\nlet (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\nbigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x) in\nlet result = helper padding l acc padded_x in\n([0], l, result) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet rec pow10 exp =\nmatch exp with\n| 0 -> 1\n| n -> 10 * (pow10 (n-1)) in\nlet padded_x = x * pow10 ((List.length padding) - 1) in\nlet rec helper padding l acc padded_x = \nmatch l with\n| []   ->\n[]\n| h::t ->\nlet (first, second) = padZero [h] padding in\nlet f_rev = List.reverse first in\nbigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x in\nlet result = helper padding l acc padded_x in\n([0], t, result) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet (padding, l, acc) = a in\nlet rec pow10 exp =\nmatch exp with\n| 0 -> 1\n| n -> 10 * (pow10 (n-1)) in\nlet padded_x = x * pow10 ((List.length padding) - 1) in\nlet rec helper padding l acc padded_x = \nmatch l with\n| []   ->\n[]\n| h::t ->\nlet (first, second) = padZero [h] padding in\nlet f_rev = List.reverse first in\nbigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x in\nlet result = helper padding l acc padded_x in\n([0], t, result) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet rec pow10 exp =\nmatch exp with\n| 0 -> 1\n| n -> 10 * (pow10 (n-1)) in\nlet padded_x = x * pow10 ((List.length padding) - 1) in\nlet rec helper padding l acc padded_x = \nmatch l with\n| []   ->\n[]\n| h::t ->\nlet (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\nbigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x) in\nlet result = helper padding l acc padded_x in\n([0], l, result) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet rec pow10 exp =\nmatch exp with\n| 0 -> 1\n| n -> 10 * (pow10 (n-1)) in\nlet padded_x = x * pow10 ((List.length padding) - 1) in\nlet rec helper padding l acc padded_x = \nmatch l with\n| []   ->\n[]\n| h::t ->\nlet (first, second) = padZero [h] padding in\nlet f_rev = List.reverse first in\nlet this_guy = bigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x in\nlet result = helper padding l acc padded_x in\n([0], t, result) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet (padding, l, acc) = a in\nlet rec pow10 exp =\nmatch exp with\n| 0 -> 1\n| n -> 10 * (pow10 (n-1)) in\nlet padded_x = x * pow10 ((List.length padding) - 1) in\nlet rec helper padding l acc padded_x = \nmatch l with\n| []   ->\n[]\n| h::t ->\nlet (first, second) = padZero [h] padding in\nlet f_rev = List.reverse first in\nlet this_guy = bigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x in\nlet result = helper padding l acc padded_x in\n([0], t, result) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet rec pow10 exp =\nmatch exp with\n| 0 -> 1\n| n -> 10 * (pow10 (n-1)) in\nlet padded_x = x * pow10 ((List.length padding) - 1) in\nlet rec helper padding l acc padded_x = \nmatch l with\n| []   ->\n[]\n| h::t ->\nlet (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\nbigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x) in\nlet result = helper padding l acc padded_x in\n([0], l, result) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet rec pow10 exp =\nmatch exp with\n| 0 -> 1\n| n -> 10 * (pow10 (n-1)) in\nlet padded_x = x * pow10 ((List.length padding) - 1) in\nlet rec helper padding l acc padded_x = \nmatch l with\n| []   ->\n[]\n| h::t ->\nlet (first, second) = padZero [h] padding in\nlet f_rev = List.reverse first in\nbigAdd (mulByDigit (padded_x) (f_rev)) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x in\nlet result = helper padding l acc padded_x in\n([0], t, result) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet (padding, l, acc) = a in\nlet rec pow10 exp =\nmatch exp with\n| 0 -> 1\n| n -> 10 * (pow10 (n-1)) in\nlet padded_x = x * pow10 ((List.length padding) - 1) in\nlet rec helper padding l acc padded_x = \nmatch l with\n| []   ->\n[]\n| h::t ->\nlet (first, second) = padZero [h] padding in\nlet f_rev = List.reverse first in\nbigAdd (mulByDigit (padded_x) (f_rev)) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x in\nlet result = helper padding l acc padded_x in\n([0], t, result) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet rec pow10 exp =\nmatch exp with\n| 0 -> 1\n| n -> 10 * (pow10 (n-1)) in\nlet padded_x = x * pow10 ((List.length padding) - 1) in\nlet rec helper padding l acc padded_x = \nmatch l with\n| []   ->\n[]\n| h::t ->\nlet (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\nbigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x) in\nlet result = helper padding l acc padded_x in\n([0], l, result) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet rec pow10 exp =\nmatch exp with\n| 0 -> 1\n| n -> 10 * (pow10 (n-1)) in\nlet padded_x = x * pow10 ((List.length padding) - 1) in\nlet rec helper padding l acc padded_x = \nmatch l with\n| []   ->\n[]\n| h::t ->\nlet (first, second) = padZero [h] padding in\nlet f_rev = List.reverse first in\nbigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x) in\nlet result = helper padding l acc padded_x in\n([0], t, result) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet (padding, l, acc) = a in\nlet rec pow10 exp =\nmatch exp with\n| 0 -> 1\n| n -> 10 * (pow10 (n-1)) in\nlet padded_x = x * pow10 ((List.length padding) - 1) in\nlet rec helper padding l acc padded_x = \nmatch l with\n| []   ->\n[]\n| h::t ->\nlet (first, second) = padZero [h] padding in\nlet f_rev = List.reverse first in\nbigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x) in\nlet result = helper padding l acc padded_x in\n([0], t, result) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet rec pow10 exp =\nmatch exp with\n| 0 -> 1\n| n -> 10 * (pow10 (n-1)) in\nlet padded_x = x * pow10 ((List.length padding) - 1) in\nlet rec helper padding l acc padded_x = \nmatch l with\n| []   ->\n[]\n| h::t ->\nlet (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\nbigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x) in\nlet result = helper padding l acc padded_x in\n([0], l, result) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet (padding, l, acc) = a in\nlet rec pow10 exp =\nmatch exp with\n| 0 -> 1\n| n -> 10 * (pow10 (n-1)) in\nlet padded_x = x * pow10 ((List.length padding) - 1) in\nlet rec helper padding l acc padded_x = \nmatch l with\n| []   ->\n[]\n| h::t ->\nlet (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\nbigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x) in\nlet result = helper padding l acc padded_x in\n([0], t, result) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet (padding, l, acc) = a in\nlet rec pow10 exp =\nmatch exp with\n| 0 -> 1\n| n -> 10 * (pow10 (n-1)) in\nlet padded_x = x * pow10 ((List.length padding) - 1) in\nlet rec helper padding l acc padded_x = \nmatch l with\n| []   ->\n[]\n| h::t ->\nlet (first, second) = padZero [h] padding in\nlet f_rev = List.rev first in\nbigAdd (mulByDigit padded_x f_rev) (helper (0::padding) t (mulByDigit padded_x f_rev) padded_x) in\nlet result = helper padding l acc padded_x in\n([0], t, result) in\nlet base = ([0], List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, _, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x =\nlet (padding, acc) = a in\n(padding+1, bigAdd acc ((mulByDigit x l1) @ (clone 0 padding))) in\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x =\nlet (padding, acc) = a in\n(padding+1, l1, bigAdd acc ((mulByDigit x l1) @ (clone 0 padding))) in\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x =\nlet (padding, acc) = a in\n(padding+1, l1, bigAdd acc ((mulByDigit x l1) @ (clone 0 padding))) in\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let rec digitsOfInt n = if n > 0\nthen\n(n mod 10) :: (digitsOfInt (n/10))\nelse\n[]", "bad": "let rec digitsOfInt n = if n > 0\nthen\n(digitsOfInt (n/10)) :: n mod 10\nelse\n0", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  if n > 0\nthen\n(digitsOfInt (n/10)) :: n mod 10\nelse\n0"}
{"fix": "let rec digitsOfInt n = if n > 0\nthen\n(n mod 10) :: (digitsOfInt (n/10))\nelse\n[]", "bad": "let rec digitsOfInt n = if n > 0\nthen\n(digitsOfInt (n/10)) :: n mod 10\nelse\n[]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  if n > 0\nthen\n(digitsOfInt (n/10)) :: n mod 10\nelse\n[]"}
{"fix": "let rec listReverse l = function\n| [] -> l\n| (h::t) -> listReverse (h::l) t", "bad": "let rec listReverse l = function\n| [] -> l\n| (h::t) -> listReverse (h::l) t", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  function\n| [] -> l\n| (h::t) -> listReverse (h::l) t"}
{"fix": "let rec listReverse l = match l with\n| [] -> l\n| [other::tail::[]] -> tail :: other", "bad": "let rec listReverse l = function\n| [] -> l\n| (h::t) -> listReverse (h::l) t in\nlistReverse [] l", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  function\n| [] -> l\n| (h::t) -> listReverse (h::l) t in\nlistReverse [] l"}
{"fix": "let rec listReverse l = match l with\n| [] -> l\n| [other::tail::[]] -> tail :: other", "bad": "let rec listReverse l = match l with\n| [] -> l\n| [_::tail::[]] -> l", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> l\n| [_::tail::[]] -> l"}
{"fix": "let rec listReverse l =\nlet rec listReverseHelper l ans = match ans with\n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans", "bad": "let rec listReverseHelper l ans = \n[] -> [];\n(h::t) -> ans :: listReverseHelper t ans", "annotated": "let rec listReverse : 'a list -> 'a list = fun Helper l ans  ->  \n[] -> [];\n(h::t) -> ans :: listReverseHelper t ans"}
{"fix": "let rec listReverse l =\nlet rec listReverseHelper l ans = match ans with\n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans", "bad": "let rec listReverse l =\nlistReverseHelper l []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlistReverseHelper l []"}
{"fix": "let rec listReverse l =\nlet rec listReverseHelper l ans = match ans with\n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans", "bad": "let rec listReverseHelper l ans = \n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans", "annotated": "let rec listReverse : 'a list -> 'a list = fun Helper l ans  ->  \n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans"}
{"fix": "let rec listReverse l =\nlet rec listReverseHelper l ans = match ans with\n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans", "bad": "let rec listReverseHelper l ans = match l with\n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans", "annotated": "let rec listReverse : 'a list -> 'a list = fun Helper l ans  ->  match l with\n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l =\nlet rec listReverseHelper l ans = match ans with\n| [] -> []\n| h::t -> listReverseHelper t (h::ans)\n\nlistReverseHelper l []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet rec listReverse : 'a list -> 'a list = fun  l  ->  match ans with\n| [] -> []\n| h::t -> listReverseHelper t (h::ans)\n\nlistReverseHelper l []"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l =\nlet rec listReverseHelper l ans = match ans with\n| [] -> []\n| h::t -> listReverseHelper t (h::ans) in \n\nlistReverseHelper l []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet rec listReverse : 'a list -> 'a list = fun  l  ->  match ans with\n| [] -> []\n| h::t -> listReverseHelper t (h::ans) in \n\nlistReverseHelper l []"}
{"fix": "let _ = additivePersistence 9876", "bad": "let rec additivePersistence n = \nlet rec sumDigits n1 = \nif n < 10 then \nn \nelse\nn1 mod 10 + sumDigits (n1 / 10) in \nif (n < 10) then\n0\nelse\n1 + additivePersistence (sumDigits n)", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet rec sumDigits n1 = \nif n < 10 then \nn \nelse\nn1 mod 10 + sumDigits (n1 / 10) in \nif (n < 10) then\n0\nelse\n1 + additivePersistence (sumDigits n)"}
{"fix": "let _ = digitalRoot 9873", "bad": "let rec digitalRoot n = \nif (n > 10) then \ndigitalRoot (sumDigits n)\nelse\nn", "annotated": "let rec digitalRoot : int -> int = fun  n  ->  \nif (n > 10) then \ndigitalRoot (sumDigits n)\nelse\nn"}
{"fix": "let palindrome w = (explode w) = (listReverse (explode w))", "bad": "let palindrome w = (explode w) = (listReverse (explode w))", "annotated": "let palindrome : string -> bool = fun  w = (explode w)  ->  (listReverse (explode w))"}
{"fix": "let rec fixpoint (f,x) = \nlet x' = f x in\nif x' = x then x else fixpoint (f, x')", "bad": "let rec fixpoint (f,x) = \nlet x' = f x in\nif x' = x then x else fixpoint f x'", "annotated": "let rec fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,x)  ->  \nlet x' = f x in\nif x' = x then x else fixpoint f x'"}
{"fix": "let rec fixpoint (f,x) = \nlet x' = f x in\nlet g x = (x', x' = x) in \nwwhile (g,x)", "bad": "let rec fixpoint (f,x) = \nlet x' = f x in\nlet g x = (f, x' = x) in \nwwhile (g,x)", "annotated": "let rec fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,x)  ->  \nlet x' = f x in\nlet g x = (f, x' = x) in \nwwhile (g,x)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 2)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, .2)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, .2)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine     (e1) -> sin(pi *. (eval (e1, x, y)))\n| Cosine   (e1) -> cos(pi *. (eval (e1, x, y)))\n| Average  (e1, e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y)))/.2.\n| Times    (e1, e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n| Thresh   (e1, e2, e3, e4) \n-> if (eval (e1, x, y)) < (eval (e2, x, y)) then\n(eval (e3, x, y)) else\n(eval (e4, x, y))", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine     (e1) -> sin(pi *. (exprToString e1))\n| Cosine   (e1) -> cos(pi *. (exprToString e1))\n| Average  (e1, e2) -> ((exprToString e1) +. (exprToString e2))/.2.\n| Times    (e1, e2) -> (exprToString e1) *. (exprToString e2)\n| Thresh   (e1, e2, e3, e4) \n-> if (exprToString e1) < (exprToString e2) then\n(exprToString e3) else\n(exprToString e4)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine     (e1) -> sin(pi *. (exprToString e1))\n| Cosine   (e1) -> cos(pi *. (exprToString e1))\n| Average  (e1, e2) -> ((exprToString e1) +. (exprToString e2))/.2.\n| Times    (e1, e2) -> (exprToString e1) *. (exprToString e2)\n| Thresh   (e1, e2, e3, e4) \n-> if (exprToString e1) < (exprToString e2) then\n(exprToString e3) else\n(exprToString e4)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine     (e1) -> sin(pi *. (eval (e1, x, y)))\n| Cosine   (e1) -> cos(pi *. (eval (e1, x, y)))\n| Average  (e1, e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y)))/.2.\n| Times    (e1, e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n| Thresh   (e1, e2, e3, e4) \n-> if (eval (e1, x, y)) < (eval (e2, x, y)) then\n(eval (e3, x, y)) else\n(eval (e4, x, y))", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine     (e1) -> sin(pi *. (eval e1))\n| Cosine   (e1) -> cos(pi *. (eval e1))\n| Average  (e1, e2) -> ((eeval e1) +. (eval e2))/.2.\n| Times    (e1, e2) -> (eval e1) *. (eval e2)\n| Thresh   (e1, e2, e3, e4) \n-> if (eval e1) < (eval e2) then\n(eval e3) else\n(eval e4)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine     (e1) -> sin(pi *. (eval e1))\n| Cosine   (e1) -> cos(pi *. (eval e1))\n| Average  (e1, e2) -> ((eeval e1) +. (eval e2))/.2.\n| Times    (e1, e2) -> (eval e1) *. (eval e2)\n| Thresh   (e1, e2, e3, e4) \n-> if (eval e1) < (eval e2) then\n(eval e3) else\n(eval e4)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine     (e1) -> sin(pi *. (eval (e1, x, y)))\n| Cosine   (e1) -> cos(pi *. (eval (e1, x, y)))\n| Average  (e1, e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y)))/.2.\n| Times    (e1, e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n| Thresh   (e1, e2, e3, e4) \n-> if (eval (e1, x, y)) < (eval (e2, x, y)) then\n(eval (e3, x, y)) else\n(eval (e4, x, y))\n| AbsThresh (e1, e2, e3) -> let s = eval (e3, x, y) in\nif abs_float (eval (e1, x, y)) < abs_float (eval (e2, x, y)) then\ns else\nabs_float s\n| ModThresh (e1, e2, e3) -> \nif (truncate (100. *. (eval (e1, x, y)))) mod 5 = 0 then\n(eval (e2, x, y)) else\n(eval (e3, x, y))", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine     (e1) -> sin(pi *. (eval (e1, x, y)))\n| Cosine   (e1) -> cos(pi *. (eval (e1, x, y)))\n| Average  (e1, e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y)))/.2.\n| Times    (e1, e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n| Thresh   (e1, e2, e3, e4) \n-> if (eval (e1, x, y)) < (eval (e2, x, y)) then\n(eval (e3, x, y)) else\n(eval (e4, x, y))\n| AbsThresh (e1, e2, e3) -> let s = eval (e3, x, y) in\nif abs_float (eval (e1, x, y)) < abs_float (eval (e2, x, y)) then\ns else\nabs_float s\n| ModThresh (e1, e2, e3) -> \nif (truncate (100 *. (eval (e1, x, y)))) mod 5 = 0 then\n(eval (e2, x, y)) else\n(eval (e3, x, y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine     (e1) -> sin(pi *. (eval (e1, x, y)))\n| Cosine   (e1) -> cos(pi *. (eval (e1, x, y)))\n| Average  (e1, e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y)))/.2.\n| Times    (e1, e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n| Thresh   (e1, e2, e3, e4) \n-> if (eval (e1, x, y)) < (eval (e2, x, y)) then\n(eval (e3, x, y)) else\n(eval (e4, x, y))\n| AbsThresh (e1, e2, e3) -> let s = eval (e3, x, y) in\nif abs_float (eval (e1, x, y)) < abs_float (eval (e2, x, y)) then\ns else\nabs_float s\n| ModThresh (e1, e2, e3) -> \nif (truncate (100 *. (eval : expr * float * float -> float = fun  (e,x,y)  ->  0 then\n(eval (e2, x, y)) else\n(eval (e3, x, y))"}
{"fix": "let _ = buildY()", "bad": "let rec build (rand, depth) = \nlet r = rand (0,99) in\nif depth = 0 then\nif (r < 50) then\nbuildX\nelse\nbuildY\nelse\nif (r < 5) then\nbuildX()\nelse if (r < 10) then\nbuildY()\nelse if (r < 30) then \nbuildSine (build (rand, depth - 1))\nelse if (r < 50) then \nbuildCosine (build (rand, depth - 1))\nelse if (r < 60) then \nbuildAverage (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 70) then \nbuildTimes (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 80) then \nbuildThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 90) then \nbuildAbsThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))\nelse if (r < 90) then \nbuildModThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet r = rand (0,99) in\nif depth = 0 then\nif (r < 50) then\nbuildX\nelse\nbuildY\nelse\nif (r < 5) then\nbuildX()\nelse if (r < 10) then\nbuildY()\nelse if (r < 30) then \nbuildSine (build (rand, depth - 1))\nelse if (r < 50) then \nbuildCosine (build (rand, depth - 1))\nelse if (r < 60) then \nbuildAverage (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 70) then \nbuildTimes (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 80) then \nbuildThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 90) then \nbuildAbsThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))\nelse if (r < 90) then \nbuildModThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))"}
{"fix": "let _ = buildY()", "bad": "let rec build (rand, depth) = \nlet r = rand (0,99) in\nif depth = 0 then\nif (r < 50) then\nbuildX()\nelse\nbuildY()\nelse\nif (r < 5) then\nbuildX()\nelse if (r < 10) then\nbuildY()\nelse if (r < 30) then \nbuildSine (build (rand, depth - 1))\nelse if (r < 50) then \nbuildCosine (build (rand, depth - 1))\nelse if (r < 60) then \nbuildAverage (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 70) then \nbuildTimes (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 80) then \nbuildThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 90) then \nbuildAbsThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))\nelse if (r < 90) then \nbuildModThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet r = rand (0,99) in\nif depth = 0 then\nif (r < 50) then\nbuildX()\nelse\nbuildY()\nelse\nif (r < 5) then\nbuildX()\nelse if (r < 10) then\nbuildY()\nelse if (r < 30) then \nbuildSine (build (rand, depth - 1))\nelse if (r < 50) then \nbuildCosine (build (rand, depth - 1))\nelse if (r < 60) then \nbuildAverage (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 70) then \nbuildTimes (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 80) then \nbuildThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 90) then \nbuildAbsThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))\nelse if (r < 90) then \nbuildModThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))"}
{"fix": "let rec build (rand, depth) = \nlet r = rand (0,99) in\nif depth = 0 then\nif (r < 50) then\nbuildX()\nelse\nbuildY()\nelse\nbuildY()", "bad": "let rec build (rand, depth) = \nlet r = rand (0,99) in\nif depth = 0 then\nif (r < 50) then\nbuildX() : expr\nelse\nbuildY()\nelse\nif (r < 5) then\nbuildX()\nelse if (r < 10) then\nbuildY()\nelse if (r < 30) then \nbuildSine (build (rand, depth - 1))\nelse if (r < 50) then \nbuildCosine (build (rand, depth - 1))\nelse if (r < 60) then \nbuildAverage (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 70) then \nbuildTimes (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 80) then \nbuildThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 90) then \nbuildAbsThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))\nelse if (r < 90) then \nbuildModThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet r = rand (0,99) in\nif depth = 0 then\nif (r < 50) then\nbuildX() : expr\nelse\nbuildY()\nelse\nif (r < 5) then\nbuildX()\nelse if (r < 10) then\nbuildY()\nelse if (r < 30) then \nbuildSine (build (rand, depth - 1))\nelse if (r < 50) then \nbuildCosine (build (rand, depth - 1))\nelse if (r < 60) then \nbuildAverage (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 70) then \nbuildTimes (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 80) then \nbuildThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 90) then \nbuildAbsThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))\nelse if (r < 90) then \nbuildModThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))"}
{"fix": "let rec build (rand, depth) = \nlet r = rand (0,99) in\nif depth = 0 then\nif (r < 50) then\nbuildX()\nelse\nbuildY()\nelse\nbuildY()", "bad": "let rec build (rand, depth) = \nlet r = rand (0,99) in\nif depth = 0 then\nif (r < 50) then\nbuildX() :: expr\nelse\nbuildY()\nelse\nif (r < 5) then\nbuildX()\nelse if (r < 10) then\nbuildY()\nelse if (r < 30) then \nbuildSine (build (rand, depth - 1))\nelse if (r < 50) then \nbuildCosine (build (rand, depth - 1))\nelse if (r < 60) then \nbuildAverage (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 70) then \nbuildTimes (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 80) then \nbuildThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 90) then \nbuildAbsThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))\nelse if (r < 90) then \nbuildModThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet r = rand (0,99) in\nif depth = 0 then\nif (r < 50) then\nbuildX() :: expr\nelse\nbuildY()\nelse\nif (r < 5) then\nbuildX()\nelse if (r < 10) then\nbuildY()\nelse if (r < 30) then \nbuildSine (build (rand, depth - 1))\nelse if (r < 50) then \nbuildCosine (build (rand, depth - 1))\nelse if (r < 60) then \nbuildAverage (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 70) then \nbuildTimes (build (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 80) then \nbuildThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1), build (rand, depth - 1))\nelse if (r < 90) then \nbuildAbsThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))\nelse if (r < 90) then \nbuildModThresh (build (rand, depth - 1), build (rand, depth - 1),\nbuild (rand, depth - 1))"}
{"fix": "let padZero l1 l2 = \nlet dif = (List.length l1) - (List.length l2) in\nif (dif = 0) then\n(l1, l2)\nelse if (dif < 0) then (*l2 is bigger*)\n((clone 0 (0-dif)) @ l1, l2)\nelse\n(l1, ((clone 0 dif) @ l2))", "bad": "let padZero l1 l2 = \nlet dif = (List.length l1) - (List.length l2) in\nif (dif = 0) then\n(l1, l2)\nelse if (dif < 0) then (*l2 is bigger*)\n((clone 0 (0-diff)) @ l1, l2)\nelse\n(l1, ((clone 0 diff) @ l2))", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet dif = (List.length l1) - (List.length l2) in\nif (dif = 0) then\n(l1, l2)\nelse if (dif < 0) then (*l2 is bigger*)\n((clone 0 (0-diff)) @ l1, l2)\nelse\n(l1, ((clone 0 diff) @ l2))"}
{"fix": "let padZero l1 l2 = \nlet dif = (List.length l1) - (List.length l2) in\nif (dif = 0) then\n(l1, l2)\nelse if (dif < 0) then (*l2 is bigger*)\n((clone 0 (0-dif)) @ l1, l2)\nelse\n(l1, ((clone 0 dif) @ l2))", "bad": "let _ = padZero [9;9] [1;0;0;2]", "annotated": "let _ = padZero [9;9] [1;0;0;2]"}
{"fix": "let padZero l1 l2 = \nlet dif = (List.length l1) - (List.length l2) in\nif (dif = 0) then\n(l1, l2)\nelse if (dif < 0) then (*l2 is bigger*)\n((clone 0 (0-dif)) @ l1, l2)\nelse\n(l1, ((clone 0 dif) @ l2))", "bad": "let _ = padZero [1;0;0;2] [9;9]", "annotated": "let _ = padZero [1;0;0;2] [9;9]"}
{"fix": "let padZero l1 l2 = \nlet dif = (List.length l1) - (List.length l2) in\nif (dif = 0) then\n(l1, l2)\nelse if (dif < 0) then (*l2 is bigger*)\n((clone 0 (0-dif)) @ l1, l2)\nelse\n(l1, ((clone 0 dif) @ l2))", "bad": "let _ = padZero [1;0;0;2] [9;9;9;9]", "annotated": "let _ = padZero [1;0;0;2] [9;9;9;9]"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, rest) = a in\nlet (d1, d2) = x in\nlet sum = d1 + d2 + carry in\nif (sum > 9) then\n(1, (sum - 10)::rest)\nelse\n(0, sum::rest) in\nlet base = (0, []) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, rest) = a in\nlet (d1, d2) = x in\nlet sum = d1 + d2 + carry in\nif (sum > 9) then\n(1, (sum - 10)::rest)\nelse\n(0, sum::rest) in\nlet base = (0, []) in\nlet args = List.combine (list.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (carry, rest) = a in\nlet (d1, d2) = x in\nlet sum = d1 + d2 + carry in\nif (sum > 9) then\n(1, (sum - 10)::rest)\nelse\n(0, sum::rest) in\nlet base = (0, []) in\nlet args = List.combine (list.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let _ = bigMul [0;99] []", "bad": "let _ = bigMul [0,99] []", "annotated": "let _ = bigMul [0,99] []"}
{"fix": "let rec digitsOfInt n = \nif (n <= 0) \nthen []\nelse \nn :: []", "bad": "let rec digitsOfInt n = \nif (n <= 0) \nthen []\nelse \n|", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif (n <= 0) \nthen []\nelse \n|"}
{"fix": "let rec digitsOfInt n = \nif (n <= 0) \nthen []\nelse \nn :: []", "bad": "let rec digitsOfInt n = \nif (n <= 0) \nthen []\nelse \nn mod 10", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif (n <= 0) \nthen []\nelse \nn mod 10"}
{"fix": "let rec digitsOfInt n = \nif (n <= 0) \nthen []\nelse \nn :: []", "bad": "let rec digitsOfInt n = \nif (n <= 0) \nthen []\nelse \nn mod 10\nn::[]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif (n <= 0) \nthen []\nelse \nn mod 10\nn::[]"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "bad": "let rec digitsOfInt n = \nif (n <= 0) \nthen []\nelse \n(n mod 10) :: [digitsOfInt n]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif (n <= 0) \nthen []\nelse \n(n mod 10) :: [digitsOfInt n]"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "bad": "let rec digitsOfInt n = \nif (n <= 0) \nthen []\nelse \n(n mod 10) :: digitsOfInt n :: []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif (n <= 0) \nthen []\nelse \n(n mod 10) :: digitsOfInt n :: []"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 :: myList", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nlet toAdd = (n mod 10)\ntoAdd@[]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nlet toAdd = (n mod 10)\ntoAdd@[]"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 :: myList", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nlet toAdd = (n mod 10)\ntoAdd@myList", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nlet toAdd = (n mod 10)\ntoAdd@myList"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 :: myList", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nlet toAdd = (n mod 10)\ntoAdd@myList", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nlet toAdd = (n mod 10)\ntoAdd@myList"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 :: myList", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nlet toAdd = (n mod 10)\ntoAdd@myList", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nlet toAdd = (n mod 10)\ntoAdd@myList"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 :: myList", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nlet toAdd = (n mod 10)\ntoAdd@myList", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nlet toAdd = (n mod 10)\ntoAdd@myList"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 :: myList", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nlet toAdd = (n mod 10)\ntoAdd@myList", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nlet toAdd = (n mod 10)\ntoAdd@myList"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 :: myList", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nlet toAdd = (n mod 10)\ntoAdd@myList\nhi", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nlet toAdd = (n mod 10)\ntoAdd@myList\nhi"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 :: myList", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nlet toAdd = (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nlet toAdd = (n mod 10)"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 :: myList", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nlet toAdd = (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nlet toAdd = (n mod 10)"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 :: myList", "bad": "toAdd@myList", "annotated": "toAdd@myList"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 :: myList", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nlet toAdd = (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nlet toAdd = (n mod 10)"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 :: myList", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse (\nlet toAdd = (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) \nthen []\nelse (\nlet toAdd = (n mod 10)"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 :: myList", "bad": "toAdd@myList", "annotated": "toAdd@myList"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 :: myList", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse (\n(n mod 10)@myList", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) \nthen []\nelse (\n(n mod 10)@myList"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 :: myList", "bad": ")", "annotated": ")"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 :: myList", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse (\n(n mod 10)@myList", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) \nthen []\nelse (\n(n mod 10)@myList"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 :: myList", "bad": ")", "annotated": ")"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 :: myList", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse (\nn mod 10 @myList", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) \nthen []\nelse (\nn mod 10 @myList"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 :: myList", "bad": ")", "annotated": ")"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 :: myList", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse (\nn mod 10 @myList", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) \nthen []\nelse (\nn mod 10 @myList"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 :: myList", "bad": ")", "annotated": ")"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 :: myList", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 @myList", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) \nthen []\nelse \nn mod 10 @myList"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) \nthen []"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []", "bad": "let _ = 1;l\nn mod 10 :: myList", "annotated": "let _ = 1;l\nn mod 10 :: myList"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse []", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\n\nn mod 10 :: myList", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) \nthen []\n\nn mod 10 :: myList"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse []", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) \nthen []"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse []", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) \nthen []"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse []", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen ->[]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) \nthen ->[]"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen []\nelse []", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) \nthen -> []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) \nthen -> []"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nn mod 10 :: myList", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) then []"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nn mod 10 :: myList", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) then []\nelse"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nn mod 10 :: myList", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\n\nn mod 10 :: myList", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) then []\n\nn mod 10 :: myList"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nn mod 10 :: myList", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) then []"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nn mod 10 :: myList", "bad": "n mod 10 :: myList", "annotated": "n mod 10 :: myList"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nn mod 10 :: myList", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nn mod 10 :: myList\nn mod 100 :: myList", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) then []\nelse\nn mod 10 :: myList\nn mod 100 :: myList"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt n", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nn = n - (n mod 10);\n(n :: myList) :: digitsOfInt", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) then []\nelse\nn = n - (n mod 10);\n(n :: myList) :: digitsOfInt"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt n", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nlet n = n - (n mod 10);\n(n :: myList) :: digitsOfInt", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) then []\nelse\nlet n = n - (n mod 10);\n(n :: myList) :: digitsOfInt"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt n", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse\nlet n = n - (n mod 10);\n(n :: myList) :: digitsOfInt", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) then []\nelse\nlet n = n - (n mod 10);\n(n :: myList) :: digitsOfInt"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt n", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse (\nlet n = n - (n mod 10);\n(n :: myList) :: digitsOfInt\n)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) then []\nelse (\nlet n = n - (n mod 10);\n(n :: myList) :: digitsOfInt\n)"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt n", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse (\nlet n = n - (n mod 10);\n(n :: myList) :: digitsOfInt\n)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) then []\nelse (\nlet n = n - (n mod 10);\n(n :: myList) :: digitsOfInt\n)"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt n", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse (\nlet n = n - (n mod 10);\n(n :: myList) :: digitsOfInt", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) then []\nelse (\nlet n = n - (n mod 10);\n(n :: myList) :: digitsOfInt"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt n", "bad": ")", "annotated": ")"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt n", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse (\n(n mod 10 :: myList) :: digitsOfInt\n)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) then []\nelse (\n(n mod 10 :: myList) :: digitsOfInt\n)"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt (n - n mod 10)", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt"}
{"fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10))", "bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10)"}
{"fix": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \nList.rev (n mod 10 :: digitsOfInt (n / 10))", "bad": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \nrev (n mod 10 :: digitsOfInt (n / 10))", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif (n <= 0) then []\nelse \nrev (n mod 10 :: digitsOfInt (n / 10))"}
{"fix": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10))", "bad": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: List.rev digitsOfInt (n / 10))", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif (n <= 0) then []\nelse \n(n mod 10 :: List.rev digitsOfInt (n / 10))"}
{"fix": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10))", "bad": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \nlet _ = (n mod 10 :: digitsOfInt (n / 10))", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif (n <= 0) then []\nelse \nlet _ = (n mod 10 :: digitsOfInt (n / 10))"}
{"fix": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10))", "bad": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10))\nList.rev", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif (n <= 0) then []\nelse \n(n mod 10 :: digitsOfInt (n / 10))\nList.rev"}
{"fix": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: List.rev (digitsOfInt (n / 10)))", "bad": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: List.rev digitsOfInt (n / 10))", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif (n <= 0) then []\nelse \n(n mod 10 :: List.rev digitsOfInt (n / 10))"}
{"fix": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: List.rev (digitsOfInt (n / 10)))", "bad": "let rec digitsOfInt n =\nif (n <= 0) then []\nelse \n(n mod 10 :: (List.rev digitsOfInt (n / 10)))", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif (n <= 0) then []\nelse \n(n mod 10 :: (List.rev digitsOfInt (n / 10)))"}
{"fix": "let rec additivePersistence n = \n(digitsOfInt n)", "bad": "let rec additivePersistence n = \n- = digitsOfInt n", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \n- = digitsOfInt n"}
{"fix": "let rec additivePersistence n = \n(digitsOfInt n)", "bad": "let rec additivePersistence n = \nlet a = (digitsOfInt n)", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet a = (digitsOfInt n)"}
{"fix": "let rec additivePersistence n = \nmatch (digitsOfInt n) with\n| [] -> 0\n| _ -> sumList (digitsOfInt n)", "bad": "let rec additivePersistence n = \nmatch (digitsOfInt n) with\n| [] -> 0\n| (h::t) -> h + t", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nmatch (digitsOfInt n) with\n| [] -> 0\n| (h::t) -> h + t"}
{"fix": "let rec additivePersistence n = \nmatch (digitsOfInt n) with\n| [] -> 0\n| _ -> sumList (digitsOfInt n)", "bad": "let rec additivePersistence n = \nmatch (digitsOfInt n) with\n| [] -> 0\n| _ -> sumList digitsOfInt n", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nmatch (digitsOfInt n) with\n| [] -> 0\n| _ -> sumList digitsOfInt n"}
{"fix": "let rec additivePersistence n = \nmatch (digitsOfInt n) with\n| [] -> 0\n| _ -> sumList (digitsOfInt n)", "bad": "let rec additivePersistence n = \nmatch (digitsOfInt n) with\n| [] -> 0;\n| _ -> sumList digitsOfInt n", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nmatch (digitsOfInt n) with\n| [] -> 0;\n| _ -> sumList digitsOfInt n"}
{"fix": "let rec additivePersistence n = \nmatch (digitsOfInt n) with\n| [] -> 0\n| _ -> sumList (digitsOfInt n)", "bad": "let rec additivePersistence n = \nmatch (digitsOfInt n) with\n| [] -> 0\n| _ -> sumList digitsOfInt n;", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nmatch (digitsOfInt n) with\n| [] -> 0\n| _ -> sumList digitsOfInt n;"}
{"fix": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) then additivePersistence (sumList (digitsOfInt n))", "bad": "let rec additivePersistence n = \nlet _ = sumList (digitsOfInt n)", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet _ = sumList (digitsOfInt n)"}
{"fix": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) then additivePersistence (sumList (digitsOfInt n))", "bad": "let rec additivePersistence n = \nlet _ = sumList (digitsOfInt n)", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet _ = sumList (digitsOfInt n)"}
{"fix": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) then additivePersistence (sumList (digitsOfInt n))", "bad": "let rec additivePersistence n = \nlet _ = 2", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet _ = 2"}
{"fix": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) > 9) then additivePersistence (sumList (digitsOfInt n))", "bad": "let rec additivePersistence n = \nlet _ = 2", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet _ = 2"}
{"fix": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen  \nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count", "bad": "let rec additivePersistence n = \nlet count = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen  \ncount++\nelse\nsumList (digitsOfInt n)", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet count = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen  \ncount++\nelse\nsumList (digitsOfInt n)"}
{"fix": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen  \nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count", "bad": "let rec additivePersistence n = \nlet count = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen  \ncount++", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet count = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen  \ncount++"}
{"fix": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen  \nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count", "bad": "let rec additivePersistence n = \nlet count = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen  \ncount = count + 1", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet count = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen  \ncount = count + 1"}
{"fix": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen  \nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count", "bad": "let rec additivePersistence n = \nlet count = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen  \nlet count = count + 1", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet count = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen  \nlet count = count + 1"}
{"fix": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen  \nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count", "bad": "let rec additivePersistence n = \nlet count = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen  \nlet count = 9", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet count = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen  \nlet count = 9"}
{"fix": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen  \nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count", "bad": "let rec additivePersistence n = \nlet count = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen  \nlet co = 9", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet count = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen  \nlet co = 9"}
{"fix": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen  \nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count", "bad": "let rec additivePersistence n = \nlet count = [] in\nif (sumList (digitsOfInt n) > 9) \nthen  \n1::count\nadditivePersistence (sumList (digitsOfInt n))", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet count = [] in\nif (sumList (digitsOfInt n) > 9) \nthen  \n1::count\nadditivePersistence (sumList (digitsOfInt n))"}
{"fix": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen  \nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count", "bad": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen  \n1::count\nadditivePersistence (sumList (digitsOfInt n))", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen  \n1::count\nadditivePersistence (sumList (digitsOfInt n))"}
{"fix": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen  \nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count", "bad": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen  \n1::count\nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen  \n1::count\nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "bad": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen  \n1::count\nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen  \n1::count\nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "bad": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen (\n1::count\nadditivePersistence (sumList (digitsOfInt n)))\nelse sumList count", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen (\n1::count\nadditivePersistence (sumList (digitsOfInt n)))\nelse sumList count"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "bad": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen \n1::count\nelse sumList count", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen \n1::count\nelse sumList count"}
{"fix": "let rec additivePersistence n = \nlet x = 1 in x + 1;\nif (sumList (digitsOfInt n) > 9) \nthen \nadditivePersistence (sumList (digitsOfInt n))\nelse x", "bad": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen \n1::count & additivePersistence (sumList (digitsOfInt n))\nelse sumList count", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen \n1::count & additivePersistence (sumList (digitsOfInt n))\nelse sumList count"}
{"fix": "let rec additivePersistence n = \nlet x = 1 in x + 1;\nif (sumList (digitsOfInt n) > 9) \nthen \nadditivePersistence (sumList (digitsOfInt n))\nelse x", "bad": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen \n1::count && additivePersistence (sumList (digitsOfInt n))\nelse sumList count", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen \n1::count && additivePersistence (sumList (digitsOfInt n))\nelse sumList count"}
{"fix": "let rec additivePersistence n = \nlet x = 1 in x + 1;\nif (sumList (digitsOfInt n) > 9) \nthen \nadditivePersistence (sumList (digitsOfInt n))\nelse x", "bad": "let rec additivePersistence n = \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen \n1::count &&& additivePersistence (sumList (digitsOfInt n))\nelse sumList count", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet count = [0] in\nif (sumList (digitsOfInt n) > 9) \nthen \n1::count &&& additivePersistence (sumList (digitsOfInt n))\nelse sumList count"}
{"fix": "let rec additivePersistence n = \nlet x = 1 in x + 1;\nif (sumList (digitsOfInt n) > 9) \nthen \nadditivePersistence (sumList (digitsOfInt n))\nelse x", "bad": "let rec additivePersistence n = \nlet x = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen \nx + 1\nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet x = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen \nx + 1\nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count"}
{"fix": "let rec additivePersistence n = \nlet x = 1 in x + 1;\nif (sumList (digitsOfInt n) > 9) \nthen \nadditivePersistence (sumList (digitsOfInt n))\nelse x", "bad": "let rec additivePersistence n = \nlet x = 1 in\nx = x + 1\nif (sumList (digitsOfInt n) > 9) \nthen \nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet x = 1 in\nx = x + 1\nif (sumList (digitsOfInt n) > 9) \nthen \nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count"}
{"fix": "let rec additivePersistence n = \nlet x = 1 in x + 1;\nif (sumList (digitsOfInt n) > 9) \nthen \nadditivePersistence (sumList (digitsOfInt n))\nelse x", "bad": "let rec additivePersistence n = \nlet x = 1 in x + 1\nif (sumList (digitsOfInt n) > 9) \nthen \nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet x = 1 in x + 1\nif (sumList (digitsOfInt n) > 9) \nthen \nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count"}
{"fix": "let rec additivePersistence n = \nlet x = 1 in x + 1;\nif (sumList (digitsOfInt n) > 9) \nthen \nadditivePersistence (sumList (digitsOfInt n))\nelse x", "bad": "let rec additivePersistence n = \nlet x = 1 in x + 1;\nif (sumList (digitsOfInt n) > 9) \nthen \nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet x = 1 in x + 1;\nif (sumList (digitsOfInt n) > 9) \nthen \nadditivePersistence (sumList (digitsOfInt n))\nelse sumList count"}
{"fix": "let rec additivePersistence n = \nlet x = 1 in x + 1", "bad": "let rec additivePersistence n = \nlet x = 1 in x + 1\nif (sumList (digitsOfInt n) > 9) \nthen \nadditivePersistence (sumList (digitsOfInt n))\nelse x", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet x = 1 in x + 1\nif (sumList (digitsOfInt n) > 9) \nthen \nadditivePersistence (sumList (digitsOfInt n))\nelse x"}
{"fix": "let rec additivePersistence n = \nlet x = [0] in\nif (sumList (digitsOfInt n) > 9) then begin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse sumList x", "bad": "let rec additivePersistence n = \nlet x = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen begin\nlet x = x + 1;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse x", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet x = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen begin\nlet x = x + 1;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse x"}
{"fix": "let rec additivePersistence n = \nlet x = [0] in\nif (sumList (digitsOfInt n) > 9) then begin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse sumList x", "bad": "let rec additivePersistence n = \nlet x = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen begin\nlet x = x + 1;\nadditivePersistence (sumList (digitsOfInt n))\nend;\nelse x", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet x = 1 in\nif (sumList (digitsOfInt n) > 9) \nthen begin\nlet x = x + 1;\nadditivePersistence (sumList (digitsOfInt n))\nend;\nelse x"}
{"fix": "let rec additivePersistence n = \nlet x = [0] in\nif (sumList (digitsOfInt n) > 9) then begin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse sumList x", "bad": "let rec additivePersistence n = \nlet x = 1 in\nif (sumList (digitsOfInt n) > 9) then begin\nlet x = x + 1", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet x = 1 in\nif (sumList (digitsOfInt n) > 9) then begin\nlet x = x + 1"}
{"fix": "let rec additivePersistence n = \nlet x = [0] in\nif (sumList (digitsOfInt n) > 9) then begin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse sumList x", "bad": "additivePersistence (sumList (digitsOfInt n))\nend;\nelse x", "annotated": "additivePersistence (sumList (digitsOfInt n))\nend;\nelse x"}
{"fix": "let rec additivePersistence n = \nlet x = [0] in\nif (sumList (digitsOfInt n) > 9) then begin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse sumList x", "bad": "let rec additivePersistence n = \nlet x = [0] in\nif (sumList (digitsOfInt n) > 9) then begin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend;\nelse sumList x", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet x = [0] in\nif (sumList (digitsOfInt n) > 9) then begin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend;\nelse sumList x"}
{"fix": "let rec additivePersistence n = \nlet x = [0] in\nif (sumList (digitsOfInt n) > 9) then begin\n1 :: x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse sumList x", "bad": "let rec additivePersistence n = \nlet x = [0] in\nif (sumList (digitsOfInt n) > 9) then begin\n1::x\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse sumList x", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet x = [0] in\nif (sumList (digitsOfInt n) > 9) then begin\n1::x\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse sumList x"}
{"fix": "let rec additivePersistence n = \nlet x = [1] in\n1::x;\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x", "bad": "let rec additivePersistence n = \nlet x = [1]\n1::x;\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet x = [1]\n1::x;\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x"}
{"fix": "let rec additivePersistence n = \nlet x = [1] in\n1::x;\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x", "bad": "let rec additivePersistence n = \nlet x = [1]\n1::x\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet x = [1]\n1::x\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x"}
{"fix": "let rec additivePersistence n = \nlet x = [1] in\n1::x;\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x", "bad": "let rec additivePersistence n = \nlet x = [1]\n1::x\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet x = [1]\n1::x\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x"}
{"fix": "let x = [1]", "bad": "let x = [1] in\nlet rec additivePersistence n = \n1::x;\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x", "annotated": "let x = [1] in\nlet rec additivePersistence : int -> int = fun  n  ->  \n1::x;\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x"}
{"fix": "let rec additivePersistence n = \n1::x", "bad": "let rec additivePersistence n = \n1::x\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \n1::x\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x"}
{"fix": "let rec additivePersistence n = \n1::x", "bad": "let rec additivePersistence n = \n1::x\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \n1::x\nif (sumList (digitsOfInt n) > 9) then \nadditivePersistence (sumList (digitsOfInt n))\nelse \nsumList x"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "bad": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) then begin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse begin\n1:x;\nsumList x\nend", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif (sumList (digitsOfInt n) < 9) then begin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse begin\n1:x;\nsumList x\nend"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "bad": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) then begin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend;\nelse begin\n1:x;\nsumList x\nend;", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif (sumList (digitsOfInt n) < 9) then begin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend;\nelse begin\n1:x;\nsumList x\nend;"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "bad": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) then begin\n1::x\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse begin\n1:x;\nsumList x\nend", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif (sumList (digitsOfInt n) < 9) then begin\n1::x\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse begin\n1:x;\nsumList x\nend"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "bad": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) then begin\n1::x\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse begin\n1:x;\nsumList x", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif (sumList (digitsOfInt n) < 9) then begin\n1::x\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse begin\n1:x;\nsumList x"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "bad": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) then begin\n1::x\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse begin\n1:x;\nsumList x\nend", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif (sumList (digitsOfInt n) < 9) then begin\n1::x\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse begin\n1:x;\nsumList x\nend"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "bad": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) then begin\n1::x\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse begin\n1:x;\nsumList x;\nend", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif (sumList (digitsOfInt n) < 9) then begin\n1::x\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse begin\n1:x;\nsumList x;\nend"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "bad": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) then begin\n1::x\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse begin\n1:x;\nsumList x;", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif (sumList (digitsOfInt n) < 9) then begin\n1::x\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse begin\n1:x;\nsumList x;"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "bad": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) then begin\n1::x\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse begin\n1:x;\nsumList x;\nend", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif (sumList (digitsOfInt n) < 9) then begin\n1::x\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse begin\n1:x;\nsumList x;\nend"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "bad": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) then begin\n1::x\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1:x;\nsumList x;\nend", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif (sumList (digitsOfInt n) < 9) then begin\n1::x\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1:x;\nsumList x;\nend"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "bad": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1:x;\nsumList x;\nend", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1:x;\nsumList x;\nend"}
{"fix": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \n\nsumList x;", "bad": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1:x;\nsumList x;\nend", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1:x;\nsumList x;\nend"}
{"fix": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \n\nsumList x;", "bad": "end", "annotated": "end"}
{"fix": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \n\nsumList x;", "bad": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1:x;\nsumList x;\nend", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1:x;\nsumList x;\nend"}
{"fix": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \n\nsumList x;", "bad": "end", "annotated": "end"}
{"fix": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \n\nsumList x;", "bad": "end", "annotated": "end"}
{"fix": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \n\nsumList x;", "bad": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \n1:x;\nsumList x;", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \n1:x;\nsumList x;"}
{"fix": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \n\nsumList x;", "bad": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \n1::x;\nsumList x;", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \n1::x;\nsumList x;"}
{"fix": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList x;\nend", "bad": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList x;", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList x;"}
{"fix": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList x;\nend", "bad": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1:x;\nsumList x;\nend", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1:x;\nsumList x;\nend"}
{"fix": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList [1;2];\nend", "bad": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList [1:2];\nend", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList [1:2];\nend"}
{"fix": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList x\nend", "bad": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x"}
{"fix": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList x\nend", "bad": "additivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x", "annotated": "additivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x"}
{"fix": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList x\nend", "bad": "sumList x\nend", "annotated": "sumList x\nend"}
{"fix": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList x\nend", "bad": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x"}
{"fix": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList x\nend", "bad": "additivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x\nsumList x\nend", "annotated": "additivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x\nsumList x\nend"}
{"fix": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n(1::x);\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n(1::x);\nsumList x\nend", "bad": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x;\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x"}
{"fix": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n(1::x);\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n(1::x);\nsumList x\nend", "bad": "sumList x\nend", "annotated": "sumList x\nend"}
{"fix": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n(1::x);\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n(1::x);\nsumList x\nend", "bad": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n1::x"}
{"fix": "let rec additivePersistence n = \nif (sumList (digitsOfInt n) < 9) \nthen \nbegin\n(1::x);\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n(1::x);\nsumList x\nend", "bad": "additivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList x\nend", "annotated": "additivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\n1::x;\nsumList x\nend"}
{"fix": "let rec listReverse l = \nlet explosion = explode l;", "bad": "let rec listReverse l = \nexplode l\n\nlistReverse \"nikhil\"", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nexplode l\n\nlistReverse \"nikhil\""}
{"fix": "let rec listReverse l = \nexplode l", "bad": "let rec listReverse l = \nlet explosion = explode l", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nlet explosion = explode l"}
{"fix": "let rec listReverse l = match l with \n[] -> []", "bad": "let rec listReverse l = \nexplode l match l with\n| [] -> 0", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nexplode l match l with\n| [] -> 0"}
{"fix": "let rec listReverse l = match l with \n[] -> []", "bad": "let rec listReverse l = \nlet p = explode l match p with\n| [] -> 0", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nlet p = explode l match p with\n| [] -> 0"}
{"fix": "let rec listReverse l = match l with \n[] -> []", "bad": "let rec listReverse l = \nlet p = (explode l) match p with\n| [] -> 0", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nlet p = (explode l) match p with\n| [] -> 0"}
{"fix": "let rec listReverse l = match l with \n[] -> []", "bad": "let rec listReverse l = \nlet p -> (explode l) match p with\n| [] -> 0", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nlet p -> (explode l) match p with\n| [] -> 0"}
{"fix": "let rec listReverse l = match l with \n[] -> []", "bad": "let rec listReverse l = \nlet explosion = \n(explode l) match p with\n| [] -> 0", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nlet explosion = \n(explode l) match p with\n| [] -> 0"}
{"fix": "let rec listReverse l = match l with \n|[] -> []\n|[h1] -> h1::[]\n|(h::t) -> h::(listReverse t)", "bad": "let rec listReverse l = match l with \n|[] -> []\n|(h1) -> h1::[]\n|(h::t) -> h::(listReverse t)", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with \n|[] -> []\n|(h1) -> h1::[]\n|(h::t) -> h::(listReverse t)"}
{"fix": "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> h::(listReverse t)", "bad": "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> (listReverse t)::h", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with \n|[] -> []\n|(h::t) -> (listReverse t)::h"}
{"fix": "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> begin\n(listReverse t);\nh::[]\nend", "bad": "let rec listReverse l = match l with \n|[] -> h::[]\n|(h::t) -> listReverse t", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with \n|[] -> h::[]\n|(h::t) -> listReverse t"}
{"fix": "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> begin\n(listReverse t);\nh::[]\nend", "bad": "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> listReverse t\n|_ -> h::[]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with \n|[] -> []\n|(h::t) -> listReverse t\n|_ -> h::[]"}
{"fix": "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> begin\n(listReverse t);\nh::[]\nend", "bad": "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> listReverse t\nh::[]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with \n|[] -> []\n|(h::t) -> listReverse t\nh::[]"}
{"fix": "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> begin\n(listReverse t);\nh::[]\nend", "bad": "let rec listReverse l = match l with \n|[] -> []\n|(h::t) -> (listReverse t)\nh::[]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with \n|[] -> []\n|(h::t) -> (listReverse t)\nh::[]"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "bad": "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count = function\nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n\nsumList x\nend", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet count = 1 in\nlet rec apCalc n count = function\nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n\nsumList x\nend"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "bad": "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count = function\nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n\nsumList x\nend", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet count = 1 in\nlet rec apCalc n count = function\nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n\nsumList x\nend"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "bad": "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count = function\nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n\nsumList x\nend", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet count = 1 in\nlet rec apCalc n count = function\nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n\nsumList x\nend"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "bad": "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count = function\nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n\nsumList x\nend", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet count = 1 in\nlet rec apCalc n count = function\nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n\nsumList x\nend"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "bad": "let additivePersistence n = \nlet count = 1", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet count = 1"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "bad": "let rec apCalc n count = function\nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n\nsumList x\nend", "annotated": "let rec apCalc n count = function\nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\nadditivePersistence (sumList (digitsOfInt n))\nend\nelse \nbegin\nprint_string \"going into else | \";\n\nsumList x\nend"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "bad": "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count = function\nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\napCalc (sumList (digitsOfInt n)) (count + 1)\nend\nelse \nbegin\nprint_string \"going into else | \";\n\ncount\nend", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet count = 1 in\nlet rec apCalc n count = function\nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\napCalc (sumList (digitsOfInt n)) (count + 1)\nend\nelse \nbegin\nprint_string \"going into else | \";\n\ncount\nend"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "bad": "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count = fun\nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\napCalc (sumList (digitsOfInt n)) (count + 1)\nend\nelse \nbegin\nprint_string \"going into else | \";\n\ncount\nend", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet count = 1 in\nlet rec apCalc n count = fun\nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\napCalc (sumList (digitsOfInt n)) (count + 1)\nend\nelse \nbegin\nprint_string \"going into else | \";\n\ncount\nend"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "bad": "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count = \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\napCalc (sumList (digitsOfInt n)) (count + 1)\nend\nelse \nbegin\nprint_string \"going into else | \";\n\ncount\nend", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet count = 1 in\nlet rec apCalc n count = \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\napCalc (sumList (digitsOfInt n)) (count + 1)\nend\nelse \nbegin\nprint_string \"going into else | \";\n\ncount\nend"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "bad": "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count = \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\napCalc (sumList (digitsOfInt n)) (count + 1)\nend\nelse \nbegin\nprint_string \"going into else | \";\n\ncount\nend\nin", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet count = 1 in\nlet rec apCalc n count = \nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\napCalc (sumList (digitsOfInt n)) (count + 1)\nend\nelse \nbegin\nprint_string \"going into else | \";\n\ncount\nend\nin"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "bad": "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count = in\nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\napCalc (sumList (digitsOfInt n)) (count + 1)\nend\nelse \nbegin\nprint_string \"going into else | \";\n\ncount\nend", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet count = 1 in\nlet rec apCalc n count = in\nif (sumList (digitsOfInt n) > 9) \nthen \nbegin\nprint_string \"going into then | \";\n\napCalc (sumList (digitsOfInt n)) (count + 1)\nend\nelse \nbegin\nprint_string \"going into else | \";\n\ncount\nend"}
{"fix": "let additivePersistence n = \nlet count = 1", "bad": "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count"}
{"fix": "let additivePersistence n = \nlet count = 1", "bad": "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count"}
{"fix": "let additivePersistence n = \nlet count = 1", "bad": "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse sumList count", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse sumList count"}
{"fix": "let additivePersistence n = \nlet count = 1", "bad": "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count"}
{"fix": "let additivePersistence n = \nlet count = 1", "bad": "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count in", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count in"}
{"fix": "let additivePersistence n = \nlet count = 1", "bad": "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count\nin", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count\nin"}
{"fix": "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count", "bad": "let additivePersistence n = \nlet count = 1;\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet count = 1;\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count"}
{"fix": "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count", "bad": "let additivePersistence n = \nlet count = 1;\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet count = 1;\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count"}
{"fix": "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count", "bad": "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count"}
{"fix": "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count", "bad": "let additivePersistence n = \nlet count = 1 in\nbegin \nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count\nend", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet count = 1 in\nbegin \nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count\nend"}
{"fix": "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count", "bad": "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse count"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| (h::t) -> h + sumList t\n| _ -> -1", "bad": "let additivePersistence n = \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse poum", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet count = 1 in\nlet rec apCalc n count =\nif (sumList (digitsOfInt n) > 9) then apCalc (sumList (digitsOfInt n)) (count + 1)\nelse poum"}
{"fix": "let additivePersistence n = n + 1", "bad": "let additivePersistence n =", "annotated": "let additivePersistence : int -> int = fun  n  -> "}
{"fix": "let additivePersistence n a = n + a", "bad": "let additivePersistence n a = n + a + b", "annotated": "let additivePersistence : int -> int = fun  n a  ->  n + a + b"}
{"fix": "let additivePersistence n a = \nif (sumList (digitsOfInt n) > 9)\nthen additivePersistence (sumList (digitsOfInt n)) (a + 1)\nelse 9", "bad": "let additivePersistence n a = \nif (sumList (digitsOfInt n) > 9)\nthen additivePersistence (sumList (digitsOfInt n)) (a + 1)", "annotated": "let additivePersistence : int -> int = fun  n a  ->  \nif (sumList (digitsOfInt n) > 9)\nthen additivePersistence (sumList (digitsOfInt n)) (a + 1)"}
{"fix": "let _ = additivePersistence 9876", "bad": "let _ = additivePersistence 9876 1", "annotated": "let _ = additivePersistence 9876 1"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> if ((extract1 h) = k) then (extract2)\nelse assoc (d, k, t)", "bad": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t - > if ((extract1 h) = k) then (extract2)\nelse assoc (d, k, t)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with\n| [] -> d\n| h::t - > if ((extract1 h) = k) then (extract2)\nelse assoc (d, k, t)"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> d", "bad": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n|", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with\n| [] -> d\n| h::t -> match h with\n|"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> d", "bad": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if ("}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) else (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (mem h l) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (mem h l) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) else (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (not l.mem h ) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (not l.mem h ) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) else (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if not (l.mem h ) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if not (l.mem h ) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) else (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if !(l.mem h ) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if !(l.mem h ) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) else (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if !(List.mem h seen) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if !(List.mem h seen) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) else (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (!List.mem h seen) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (!List.mem h seen) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) else (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (!(List.mem h seen)) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (!(List.mem h seen)) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) else (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h :: seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) else (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) else (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::[]) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::[]) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) else (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) else (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) else (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then ([]) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then ([]) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) else (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then ([2]) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then ([2]) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) else (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen) then (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen) then (h::seen) in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then (h::seen) else seen in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if !(List.mem h seen) then (h::seen) else seen in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if !(List.mem h seen) then (h::seen) else seen in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (not (List.mem h seen)) then (h::seen) else seen in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (!List.mem h seen) then (h::seen) else seen in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (!List.mem h seen) then (h::seen) else seen in\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let fixpoint (f,b) = wwhile (f,b)", "bad": "let fixpoint (f,b) = wwhile (b,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (b,b)"}
{"fix": "let fixpoint (f,b) = b", "bad": "let fixpoint (f,b) = wwhile (b,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (b,b)"}
{"fix": "let fixpoint (f,b) = wwhile ((f),b)", "bad": "let fixpoint (f,b) = wwhile (f,f b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (f,f b)"}
{"fix": "let fixpoint (f,b) = wwhile ((f ),b)", "bad": "let fixpoint (f,b) = wwhile ((f a),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((f a),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((f b),b)", "bad": "let fixpoint (f,b) = wwhile ((fixpoint (f,b)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((fixpoint (f,b)),b)"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "bad": "let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else fixpoint (f b, b),b))", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((if (not(f b)  ->  b) then b else fixpoint (f b, b),b))"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "bad": "let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else fixpoint (f,f b),b))", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((if (not(f b)  ->  b) then b else fixpoint (f,f b),b))"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "bad": "let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else (fixpoint (f,f b),b)))", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((if (not(f b)  ->  b) then b else (fixpoint (f,f b),b)))"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "bad": "let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else (fixpoint (f,b))))", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((if (not(f b)  ->  b) then b else (fixpoint (f,b))))"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "bad": "let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else (fixpoint (f,b),b)))", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((if (not(f b)  ->  b) then b else (fixpoint (f,b),b)))"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "bad": "let fixpoint (f,b) = wwhile ((if (not(f b) = b) then b else (fixpoint (f,b),b)))", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((if (not(f b)  ->  b) then b else (fixpoint (f,b),b)))"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "bad": "let fixpoint (f,b) = wwhile (if ((f b) = b) then b else (fixpoint (f,b),b))", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (if ((f b)  ->  b) then b else (fixpoint (f,b),b))"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "bad": "let fixpoint (f,b) = wwhile (if ((f b) = b) then b else wwhile (f,f b))", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (if ((f b)  ->  b) then b else wwhile (f,f b))"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "bad": "let fixpoint (f,b) = wwhile (if ((f b) = b) then b, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (if ((f b)  ->  b) then b, b)"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "bad": "let fixpoint (f,b) = wwhile ((if ((f b) = b) then b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((if ((f b)  ->  b) then b), b)"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "bad": "let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (f (if ((f b)  ->  b) then b), b)"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "bad": "let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b else b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (f (if ((f b)  ->  b) then b else b), b)"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "bad": "let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b else b), a)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (f (if ((f b)  ->  b) then b else b), a)"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "bad": "let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b else b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (f (if ((f b)  ->  b) then b else b), b)"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "bad": "let fixpoint (f,b) = wwhile (f (if ((f b) = b) then b else b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (f (if ((f b)  ->  b) then b else b), b)"}
{"fix": "let fixpoint (f,b) = wwhile ((failwith \"to be written\"), b)", "bad": "let fixpoint (f,b) = wwhile (f (if ((f b) = b) then 1 else 0), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (f (if ((f b)  ->  b) then 1 else 0), b)"}
{"fix": "let fixpoint (f,b) = wwhile ((failwith \"to be written\"), b)", "bad": "let fixpoint (f,b) = wwhile ((let h x = (f x) in (x, x = b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let h x = (f x) in (x, x  ->  b), b)"}
{"fix": "let fixpoint (f,b) = wwhile ((failwith \"to be written\"), b)", "bad": "let fixpoint (f,b) = wwhile ((let h x = (f x) in (x, x = b), b))", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let h x = (f x) in (x, x  ->  b), b))"}
{"fix": "let fixpoint (f,b) = wwhile ((failwith \"to be written\"), b)", "bad": "let fixpoint (f,b) = wwhile ((fun x -> x ), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((fun x -> x ), b)"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "bad": "let rec exprToString e = match e with\n| VarX -> sprintf \"%s\" VarX", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> sprintf \"%s\" VarX"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "bad": "let rec exprToString e = match e with\n| VarX -> sprintf \"%s\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> sprintf \"%s\""}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "bad": "let rec exprToString e = match e with\n| VarX -> printf \"%s\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> printf \"%s\""}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "bad": "let rec exprToString e = match e with\n| VarX a -> sprintf \"%s\" a", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX a -> sprintf \"%s\" a"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "bad": "let rec exprToString e = match e with\n| VarX v a -> sprintf \"%s\" a", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX v a -> sprintf \"%s\" a"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "bad": "let rec exprToString e = match e with\n| VarX a b -> sprintf \"%s\" a", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX a b -> sprintf \"%s\" a"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "bad": "let rec exprToString e = match e with\n| VarX a -> sprintf \"%s\" a", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX a -> sprintf \"%s\" a"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "bad": "let rec exprToString e = match e with\n| Sine s -> sprintf \"%s\" s", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| Sine s -> sprintf \"%s\" s"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "bad": "let rec exprToString e = match e with\n| Sine s -> printf \"%s\" s", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| Sine s -> printf \"%s\" s"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"", "bad": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3.142 * e))", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3.142 * e))"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"", "bad": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * e))", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * e))"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"", "bad": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * 2))", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * 2))"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"", "bad": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3.0 * 2.0))", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3.0 * 2.0))"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"", "bad": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * 2.0))", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * 2.0))"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"", "bad": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * 2))", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * 2))"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"", "bad": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%i\" (sin (3 * 2))", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| Sine s -> Format.sprintf \"%i\" (sin (3 * 2))"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"", "bad": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%i\" (sin (3.0 * 2.0))", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| Sine s -> Format.sprintf \"%i\" (sin (3.0 * 2.0))"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.sprintf \"%expr\" 1.0 ^ \")\"", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ s ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ s ^ \")\""}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.sprintf \"%expr\" 1.0 ^ \")\"", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.sprintf \"%expr\" s ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.sprintf \"%expr\" s ^ \")\""}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ (exprToString s)  ^ \")\"", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.sprintf \"%_\" s  ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.sprintf \"%_\" s  ^ \")\""}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ (exprToString s)  ^ \")\"", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.sprintf \"%\" s  ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.sprintf \"%\" s  ^ \")\""}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ (exprToString s)  ^ \")\"", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.printf \"%\" s  ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.printf \"%\" s  ^ \")\""}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ (exprToString s)  ^ \")\"", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.printf \"%f\" s  ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.printf \"%f\" s  ^ \")\""}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ (exprToString s)  ^ \")\"", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.printf \"%i\" s  ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.printf \"%i\" s  ^ \")\""}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ (exprToString s)  ^ \")\"", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.printf \"%expr\" s  ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.printf \"%expr\" s  ^ \")\""}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ (exprToString s)  ^ \")\"", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.printf \"%e\" s  ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ Format.printf \"%e\" s  ^ \")\""}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ (exprToString s)  ^ \")\"\n| Cosine c -> \"cos(pi*\" ^ (exprToString c) ^ \")\"\n| Average (a1,a2) -> \"((\" ^ (exprToString a1) ^ \"+\" ^ (exprToString a2) ^ \")/2)\"\n| Times (t1,t2) -> \"(\" ^ (exprToString t1) ^ \"*\" ^ (exprToString t2) ^ \")\"", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ (exprToString s)  ^ \")\"\n| Cosine c -> \"cos(pi*\" ^ (exprToString c) ^ \")\"\n| Average a1 a2 -> \"((\" ^ (exprToString a1) ^ \"+\" ^ (exprToString a2) ^ \")/2)\"\n| Times t1 t2 -> \"(\" ^ (exprToString t1) ^ \"*\" ^ (exprToString t2) ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ (exprToString s)  ^ \")\"\n| Cosine c -> \"cos(pi*\" ^ (exprToString c) ^ \")\"\n| Average a1 a2 -> \"((\" ^ (exprToString a1) ^ \"+\" ^ (exprToString a2) ^ \")/2)\"\n| Times t1 t2 -> \"(\" ^ (exprToString t1) ^ \"*\" ^ (exprToString t2) ^ \")\""}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ (exprToString s)  ^ \")\"\n| Cosine c -> \"cos(pi*\" ^ (exprToString c) ^ \")\"\n| Average (a1,a2) -> \"((\" ^ (exprToString a1) ^ \"+\" ^ (exprToString a2) ^ \")/2)\"\n| Times (t1,t2) -> \"(\" ^ (exprToString t1) ^ \"*\" ^ (exprToString t2) ^ \")\"", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ (exprToString s)  ^ \")\"\n| Cosine c -> \"cos(pi*\" ^ (exprToString c) ^ \")\"\n| Average a1 a2 -> \"((\" ^ (exprToString a1) ^ \"+\" ^ (exprToString a2) ^ \")/2)\"\n| Times t1 t2 -> \"(\" ^ (exprToString t1) ^ \"*\" ^ (exprToString t2) ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ (exprToString s)  ^ \")\"\n| Cosine c -> \"cos(pi*\" ^ (exprToString c) ^ \")\"\n| Average a1 a2 -> \"((\" ^ (exprToString a1) ^ \"+\" ^ (exprToString a2) ^ \")/2)\"\n| Times t1 t2 -> \"(\" ^ (exprToString t1) ^ \"*\" ^ (exprToString t2) ^ \")\""}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ (exprToString s)  ^ \")\"\n| Cosine c -> \"cos(pi*\" ^ (exprToString c) ^ \")\"\n| Average (a1,a2) -> \"((\" ^ (exprToString a1) ^ \"+\" ^ (exprToString a2) ^ \")/2)\"\n| Times (t1,t2) -> \"(\" ^ (exprToString t1) ^ \"*\" ^ (exprToString t2) ^ \")\"", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ (exprToString s)  ^ \")\"\n| Cosine c -> \"cos(pi*\" ^ (exprToString c) ^ \")\"\n| Average (a1,a2) -> \"((\" ^ (exprToString a1) ^ \"+\" ^ (exprToString a2) ^ \")/2)\"\n| Times t1 t2 -> \"(\" ^ (exprToString t1) ^ \"*\" ^ (exprToString t2) ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine s -> \"sin(pi*\" ^ (exprToString s)  ^ \")\"\n| Cosine c -> \"cos(pi*\" ^ (exprToString c) ^ \")\"\n| Average (a1,a2) -> \"((\" ^ (exprToString a1) ^ \"+\" ^ (exprToString a2) ^ \")/2)\"\n| Times t1 t2 -> \"(\" ^ (exprToString t1) ^ \"*\" ^ (exprToString t2) ^ \")\""}
{"fix": "let mine = buildAverage(VarX, VarY)", "bad": "let mine = buildAverage(2.0, 4.0)", "annotated": "let mine = buildAverage(2.0, 4.0)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x \n| VarY -> y\n| Average (a1,a2) -> buildAverage(a1,a2)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> let vx = x in\n| VarY -> let vy = y in \n| Average -> buildAverage (vx, vy)", "annotated": "let rec eval (e,x,y) = match e with\n| VarX -> let vx = x in\n| VarY -> let vy = y in \n| Average -> buildAverage (vx, vy)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x \n| VarY -> y\n| Average (a1,a2) -> buildAverage(a1,a2)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> let vx = x in \n| VarY -> let vy = y in\n| Sine -> \n| Average -> buildAverage(vx,vy)", "annotated": "let rec eval (e,x,y) = match e with\n| VarX -> let vx = x in \n| VarY -> let vy = y in\n| Sine -> \n| Average -> buildAverage(vx,vy)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x \n| VarY -> y\n| Average (a1,a2) -> buildAverage(a1,a2)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> let vx = x  \n| VarY -> let vy = y in\n| Sine -> \n| Average -> buildAverage(vx,vy)", "annotated": "let rec eval (e,x,y) = match e with\n| VarX -> let vx = x  \n| VarY -> let vy = y in\n| Sine -> \n| Average -> buildAverage(vx,vy)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x \n| VarY -> y\n| Average (a1,a2) -> buildAverage(a1,a2)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> let vx = x  \n| VarY -> let vy = y \n| Sine -> \n| Average -> buildAverage(vx,vy)", "annotated": "let rec eval (e,x,y) = match e with\n| VarX -> let vx = x  \n| VarY -> let vy = y \n| Sine -> \n| Average -> buildAverage(vx,vy)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x \n| VarY -> y\n| Average (a1,a2) -> buildAverage(a1,a2)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> let vx = x  \n| VarY -> let vy = y \n| Average -> buildAverage(vx,vy)", "annotated": "let rec eval (e,x,y) = match e with\n| VarX -> let vx = x  \n| VarY -> let vy = y \n| Average -> buildAverage(vx,vy)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x \n| VarY -> y\n| Average (a1,a2) -> buildAverage(a1,a2)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> let vx = x in vx \n| VarY -> let vy = y in vy\n| Average -> buildAverage(vx,vy)", "annotated": "let rec eval (e,x,y) = match e with\n| VarX -> let vx = x in vx \n| VarY -> let vy = y in vy\n| Average -> buildAverage(vx,vy)"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (a, b) -> if (a = k) then b else assoc (d, k, t)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> buildAverage(a1,a2)", "annotated": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> buildAverage(a1,a2)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (eval (VarX,a1,a2))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (eval (VarX,a1,a2))"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (a1 + a2)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (a1 + a2)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (eval(VarX,a1,a2) + eval(VarY,a1,a2))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (eval(VarX,a1,a2) + eval(VarY,a1,a2))"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (eval(VarX,x,y) + eval(VarY,a1,a2))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (eval(VarX,x,y) + eval(VarY,a1,a2))"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,a1,a2))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,a1,a2))"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval (s1,x,y))\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin(s1)\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin(s1)\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval (s1,x,y))\n| Cosine (c1) -> cos (eval (c1,x,y))\n| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.(2.0)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval (s1,x,y))\n| Cosine (c1) -> cos (eval (c1,x,y))\n| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/2.0", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval (s1,x,y))\n| Cosine (c1) -> cos (eval (c1,x,y))\n| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/2.0"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval (s1,x,y))\n| Cosine (c1) -> cos (eval (c1,x,y))\n| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.(2.0)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval (s1,x,y))\n| Cosine (c1) -> cos (eval (c1,x,y))\n| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.2", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval (s1,x,y))\n| Cosine (c1) -> cos (eval (c1,x,y))\n| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.2"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (pi *. eval(s1,x,y))\n| Cosine (c1) -> cos (pi *. eval(c1,x,y))\n| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.(2.0)\n| Times (t1,t2) -> (eval(t1,x,y) *. eval(t2,x,y))\n| Thresh (h1,h2,h3,h4) -> if (eval(h1,x,y) < eval(h2,x,y)) then eval(h3,x,y) else eval(h4,x,y)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (pi *. eval(s1,x,y))\n| Cosine (c1) -> cos (pi *. eval(c1,x,y))\n| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.(2.0)\n| Times (t1,t2) -> (eval(t1,x,y) *. eval(t2,x,y))\n| Thresh (h1,h2,h3,h4) ->", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (pi *. eval(s1,x,y))\n| Cosine (c1) -> cos (pi *. eval(c1,x,y))\n| Average (a1,a2) -> (eval(a1,x,y) +. eval(a2,x,y))/.(2.0)\n| Times (t1,t2) -> (eval(t1,x,y) *. eval(t2,x,y))\n| Thresh (h1,h2,h3,h4) ->"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)), 0.5, -0.5)", "bad": "let _ = eval (Sine(Average(Varx,VarY)), 0.5, -0.5)", "annotated": "let _ = eval (Sine(Average(Varx,VarY)), 0.5, -0.5)"}
{"fix": "build (makeRand (10,39), 4)", "bad": "build (rand, 4)", "annotated": "build (rand, 4)"}
{"fix": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildX()\n| 4 -> buildY()\n| 5 -> buildX()\n| 6 -> buildY()\n| 7 -> buildX()", "bad": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> VarX\n| 2 -> 22\n| 3 -> 33\n| 4 -> 44\n| 5 -> 55\n| 6 -> 66\n| 7 -> 77", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand (1,7)) with\n| 1 -> VarX\n| 2 -> 22\n| 3 -> 33\n| 4 -> 44\n| 5 -> 55\n| 6 -> 66\n| 7 -> 77"}
{"fix": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildSine(buildX())\n| 2 -> buildY()\n| 3 -> buildX()\n| 4 -> buildY()\n| 5 -> buildX()\n| 6 -> buildY()\n| 7 -> buildX()", "bad": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX(buildY())\n| 2 -> buildY()\n| 3 -> buildX()\n| 4 -> buildY()\n| 5 -> buildX()\n| 6 -> buildY()\n| 7 -> buildX()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand (1,7)) with\n| 1 -> buildX(buildY())\n| 2 -> buildY()\n| 3 -> buildX()\n| 4 -> buildY()\n| 5 -> buildX()\n| 6 -> buildY()\n| 7 -> buildX()"}
{"fix": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildTimes(buildCosine(buildSine(buildX())), buildCosine(buildSine(buildX())))\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine(build(rand, depth))\n| 4 -> buildCosine(build(rand, depth))\n| 5 -> buildAverage(build(rand, depth), build(rand, depth))\n| 6 -> buildTimes(build(rand, depth), build(rand, depth))\n| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))", "bad": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildTimes(buildCosine(buildSine(buildX())), buildCosine(buildSine(buildX())))\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine(buildX())\n| 4 -> buildSine(buildX())\n| 5 -> buildSine(buildX())\n| 6 -> buildSine(buildX())\n| 7 -> buildSine(buildX())", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand (1,7)) with\n| _ -> buildTimes(buildCosine(buildSine(buildX())), buildCosine(buildSine(buildX())))\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine(buildX())\n| 4 -> buildSine(buildX())\n| 5 -> buildSine(buildX())\n| 6 -> buildSine(buildX())\n| 7 -> buildSine(buildX())"}
{"fix": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ( (if (depth = 0) then buildX() else build(rand, depth - 1)), (if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes(build(rand, depth), build(rand, depth))\n| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))", "bad": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ( (if (depth = 0) then buildX() else build(rand, depth - 1)), if (depth = 0) then buildY() else build(rand, depth - 1))\n| 6 -> buildTimes(build(rand, depth), build(rand, depth))\n| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  0) then buildX() else build(rand, depth - 1))\n| 4 -> build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  0) then buildY() else build(rand, depth - 1))\n| 5 -> build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  0) then buildY() else build(rand, depth - 1))\n| 6 -> buildTimes(build(rand, depth), build(rand, depth))\n| 7 -> buildThresh(build(rand,depth), build(rand,depth), build(rand, depth), build(rand, depth))"}
{"fix": "let _ = build (makeRand(1,2), 0)", "bad": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> rand(1,7)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand (1,7)) with\n| _ -> rand(1,7)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  0) then buildX() else build(rand, depth - 1))\n| 4 -> build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  0) then buildY() else build(rand, depth - 1))\n| 5 -> build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))"}
{"fix": "let _ = build (makeRand(1,2), 0)", "bad": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> rand(1,7)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand (1,7)) with\n| _ -> rand(1,7)"}
{"fix": "let _ = build (makeRand(1, 7), 0)", "bad": "let _ = build (makeRand(1, 78), 0)", "annotated": "let _ = build (makeRand(1, 78), 0)"}
{"fix": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildThresh(VarX,VarX,VarX,VarX)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))", "bad": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildTimes (VarX)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand (1,7)) with\n| _ -> buildTimes (VarX)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  0) then buildX() else build(rand, depth - 1))\n| 4 -> build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  0) then buildY() else build(rand, depth - 1))\n| 5 -> build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))"}
{"fix": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildThresh(VarX,VarX,VarX,VarX)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))", "bad": "let _ = build (makeRand(1,2), 0)", "annotated": "let _ = build (makeRand(1,2), 0)"}
{"fix": "let fixpoint (f,b) = if (wwhile (f, b) = b) then b else (wwhile (f, f b))", "bad": "f 2", "annotated": "f 2"}
{"fix": "let fixpoint (f,b) = if (wwhile (f, b) = b) then b else (wwhile (f, f b))", "bad": "let fixpoint (f,b) = wwhile ((f,b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((f,b), b)"}
{"fix": "let fixpoint (f,b) = if (wwhile (f, b) = b) then b else (wwhile (f, f b))", "bad": "let fixpoint (f,b) = wwhile ((f,b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((f,b), b)"}
{"fix": "let fixpoint (f,b) = if (wwhile (f, b) = b) then b else (wwhile (f, f b))", "bad": "let fixpoint (f,b) = wwhile ((f, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((f, b)"}
{"fix": "let fixpoint (f,b) = if (wwhile (f, b) = b) then b else (wwhile (f, f b))", "bad": "let fixpoint (f,b) = wwhile (f, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (f, b)"}
{"fix": "let fixpoint (f,b) = wwhile ( (let f x =  in f), b)", "bad": "let fixpoint (f,b) = if (wwhile (f, b) = b) then b else (wwhile (f, (f b)))", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = if (wwhile (f, b)  ->  b) then b else (wwhile (f, (f b)))"}
{"fix": "let fixpoint (f,b) = wwhile ( (let f x =  in f), b)", "bad": "let fixpoint (f,b) = if (wwhile (f, b) = b) then b else (wwhile (f, wwhile (f,b)))", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = if (wwhile (f, b)  ->  b) then b else (wwhile (f, wwhile (f,b)))"}
{"fix": "let fixpoint (f,b) = \nlet h x = let x = b in (x, x != f x)  in\nwwhile (h, b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = \nlet h x = (b, b != f b)  in\nwwhile (h, b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = \nlet h b = (b, b != f b)  in\nwwhile (h, b)", "bad": "let fixpoint (f,b) = \nlet h x = (b, b != f b)  in\nwwhile (h, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet h x = (b, b != f b)  in\nwwhile (h, b)"}
{"fix": "let fixpoint (f,b) = \nlet h b = (b, b != f b)  in\nwwhile (h, b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = \nlet f x = (x, x != f x)  in\nwwhile (h, b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx != b)  in\nwwhile (f, b)", "bad": "let fixpoint (f,b) = \nlet f x = (x, x != f x)  in\nwwhile (f, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet f x = (x, x != f x)  in\nwwhile (f, b)"}
{"fix": "let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx != b)  in\nwwhile (f, b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx != b)  in\nwwhile (f, x)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet g x = let xx = (f x) in (xx, xx != b)  in\nwwhile (f, x)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx != b)  in\nwwhile (f, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet g x = let xx = (f x) in (xx, xx != b)  in\nwwhile (f, b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx != x)  in\nwwhile (f, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet g x = let xx = (f x) in (xx, xx != x)  in\nwwhile (f, b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx != x)  in\nwwhile (g, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet g x = let xx = (f x) in (xx, xx != x)  in\nwwhile (g, b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = \nlet f x = let xx = (f x) in (xx, xx != x)  in\nwwhile (f, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet f x = let xx = (f x) in (xx, xx != x)  in\nwwhile (f, b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = \nlet a x = let xx = (f x) in (xx, xx != x)  in\nwwhile (a, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet a x = let xx = (f x) in (xx, xx != x)  in\nwwhile (a, b)"}
{"fix": "let sqsum xs = \nlet f a x = (x *. x) in\nlet base = 0.0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a -> (x *. x) in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a -> (x *. x) in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = (x *. x) in\nlet base = 0.0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = fun a x -> (x *. x) in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = fun a x -> (x *. x) in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = (x *. x) in\nlet base = 0.0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = fun a x -> (x *. x) in\nlet base = 0.0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = fun a x -> (x *. x) in\nlet base = 0.0 in\nList.fold_left f base xs"}
{"fix": "let pipe fs = \nlet f a x =  x in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let _ = pipe[] 3", "annotated": "let _ = pipe[] 3"}
{"fix": "let pipe fs = \nlet f a x = x + a in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a -> a in\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a -> a in\nlet base = 0 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base =  \"\" in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x + a in\nlet base =  in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x + a in\nlet base =  in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base =  \"\" in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x + a in\nlet base = \"\" in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x + a in\nlet base = \"\" in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 1 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base =   in\nList.fold_left f base fs\nE", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base =   in\nList.fold_left f base fs\nE"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let _ = pipe[] 3", "annotated": "let _ = pipe[] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fun x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x + 1 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = a' in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = a' in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x + 1 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fun in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base =  fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fs in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fs in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base =  0 in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base =  a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base =  a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = h::t -> h in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = h::t -> h in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fun x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun x -> a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (+) 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = _ in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = _ in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (()) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = (_) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = (_) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (+) 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = (+) x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = (+) x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base =  fun x b -> b in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base =  fun x b -> 0 + b in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base =  fun x b in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base =  fun x b in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (+) 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = (+) x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = (+) x in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = (x * x) + a in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (+) 0 in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3"}
{"fix": "let _ = pipe []", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (+) 0   in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = 0 (+)   in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = 0 (+)   in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (x a) a in\nlet base = (+) 0 in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = (x a) a in\nlet base = (+) 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = (+) 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = (+) 0 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (x a) in\nlet base = (+) 0 in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x + x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = (x a) a in\nlet base = (+) 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (a x) a in\nlet base = (+) 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (a x) a in\nlet base = (+) 0 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (x a) a in\nlet base = (+) 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (a x) x in\nlet base = (+) 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (a x) x in\nlet base = (+) 0 in\nList.fold_left f base fs"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (x^sep) ^ a in\nlet base = \"\" in\nlet l = [] in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (x^sep) ^ a in\nlet base = \"\" in\nlet l = \"\" in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (x^sep) ^ a in\nlet base = \"\" in\nlet l = \"\" in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (h^sep) ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (h^sep) ^ t in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (h^sep) ^ t in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (h^sep) ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (h^sep) ^ x in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (h^sep) ^ x in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (h^sep) ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (h^sep) ^ x in\nlet base = \"\" in\nlet l = a in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (h^sep) ^ x in\nlet base = \"\" in\nlet l = a in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (x^sep) ^ a in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (x^sep) ^ a in\nlet base = \"\" in\nlet l = h ^ t in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (x^sep) ^ a in\nlet base = \"\" in\nlet l = h ^ t in\nList.fold_left f base l"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 3 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = List.hd fs in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = List.hd fs in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 3 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = List.head fs in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = List.head fs in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 3 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = List.hd fs in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = List.hd fs in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (+) 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = -> _ in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = -> _ in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (+) 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = :: 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = :: 0 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (+) 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = (::) 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = (::) 0 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (+) 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = (::) 0 2 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = (::) 0 2 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (+) 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = (::)  in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = (::)  in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (+) 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = 0 (::) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = 0 (::) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (-) 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = * 1 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = * 1 in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = (x * x) + a in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = 0 + in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = 0 + in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun y -> (+) y  in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fun y -> (+) x  in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun y -> (+) x  in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun _ -> 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = x -> 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = x -> 0 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun _ -> 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fun _ ->  in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun _ ->  in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun _ -> 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fun _ -> _ in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun _ -> _ in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = (x * x) + a in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = x -> x + 1 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = x -> x + 1 in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = (x * x) + a in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = x + 1 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = x + 1 in\nList.fold_left f base fs"}
{"fix": "let rec clone x n = \nif n > 0 then clone (x) (n - 1) else []", "bad": "let rec clone x n = \nif n > 0 then clone (x::[]) (n - 1) else []", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif n > 0 then clone (x::[]) (n - 1) else []"}
{"fix": "let rec clone x n = \nlet acc = [] in\nif n > 0 then clone (x@acc) (n - 1) else []", "bad": "let rec clone x n = \nlet acc = [] in\nif n > 0 then clone (x::acc) (n - 1) else []", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nlet acc = [] in\nif n > 0 then clone (x::acc) (n - 1) else []"}
{"fix": "let rec clone x n = \nlet acc = [x] in\nif n > 0 then clone (x) (n - 1) else []", "bad": "let _ = clone 3 5", "annotated": "let _ = clone 3 5"}
{"fix": "let rec clone x n = \nlet acc = [x] in\nif n > 0 then clone (x) (n - 1) else []", "bad": "let rec clone x n = \nlet acc = [] in\nif n > 0 then clone (x::x) (n - 1) else []", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nlet acc = [] in\nif n > 0 then clone (x::x) (n - 1) else []"}
{"fix": "let rec clone x n = \nlet acc = [0] in\nif n > 0 then clone (x) (n - 1) else []", "bad": "let rec clone x n = \nlet acc = [x] in\nif n > 0 then clone (x::acc) (n - 1) else []", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nlet acc = [x] in\nif n > 0 then clone (x::acc) (n - 1) else []"}
{"fix": "let rec clone x n = \nlet acc = [0] in\nif n > 0 then clone (x) (n - 1) else []", "bad": "let rec clone x n = \nlet acc = [0] in\nif n > 0 then clone (x::acc) (n - 1) else []", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nlet acc = [0] in\nif n > 0 then clone (x::acc) (n - 1) else []"}
{"fix": "let _ = clone 3 (-4)", "bad": "let _ = clone 3 -4", "annotated": "let _ = clone 3 -4"}
{"fix": "let padZero l1 l2 = \nlet l1_len = List.length l1 in\nlet l2_len = List.length l2 in\nlet l_diff = l1_len - l2_len in\nlet to_append = clone 0 l_diff in\nif (l_diff < 0) then ((to_append @ l1), l2) else (l1, (to_append @ l2))", "bad": "let padZero l1 l2 = \nlet l1_len = List.length l1 in\nlet l2_len = List.length l2 in\nlet l_diff = l1_len - l2_len in\nlet to_append = clone 0 l_diff in\nif (l_diff < 0) then (to_append @ l1), l2", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet l1_len = List.length l1 in\nlet l2_len = List.length l2 in\nlet l_diff = l1_len - l2_len in\nlet to_append = clone 0 l_diff in\nif (l_diff < 0) then (to_append @ l1), l2"}
{"fix": "let padZero l1 l2 = \nlet l1_len = List.length l1 in\nlet l2_len = List.length l2 in\nlet l_diff = l1_len - l2_len in\nlet to_append = clone 0 l_diff in\nif (l_diff < 0) then ((to_append @ l1), l2) else (l1, (to_append @ l2))", "bad": ") else (l1, (to_append @ l2))", "annotated": ") else (l1, (to_append @ l2))"}
{"fix": "let padZero l1 l2 = \nlet l1_len = List.length l1 in\nlet l2_len = List.length l2 in\nlet l_diff = l1_len - l2_len in\nlet to_append = clone 0 l_diff in\nif (l_diff < 0) then ((to_append @ l1), l2) else (l1, (to_append @ l2))", "bad": "let padZero l1 l2 = \nlet l1_len = List.length l1 in\nlet l2_len = List.length l2 in\nlet l_diff = l1_len - l2_len in\nlet to_append = clone 0 l_diff in\nif (l_diff < 0) then (to_append @ l1), l2", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet l1_len = List.length l1 in\nlet l2_len = List.length l2 in\nlet l_diff = l1_len - l2_len in\nlet to_append = clone 0 l_diff in\nif (l_diff < 0) then (to_append @ l1), l2"}
{"fix": "let padZero l1 l2 = \nlet l1_len = List.length l1 in\nlet l2_len = List.length l2 in\nlet l_diff = l1_len - l2_len in\nlet to_append = clone 0 l_diff in\nif (l_diff < 0) then ((to_append @ l1), l2) else (l1, (to_append @ l2))", "bad": ")", "annotated": ")"}
{"fix": "let padZero l1 l2 = \nlet l1_len = List.length l1 in\nlet l2_len = List.length l2 in\nlet l_diff = l1_len - l2_len in\nlet to_append = clone 0 l_diff in\nif (l_diff < 0) then ((to_append @ l1), l2) else (l1, (to_append @ l2))", "bad": ") else (l1, (to_append @ l2))", "annotated": ") else (l1, (to_append @ l2))"}
{"fix": "let padZero l1 l2 = \nlet l1_len = List.length l1 in\nlet l2_len = List.length l2 in\nlet l_diff = l1_len - l2_len in\nif (l_diff < 0) then ((clone 0 (l_diff * (-1)) @ l1), l2) else (l1, (clone 0 l_diff @ l2))", "bad": "let padZero l1 l2 = \nlet l1_len = List.length l1 in\nlet l2_len = List.length l2 in\nlet l_diff = l1_len - l2_len in\nif (l_diff < 0) then ((clone 0 (l_diff * (-1) @ l1), l2)) else (l1, (clone 0 l_diff @ l2))", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet l1_len = List.length l1 in\nlet l2_len = List.length l2 in\nlet l_diff = l1_len - l2_len in\nif (l_diff < 0) then ((clone 0 (l_diff * (-1) @ l1), l2)) else (l1, (clone 0 l_diff @ l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = (l1, l2) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = (l1, l2) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = [(l1,l2)] in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = [(l1,l2)] in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = let (a,b) = List.hd x in ([a+1],[b+2])\nin\nlet base = ([],[]) in\nlet args = [(l1,l2)] in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = let (a,b) = List.hd x in ([a+1],[b+2])\nin\nlet base = ([],[]) in\nlet args = [(l1,l2)] in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = let (a,b) = List.hd x in ([(List.hd a)+1],[(List.hd b)+2])\nin\nlet base = ([],[]) in\nlet args = [(l1,l2)] in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = let (a,b) = List.hd x in ([(List.hd a)+1],[(List.hd b)+2])\nin\nlet base = ([],[]) in\nlet args = [(l1,l2)] in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([(List.hd x)+1],[(List.hd x)+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = ([(List.hd x)+1],[(List.hd x)+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = let (a,b) = List.hd x in ((List.hd a)+1", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = let (a,b) = List.hd x in ((List.hd a)+1"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "],(List.hd b)+2", "annotated": "],(List.hd b)+2"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": ")\nin\nlet base = ([],[]) in\nlet args = [(l1,l2)] in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": ")\nin\nlet base = ([],[]) in\nlet args = [(l1,l2)] in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = let (a,b) = List.hd x in ((List.hd a)+1,(List.hd b)+2)\nin\nlet base = ([],[]) in\nlet args = [(l1,l2)] in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = let (a,b) = List.hd x in ((List.hd a)+1,(List.hd b)+2)\nin\nlet base = ([],[]) in\nlet args = [(l1,l2)] in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+1])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+a],[x+a])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = ([x+a],[x+a])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+1])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+a],[x+a])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = ([x+a],[x+a])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+1])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x::a],[x::a])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = ([x::a],[x::a])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet y = List.hd l2 in\nlet (one,two) = a in (x::one,y::two)\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet y = l2 in\nlet (one,two) = a in (x::one,y::two)\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet y = l2 in\nlet (one,two) = a in (x::one,y::two)\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet y = List.hd l2 in\nList.split  ((let (one,two) = a in (x::one,y::two)))\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet y = List.hd l2 in\nList.combine (let (one,two) = a in (x::one,y::two))\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet y = List.hd l2 in\nList.combine (let (one,two) = a in (x::one,y::two))\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet y = List.hd l2 in\nList.split  ((let (one,two) = a in (x::one,y::two)))\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet y = List.hd l2 in\nList.split (List.combine (let (one,two) = a in (x::one,y::two)))\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet y = List.hd l2 in\nList.split (List.combine (let (one,two) = a in (x::one,y::two)))\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet y = List.hd l2 in\n(let (one,two) = a in (x::one,y::two))\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet y = List.hd l2 in\nList.combine (List.split  ((let (one,two) = a in (x::one,y::two))))\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet y = List.hd l2 in\nList.combine (List.split  ((let (one,two) = a in (x::one,y::two))))\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> if ((fir + sec) < 10) then ([], (fir + sec)::b2)  else ([], (fir + sec)::b2)\nin\nlet base = ([],[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match x with\n| (a, b) -> (a + b) mod 10\nin\nlet base = (_,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = match x with\n| (a, b) -> (a + b) mod 10\nin\nlet base = (_,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> if ((fir + sec) < 10) then ([], (fir + sec)::b2)  else ([], (fir + sec)::b2)\nin\nlet base = ([],[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match x with\n| (a, b) -> (a + b) mod 10\nin\nlet base = ((_),[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = match x with\n| (a, b) -> (a + b) mod 10\nin\nlet base = ((_),[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> if ((fir + sec) < 10) then ([], (fir + sec)::b2)  else ([], (fir + sec)::b2)\nin\nlet base = ([],[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = base in \nmatch x with\n| (a, b) -> if ((a + b) < 10) then ([], (a + b)::b2)  else ([], (a + b)::b2)\nin\nlet base = ([],[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = base in \nmatch x with\n| (a, b) -> if ((a + b) < 10) then ([], (a + b)::b2)  else ([], (a + b)::b2)\nin\nlet base = ([],[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = (x * x) + a in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec) < 10) \nthen ([], (fir + sec)::b2)  else ((fir + sec) / 10, (fir + sec) mod 10 ::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec) < 10) \nthen ([], (fir + sec)::b2)  else ((fir + sec) / 10, (fir + sec) mod 10 ::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec) < 10) \nthen (b1, (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec) < 10) \nthen ([], (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec) < 10) \nthen ([], (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec) < 10) \nthen (b1, (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec) < 10) \nthen ([], (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)\nin\nlet base = (\"\",[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec) < 10) \nthen ([], (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)\nin\nlet base = (\"\",[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec) < 10) \nthen (b1, (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec) < 10) \nthen ([], (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)\nin\nlet base = ([],[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec) < 10) \nthen ([], (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)\nin\nlet base = ([],[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec) < 10) \nthen (b1, (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec) < 10) \nthen ([], (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec) < 10) \nthen ([], (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec + b1) < 10) \nthen \nif (List.length b2 = List.length l1) then (0, b1::b2) else (0, (fir + sec + b1)::b2)  \nelse \nif (List.length b2 = List.length l1) then (0, b1::b2) else (((fir + sec + b1) / 10), ((fir + sec + b1) mod 10)::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec + b1) < 10) \nthen (0, (fir + sec + b1)::b2)  \nelse (((fir + sec + b1) / 10), ((fir + sec + b1) mod 10)::b2)\nif (List.length b2 = List.length l1) then (0,b1::b2) else (0,b1::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec + b1) < 10) \nthen (0, (fir + sec + b1)::b2)  \nelse (((fir + sec + b1) / 10), ((fir + sec + b1) mod 10)::b2)\nif (List.length b2 = List.length l1) then (0,b1::b2) else (0,b1::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec + b1) < 10) \nthen \nif (List.length b2 = List.length l1) \nthen (0, b1::b2) \nelse (0, (fir + sec + b1)::b2)  \nelse \nif (List.length b2 = List.length l1) \nthen (0, b1::b2) \nelse (((fir + sec + b1) / 10), ((fir + sec + b1) mod 10)::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec + b1) < 10) \nthen \nif (List.length b2 = List.length l1) \nthen (0, b1::b2) \nelse (0, (fir + sec + b1)::b2)  \nelse if \nif (List.length b2 = List.length l1) \nthen (0, b1::b2) \nelse (((fir + sec + b1) / 10), ((fir + sec + b1) mod 10)::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec + b1) < 10) \nthen \nif (List.length b2 = List.length l1) \nthen (0, b1::b2) \nelse (0, (fir + sec + b1)::b2)  \nelse if \nif (List.length b2 = List.length l1) \nthen (0, b1::b2) \nelse (((fir + sec + b1) / 10), ((fir + sec + b1) mod 10)::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let rec mulByDigit i l = \nlet rec helper a b acc = \nif (a > 0) \nthen helper (a - 1) b (bigAdd b b)\nelse acc\nin\nhelper i l []", "bad": "let rec mulByDigit i l = \nlet rec helper a b acc = \nif (a > 0) \nthen helper (a - 1) b (bigAdd b b)\nelse acc\nin\nhelper i l 0", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet rec helper a b acc = \nif (a > 0) \nthen helper (a - 1) b (bigAdd b b)\nelse acc\nin\nhelper i l 0"}
{"fix": "let _ = mulByDigit 3 [1;7]", "bad": "let _ = mulByDigit 3 [1;7]\nkjlk", "annotated": "let _ = mulByDigit 3 [1;7]\nkjlk"}
{"fix": "let _ = mulByDigit 9 [9;9;9;9]", "bad": "let _ = mulByDigit 3 [1;7]\n\nsdf", "annotated": "let _ = mulByDigit 3 [1;7]\n\nsdf"}
{"fix": "let bigMul l1 l2 = \nlet f a x = (0,((mulByDigit x l2) @ (clone 0 ((List.length l1) - 1))))\nin\nlet base = (0, [0]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nmatch x with\n| (h::t) -> (0,((mulByDigit h sec) @ (clone 0 ((List.length fir) - 1))))\nin\nlet base = (0, [0]) in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nmatch x with\n| (h::t) -> (0,((mulByDigit h sec) @ (clone 0 ((List.length fir) - 1))))\nin\nlet base = (0, [0]) in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = (0,((mulByDigit x l2) @ (clone 0 ((List.length l1) - 1))))\nin\nlet base = (0, [0]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = (0,((mulByDigit x l2) @ (clone 0 ((List.length l1) - 1))))\nin\nlet base = (0, [0]) in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = (0,((mulByDigit x l2) @ (clone 0 ((List.length l1) - 1))))\nin\nlet base = (0, [0]) in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "bad": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nmatch rand with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}
{"fix": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "bad": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nmatch rand with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}
{"fix": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "bad": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = makeRand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nmatch rand with\n| 0 -> \nlet halff = makeRand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}
{"fix": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "bad": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = let r = makeRand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nmatch rand with\n| 0 -> \nlet halff = let r = makeRand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}
{"fix": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "bad": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = let r = makeRand(0,2) in in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nmatch rand with\n| 0 -> \nlet halff = let r = makeRand(0,2) in in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}
{"fix": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "bad": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = r = makeRand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nmatch rand with\n| 0 -> \nlet halff = r = makeRand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}
{"fix": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "bad": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nmatch rand with\n| 0 -> \nlet halff = rand in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}
{"fix": "let rec build (rand, depth) =\nmatch depth with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "bad": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nmatch rand with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}
{"fix": "let rec build (rand, depth) =\nmatch depth with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "bad": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nmatch rand with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}
{"fix": "let rec build (rand, depth) =\nmatch depth with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "bad": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nmatch rand with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}
{"fix": "let rec build (rand, depth) =\nmatch depth with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "bad": "let rec build (rand, depth) =\nmatch depth with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nmatch depth with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}
{"fix": "let rec build (rand, depth) =\nlet rdm = rand in\nmatch rdm with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> Cosine(build(rand, depth-1)) \n| 3 -> Sine(build(rand,depth-1))\n| 4 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 5 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 7 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "bad": "let rec build (rand, depth) =\nlet rdm = rand in\nmatch rdm with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 4 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nlet rdm = rand in\nmatch rdm with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 4 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"}
{"fix": "let rec build (rand, depth) =\nlet rdm = rand in\nmatch rdm with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> Cosine(build(rand, depth-1)) \n| 3 -> Sine(build(rand,depth-1))\n| 4 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 5 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 7 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "bad": "let rec build (rand, depth) =\nlet rdm = rand in\nmatch rdm with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 4 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nlet rdm = rand in\nmatch rdm with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 4 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"}
{"fix": "let rec build (rand, depth) =\nlet rdm = rand(0,7) in\nmatch rdm with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> Cosine(build(rand, depth-1)) \n| 3 -> Sine(build(rand,depth-1))\n| 4 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 5 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 6 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "bad": "let rec build (rand, depth) =\nmatch rand with \n| (a,b) -> \nlet rdm = rand(a,b) in\nmatch rdm with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> Cosine(build(rand, depth-1)) \n| 3 -> Sine(build(rand,depth-1))\n| 4 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 5 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 6 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nmatch rand with \n| (a,b) -> \nlet rdm = rand(a,b) in\nmatch rdm with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> Cosine(build(rand, depth-1)) \n| 3 -> Sine(build(rand,depth-1))\n| 4 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 5 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 6 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"}
{"fix": "let b = build(r,5)", "bad": "let b = build(rnd,5)", "annotated": "let b = build(rnd,5)"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "bad": "let rec digitsOfInt n = match n with\n| n < 0 -> []\n| h::t -> h", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  match n with\n| n < 0 -> []\n| h::t -> h"}
{"fix": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "bad": "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]", "annotated": "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]"}
{"fix": "let rec digitsOfInt n =\nif n <= 0 then []\nelse let n2 = [n mod 10] @ digitsOfInt (n/10) in\nlistReverse n2", "bad": "let rec digitsOfInt n =\nif n <= 0 then []\nelse let n2 = [n mod 10] @ digitsOfInt (n/10) in\nlistReverse n2", "annotated": "let rec digitsOfInt n =\nif n <= 0 then []\nelse let n2 = [n mod 10] @ digitsOfInt (n/10) in\nlistReverse n2"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n =\nif n <= 0 then []\nelse (n mod 10) :: digitsOfInt (n/10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n <= 0 then []\nelse (n mod 10) :: digitsOfInt (n/10)"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let rec listReverse l = match l with\n| [] -> []\n| h::t -> h :: listReverse l", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> []\n| h::t -> h :: listReverse l"}
{"fix": "let rec myAppend l n = match l with\n| [] -> [i]\n| h::t -> h :: myAppend t i", "bad": "let rec listReverse l = match l with\n| [] -> []\n| h::t -> listReverse t :: [h]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> []\n| h::t -> listReverse t :: [h]"}
{"fix": "let _ = palindrome \"malayalam\"", "bad": "let palindrome w =\nlistReverse (explode w) = explode w", "annotated": "let palindrome : string -> bool = fun  w  -> \nlistReverse (explode w) = explode w"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| s,i -> s", "bad": "let rec assoc (d,k,l) = let l match with\n| [] -> d\n| h::t -> let h match with\n| (s*i) -> s\n| d", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  let l match with\n| [] -> d\n| h::t -> let h match with\n| (s*i) -> s\n| d"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| s,i -> s", "bad": "let rec assoc (d,k,l) = l match with\n| [] -> d\n| h::t -> h match with\n| (s*i) -> s\n| d", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  l match with\n| [] -> d\n| h::t -> h match with\n| (s*i) -> s\n| d"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| s,i -> s", "bad": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| (s*i) -> s\n| d", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with\n| [] -> d\n| h::t -> match h with\n| (s*i) -> s\n| d"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| s,i -> s", "bad": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| s,i -> s\n| d", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with\n| [] -> d\n| h::t -> match h with\n| s,i -> s\n| d"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| s,i -> i", "bad": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let _ = removeDuplicates []", "bad": "let _ = removeDuplicates [];\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "annotated": "let _ = removeDuplicates [];\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"}
{"fix": "let rec wwhile (f,b) = match (f b) with\n| (f', x') -> if x' then wwhile (f, f')\nelse f'", "bad": "let rec wwhile (f,b) = match b with\n| (f', b') -> if b' then wwhile (f, f')\nelse f'", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match b with\n| (f', b') -> if b' then wwhile (f, f')\nelse f'"}
{"fix": "let rec wwhile (f,b) = match f,b with\n| (f', bool1) -> if bool1 then wwhile (f, f')\nelse f'", "bad": "let rec wwhile (f,b) = match me b with\n| (f', bool1) -> if bool1 then wwhile (f, f')\nelse f'", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match me b with\n| (f', bool1) -> if bool1 then wwhile (f, f')\nelse f'"}
{"fix": "let rec wwhile (f,b) = match f b with\n| (f', bool1) -> if bool1 then wwhile (f, f')\nelse f'", "bad": "let me x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (me, 2)", "annotated": "let me x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (me, 2)"}
{"fix": "let rec wwhile (f,b) = match f b with\n| (f', bool1) -> if bool1 then wwhile (f, f')\nelse f'", "bad": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "annotated": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "bad": "let fixpoint (f,b) = wwhile ((let helper = (f b,f b != helper)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let helper = (f b,f b ! ->  helper)),b)"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n(s,i) -> if s = k then i\nelse assoc (d,k,t)", "bad": "let fixpoint (f,b) = wwhile (let helper = (f b,f b != helper),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let helper = (f b,f b ! ->  helper),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((fun x -> let b = (f x) in (b, b != x)),b)", "bad": "let fixpoint (f,b) = wwhile (let helper = if ((f b) = b) then (f b,true) else (f b, false) in helper,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let helper = if ((f b)  ->  b) then (f b,true) else (f b, false) in helper,b)"}
{"fix": "let fixpoint (f,b) = wwhile ((fun x -> let b = (f x) in (b, b != x)),b)", "bad": "let fixpoint (f,b) = wwhile (let helper = if ((f b) = b) then (f b,true) else (f b, false) in helper, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let helper = if ((f b)  ->  b) then (f b,true) else (f b, false) in helper, b)"}
{"fix": "let fixpoint (f,b) = wwhile ((fun x -> let b = (f x) in (b, b != x)),b)", "bad": "let fixpoint (f,b) = wwhile (let helper = if ((f b) = b) then (f b,true)\nelse (f b, false)\nin helper,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let helper = if ((f b)  ->  b) then (f b,true)\nelse (f b, false)\nin helper,b)"}
{"fix": "let fixpoint (f,b) = wwhile ((fun x -> let b = (f x) in (b, b != x)),b)", "bad": "let fixpoint (f,b) = wwhile ((fun x -> let b = (f x) in (b, b != x)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun x -> let b = (f x) in (b, b ! ->  x)),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let helper b =\nif b = f b then (f b, false)\nelse (f b, true)\nin helper),b)", "bad": "let f x = let xx = x*x*x in (xx, xx < 100) in\nfixpoint (f, 1)", "annotated": "let f x = let xx = x*x*x in (xx, xx < 100) in\nfixpoint (f, 1)"}
{"fix": "let fixpoint (f,b) = wwhile ((let helper b =\nif b = f b then (f b, false)\nelse (f b, true)\nin helper),b)", "bad": "let _ = fixpoint (collatz, 9001)", "annotated": "let _ = fixpoint (collatz, 9001)"}
{"fix": "let rec build (rand, depth) = if depth = 0 then\nif rand(0,1) = 0 then buildX()\nelse buildY()\nelse match rand(0,6) with\n|0 -> build(rand,(depth - 1))\n|1 -> buildSine(build(rand,(depth - 1))) \n|2 -> buildCosine(build(rand, (depth - 1)))\n|3 -> buildAverage(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|4 -> buildTimes(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|5 -> buildThresh(build(rand, (depth - 1)),build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),build(rand, (depth - 1)))", "bad": "let rec build (rand, depth) = if depth = 0 then\nif rand(0,1) = 0 then buildX()\nelse buildY()\nelse match rand(0,7) with\n|0 -> build(rand, (depth-1))\n|1 -> buildSine(build(rand, (depth-1))) \n|2 -> buildCosine(build(rand, (depth - 1)))\n|3 -> buildAverage(build(rand, (depth-1)),build(rand, (depth-1)))\n|4 -> buildTimes(build(rand, (depth-1)),build(rand, (depth-1)))\n|5 -> buildMax(build(rand, (depth-1)),build(rand, (depth-1)))\n|6 -> buildCubic(build(rand, (depth-1)),build(rand, (depth-1)),build(rand, (depth-1)))\n|7 -> buildThresh(build(rand, (depth-1)),build(rand, (depth-1)),build(rand, (depth-1)),build(rand, (depth-1)))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = if depth  ->  0 then\nif rand(0,1) = 0 then buildX()\nelse buildY()\nelse match rand(0,7) with\n|0 -> build(rand, (depth-1))\n|1 -> buildSine(build(rand, (depth-1))) \n|2 -> buildCosine(build(rand, (depth - 1)))\n|3 -> buildAverage(build(rand, (depth-1)),build(rand, (depth-1)))\n|4 -> buildTimes(build(rand, (depth-1)),build(rand, (depth-1)))\n|5 -> buildMax(build(rand, (depth-1)),build(rand, (depth-1)))\n|6 -> buildCubic(build(rand, (depth-1)),build(rand, (depth-1)),build(rand, (depth-1)))\n|7 -> buildThresh(build(rand, (depth-1)),build(rand, (depth-1)),build(rand, (depth-1)),build(rand, (depth-1)))"}
{"fix": "let rec build (rand, depth) = if depth = 0 then\nif rand(0,1) = 0 then buildX()\nelse buildY()\nelse match rand(0,6) with\n|0 -> build(rand,(depth - 1))\n|1 -> buildSine(build(rand,(depth - 1))) \n|2 -> buildCosine(build(rand, (depth - 1)))\n|3 -> buildAverage(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|4 -> buildTimes(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|5 -> buildThresh(build(rand, (depth - 1)),build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),build(rand, (depth - 1)))", "bad": "let rec build (rand, depth) = if depth = 0 then\nif rand(0,1) = 0 then buildX()\nelse buildY()\nelse match rand(0,5) with\n|0 -> build(rand,(depth - 1))\n|1 -> buildSine(build(rand,(depth - 1))) \n|2 -> buildCosine(build(rand, (depth - 1)))\n|3 -> buildAverage(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|4 -> buildTimes(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|5 -> buildThresh(build(rand, (depth - 1)),build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),build(rand, (depth - 1)))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = if depth  ->  0 then\nif rand(0,1) = 0 then buildX()\nelse buildY()\nelse match rand(0,5) with\n|0 -> build(rand,(depth - 1))\n|1 -> buildSine(build(rand,(depth - 1))) \n|2 -> buildCosine(build(rand, (depth - 1)))\n|3 -> buildAverage(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|4 -> buildTimes(build(rand, (depth - 1)),build(rand, (depth - 1)))\n|5 -> buildThresh(build(rand, (depth - 1)),build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),build(rand, (depth - 1)))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let carry = (fst x + snd x) in\nmatch a with\n| h::t -> ((h+carry)/10)::((h+carry) mod 10)::t\n| _ -> (carry/10)::[carry mod 10]\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let carry = (fst x + snd x) in\nmatch a with\n| h::t -> ((h+carry)/10)::((h+c) mod 10)::t\n| _ -> (carry/10)::[carry mod 10]\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let carry = (fst x + snd x) in\nmatch a with\n| h::t -> ((h+carry)/10)::((h+c) mod 10)::t\n| _ -> (carry/10)::[carry mod 10]\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((o,sum),[])\t      -> (0,sum)\n| ((o,sum),(b,c)::l') -> let d = (b + c + o) in\nif d", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((o,sum),[])\t      -> (0,sum)\n| ((o,sum),(b,c)::l') -> let d = (b + c + o) in\nif d < 10 then (0, d::sum)\nelse (1, (d-10)::sum)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match (a,x) with\n| ((o,sum),[])\t      -> (0,sum)\n| ((o,sum),(b,c)::l') -> let d = (b + c + o) in\nif d < 10 then (0, d::sum)\nelse (1, (d-10)::sum)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let carry = match a with (x,y) -> x in\nmatch x with (d1,d2) -> let new_carry = (carry + d1 + d2)/10 in\nlet digit = (carry + d1 + d2) mod 10 in\nmatch a with (x,y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (*let carry = match a with (x,y) -> x in*)\nmatch x with (d1,d2) -> let new_carry = (a + d1 + d2)/10 in\nlet digit = (a + d1 + d2) mod 10 in\nmatch a with (x,y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = (*let carry = match a with (x,y) -> x in*)\nmatch x with (d1,d2) -> let new_carry = (a + d1 + d2)/10 in\nlet digit = (a + d1 + d2) mod 10 in\nmatch a with (x,y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let carry = match a with (x,y) -> x in\nmatch x with (d1,d2) -> let new_carry = (carry + d1 + d2)/10 in\nlet digit = (carry + d1 + d2) mod 10 in\nmatch a with (x,y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let carry = match a with (x,y) -> x in\nmatch x with (d1,d2) -> let new_carry = (a + d1 + d2)/10 in\nlet digit = (a + d1 + d2) mod 10 in\nmatch a with (x,y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let carry = match a with (x,y) -> x in\nmatch x with (d1,d2) -> let new_carry = (a + d1 + d2)/10 in\nlet digit = (a + d1 + d2) mod 10 in\nmatch a with (x,y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let c = match a with\n| ((d1,d2),sum) -> let c' = (c + d1 + d2)/10 in\nlet sum = (c + d1 + d2) mod 10 in\nmatch a with (pair,sum) -> (c', digit::sum) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let c = match a with\n| ((d1,d2),sum) -> let c' = (c + d1 + d2)/10 in\nlet sum = (c + d1 + d2) mod 10 in\nmatch a with (pair,sum) -> (c', digit::sum) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let c = match a with\n| ((d1,d2),sum) -> let c' = (c + d1 + d2)/10 in\nlet sum = (c + d1 + d2) mod 10 in\nmatch a with (pair,sum) -> (c', digit::sum) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let c = match a with\n| ((d1,d2),sum) -> let c' = (c + d1 + d2)/10 in\nlet sum = (c + d1 + d2) mod 10 in\nmatch a with (pair,sum) -> (c', digit::sum) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let c = match a with\n| ((d1,d2),sum) -> let c' = (c + d1 + d2)/10 in\nlet sum = (c + d1 + d2) mod 10 in\nmatch a with (pair,sum) -> (c', digit::sum) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let c = match a with\n| ((d1,d2),sum) -> let c' = (c + d1 + d2)/10 in\nlet sum = (c + d1 + d2) mod 10 in\nmatch a with (pair,sum) -> (c', digit::sum) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let c = match a with (pair,sum) -> pair in\nmatch x with (d1,d2) -> let c' = (c + d1 + d2)/10 in\nlet digit = (c + d1 + d2) mod 10 in\nmatch a with (pair,sum) -> (c', digit::sum) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let c = match a with (pair,sum) -> pair in\nmatch a with ((d1,d2),sum) -> let c' = (c + d1 + d2)/10 in\nlet sum = (c + d1 + d2) mod 10 in\nmatch a with (pair,sum) -> (c', digit::sum) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let c = match a with (pair,sum) -> pair in\nmatch a with ((d1,d2),sum) -> let c' = (c + d1 + d2)/10 in\nlet sum = (c + d1 + d2) mod 10 in\nmatch a with (pair,sum) -> (c', digit::sum) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let c = match a with (pair,sum) -> pair in\nmatch x with (d1,d2) -> let c' = (c + d1 + d2)/10 in\nlet digit = (c + d1 + d2) mod 10 in\nmatch a with (pair,sum) -> (c', digit::sum) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let c = match a with (pair,sum) -> pair in\nmatch pair with (d1,d2) -> let c' = (c + d1 + d2)/10 in\nlet digit = (c + d1 + d2) mod 10 in\nmatch a with (pair,sum) -> (c', digit::sum) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let c = match a with (pair,sum) -> pair in\nmatch pair with (d1,d2) -> let c' = (c + d1 + d2)/10 in\nlet digit = (c + d1 + d2) mod 10 in\nmatch a with (pair,sum) -> (c', digit::sum) in\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let rec mulByDigit i l = \nif i = 1 then l\nelse if i = 0 then []\nelse if i < 0 then match (bigAdd (bigAdd l l) (mulByDigit ( (i*(-1)) -2) l)) with\n| h::t -> (h*(-1))::t\n| _ -> []\nelse bigAdd (bigAdd l l) (mulByDigit (i-2) l)", "bad": "let rec mulByDigit i l = \nif i = 1 then l\nelse if i = 0 then []\nelse if i < 0 then match (bigAdd (bigAdd l l) (mulByDigit ( (i*(-1)) -2) l)) with\n| h::t -> (h*(-1))::t\n| _ -> 0\nelse bigAdd (bigAdd l l) (mulByDigit (i-2) l)", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nif i = 1 then l\nelse if i = 0 then []\nelse if i < 0 then match (bigAdd (bigAdd l l) (mulByDigit ( (i*(-1)) -2) l)) with\n| h::t -> (h*(-1))::t\n| _ -> 0\nelse bigAdd (bigAdd l l) (mulByDigit (i-2) l)"}
{"fix": "let bigMul l1 l2 = \nlet f a x = match a with\n(c,sum) -> (c + 1, bigAdd ((mulByDigit x l1) @ clone 0 c) sum) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = match a with\n(c,sum) -> (c + 1, bigAdd ((mulByDigit x l1) @ clone 0 c) sum) in\nlet base = failwith (0, []) in\nlet args = failwith l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match a with\n(c,sum) -> (c + 1, bigAdd ((mulByDigit x l1) @ clone 0 c) sum) in\nlet base = failwith (0, []) in\nlet args = failwith l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse [1;2;3]", "bad": "let rec digitsOfInt n = \nif n < 0 then -> 4", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then -> 4"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse [1;2;3]", "bad": "let _ = digitsOfInt -3124", "annotated": "let _ = digitsOfInt -3124"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse [1;2;3]", "bad": "let rec digitsOfInt n = \nif n < 0 then 4", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then 4"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse [1;2;3]", "bad": "let rec digitsOfInt n = \nif n < 0 then []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse [1;2;3]", "bad": "let rec digitsOfInt n = \nif n < 0 then 0", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then 0"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse [1;2;3]", "bad": "let rec digitsOfInt n = \nif n < 0 then _", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then _"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse [1;2;3]", "bad": "let rec digitsOfInt n = \nif n < 0 then 'a", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then 'a"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse [1;2;3]", "bad": "let rec digitsOfInt n = \nif n < 0 then '", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then '"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse [1;2;3]", "bad": "let rec digitsOfInt n = \nif n < 0 then n", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then n"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse [1;2;3]", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse n", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse n"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let _ = digitsOfInt -3124", "annotated": "let _ = digitsOfInt -3124"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet f elem =", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet f elem = \nPrintf.printf \"Element is %d\\n\" elem in\nList.iter f n", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse \nlet f elem = \nPrintf.printf \"Element is %d\\n\" elem in\nList.iter f n"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| _ -> loop n []", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet f elem = \nPrintf.printf \"Element is %d\\n\" elem in\nList.iter f n", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse \nlet f elem = \nPrintf.printf \"Element is %d\\n\" elem in\nList.iter f n"}
{"fix": "let rec additivePersistence n = \nif n mod 10  != 0 then \nx = x + 1", "bad": "let rec additivePersistence n =\nlet x = 0\nif n mod 10  != 0 then \nx = x + 1", "annotated": "let rec additivePersistence : int -> int = fun  n  -> \nlet x = 0\nif n mod 10  != 0 then \nx = x + 1"}
{"fix": "let rec additivePersistence n = \nlet rec loop retVal = \nif retVal < 10 then retVal\nelse loop sumList(digitsOfInt retVal ) \n| 0 -> 0\n| _ -> loop retVal", "bad": "let rec additivePersistence n = \nlet x = 0\nif n mod 10  != 0 then \nx = x + 1", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet x = 0\nif n mod 10  != 0 then \nx = x + 1"}
{"fix": "let rec additivePersistence n = \nlet rec loop retVal = \nif retVal < 10 then retVal\nelse loop sumList(digitsOfInt retVal ) \n| 0 -> 0\n| _ -> loop retVal", "bad": "let total += sumList (digitsOfInt (abs n) )\nelse x", "annotated": "let total += sumList (digitsOfInt (abs n) )\nelse x"}
{"fix": "let rec additivePersistence n = \nlet rec loop retVal = \nif retVal < 10 then retVal\nelse loop sumList(digitsOfInt retVal ) \n| 0 -> 0\n| _ -> loop retVal", "bad": "let rec additivePersistence n = \nif n mod 10  != 0 then \nlet x = 0", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif n mod 10  != 0 then \nlet x = 0"}
{"fix": "let rec additivePersistence n = \nlet rec loop retVal = \nif retVal < 10 then retVal\nelse loop sumList(digitsOfInt retVal ) \n| 0 -> 0\n| _ -> loop retVal", "bad": "let total += sumList (digitsOfInt (abs n) )\nx = x + 1\nelse x", "annotated": "let total += sumList (digitsOfInt (abs n) )\nx = x + 1\nelse x"}
{"fix": "let rec additivePersistence n = \nlet rec loop retVal = \nif retVal < 10 then retVal\nelse loop sumList(digitsOfInt retVal ) \n| 0 -> 0\n| _ -> loop retVal", "bad": "let rec additivePersistence n = \nif n mod 10  != 0 then \nlet x = 0", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif n mod 10  != 0 then \nlet x = 0"}
{"fix": "let rec additivePersistence n = \nlet rec loop retVal = \nif retVal < 10 then retVal\nelse loop sumList(digitsOfInt retVal ) \n| 0 -> 0\n| _ -> loop retVal", "bad": "let rec additivePersistence n = \nif n mod 10  != 0 then \nlet x = 0 in\nlet total += sumList (digitsOfInt (abs n) )\nx = x + 1\nelse x", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif n mod 10  != 0 then \nlet x = 0 in\nlet total += sumList (digitsOfInt (abs n) )\nx = x + 1\nelse x"}
{"fix": "let rec additivePersistence n = \nlet rec loop retVal = \nif retVal < 10 then retVal\nelse loop sumList(digitsOfInt retVal ) \n| 0 -> 0\n| _ -> loop retVal", "bad": "let rec additivePersistence n = \nif n mod 10  != 0 then \nlet x = 0 in\nlet total = sumList (digitsOfInt (abs n) )\nx = x + 1\nelse x", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif n mod 10  != 0 then \nlet x = 0 in\nlet total = sumList (digitsOfInt (abs n) )\nx = x + 1\nelse x"}
{"fix": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "bad": "let rec additivePersistence n = \nlet rec addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \naddP = addP + 1\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet rec addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \naddP = addP + 1\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n"}
{"fix": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "bad": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \naddP = addP + 1\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \naddP = addP + 1\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n"}
{"fix": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "bad": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \nincr addP\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \nincr addP\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n"}
{"fix": "let rec additivePersistence n = \nlet rec addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse recursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "bad": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n\n| addP", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n\n| addP"}
{"fix": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "bad": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \naddP -> addP + 1\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \naddP -> addP + 1\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n"}
{"fix": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "bad": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n"}
{"fix": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "bad": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \naddP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \naddP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n"}
{"fix": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "bad": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \naddP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \naddP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n"}
{"fix": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "bad": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \naddP + 1\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet addP = 0 in\nlet rec recursive_loop retVal = \nif retVal < 10 then addP\nelse \naddP + 1\nrecursive_loop (sumList(digitsOfInt retVal )) in match n with\n| 0 -> 0\n| _ -> recursive_loop n"}
{"fix": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal addP = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) addP in match n with\n| 0 -> 0\n| _ -> recursive_loop n addP", "bad": "let rec additivePersistence n = \nlet addP = 0 in\nlet rec recursive_loop retVal addP = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) addP in match n with\n| 0 -> 0\n| _ -> recursive_loop n", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet addP = 0 in\nlet rec recursive_loop retVal addP = \nif retVal < 10 then addP\nelse \nlet addP = addP + 1 in\nrecursive_loop (sumList(digitsOfInt retVal )) addP in match n with\n| 0 -> 0\n| _ -> recursive_loop n"}
{"fix": "let rec listReverse l = \nlet rec aux acc = function\n| [] -> acc\n| h::t -> aux (h::acc) t in\naux [] l", "bad": "let rec listReverse l = \nlet rev l =\nlet rec aux acc = function\n| [] -> acc\n| h::t -> aux (h::acc) t in\naux [] l", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nlet rev l =\nlet rec aux acc = function\n| [] -> acc\n| h::t -> aux (h::acc) t in\naux [] l"}
{"fix": "let rec listReverse l = \nlet rec aux acc = function\n| [] -> acc\n| h::t -> aux (h::acc) t in\naux [] l", "bad": "let rec listReverse l = \nlet rev l =\nlet rec aux acc = \n| [] -> acc\n| h::t -> aux (h::acc) t in\naux [] l", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nlet rev l =\nlet rec aux acc = \n| [] -> acc\n| h::t -> aux (h::acc) t in\naux [] l"}
{"fix": "let palindrome w =\nlet reverse = listReverse w in\nif reverse = w then true\nelse false", "bad": "let _ = palindrome \"malayalam\"", "annotated": "let _ = palindrome \"malayalam\""}
{"fix": "let palindrome w =\nlet pk = explode w in\nlet reverse = listReverse (explode w) in\nif reverse = pk then true\nelse false", "bad": "let _ = palindrome \"malayalam\"", "annotated": "let _ = palindrome \"malayalam\""}
{"fix": "let palindrome w =\nlet pk = explode w in\nlet reverse = listReverse (explode w) in\nif reverse = pk then true\nelse false", "bad": "let palindrome w =\nlet reverse = explode (listReverse w) in\nif reverse = w then true\nelse false", "annotated": "let palindrome : string -> bool = fun  w  -> \nlet reverse = explode (listReverse w) in\nif reverse = w then true\nelse false"}
{"fix": "let palindrome w =\nlet pk = explode w in\nlet reverse = listReverse (explode w) in\nif reverse = pk then true\nelse false", "bad": "let palindrome w =\nlet reverse = listReverse (explode w) in\nif reverse = w then true\nelse false", "annotated": "let palindrome : string -> bool = fun  w  -> \nlet reverse = listReverse (explode w) in\nif reverse = w then true\nelse false"}
{"fix": "let palindrome w =\nlet pk = explode w in\nlet reverse = listReverse (explode w) in\nif reverse = pk then true\nelse false", "bad": "let palindrome w =\nlet pk = explode w in\nlet reverse = listReverse (explode w) in\nif reverse = w then true\nelse false", "annotated": "let palindrome : string -> bool = fun  w  -> \nlet pk = explode w in\nlet reverse = listReverse (explode w) in\nif reverse = w then true\nelse false"}
{"fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (num,name)::tail ->\nif num = k then name\nelse assoc(d, k, tail)", "bad": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = seen in\nif List.mem h seen' then h::seen \nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = h in\nif List.mem h l then h::seen'", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = h in\nif List.mem h l then h::seen'"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = seen in\nif List.mem h seen' then h::seen \nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = seen in\nif List.mem h seen' then h::seen \nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = h in\nif List.mem h l then h::seen'", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = h in\nif List.mem h l then h::seen'"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = seen in\nif List.mem h seen' then h::seen \nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = seen in\nif List.mem h seen' then h::seen \nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = h in\nif List.mem h l then h::seen'", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = h in\nif List.mem h l then h::seen'"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = seen in\nif List.mem h seen' then h::seen \nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = seen in\nif List.mem h seen' then h::seen \nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = h in\nif List.mem h l then h::seen' \nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = h in\nif List.mem h l then h::seen' \nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = l in\nif List.mem h l then h::seen' \nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = h in\nif List.mem h seen then h::seen' \nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = h in\nif List.mem h seen then h::seen' \nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t ->\n(* Seen' should hold only the unique ones *)\nlet seen' =  \nif List.mem h seen = false then h::seen\nelse seen\nin\n(* If the head is NOT in hte list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = l in \nif List.mem h seen then h::seen'", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = l in \nif List.mem h seen then h::seen'"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t ->\n(* Seen' should hold only the unique ones *)\nlet seen' =  \nif List.mem h seen = false then h::seen\nelse seen\nin\n(* If the head is NOT in hte list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t ->\n(* Seen' should hold only the unique ones *)\nlet seen' =  \nif List.mem h seen = false then h::seen\nelse seen\nin\n(* If the head is NOT in hte list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = \nif List.mem h seen then h::seen'", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = \nif List.mem h seen then h::seen'"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t ->\n(* Seen' should hold only the unique ones *)\nlet seen' =  \nif List.mem h seen = false then h::seen\nelse seen\nin\n(* If the head is NOT in hte list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = l in\nif List.mem h seen' then h::seen", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = l in\nif List.mem h seen' then h::seen"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t ->\n(* Seen' should hold only the unique ones *)\nlet seen' =  \nif List.mem h seen = false then h::seen\nelse seen\nin\n(* If the head is NOT in hte list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t ->\n(* Seen' should hold only the unique ones *)\nlet seen' =  \nif List.mem h seen = false then h::seen\nelse seen\nin\n(* If the head is NOT in hte list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = l in\nif List.mem h l then h::seen", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = l in\nif List.mem h l then h::seen"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t ->\n(* Seen' should hold only the unique ones *)\nlet seen' =  \nif List.mem h seen = false then h::seen\nelse seen\nin\n(* If the head is NOT in hte list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t ->\n(* Seen' should hold only the unique ones *)\nlet seen' =  \nif List.mem h seen = false then h::seen\nelse seen\nin\n(* If the head is NOT in hte list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = l in\nif List.mem h l then h::seen'", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = l in\nif List.mem h l then h::seen'"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t ->\n(* Seen' should hold only the unique ones *)\nlet seen' =  \nif List.mem h seen = false then h::seen\nelse seen\nin\n(* If the head is NOT in hte list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t ->\n(* Seen' should hold only the unique ones *)\nlet seen' =  \nif List.mem h seen = false then h::seen\nelse seen\nin\n(* If the head is NOT in hte list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = l in\nif List.mem h seen' then h::seen\nelse seen", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = l in\nif List.mem h seen' then h::seen\nelse seen"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t ->\n(* Seen' should hold only the unique ones *)\nlet seen' =  \nif List.mem h seen = false then h::seen\nelse seen\nin\n(* If the head is NOT in hte list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t ->\n(* Seen' should hold only the unique ones *)\nlet seen' =  \nif List.mem h seen = false then h::seen\nelse seen\nin\n(* If the head is NOT in hte list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = l in\nif List.mem h seen' then h::seen\nelse h::seen", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = l in\nif List.mem h seen' then h::seen\nelse h::seen"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t ->\n(* Seen' should hold only the unique ones *)\nlet seen' =  \nif List.mem h seen = false then h::seen\nelse seen\nin\n(* If the head is NOT in hte list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t ->\n(* Seen' should hold only the unique ones *)\nlet seen' =  \nif List.mem h seen = false then h::seen\nelse seen\nin\n(* If the head is NOT in hte list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t ->\n(* Seen' should hold only the unique ones *)\nlet seen' =  \nif List.mem h seen = false then h::seen\nin\n(* If the head is NOT in hte list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t ->\n(* Seen' should hold only the unique ones *)\nlet seen' =  \nif List.mem h seen = false then h::seen\nin\n(* If the head is NOT in hte list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let rec wwhile (f,b) = match (f,b) with\n| (func, param) ->\nif param = true then func param \nelse param\n| _ -> b", "bad": "let rec wwhile (f,b) = match (f,b) with\n| (func, param) ->\nif param = true then func param \nelse num\n| _ -> 0", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match (f,b) with\n| (func, param) ->\nif param = true then func param \nelse num\n| _ -> 0"}
{"fix": "let rec wwhile (f,b) = match (f,b) with\n| (func, param) ->\nif param = true then func param \nelse param\n| _ -> b", "bad": "let rec wwhile (f,b) = match (f,b) with\n| (func, param) ->\nif param = true then func param \nelse num\n| _ -> b", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match (f,b) with\n| (func, param) ->\nif param = true then func param \nelse num\n| _ -> b"}
{"fix": "let rec wwhile (f,b) = match (f,b) with\n| (func, param) ->\nif param = true then f param \nelse 0", "bad": "let rec wwhile (f,b) = match (f,b) with\n| (func, param) ->\nif param = true then f param \nelse 0\n| _ -> b", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match (f,b) with\n| (func, param) ->\nif param = true then f param \nelse 0\n| _ -> b"}
{"fix": "let rec wwhile (f,b) = match b with\n| (e, boo) ->\nif boo = true then e", "bad": "let rec wwhile (f,b) = match b with\n| (e, boo) ->\nif boo = true then e\nelse wwhile f e", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match b with\n| (e, boo) ->\nif boo = true then e\nelse wwhile f e"}
{"fix": "let rec wwhile (f,b) = match b with\n| (e, boo) ->\nif boo = true then e", "bad": "let rec wwhile (f,b) = match b with\n| (e, boo) ->\nif boo = true then e\nelse wwhile e b", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match b with\n| (e, boo) ->\nif boo = true then e\nelse wwhile e b"}
{"fix": "let rec wwhile (f,b) = match b with\n| (e, boo) ->\nif boo = true then e", "bad": "let rec wwhile (f,b) = match b with\n| (e, boo) ->\nif boo = true then e\nelse wwhile b", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match b with\n| (e, boo) ->\nif boo = true then e\nelse wwhile b"}
{"fix": "let rec wwhile (f,b) = match b with\n| (e, boo) ->\nif boo = true then e", "bad": "let rec wwhile (f,b) = match b with\n| (e, boo) ->\nif boo = true then e\nelse wwhile f b", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match b with\n| (e, boo) ->\nif boo = true then e\nelse wwhile f b"}
{"fix": "let rec wwhile (f,b) = \nlet ans = f b in\nmatch ans with\n| (num, boo) ->\nif boo = true then wwhile(f, num)\nelse num", "bad": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "annotated": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}
{"fix": "let fixpoint (f,b) = \nwwhile \n((let func p = \nlet cal = f p in \nif p == cal then (cal, false)\nelse (cal, true) in func\n),b)", "bad": "let fixpoint (f,b) = \nwwhile \n((let func p = \nlet cal = f p in \nif p == cal then (cal, false)\nelse (cal, true) in xx\n),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile \n((let func p = \nlet cal = f p in \nif p == cal then (cal, false)\nelse (cal, true) in xx\n),b)"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"X\"\n| VarY -> \"Y\"\n| Sine sin  -> \"( sin \"\n| Cosine cos -> \"cos\"\n| Average (n1, n2) ->  \"( \" ^ (exprToString n1) ^ \"+\" ^ (exprToString n2) ^ \")/2\"\n| Times (t1, t2) -> \"(t1 * t2)\"\n| Thresh (th1, th2, th3, th4) -> \"bullshit\"", "bad": "let rec exprToString e = match e with\n| VarX -> \"X\"\n| VarY -> \"Y\"\n| Sine sin  -> \"( sin \"\n| Cosine cos -> \"cos\"\n| Average (n1, n2) ->  \"( \" ^ (exprToString n1) ^ \"+\" ^ (exprToString n2) ^ \")/2\"\n| Times (t1, t2) -> \"(t1 * t2)\"\n| Thresh (th1, th2, th3, th4) ->", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"X\"\n| VarY -> \"Y\"\n| Sine sin  -> \"( sin \"\n| Cosine cos -> \"cos\"\n| Average (n1, n2) ->  \"( \" ^ (exprToString n1) ^ \"+\" ^ (exprToString n2) ^ \")/2\"\n| Times (t1, t2) -> \"(t1 * t2)\"\n| Thresh (th1, th2, th3, th4) ->"}
{"fix": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine sin  -> \"(sin(pi*\" ^ (exprToString sin) ^ \")\"  \n| Cosine cos -> \"(cos(pi*\" ^ (exprToString cos) ^ \")\"\n| Average (n1, n2) ->  \"( \" ^ (exprToString n1) ^ \"+\" ^ (exprToString n2) ^ \")/2\"\n| Times (t1, t2) -> \"(\" ^ (exprToString t1) ^ \"*\" ^ (exprToString t2) ^ \")\"\n| Thresh (th1, th2, th3, th4) -> \"bullshit\"", "bad": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine sin  -> \"(sin(pi*\" ^ (exprToString sin) ^ \")\"  \n| Cosine cos -> \"(cos(pi*\" ^ (exprToString cos) ^ \")\"\n| Average (n1, n2) ->  \"( \" ^ (exprToString n1) ^ \"+\" ^ (exprToString n2) ^ \")/2\"\n| Times (t1, t2) -> \"(\" ^ (exprToString t1) ^ \"*\" (exprToString t2) ^ \")\"\n| Thresh (th1, th2, th3, th4) -> \"bullshit\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine sin  -> \"(sin(pi*\" ^ (exprToString sin) ^ \")\"  \n| Cosine cos -> \"(cos(pi*\" ^ (exprToString cos) ^ \")\"\n| Average (n1, n2) ->  \"( \" ^ (exprToString n1) ^ \"+\" ^ (exprToString n2) ^ \")/2\"\n| Times (t1, t2) -> \"(\" ^ (exprToString t1) ^ \"*\" (exprToString t2) ^ \")\"\n| Thresh (th1, th2, th3, th4) -> \"bullshit\""}
{"fix": "let rec assoc (d,k,l) = match l with\n(* If list is empty, then return the first int *)\n| [] -> d\n(* If it is of this pattern, check if the number is equal to the tuple's number *)\n| (name,num)::tail ->\n(* If it is, return the number; else recursively call with remainder *)\nif name = k then num\nelse assoc(d, k, tail)", "bad": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine sin  -> \"sin(pi*\" ^ (exprToString sin) ^ \")\"  \n| Cosine cos -> \"cos(pi*\" ^ (exprToString cos) ^ \")\"\n| Average (n1, n2) ->  \"((\" ^ (exprToString n1) ^ \"+\" ^ (exprToString n2) ^ \")/2)\"\n| Times (t1, t2) -> (exprToString t1) ^ \"*\" ^ (exprToString t2) \n| Thresh (th1, th2, th3, th4) -> \"(\" ^ (exprToString th1) ^ \"<\" ^ \n(exprToString th2) ^ \"?\" ^ (exprToString th3) ^ \n\":\" ^ (exprToString th4) ^ \")\"\n| DivAdd (ds1, ds2, ds3, ds4) -> \"((\" ^ (exprToString ds1) ^ \"+\" ^\n(exprToString ds2) ^ \") / (\" ^ (exprToString ds3) ^\n\"+\" ^ (exprToString ds4) \"))\"\n| TriMult (tm1, tm2, tm3) -> \"(\" ^ (exprToString tm1) ^ \"*\" ^ (exprToString tm2) ^\n\"*\" (exprToString tm3) ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine sin  -> \"sin(pi*\" ^ (exprToString sin) ^ \")\"  \n| Cosine cos -> \"cos(pi*\" ^ (exprToString cos) ^ \")\"\n| Average (n1, n2) ->  \"((\" ^ (exprToString n1) ^ \"+\" ^ (exprToString n2) ^ \")/2)\"\n| Times (t1, t2) -> (exprToString t1) ^ \"*\" ^ (exprToString t2) \n| Thresh (th1, th2, th3, th4) -> \"(\" ^ (exprToString th1) ^ \"<\" ^ \n(exprToString th2) ^ \"?\" ^ (exprToString th3) ^ \n\":\" ^ (exprToString th4) ^ \")\"\n| DivAdd (ds1, ds2, ds3, ds4) -> \"((\" ^ (exprToString ds1) ^ \"+\" ^\n(exprToString ds2) ^ \") / (\" ^ (exprToString ds3) ^\n\"+\" ^ (exprToString ds4) \"))\"\n| TriMult (tm1, tm2, tm3) -> \"(\" ^ (exprToString tm1) ^ \"*\" ^ (exprToString tm2) ^\n\"*\" (exprToString tm3) ^ \")\""}
{"fix": "let pipe fs = \nlet f a x = x a  in\nlet base = f  in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a  in\nlet base = f x a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a  in\nlet base = f x a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a  in\nlet base = f  in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a  in\nlet base = f a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a  in\nlet base = f a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a  in\nlet base =  3 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a  in\nlet base = a  in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a  in\nlet base = a  in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a  in\nlet base =  f 3 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a  in\nlet base =  x 3 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a  in\nlet base =  x 3 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 3  in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a  in\nlet base =  fs 3 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a  in\nlet base =  fs 3 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 3  in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x in\nlet base =  f (x a) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x in\nlet base =  f (x a) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 3  in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x in\nlet base =  f ((f a x) a) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x in\nlet base =  f ((f a x) a) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 3  in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x in\nlet base =  f base in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x in\nlet base =  f base in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 3  in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = f x in\nlet base = 3  in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = f x in\nlet base = 3  in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = 3  in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fs x in\nlet base = 3  in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fs x in\nlet base = 3  in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = f  in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = x  in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = x  in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = f  in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = a  in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = a  in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = a in\nlet base = f  in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = f  in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = f  in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nmatch fs with \n| [] -> base\n| f::fs' -> \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nmatch fs with \n| [] -> base\n| f::fs' -> \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "bad": "let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = f 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = f 0 in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "bad": "let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = f a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = f a in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "bad": "let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = f x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = f x in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "bad": "let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "bad": "let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = fs' in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = fs' in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "bad": "let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = fs' in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = fs' in\nList.fold_left f base fs"}
{"fix": "let pipe fs =\nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs", "bad": "let pipe fs =\nlet f a x = x a in\nlet base = f(x,a) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> \nlet f a x = x a in\nlet base = f(x,a) in\nList.fold_left f base fs"}
{"fix": "let pipe fs =\nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs", "bad": "let pipe fs =\nlet f a x = x a in\nlet base = f a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> \nlet f a x = x a in\nlet base = f a in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs =\nlet f a x = x a in\nlet base = f (x a) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> \nlet f a x = x a in\nlet base = f (x a) in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let pipe fs =\nlet f a x = x a in\nlet base = _ in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> \nlet f a x = x a in\nlet base = _ in\nList.fold_left f base fs"}
{"fix": "let stringOfList f l = \nList.map sepConcat l", "bad": "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "annotated": "let _ = stringOfList string_of_int [1;2;3;4;5;6]"}
{"fix": "let stringOfList f l = \nList.map sepConcat l", "bad": "let stringOfList f l = \nList.map (sepConcat f l) l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \nList.map (sepConcat f l) l"}
{"fix": "let stringOfList f l = \nList.map (sepConcat \"\") l", "bad": "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "annotated": "let _ = stringOfList string_of_int [1;2;3;4;5;6]"}
{"fix": "let stringOfList f l = \nList.map (sepConcat (f \"\")) l", "bad": "let stringOfList f l = \nList.map (sepConcat fun y -> f \"\") l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \nList.map (sepConcat fun y -> f \"\") l"}
{"fix": "let stringOfList f l = \nList.map ( sepConcat (f l) ) l", "bad": "let stringOfList f l = \nList.map (( sepConcat \"\" ) l) l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \nList.map (( sepConcat \"\" ) l) l"}
{"fix": "let stringOfList f l = \nList.map ( sepConcat (f l) ) l", "bad": "let stringOfList f l = \nList.map f (( sepConcat \"\" ) l)", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \nList.map f (( sepConcat \"\" ) l)"}
{"fix": "let stringOfList f l = \nList.map ( sepConcat (f) ) l", "bad": "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "annotated": "let _ = stringOfList string_of_int [1;2;3;4;5;6]"}
{"fix": "let stringOfList f l = \nList.map (sepConcat f) l", "bad": "let stringOfList f l = \nList.map (sepConcat f) (f l)", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \nList.map (sepConcat f) (f l)"}
{"fix": "let stringOfList f l = \nList.map (sepConcat f) l", "bad": "let stringOfList f l = \nList.map (sepConcat f) (f l)", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \nList.map (sepConcat f) (f l)"}
{"fix": "let stringOfList f l = \nList.map (sepConcat f) l", "bad": "let stringOfList f l = \nList.map (sepConcat (\"\" l)) l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \nList.map (sepConcat (\"\" l)) l"}
{"fix": "let stringOfList f l = \nList.map (sepConcat f) l", "bad": "let stringOfList f l = \nList.map (sepConcat \"\" l) l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \nList.map (sepConcat \"\" l) l"}
{"fix": "let stringOfList f l = \nList.map (sepConcat f) l", "bad": "let stringOfList f l = \nList.map (sepConcat f l) l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \nList.map (sepConcat f l) l"}
{"fix": "let stringOfList f l = \n\"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"", "bad": "let stringOfList f l = \nList.map f (sepConcat f l)", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \nList.map f (sepConcat f l)"}
{"fix": "let stringOfList f l = \n\"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"", "bad": "let stringOfList f l = \nList.map f (sepConcat l)", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \nList.map f (sepConcat l)"}
{"fix": "let stringOfList f l = \n\"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"", "bad": "let stringOfList f l = \n(sepConcat \"\" l) List.map (f l)", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \n(sepConcat \"\" l) List.map (f l)"}
{"fix": "let stringOfList f l = \n\"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"", "bad": "let stringOfList f l = \n(sepConcat List.map (f l) l)", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \n(sepConcat List.map (f l) l)"}
{"fix": "let stringOfList f l = \n\"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"", "bad": "let stringOfList f l = \n(sepConcat (List.map (f l)) l)", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \n(sepConcat (List.map (f l)) l)"}
{"fix": "let stringOfList f l = \n\"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"", "bad": "let stringOfList f l = \n\"[\" ^ sepConcat \";\" ^ List.map(f l) ^ \"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \n\"[\" ^ sepConcat \";\" ^ List.map(f l) ^ \"]\""}
{"fix": "let stringOfList f l = \n\"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"", "bad": "let stringOfList f l = \n\"[\" ^ sepConcat \";\" List.map(f l) ^ \"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \n\"[\" ^ sepConcat \";\" List.map(f l) ^ \"]\""}
{"fix": "let stringOfList f l = \n\"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"", "bad": "let stringOfList f l = \n\"[\" ^ sepConcat \";\" List.map(f l) ^ \"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \n\"[\" ^ sepConcat \";\" List.map(f l) ^ \"]\""}
{"fix": "let rec clone x n = match n with \n| 0 -> []\n| n -> x@clone x (n-1)", "bad": "let rec clone x n = match n with \n| 0 -> []\n| _ -> clone x::[] (n-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with \n| 0 -> []\n| _ -> clone x::[] (n-1)"}
{"fix": "let rec clone x n = \nif n <= 0 then []\nelse [x]@clone x (n-1)", "bad": "let rec clone x n = match n with \nif n <= 0 then []\nelse [x]@clone x (n-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with \nif n <= 0 then []\nelse [x]@clone x (n-1)"}
{"fix": "let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "bad": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 = List.length l2 then (l1, l2)"}
{"fix": "let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "bad": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then List.combine (l1, l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 = List.length l2 then List.combine (l1, l2)"}
{"fix": "let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "bad": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then List.combine l1 l2", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 = List.length l2 then List.combine l1 l2"}
{"fix": "let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "bad": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then l1 l2", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 = List.length l2 then l1 l2"}
{"fix": "let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "bad": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 = List.length l2 then (l1, l2)"}
{"fix": "let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "bad": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then padZero(0::l1 l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then padZero(0::l1 l2)"}
{"fix": "let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "bad": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then padZero((0::l1) l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then padZero((0::l1) l2)"}
{"fix": "let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "bad": "let rec padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then padZero((0::l1) l2)", "annotated": "let rec padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then padZero((0::l1) l2)"}
{"fix": "let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "bad": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then 0::l1", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then 0::l1"}
{"fix": "let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "bad": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then (0::l1, l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then (0::l1, l2)"}
{"fix": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then (l1, l2)\nelse (l1, l2)", "bad": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then (0::l1, l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then (0::l1, l2)"}
{"fix": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then (l1, l2)\nelse (l1, l2)", "bad": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then (List.append [0] l1, l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then (List.append [0] l1, l2)"}
{"fix": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then (l1, l2)\nelse (l1, l2)", "bad": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then (l1, l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then (l1, l2)"}
{"fix": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then (l1, 0::l2)\nelse if List.length l1 < List.length l2 then (0::l1, l2)\nelse (l1, l2)", "bad": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then (0::l1, 0::l2)\nelse (l1::[], l2::[])", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then (0::l1, 0::l2)\nelse (l1::[], l2::[])"}
{"fix": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then (l1, 0::l2)\nelse if List.length l1 < List.length l2 then (0::l1, l2)\nelse (l1, l2)", "bad": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then (l1, l2::0)\nelse if List.length l1 < List.length l2 then (0::l1, l2)\nelse (l1, l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 > List.length l2 then (l1, l2::0)\nelse if List.length l1 < List.length l2 then (0::l1, l2)\nelse (l1, l2)"}
{"fix": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \n(* L1 is greater, so append 0's to l2 *)\n(l1, List.append (clone 0 l1G) l2) \nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l1 in \n(List.append (clone 0 l2G) l1, l2)\nelse (l1, l2)", "bad": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then clone (l1, 0::l2)\nelse if List.length l1 < List.length l2 then clone (0::l1, l2)\nelse (l1, l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 > List.length l2 then clone (l1, 0::l2)\nelse if List.length l1 < List.length l2 then clone (0::l1, l2)\nelse (l1, l2)"}
{"fix": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \n(* L1 is greater, so append 0's to l2 *)\n(l1, List.append (clone 0 l1G) l2) \nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l1 in \n(List.append (clone 0 l2G) l1, l2)\nelse (l1, l2)", "bad": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then clone (l1, 0::l2) ,\nelse if List.length l1 < List.length l2 then clone (0::l1, l2)\nelse (l1, l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 > List.length l2 then clone (l1, 0::l2) ,\nelse if List.length l1 < List.length l2 then clone (0::l1, l2)\nelse (l1, l2)"}
{"fix": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \n(* L1 is greater, so append 0's to l2 *)\n(l1, List.append (clone 0 l1G) l2) \nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l1 in \n(List.append (clone 0 l2G) l1, l2)\nelse (l1, l2)", "bad": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then List.combine(l1, clone(0::l2) \nelse if List.length l1 < List.length l2 then clone (0::l1, l2)\nelse (l1, l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 > List.length l2 then List.combine(l1, clone(0::l2) \nelse if List.length l1 < List.length l2 then clone (0::l1, l2)\nelse (l1, l2)"}
{"fix": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \n(* L1 is greater, so append 0's to l2 *)\n(l1, List.append (clone 0 l1G) l2) \nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l1 in \n(List.append (clone 0 l2G) l1, l2)\nelse (l1, l2)", "bad": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then List.append(l1, clone(0::l2) \nelse if List.length l1 < List.length l2 then List.append (0::l1, l2)\nelse (l1, l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 > List.length l2 then List.append(l1, clone(0::l2) \nelse if List.length l1 < List.length l2 then List.append (0::l1, l2)\nelse (l1, l2)"}
{"fix": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \n(* L1 is greater, so append 0's to l2 *)\n(l1, List.append (clone 0 l1G) l2) \nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l1 in \n(List.append (clone 0 l2G) l1, l2)\nelse (l1, l2)", "bad": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \nList.append(l1, clone(0 l2) )\nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l2 in \nthen List.append (0::l1, l2)\nelse (l1, l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \nList.append(l1, clone(0 l2) )\nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l2 in \nthen List.append (0::l1, l2)\nelse (l1, l2)"}
{"fix": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \n(* L1 is greater, so append 0's to l2 *)\n(l1, List.append (clone 0 l1G) l2) \nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l1 in \n(List.append (clone 0 l2G) l1, l2)\nelse (l1, l2)", "bad": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \nList.append(l1, clone(l1, l2) )\nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l2 in \nthen List.append (clone (l1 l2G), l2)\nelse (l1, l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \nList.append(l1, clone(l1, l2) )\nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l2 in \nthen List.append (clone (l1 l2G), l2)\nelse (l1, l2)"}
{"fix": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \n(* L1 is greater, so append 0's to l2 *)\n(l1, List.append (clone 0 l1G) l2) \nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l1 in \n(List.append (clone 0 l2G) l1, l2)\nelse (l1, l2)", "bad": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \nList.append(l1, clone(l1, l2) )\nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l2 in \nList.append (clone (l1 l2G), l2)\nelse (l1, l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \nList.append(l1, clone(l1, l2) )\nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l2 in \nList.append (clone (l1 l2G), l2)\nelse (l1, l2)"}
{"fix": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \n(* L1 is greater, so append 0's to l2 *)\n(l1, List.append (clone 0 l1G) l2) \nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l1 in \n(List.append (clone 0 l2G) l1, l2)\nelse (l1, l2)", "bad": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \nList.append(l1, clone(0, l1G) )\nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l2 in \nList.append (clone (0 l2G), l2)\nelse (l1, l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \nList.append(l1, clone(0, l1G) )\nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l2 in \nList.append (clone (0 l2G), l2)\nelse (l1, l2)"}
{"fix": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \n(* L1 is greater, so append 0's to l2 *)\n(l1, List.append (clone 0 l1G) l2) \nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l1 in \n(List.append (clone 0 l2G) l1, l2)\nelse (l1, l2)", "bad": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \nList.append(l1, clone(0  l1G) )\nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l2 in \nList.append (clone (0 l2G), l2)\nelse (l1, l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \nList.append(l1, clone(0  l1G) )\nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l2 in \nList.append (clone (0 l2G), l2)\nelse (l1, l2)"}
{"fix": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \n(* L1 is greater, so append 0's to l2 *)\n(l1, List.append (clone 0 l1G) l2) \nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l1 in \n(List.append (clone 0 l2G) l1, l2)\nelse (l1, l2)", "bad": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \nList.append(l1 clone(0  l1G) )\nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l2 in \nList.append (clone (0 l2G) l2)\nelse (l1, l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \nList.append(l1 clone(0  l1G) )\nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l2 in \nList.append (clone (0 l2G) l2)\nelse (l1, l2)"}
{"fix": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \n(* L1 is greater, so append 0's to l2 *)\n(l1, List.append (clone 0 l1G) l2) \nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l1 in \n(List.append (clone 0 l2G) l1, l2)\nelse (l1, l2)", "bad": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \nList.append(l1, clone(0  l1G) l2 )\nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l1 in \nList.append (clone (0 l2G) l1) l2\nelse (l1, l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \nList.append(l1, clone(0  l1G) l2 )\nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l1 in \nList.append (clone (0 l2G) l1) l2\nelse (l1, l2)"}
{"fix": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \n(* L1 is greater, so append 0's to l2 *)\n(l1, List.append (clone 0 l1G) l2) \nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l1 in \n(List.append (clone 0 l2G) l1, l2)\nelse (l1, l2)", "bad": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \nList.append(l1, (clone 0  l1G) l2 )\nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l1 in \nList.append ((clone 0 l2G) l1, l2)\nelse (l1, l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \nList.append(l1, (clone 0  l1G) l2 )\nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l1 in \nList.append ((clone 0 l2G) l1, l2)\nelse (l1, l2)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x in\nlet (carry, rest) = a in \nlet total = n1 + n2 + carry in\n(total/10, (total mod 10)::rest) in\nlet base = (0, []) in\nlet args = List.rev (List.combine(0::l1) ( 0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| [] -> []\n| h::t -> h in\nmatch x with\n| [] -> [] \n| h2::t2 -> in \nlet base = h in\nlet args = h2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| [] -> []\n| h::t -> h in\nmatch x with\n| [] -> [] \n| h2::t2 -> in \nlet base = h in\nlet args = h2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x in\nlet (carry, rest) = a in \nlet total = n1 + n2 + carry in\n(total/10, (total mod 10)::rest) in\nlet base = (0, []) in\nlet args = List.rev (List.combine(0::l1) ( 0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x in\nlet (carry, rest) = a in \nlet total = n1 + n2 + carry in\n(total/10, (sum mod 10)::rest) in\nlet base = (0, []) in\nlet args = List.rev (List.combine(0::l1, 0::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x in\nlet (carry, rest) = a in \nlet total = n1 + n2 + carry in\n(total/10, (sum mod 10)::rest) in\nlet base = (0, []) in\nlet args = List.rev (List.combine(0::l1, 0::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x in\nlet (carry, rest) = a in \nlet total = n1 + n2 + carry in\n(total/10, (total mod 10)::rest) in\nlet base = (0, []) in\nlet args = List.rev (List.combine(0::l1) ( 0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x in\nlet (carry, rest) = a in \nlet total = n1 + n2 + carry in\n(total/10, (sum mod 10)::rest) in\nlet base = (0, []) in\nlet args = List.rev (List.combine(0::l1, 0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x in\nlet (carry, rest) = a in \nlet total = n1 + n2 + carry in\n(total/10, (sum mod 10)::rest) in\nlet base = (0, []) in\nlet args = List.rev (List.combine(0::l1, 0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x in\nlet (carry, rest) = a in \nlet total = n1 + n2 + carry in\n(total/10, (total mod 10)::rest) in\nlet base = (0, []) in\nlet args = List.rev (List.combine(0::l1) ( 0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x in\nlet (carry, rest) = a in \nlet total = n1 + n2 + carry in\n(total/10, (total mod 10)::rest) in\nlet base = (0, []) in\nlet args = List.rev (List.combine(0::l1, 0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x in\nlet (carry, rest) = a in \nlet total = n1 + n2 + carry in\n(total/10, (total mod 10)::rest) in\nlet base = (0, []) in\nlet args = List.rev (List.combine(0::l1, 0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10)::(mulByDigit i t))\nelse prod::t", "bad": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10) + (mulByDigit i t))\nelse prod::t", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10) + (mulByDigit i t))\nelse prod::t"}
{"fix": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10)::(mulByDigit i t))\nelse prod::t", "bad": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10) + ((mulByDigit i t))\nelse prod::t", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10) + ((mulByDigit i t))\nelse prod::t"}
{"fix": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10)::(mulByDigit i t))\nelse prod::t", "bad": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10) + (mulByDigit i t)::t)\nelse prod::t", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10) + (mulByDigit i t)::t)\nelse prod::t"}
{"fix": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10)::(mulByDigit i t))\nelse prod::t", "bad": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10))\nelse prod::t", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10))\nelse prod::t"}
{"fix": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)::(mulByDigit i t) )\nelse (prod mod 10)::t", "bad": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::[((prod / 10)::(mulByDigit i t))]\nelse prod::t", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::[((prod / 10)::(mulByDigit i t))]\nelse prod::t"}
{"fix": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)::(mulByDigit i t) )\nelse (prod mod 10)::t", "bad": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )::t\nelse prod::t", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )::t\nelse prod::t"}
{"fix": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)::(mulByDigit i t) )\nelse (prod mod 10)::t", "bad": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )\nelse prod::t", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )\nelse prod::t"}
{"fix": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)::(mulByDigit i t) )\nelse (prod mod 10)::t", "bad": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t)::[] )\nelse prod::t", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t)::[] )\nelse prod::t"}
{"fix": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)::(mulByDigit i t) )\nelse (prod mod 10)::t", "bad": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> 0\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )\nelse prod::t", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nmatch List.rev l with\n| [] -> 0\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )\nelse prod::t"}
{"fix": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)::(mulByDigit i t) )\nelse (prod mod 10)::t", "bad": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )\nelse prod::t", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )\nelse prod::t"}
{"fix": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)::(mulByDigit i t) )\nelse (prod mod 10)::t", "bad": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )\nelse (prod mod 10)::t", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )\nelse (prod mod 10)::t"}
{"fix": "let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "bad": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then ((prod mod 10)::( (prod / 10) + (mulByDigit i t) ))::t\nelse (prod mod 10)::t", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then ((prod mod 10)::( (prod / 10) + (mulByDigit i t) ))::t\nelse (prod mod 10)::t"}
{"fix": "let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "bad": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10) + [(mulByDigit i t)] )\nelse (prod mod 10)::t", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10) + [(mulByDigit i t)] )\nelse (prod mod 10)::t"}
{"fix": "let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "bad": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( [(prod / 10)]::(mulByDigit i t) )\nelse (prod mod 10)::t", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( [(prod / 10)]::(mulByDigit i t) )\nelse (prod mod 10)::t"}
{"fix": "let rec mulByDigit i l = \nlet mult i l = \nlet f a x = \nlet (carryOver, rest) = a in\nlet num = carryOver + (x * i) in\nlet secondDigit = num mod 10 in\nlet carryOver = num / 10 in\nlet result = secondDigit::rest in (carryOver, rest) in\nlet base = (0, []) in\nlet (carryOver, rest) = List.fold_left f base (List.rev l) in\ncarryOver::rest in\nremoveZero(mult i l)", "bad": "let rec mulByDigit i l = \nmatch l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nlet lastDigit = prod / 10 in \nlet firstDigit = prod mod 10 in\nif prod > 10 then lastDigit::[firstDigit + mulByDigit(i t)]\nelse firstDigit::t", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nmatch l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nlet lastDigit = prod / 10 in \nlet firstDigit = prod mod 10 in\nif prod > 10 then lastDigit::[firstDigit + mulByDigit(i t)]\nelse firstDigit::t"}
{"fix": "let rec mulByDigit i l = \nlet mult i l = \nlet f a x = \nlet (carryOver, rest) = a in\nlet num = carryOver + (x * i) in\nlet secondDigit = num mod 10 in\nlet carryOver = num / 10 in\nlet result = secondDigit::rest in (carryOver, rest) in\nlet base = (0, []) in\nlet (carryOver, rest) = List.fold_left f base (List.rev l) in\ncarryOver::rest in\nremoveZero(mult i l)", "bad": "let rec mulByDigit i l = \nmatch l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nlet lastDigit = prod / 10 in \nlet firstDigit = prod mod 10 in\nlet ret = mulByDigit ( i t ) in\nmatch ret with \n| [] -> 0\n| h2::t2 -> if h2 > 10 then let temp = h2 \nelse let temp = h2 mod 10 in \nif prod > 10 then lastDigit::[firstDigit + temp]\nelse firstDigit::t", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nmatch l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nlet lastDigit = prod / 10 in \nlet firstDigit = prod mod 10 in\nlet ret = mulByDigit ( i t ) in\nmatch ret with \n| [] -> 0\n| h2::t2 -> if h2 > 10 then let temp = h2 \nelse let temp = h2 mod 10 in \nif prod > 10 then lastDigit::[firstDigit + temp]\nelse firstDigit::t"}
{"fix": "let rec mulByDigit i l = \nlet mult i l = \nlet f a x = \nlet (carryOver, rest) = a in\nlet num = carryOver + (x * i) in\nlet secondDigit = num mod 10 in\nlet carryOver = num / 10 in\nlet result = secondDigit::rest in (carryOver, rest) in\nlet base = (0, []) in\nlet (carryOver, rest) = List.fold_left f base (List.rev l) in\ncarryOver::rest in\nremoveZero(mult i l)", "bad": "let rec mulByDigit i l = \nmatch l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nlet lastDigit = prod / 10 in \nlet firstDigit = prod mod 10 in\nlet ret = mulByDigit ( i t ) in\nmatch ret with \n| [] -> 0\n| h2::t2 -> if h2 > 10 then let temp = h2 \nelse temp = h2 mod 10 in \nif prod > 10 then lastDigit::[firstDigit + temp]\nelse firstDigit::t", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nmatch l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nlet lastDigit = prod / 10 in \nlet firstDigit = prod mod 10 in\nlet ret = mulByDigit ( i t ) in\nmatch ret with \n| [] -> 0\n| h2::t2 -> if h2 > 10 then let temp = h2 \nelse temp = h2 mod 10 in \nif prod > 10 then lastDigit::[firstDigit + temp]\nelse firstDigit::t"}
{"fix": "let rec mulByDigit i l = \nlet mult i l = \nlet f a x = \nlet (carryOver, rest) = a in\nlet num = carryOver + (x * i) in\nlet secondDigit = num mod 10 in\nlet carryOver = num / 10 in\nlet result = secondDigit::rest in (carryOver, rest) in\nlet base = (0, []) in\nlet (carryOver, rest) = List.fold_left f base (List.rev l) in\ncarryOver::rest in\nremoveZero(mult i l)", "bad": "let rec mulByDigit i l = \nmatch l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nlet lastDigit = prod / 10 in \nlet firstDigit = prod mod 10 in\nlet ret = mulByDigit ( i t ) in\nmatch ret with \n| [] -> 0\n| h2::t2 -> if h2 > 10 then let temp = h2 in \nif prod > 10 then lastDigit::[firstDigit + temp]\nelse firstDigit::t", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nmatch l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nlet lastDigit = prod / 10 in \nlet firstDigit = prod mod 10 in\nlet ret = mulByDigit ( i t ) in\nmatch ret with \n| [] -> 0\n| h2::t2 -> if h2 > 10 then let temp = h2 in \nif prod > 10 then lastDigit::[firstDigit + temp]\nelse firstDigit::t"}
{"fix": "let bigMul l1 l2 = \nlet f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in\nlet base = [] in\nlet args = List.rev l2 in\nList.fold_left f base args", "bad": "let bigMul l1 l2 = \nlet f a x = List.append ((mulByDigit x l1) (clone 0 (List.length a))::a) in\nlet base = [] in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = List.append ((mulByDigit x l1) (clone 0 (List.length a))::a) in\nlet base = [] in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in\nlet base = [] in\nlet args = List.rev l2 in\nList.fold_left f base args", "bad": "let bigMul l1 l2 = \nlet f a x = ((mulByDigitx l1)@(clone 0 (List.length a)))::a in\nlet base = [] in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = ((mulByDigitx l1)@(clone 0 (List.length a)))::a in\nlet base = [] in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in\nlet base = [] in\nlet args = List.rev l2 in\nList.fold_left f base args", "bad": "let bigMul l1 l2 = \nlet f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in\nlet base = [] in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in\nlet base = [] in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let rec sumList xs = \nlet x :: t = xs in\nx + sumList (t)", "bad": "let rec sumList xs = \nxs.(0) + hd xs", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nxs.(0) + hd xs"}
{"fix": "let rec sumList xs = \nlet x :: t = xs in\nx + sumList (t)", "bad": "let rec sumList xs = \nif xs.length != 0 then xs.(0) + sumList(hd xs)", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nif xs.length != 0 then xs.(0) + sumList(hd xs)"}
{"fix": "let rec sumList xs = \nlet x :: t = xs in\nx + sumList (t)", "bad": "let rec sumList xs = \nif List.length xs != 0 then xs.(0) + sumList(hd xs)", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nif List.length xs != 0 then xs.(0) + sumList(hd xs)"}
{"fix": "let rec sumList xs = \nlet x :: t = xs in\nx + sumList (t)", "bad": "let rec sumList xs = \nif List.length xs != 0 then xs.(0) + sumList(List.hd xs)", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nif List.length xs != 0 then xs.(0) + sumList(List.hd xs)"}
{"fix": "let rec sumList xs = \nlet x :: t = xs in\nx + sumList (t)", "bad": "let rec sumList xs = \nif List.length xs != 0 then List.nth xs 0 + sumList(List.hd xs)", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nif List.length xs != 0 then List.nth xs 0 + sumList(List.hd xs)"}
{"fix": "let rec sumList xs = \nlet x :: t = xs in\nx + sumList (t)", "bad": "let rec sumList xs = \nif List.length xs != 0 then List.nth xs 0 + sumList(List.tl xs)", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nif List.length xs != 0 then List.nth xs 0 + sumList(List.tl xs)"}
{"fix": "let rec sumList xs = \nlet x :: t = xs in\nx + sumList (t)", "bad": "let rec sumList xs = \nif List.length xs != 0 then List.nth xs 0 + sumList(List.tl xs)", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nif List.length xs != 0 then List.nth xs 0 + sumList(List.tl xs)"}
{"fix": "let rec sumList xs = \nlet x :: t = xs in\nx + sumList (t)", "bad": "let rec sumList xs = \nlet rec int q =\nq + if List.length xs != 0 then List.nth xs 0 \n| sumList(List.tl xs)", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nlet rec int q =\nq + if List.length xs != 0 then List.nth xs 0 \n| sumList(List.tl xs)"}
{"fix": "let rec sumList xs = \nlet x :: t = xs in\nx + sumList (t)", "bad": "let rec sumList xs = \nlet rec int q =\nq + if List.length xs != 0 then List.nth xs 0 \nsumList(List.tl xs)", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nlet rec int q =\nq + if List.length xs != 0 then List.nth xs 0 \nsumList(List.tl xs)"}
{"fix": "let rec sumList xs = \nlet x :: t = xs in\nx + sumList (t)", "bad": "let rec sumList xs = \nlet int q =\nq + x :: xs", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nlet int q =\nq + x :: xs"}
{"fix": "let rec sumList xs = \nlet x :: t = xs in\nx + sumList (t)", "bad": "let rec sumList xs = \nlet int q =\nq + x :: xs", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nlet int q =\nq + x :: xs"}
{"fix": "let rec sumList xs = \nlet x :: t = xs in\nx + sumList (t)", "bad": "let rec sumList xs = \nlet x :: t = xs in\nlet int q = q + x + sumList(t)", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nlet x :: t = xs in\nlet int q = q + x + sumList(t)"}
{"fix": "let rec sumList xs = \nlet x :: t = xs in\nx + sumList (t)", "bad": "let rec sumList xs = \nlet x :: t = xs in\nlet int q = q + x + sumList (t)", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nlet x :: t = xs in\nlet int q = q + x + sumList (t)"}
{"fix": "let rec sumList xs = \nlet x :: t = xs in\nx + if t = [] then 0 else sumList (t)", "bad": "let rec sumList xs = \nlet x :: t = xs in\nif t != [] then x + sumList (t)", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nlet x :: t = xs in\nif t != [] then x + sumList (t)"}
{"fix": "let rec sumList xs = \nlet x :: t = xs in\nx + if t = [] then 0 else sumList (t)", "bad": "let rec sumList xs = \nlet x :: t = xs in\nif x != [] then x + sumList (t)", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nlet x :: t = xs in\nif x != [] then x + sumList (t)"}
{"fix": "let rec sumList xs = \nlet x :: t = xs in\nx + if t = [] then 0 else sumList (t)", "bad": "let rec sumList xs = \nlet x :: t = xs in\nx + if t != [] then sumList (t)", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nlet x :: t = xs in\nx + if t != [] then sumList (t)"}
{"fix": "let rec sumList xs = \nlet x :: t = xs in\nx + if t = [] then 0 else sumList (t)", "bad": "let rec digitsOfInt n = \nn mod 10 :: if n <> [] then digitsOfInt (n / 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nn mod 10 :: if n <> [] then digitsOfInt (n / 10)"}
{"fix": "let rec digitsOfInt n = \nlet int list digInt = n mod 10 in\nif n > 0 then digitsOfInt (n / 10) else []", "bad": "let rec digitsOfInt n = \nlet int list xs = \nn mod 10 :: if n > 0 then digitsOfInt (n / 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet int list xs = \nn mod 10 :: if n > 0 then digitsOfInt (n / 10)"}
{"fix": "let rec digitsOfInt n = \nlet int list digInt = n mod 10 in\nif n > 0 then digitsOfInt (n / 10) else []", "bad": "let rec digitsOfInt n = \nlet digInt =\nn mod 10 :: if n > 0 then digitsOfInt (n / 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet digInt =\nn mod 10 :: if n > 0 then digitsOfInt (n / 10)"}
{"fix": "let rec digitsOfInt n = \nlet int list digInt = n mod 10 in\nif n > 0 then digitsOfInt (n / 10) else []", "bad": "let rec digitsOfInt n = \nlet int list digInt =\nn mod 10 :: if n > 0 then digitsOfInt (n / 10) else []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet int list digInt =\nn mod 10 :: if n > 0 then digitsOfInt (n / 10) else []"}
{"fix": "let rec digitsOfInt n = \nlet int list digInt = n mod 10 in\nif n > 0 then digitsOfInt (n / 10)", "bad": "let rec digitsOfInt n = \nlet int list digInt = n mod 10 in\nif n > 0 then digitsOfInt (n / 10) else digInt", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet int list digInt = n mod 10 in\nif n > 0 then digitsOfInt (n / 10) else digInt"}
{"fix": "let rec digitsOfInt n = \nlet int list digInt = n mod 10 in\nif n > 0 then digitsOfInt (n / 10)", "bad": "let rec digitsOfInt n = \nlet int list digInt = n mod 10 in\nif n > 0 then digitsOfInt (n / 10) else digInt", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet int list digInt = n mod 10 in\nif n > 0 then digitsOfInt (n / 10) else digInt"}
{"fix": "let rec digitsOfInt n = \nlet list digInt = (n mod 10) in\nif n / 10 <> 0 then digitsOfInt (n / 10)", "bad": "let rec digitsOfInt n = \nlet int list digInt :: n mod 10 in\nif n > 0 then digitsOfInt (n / 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet int list digInt :: n mod 10 in\nif n > 0 then digitsOfInt (n / 10)"}
{"fix": "let rec digitsOfInt n = \nlet list digInt = (n mod 10) in\nif n / 10 <> 0 then digitsOfInt (n / 10)", "bad": "let rec digitsOfInt n = \nlet list digInt :: n mod 10 in\nif n > 0 then digitsOfInt (n / 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet list digInt :: n mod 10 in\nif n > 0 then digitsOfInt (n / 10)"}
{"fix": "let rec digitsOfInt n = \nlet list digInt = (n mod 10) in\nif n / 10 <> 0 then digitsOfInt (n / 10)", "bad": "let rec digitsOfInt n = \nlet list digInt :: (n mod 10) in\nif n > 0 then digitsOfInt (n / 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet list digInt :: (n mod 10) in\nif n > 0 then digitsOfInt (n / 10)"}
{"fix": "let rec digitsOfInt n = \nlet list digInt = (n mod 10) in\nif n / 10 <> 0 then digitsOfInt (n / 10)", "bad": "let rec digitsOfInt n = \nlet list digInt :: (n mod 10)\nif n > 0 then digitsOfInt (n / 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet list digInt :: (n mod 10)\nif n > 0 then digitsOfInt (n / 10)"}
{"fix": "let rec digitsOfInt n = \nlet list digInt = (n mod 10) in\nif n / 10 <> 0 then digitsOfInt (n / 10)", "bad": "let rec digitsOfInt n = \nlet list digInt :: (n mod 10) in\nif n / 10 <> 0 then digitsOfInt (n / 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet list digInt :: (n mod 10) in\nif n / 10 <> 0 then digitsOfInt (n / 10)"}
{"fix": "let int list digInt = []", "bad": "let rec digitsOfInt n = \nlet int list digInt :: (n mod 10) in\nif n / 10 <> 0 then digitsOfInt (n / 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet int list digInt :: (n mod 10) in\nif n / 10 <> 0 then digitsOfInt (n / 10)"}
{"fix": "let int list digInt = []", "bad": "let rec digitsOfInt n = \nlet int list digInt =\nn mod 10 :: if n / 10 <> 0 then digitsOfInt (n / 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet int list digInt =\nn mod 10 :: if n / 10 <> 0 then digitsOfInt (n / 10)"}
{"fix": "let int list digInt = []", "bad": "let rec digitsOfInt n = \nlet int list digInt = n mod 10 :: digitsOfInt( n / 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet int list digInt = n mod 10 :: digitsOfInt( n / 10)"}
{"fix": "let int list digInt = []", "bad": "let rec digitsOfInt n = \ndigInt = n mod 10 :: digitsOfInt( n / 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \ndigInt = n mod 10 :: digitsOfInt( n / 10)"}
{"fix": "let int list digInt = []", "bad": "let rec digitsOfInt n = \nint list digInt = n mod 10 :: digitsOfInt( n / 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nint list digInt = n mod 10 :: digitsOfInt( n / 10)"}
{"fix": "let rec sumList xs = \nlet x :: t = xs in\nx + if t = [] then 0 else sumList (t)", "bad": "let rec digitsOfInt n = \nlet int list digInt = n mod 10 :: digInt \nif (n / 10) <> 0 then digitsOfInt ( n / 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet int list digInt = n mod 10 :: digInt \nif (n / 10) <> 0 then digitsOfInt ( n / 10)"}
{"fix": "let rec sumList xs = \nlet x :: t = xs in\nx + if t = [] then 0 else sumList (t)", "bad": "let rec digitsOfInt n = \nlet int list digInt = n mod 10 :: digInt in\nif (n / 10) <> 0 then digInt :: digitsOfInt ( n / 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet int list digInt = n mod 10 :: digInt in\nif (n / 10) <> 0 then digInt :: digitsOfInt ( n / 10)"}
{"fix": "let rec sumList xs = \nlet x :: t = xs in\nx + if t = [] then 0 else sumList (t)", "bad": "let rec digitsOfInt n = \nlet int list digInt = [] in\nif (n / 10) <> 0 then digInt :: digitsOfInt ( n / 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet int list digInt = [] in\nif (n / 10) <> 0 then digInt :: digitsOfInt ( n / 10)"}
{"fix": "let l = []", "bad": "let rec digitsOfInt n = \nlet digInt =\nif (n / 10) <> 0 \nthen digInt :: digitsOfInt ( n / 10) \nelse []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet digInt =\nif (n / 10) <> 0 \nthen digInt :: digitsOfInt ( n / 10) \nelse []"}
{"fix": "let l = []", "bad": "let rec digitsOfInt n = \nlet digInt =\nif (n / 10) <> 0 \nthen n mod 10 :: digitsOfInt ( n / 10) \nelse []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet digInt =\nif (n / 10) <> 0 \nthen n mod 10 :: digitsOfInt ( n / 10) \nelse []"}
{"fix": "let l = []", "bad": "let rec digitsOfInt n = \nlet digInt = n mod 10\nif (n / 10) <> 0 \nthen n mod 10 :: digitsOfInt ( n / 10) \nelse []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet digInt = n mod 10\nif (n / 10) <> 0 \nthen n mod 10 :: digitsOfInt ( n / 10) \nelse []"}
{"fix": "let l = []", "bad": "let rec digitsOfInt n = \nlet digInt =\nif (n / 10) <> 0 \nthen n mod 10 :: digitsOfInt ( n / 10) \nelse []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet digInt =\nif (n / 10) <> 0 \nthen n mod 10 :: digitsOfInt ( n / 10) \nelse []"}
{"fix": "let rec digitsOfInt n =\nmatch n / 10 with\n| 0  -> n mod 10 ::[]\n| _  -> n mod 10 :: digitsOfInt( n / 10)", "bad": "let digitsOfInt n =\nlet l = [] in\nmatch n / 10 with\n| 0  -> []\n| _  -> l :: n mod 10 :: digitsOfInt( n / 10)", "annotated": "let digitsOfInt : int -> int list = fun  n  -> \nlet l = [] in\nmatch n / 10 with\n| 0  -> []\n| _  -> l :: n mod 10 :: digitsOfInt( n / 10)"}
{"fix": "let rec digitsOfInt n =\nmatch n / 10 with\n| 0  -> n mod 10 ::[]\n| _  -> n mod 10 :: digitsOfInt( n / 10)", "bad": "let digitsOfInt n =\nlet l = [] \nmatch n / 10 with\n| 0  -> []\n| _  -> l :: n mod 10 :: digitsOfInt( n / 10)", "annotated": "let digitsOfInt : int -> int list = fun  n  -> \nlet l = [] \nmatch n / 10 with\n| 0  -> []\n| _  -> l :: n mod 10 :: digitsOfInt( n / 10)"}
{"fix": "let rec digitsOfInt n =\nmatch n / 10 with\n| 0  -> n mod 10 ::[]\n| _  -> n mod 10 :: digitsOfInt( n / 10)", "bad": "let digitsOfInt n =\nmatch n / 10 with\n| 0  -> []\n| _  -> l :: n mod 10 :: digitsOfInt( n / 10)", "annotated": "let digitsOfInt : int -> int list = fun  n  -> \nmatch n / 10 with\n| 0  -> []\n| _  -> l :: n mod 10 :: digitsOfInt( n / 10)"}
{"fix": "let rec digitsOfInt n =\nmatch n / 10 with\n| 0  -> n mod 10 ::[]\n| _  -> n mod 10 :: digitsOfInt( n / 10)", "bad": "let digitsOfInt n =\nmatch n / 10 with\n| 0  -> n mod 10 ::[]\n| _  -> l :: n mod 10 :: digitsOfInt( n / 10)", "annotated": "let digitsOfInt : int -> int list = fun  n  -> \nmatch n / 10 with\n| 0  -> n mod 10 ::[]\n| _  -> l :: n mod 10 :: digitsOfInt( n / 10)"}
{"fix": "let rec digitsOfInt n =\nmatch n / 10 with\n| 0  -> n mod 10 ::[]\n| _  -> n mod 10 :: digitsOfInt( n / 10)", "bad": "let digitsOfInt n =\nmatch n / 10 with\n| 0  -> n mod 10 ::[]\n| _  -> n mod 10 :: digitsOfInt( n / 10)", "annotated": "let digitsOfInt : int -> int list = fun  n  -> \nmatch n / 10 with\n| 0  -> n mod 10 ::[]\n| _  -> n mod 10 :: digitsOfInt( n / 10)"}
{"fix": "let rec listReverse l = \nmatch l with \n| []   -> []\n| x::l -> x :: listReverse(l)", "bad": "let rec listReverse l = \nmatch l with \n| []   -> []\n| x::l -> listReverse(l) :: x", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with \n| []   -> []\n| x::l -> listReverse(l) :: x"}
{"fix": "let rec listReverse l = \nmatch l with \n| []   -> []\n| x::l -> x :: listReverse(l)", "bad": "let rec listReverse l = \nmatch l with \n| []   -> []\n| x::l -> x :: listReverse(l) x", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with \n| []   -> []\n| x::l -> x :: listReverse(l) x"}
{"fix": "let rec append x y =\nmatch y with\n| []   -> x\n| h::t -> append (h::x) t", "bad": "let rec listReverse l = \nmatch l with \n| [] -> []\n| h::t -> listReverse(t) :: h", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with \n| [] -> []\n| h::t -> listReverse(t) :: h"}
{"fix": "let rec listReverse l = \nlet h::t = l in\nmatch l with \n| []   -> []\n| h::t -> listReverse t", "bad": "let rec listReverse l = \nmatch l with \n| [] -> []\n| h::t -> listReverse t :: h :: []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with \n| [] -> []\n| h::t -> listReverse t :: h :: []"}
{"fix": "let rec sumList xs =\nmatch xs with\n| [] -> 0\n| h::t -> h + sumList(t)", "bad": "let rec sumList xs = \nmatch xs with\n| [] -> x + 0\n| h::t -> x + sumList(t)", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> x + 0\n| h::t -> x + sumList(t)"}
{"fix": "let rec sumList xs =\nmatch xs with\n| [] -> 0\n| h::t -> h + sumList(t)", "bad": "let rec sumList xs =\nlet x =\nmatch xs with\n| [] -> x + 0\n| h::t -> x + sumList(t)", "annotated": "let rec sumList : int list -> int = fun  xs  -> \nlet x =\nmatch xs with\n| [] -> x + 0\n| h::t -> x + sumList(t)"}
{"fix": "let rec listReverse l = \nmatch l with\n| [] -> []\n| h::t -> (listReverse t)", "bad": "let rec listReverse l = \nmatch l with\n| [] -> []\n| h::t -> (listReverse t) :: h", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> []\n| h::t -> (listReverse t) :: h"}
{"fix": "let rec listReverse l = \nmatch l with\n| [] -> []\n| h::t -> (listReverse t)", "bad": "let rec listReverse l = \nif l <> [] then let\nmatch l with \n| []   -> l\n| h::t -> (listReverse t) :: h", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nif l <> [] then let\nmatch l with \n| []   -> l\n| h::t -> (listReverse t) :: h"}
{"fix": "let rec listReverse2 l dest = \nmatch l with\n| [] -> []\n| h::t -> listReverse2 t (h::dest)", "bad": "let rec listReverse l = \nif l <> [] then let\nmatch l with \n| []   -> l\n| h::t -> (listReverse t) :: h", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nif l <> [] then let\nmatch l with \n| []   -> l\n| h::t -> (listReverse t) :: h"}
{"fix": "let rec listReverse2 l dest = \nmatch l with\n| [] -> []\n| h::t -> listReverse2 t (h::dest)", "bad": "let rec listReverse l = \nif l <> [] then \nmatch l with \n| []   -> l\n| h::t -> (listReverse t) :: h", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nif l <> [] then \nmatch l with \n| []   -> l\n| h::t -> (listReverse t) :: h"}
{"fix": "let rec digitalRoot n = digitalRoot(sumList(digits(n)))", "bad": "let rec digitalRoot n = digitalRoot(sumList(n))", "annotated": "let rec digitalRoot : int -> int = fun  n  ->  digitalRoot(sumList(n))"}
{"fix": "let listReverse l = listReverse2 l []", "bad": "let listReverse l = listReverse2 l []", "annotated": "let listReverse : 'a list -> 'a list = fun  l  ->  listReverse2 l []"}
{"fix": "let listReverse l = listReverse2 l []", "bad": "let rec listReverse2 l dest = ", "annotated": "let rec listReverse : 'a list -> 'a list = fun 2 l dest  ->  "}
{"fix": "let listReverse l = listReverse2 l []", "bad": "let rec listReverse2 l dest = \nmatch l with\n| [] -> dest\n| h::t -> listReverse2 t (h::dest)", "annotated": "let rec listReverse : 'a list -> 'a list = fun 2 l dest  ->  \nmatch l with\n| [] -> dest\n| h::t -> listReverse2 t (h::dest)"}
{"fix": "let _ = additivePersistence 9876", "bad": "let additivePersistence n = additivePersistence2 n 0", "annotated": "let additivePersistence : int -> int = fun  n  ->  additivePersistence2 n 0"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen' then seen' else h :: seen' in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen' then seen' else h :: seen' in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let fixpoint (f,b) = wwhile (f ,b)", "bad": "let fixpoint (f,b) = wwhile (f b <> b,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (f b <> b,b)"}
{"fix": "let fixpoint (f,b) = wwhile (f b ,b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = wwhile ( f, b)", "bad": "let fixpoint (f,b) = wwhile (wwhile (f, b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (wwhile (f, b),b)"}
{"fix": "let fixpoint (f,b) = wwhile ( f, b)", "bad": "let fixpoint (f,b) = wwhile (wwhile (f , b) , b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (wwhile (f , b) , b)"}
{"fix": "let fixpoint (f,b) = wwhile ( f, b)", "bad": "let fixpoint (f,b) = wwhile ( if f b = b then b else f b , b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ( if f b  ->  b then b else f b , b)"}
{"fix": "let fixpoint (f,b) = wwhile ( f, b)", "bad": "let fixpoint (f,b) = wwhile ( fixpoint (f , b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( fixpoint (f , b), b)"}
{"fix": "let fixpoint (f,b) = wwhile ( f, b)", "bad": "let fixpoint (f,b) = wwhile ( fixpoint , b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( fixpoint , b)"}
{"fix": "let fixpoint (f,b) = wwhile ( let b' = f b in if b' = b then f b else f b')", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) = wwhile ( let b' = f b in if b' = b then f b else f b')", "bad": "let fixpoint (f,b) = wwhile ( let b' = f b in if b' = b then f b else f b', b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ( let b' = f b in if b'  ->  b then f b else f b', b)"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with  \n| [] -> d\n| h::t -> \nlet (p , q) = h in\nif k = p then q\nelse assoc (d, k, t)", "bad": "let fixpoint (f,b) = wwhile ( , b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( , b)"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(expr) -> \"sin(pi*\"^exprToString(expr)^\")\"\n| Cosine(expr) -> \"cos(pi\"^ exprToString(expr)^\")\"\n| Average(expr, expr2) -> \"((\"^exprToString(expr)^\"+\"^exprToString(expr2)^\"/2)\"\n| Times(expr, expr2) -> exprToString(expr)^\"*\"^exprToString(expr2)\n| Thresh(expr, expr2, expr3, expr4) -> \"(\"^exprToString(expr)^\"<\"^exprToString(expr2)^\"?\"^exprToString(expr3)^\":\"^exprToString(expr4)^\")\"", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(expr) -> \"sin(pi*\"^exprToString(expr)^\")\"\n| Cosine(expr) -> \"cos(pi\"^ exprToString(expr)^\")\"\n| Average(expr, expr2) -> \"((\"^exprToString(expr)^\"+\"^exprToString(expr2)^\"/2)\"\n| Times(expr, expr2) -> exprToString(expr)^\"*\"exprToString(expr2)\n| Thresh(expr, expr2, expr3, expr4) -> \"(\"^exprToString(expr)^\"<\"^exprToString(expr2)^\"?\"^exprToString(expr3)^\":\"^exprToString(expr4)\")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(expr) -> \"sin(pi*\"^exprToString(expr)^\")\"\n| Cosine(expr) -> \"cos(pi\"^ exprToString(expr)^\")\"\n| Average(expr, expr2) -> \"((\"^exprToString(expr)^\"+\"^exprToString(expr2)^\"/2)\"\n| Times(expr, expr2) -> exprToString(expr)^\"*\"exprToString(expr2)\n| Thresh(expr, expr2, expr3, expr4) -> \"(\"^exprToString(expr)^\"<\"^exprToString(expr2)^\"?\"^exprToString(expr3)^\":\"^exprToString(expr4)\")\""}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(expr) -> \"sin(pi*\"^exprToString(expr)^\")\"\n| Cosine(expr) -> \"cos(pi\"^ exprToString(expr)^\")\"\n| Average(expr, expr2) -> \"((\"^exprToString(expr)^\"+\"^exprToString(expr2)^\"/2)\"\n| Times(expr, expr2) -> exprToString(expr)^\"*\"^exprToString(expr2)\n| Thresh(expr, expr2, expr3, expr4) -> \"(\"^exprToString(expr)^\"<\"^exprToString(expr2)^\"?\"^exprToString(expr3)^\":\"^exprToString(expr4)^\")\"", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(expr) -> \"sin(pi*\"^exprToString(expr)^\")\"\n| Cosine(expr) -> \"cos(pi\"^ exprToString(expr)^\")\"\n| Average(expr, expr2) -> \"((\"^exprToString(expr)^\"+\"^exprToString(expr2)^\"/2)\"\n| Times(expr, expr2) -> exprToString(expr)^\"*\"^exprToString(expr2)\n| Thresh(expr, expr2, expr3, expr4) -> \"(\"^exprToString(expr)^\"<\"^exprToString(expr2)^\"?\"^exprToString(expr3)^\":\"^exprToString(expr4)\")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(expr) -> \"sin(pi*\"^exprToString(expr)^\")\"\n| Cosine(expr) -> \"cos(pi\"^ exprToString(expr)^\")\"\n| Average(expr, expr2) -> \"((\"^exprToString(expr)^\"+\"^exprToString(expr2)^\"/2)\"\n| Times(expr, expr2) -> exprToString(expr)^\"*\"^exprToString(expr2)\n| Thresh(expr, expr2, expr3, expr4) -> \"(\"^exprToString(expr)^\"<\"^exprToString(expr2)^\"?\"^exprToString(expr3)^\":\"^exprToString(expr4)\")\""}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(eval(e, x, y ))\n| Cosine(e)  -> cos(eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) +. (eval(e2, x ,y) /. 2.0))\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(eval(e, x, y ))\n| Cosine(e)  -> cos(eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) ./ 2) + (eval(e2, x ,y) ./ 2))\n| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(eval(e, x, y ))\n| Cosine(e)  -> cos(eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) ./ 2) + (eval(e2, x ,y) ./ 2))\n| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(eval(e, x, y ))\n| Cosine(e)  -> cos(eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) +. (eval(e2, x ,y) /. 2.0))\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(eval(e, x, y ))\n| Cosine(e)  -> cos(eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) /. 2) + (eval(e2, x ,y) /. 2))\n| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(eval(e, x, y ))\n| Cosine(e)  -> cos(eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) /. 2) + (eval(e2, x ,y) /. 2))\n| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(eval(e, x, y ))\n| Cosine(e)  -> cos(eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) +. (eval(e2, x ,y) /. 2.0))\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)", "bad": "et rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(eval(e, x, y ))\n| Cosine(e)  -> cos(eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) + (eval(e2, x ,y) /. 2.0))\n| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)", "annotated": "et rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(eval(e, x, y ))\n| Cosine(e)  -> cos(eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) + (eval(e2, x ,y) /. 2.0))\n| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(eval(e, x, y ))\n| Cosine(e)  -> cos(eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) +. (eval(e2, x ,y) /. 2.0))\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(eval(e, x, y ))\n| Cosine(e)  -> cos(eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) + (eval(e2, x ,y) /. 2.0))\n| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(eval(e, x, y ))\n| Cosine(e)  -> cos(eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) + (eval(e2, x ,y) /. 2.0))\n| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)"}
{"fix": "uildX()                       = VarX", "bad": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "annotated": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))"}
{"fix": "let rec build (rand, depth) = \nif depth = 0 then \nmatch rand(0, 2) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand(2, 7) with \n| 2 -> buildSine(build(rand, depth - 1))\n| 3 -> buildCosine(build(rand, depth - 1))\n| 4 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 6 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))", "bad": "let rec build (rand, depth) = \nlet f = makeRand(rand) in\nif depth = 0 then buildX()\nelse\nmatch f with \n| 2 -> buildSine(build(rand, depth - 1))\n| 3 -> buildCosine(build(rand, depth - 1))\n| 4 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 6 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet f = makeRand(rand) in\nif depth = 0 then buildX()\nelse\nmatch f with \n| 2 -> buildSine(build(rand, depth - 1))\n| 3 -> buildCosine(build(rand, depth - 1))\n| 4 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 6 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))"}
{"fix": "let rec build (rand, depth) = \nif depth = 0 then \nmatch rand(0, 2) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand(2, 7) with \n| 2 -> buildSine(build(rand, depth - 1))\n| 3 -> buildCosine(build(rand, depth - 1))\n| 4 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 6 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))", "bad": "let rec build (rand, depth) = \nif depth = 0 then \nmatch rand(0, 2)\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand(2, 7) with \n| 2 -> buildSine(build(rand, depth - 1))\n| 3 -> buildCosine(build(rand, depth - 1))\n| 4 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 6 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0 then \nmatch rand(0, 2)\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand(2, 7) with \n| 2 -> buildSine(build(rand, depth - 1))\n| 3 -> buildCosine(build(rand, depth - 1))\n| 4 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 6 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))"}
{"fix": "let fixpoint (f,b) = wwhile (f, b)", "bad": "let fixpoint (f,b) = let xx = f(b) in (xx, xx = b) in wwhile (f, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let xx = f(b) in (xx, xx  ->  b) in wwhile (f, b)"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with  \n| [] -> d\n| h::t -> \nlet (p , q) = h in\nif k = p then q\nelse assoc (d, k, t)", "bad": "let fixpoint (f,b) = wwhile ( wwhile(f, b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( wwhile(f, b), b)"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with  \n| [] -> d\n| h::t -> \nlet (p , q) = h in\nif k = p then q\nelse assoc (d, k, t)", "bad": "let fixpoint (f,b) = wwhile (if f b = b then b else f b , b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (if f b  ->  b then b else f b , b)"}
{"fix": "let fixpoint (f,b) = \nlet (b', c') = f b in\nif b = b' then b else wwhile (f , b)", "bad": "let fixpoint (f,b) = \nlet b' = f b in\nif b = b' then b else wwhile (f , b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet b' = f b in\nif b = b' then b else wwhile (f , b)"}
{"fix": "let fixpoint (f,b) = \nlet f x = let xx = f b in (xx, xx <> b) in wwhile (f, b)", "bad": "let fixpoint (f,b) = \nlet b' = f b in\nif b = b' then b else wwhile (f , b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet b' = f b in\nif b = b' then b else wwhile (f , b)"}
{"fix": "let fixpoint (f,b) = \nlet f x = let xx = f b in (xx, xx <> b) in wwhile (f, b)", "bad": "let fixpoint (f,b) = \nlet b' = f b in\nif b = b' then b else f b in wwhile (f , b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet b' = f b in\nif b = b' then b else f b in wwhile (f , b)"}
{"fix": "let fixpoint (f,b) = \nlet f x = let xx = f b in (xx, xx <> b) in wwhile (f, b)", "bad": "let fixpoint (f,b) = \nlet b' = f b in\nif b = b' then b else f b in wwhile (f b, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet b' = f b in\nif b = b' then b else f b in wwhile (f b, b)"}
{"fix": "let fixpoint (f,b) = \nlet f x = let xx = f b in (xx, xx <> b) in wwhile (f, b)", "bad": "let fixpoint (f,b) = \nlet f b = b' in\nif b = b' then b else f b in wwhile (f b, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet f b = b' in\nif b = b' then b else f b in wwhile (f b, b)"}
{"fix": "let fixpoint (f,b) = \nlet f x = let xx = f b in (xx, xx <> b) in wwhile (f, b)", "bad": "let fixpoint (f,b) = \nlet f x = let xx = f b in (xx, xx <> b) in wwhile (f b, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet f x = let xx = f b in (xx, xx <> b) in wwhile (f b, b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let fixpoint (f,b) = \nlet f b = let xx = f b in (xx, xx <>  b) in wwhile (f, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet f b = let xx = f b in (xx, xx <>  b) in wwhile (f, b)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let sqsum xs = \nlet f a x = a + x in\nlet base =  0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = (+) x in\nlet base = [] in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = (+) x in\nlet base = [] in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a + x in\nlet base =  0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = (+) x in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = (+) x in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base =  [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base =  _ in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base =  _ in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base =  f in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base =  a' in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base =  a' in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base =  0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base =  fs in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base =  fs in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base =  x a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base =  x a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base =  a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base =  a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fs in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fs in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = _ in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = _ in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (+) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = f g in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = f g in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (+) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fun x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (+) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = fun f in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun f in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (+) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = f base in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = f base in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet rec base = base in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = (base) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = (base) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet rec base = base in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = (_) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = (_) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet rec base = base in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = x a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = x a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a + x in\nlet base =  0 in\nList.fold_left f base xs", "bad": "let stringOfList f l = sepConcat(\"\" List.map(f l))", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat(\"\" List.map(f l))"}
{"fix": "let stringOfList f l = \nlet x = List.map f l  in\nsepConcat \";\" x", "bad": "let stringOfList f l = sepConcat\"\" List.map(f l)", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat\"\" List.map(f l)"}
{"fix": "let stringOfList f l = \nlet x = List.map f l  in\nsepConcat \";\" x", "bad": "let stringOfList f l = sepConcat \"\" List.map(f l)", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat \"\" List.map(f l)"}
{"fix": "let stringOfList f l = \nlet x = List.map f l  in\nsepConcat \";\" x", "bad": "let stringOfList f l = let x = List.map(f l) in\nsepConcat \";\" x", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l = let x  ->  List.map(f l) in\nsepConcat \";\" x"}
{"fix": "let stringOfList f l = \nlet x = List.map f l  in\nsepConcat \";\" x", "bad": "let stringOfList f l = sepConcat \";\" List.map f l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  sepConcat \";\" List.map f l"}
{"fix": "let rec clone x n = \nif n <= 0 then []\nelse n :: (clone x (n-1))", "bad": "let rec clone x n = \nif n <= 0 then []\nelse n :: clone x n-1", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif n <= 0 then []\nelse n :: clone x n-1"}
{"fix": "let rec clone x n = \nif n <= 0 then []\nelse n :: (clone x (n-1))", "bad": "let rec clone x n = \nif n <= 0 then []\nelse n :: (clone x n-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif n <= 0 then []\nelse n :: (clone x n-1)"}
{"fix": "let padZero l1 l2 = \nlet x1 = List.length(l1) in\nlet x2 = List.length(l2) in\nif x1 < x2 then l1 @ clone 0 (x2-x1)\nelse l2 @ clone 0 (x1-x2)", "bad": "let padZero l1 l2 = \nlet x1 = List.length(l1) in\nlet x2 = List.length(l2) in\nif x1 < x2 then x1 @ clone 0 (x2-x1)\nelse x2 @ clone 0 (x1-x2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet x1 = List.length(l1) in\nlet x2 = List.length(l2) in\nif x1 < x2 then x1 @ clone 0 (x2-x1)\nelse x2 @ clone 0 (x1-x2)"}
{"fix": "let sqsum xs = \nlet f a x = a +. x**2.0 in\nlet base =  0.0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a + x**2 in\nlet base =  0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a + x**2 in\nlet base =  0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a +. x**2.0 in\nlet base =  0.0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a + x**2.0 in\nlet base =  0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a + x**2.0 in\nlet base =  0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a +. x**2.0 in\nlet base =  0.0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a +. x**2.0 in\nlet base =  0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a +. x**2.0 in\nlet base =  0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a + int_of_float(float_of_int(x)**2.0) in\nlet base =  0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a + x**2 in\nlet base =  0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a + x**2 in\nlet base =  0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a + int_of_float(float_of_int(x)**2.0) in\nlet base =  0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a + (pow x 2) in\nlet base =  0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a + (pow x 2) in\nlet base =  0 in\nList.fold_left f base xs"}
{"fix": "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "bad": "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[", "annotated": "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];["}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (a1, a2) = a in\nlet h :: _ = a1 in\nlet tens = x1 + x2 + h / 10 in\nlet ones = x1 + x2 + h mod 10 in\n(tens :: a1, ones :: a2)\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch x with\n| h :: t -> a\n(*\nlet (x1, x2) = h in\nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n(tens, ones) :: a *)\n| [] -> a\nin\nlet base = (0 , 0) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =\nmatch x with\n| h :: t -> a\n(*\nlet (x1, x2) = h in\nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n(tens, ones) :: a *)\n| [] -> a\nin\nlet base = (0 , 0) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (a1, a2) = a in\nlet h :: _ = a1 in\nlet tens = x1 + x2 + h / 10 in\nlet ones = x1 + x2 + h mod 10 in\n(tens :: a1, ones :: a2)\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x\n(*\nmatch x with\n| h :: t -> a\n\nlet (x1, x2) = h in\nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n(tens, ones) :: a \n| [] -> a *)\nin\nlet base = (0 , 0) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = x\n(*\nmatch x with\n| h :: t -> a\n\nlet (x1, x2) = h in\nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n(tens, ones) :: a \n| [] -> a *)\nin\nlet base = (0 , 0) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (a1, a2) = a in\nlet h :: _ = a1 in\nlet tens = x1 + x2 + h / 10 in\nlet ones = x1 + x2 + h mod 10 in\n(tens :: a1, ones :: a2)\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n(tens, ones) :: a \nin\nlet base = (0 , 0) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n(tens, ones) :: a \nin\nlet base = (0 , 0) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (a1, a2) = a in\nlet h :: _ = a1 in\nlet tens = x1 + x2 + h / 10 in\nlet ones = x1 + x2 + h mod 10 in\n(tens :: a1, ones :: a2)\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n(tens, ones) :: a \nin\nlet base = (0 , 0) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n(tens, ones) :: a \nin\nlet base = (0 , 0) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (a1, a2) = a in\nlet h :: _ = a1 in\nlet tens = x1 + x2 + h / 10 in\nlet ones = x1 + x2 + h mod 10 in\n(tens :: a1, ones :: a2)\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n(tens, ones) :: a \nin\nlet base = [(0 , 0)] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n(tens, ones) :: a \nin\nlet base = [(0 , 0)] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (a1, a2) = a in\nlet h :: _ = a1 in\nlet tens = x1 + x2 + h / 10 in\nlet ones = x1 + x2 + h mod 10 in\n(tens :: a1, ones :: a2)\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n(tens, ones)\nin\nlet base = (0 , 0) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n(tens, ones)\nin\nlet base = (0 , 0) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (a1, a2) = a in\nlet h :: _ = a1 in\nlet tens = x1 + x2 + h / 10 in\nlet ones = x1 + x2 + h mod 10 in\n(tens :: a1, ones :: a2)\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n(tens, ones) :: a\nin\nlet base = [(0 , 0)] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n(tens, ones) :: a\nin\nlet base = [(0 , 0)] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nmatch carry with\n| h :: t -> \nlet tens = x1 + x2 + h / 10 in\nlet ones = x1 + x2 + h mod 10 in\n(tens :: carry, ones :: res)\n| [] ->\nlet tens = x1 + x2 / 10 in\nlet ones = x1 + x2 mod 10 in\n(tens :: carry, ones :: res)\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nmatch carry with\n| h :: t -> \nlet tens = x1 + x2 + h / 10 in\nlet ones = x1 + x2 + h mod 10 in\n(tens :: carry, ones :: res)\n| [] ->\nlet tens = x1 + x2 / 10 in\nlet ones = x1 + x2 mod 10 in\n(carry :: a1, ones :: res)\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nmatch carry with\n| h :: t -> \nlet tens = x1 + x2 + h / 10 in\nlet ones = x1 + x2 + h mod 10 in\n(tens :: carry, ones :: res)\n| [] ->\nlet tens = x1 + x2 / 10 in\nlet ones = x1 + x2 mod 10 in\n(carry :: a1, ones :: res)\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nif carry <> [] then\nlet ch :: _ = carry in\nlet tens = (x1 + x2 + ch) / 10 in\nlet ones = (x1 + x2 + ch) mod 10 in\n([tens] , tens :: ones :: res)\nelse\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: res)\n\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nmatch x2 with\n| h :: t ->\nlet (carry, res) = a in\nlet tens = (x1 + x2 + h) / 10 in\nlet ones = (x1 + x2 + h) mod 10 in\n(tens :: carry, ones :: res)\n| [] ->\nlet (carry, res) = a in\nlet tens = (x1 + x2 + h) / 10 in\nlet ones = (x1 + x2 + h) mod 10 in\n(tens :: ones :: res)\n\nin\nlet base = ([0], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nmatch x2 with\n| h :: t ->\nlet (carry, res) = a in\nlet tens = (x1 + x2 + h) / 10 in\nlet ones = (x1 + x2 + h) mod 10 in\n(tens :: carry, ones :: res)\n| [] ->\nlet (carry, res) = a in\nlet tens = (x1 + x2 + h) / 10 in\nlet ones = (x1 + x2 + h) mod 10 in\n(tens :: ones :: res)\n\nin\nlet base = ([0], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nif carry <> [] then\nlet ch :: _ = carry in\nlet tens = (x1 + x2 + ch) / 10 in\nlet ones = (x1 + x2 + ch) mod 10 in\n([tens] , tens :: ones :: res)\nelse\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: res)\n\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nmatch x with\n| h :: t ->\nlet (carry, res) = a in\nlet tens = (x1 + x2 + h) / 10 in\nlet ones = (x1 + x2 + h) mod 10 in\n(tens :: carry, ones :: res)\n| [] ->\nlet (carry, res) = a in\nlet tens = (x1 + x2 + h) / 10 in\nlet ones = (x1 + x2 + h) mod 10 in\n(tens :: ones :: res)\n\nin\nlet base = ([0], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nmatch x with\n| h :: t ->\nlet (carry, res) = a in\nlet tens = (x1 + x2 + h) / 10 in\nlet ones = (x1 + x2 + h) mod 10 in\n(tens :: carry, ones :: res)\n| [] ->\nlet (carry, res) = a in\nlet tens = (x1 + x2 + h) / 10 in\nlet ones = (x1 + x2 + h) mod 10 in\n(tens :: ones :: res)\n\nin\nlet base = ([0], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nif carry <> [] then\nlet ch :: _ = carry in\nlet tens = (x1 + x2 + ch) / 10 in\nlet ones = (x1 + x2 + ch) mod 10 in\n([tens] , tens :: ones :: res)\nelse\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: res)\n\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| h :: t -> \nlet (x1, x2) = x in\nlet (carry, res) = a in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\nif t = [] then (0 ,tens :: ones :: res)\nelse (tens :: carry, ones :: res)\n| [] -> a\n\n\nin\nlet base = ([0], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| h :: t -> \nlet (x1, x2) = x in\nlet (carry, res) = a in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\nif t = [] then (0 ,tens :: ones :: res)\nelse (tens :: carry, ones :: res)\n| [] -> a\n\n\nin\nlet base = ([0], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nif carry <> [] then\nlet ch :: _ = carry in\nlet tens = (x1 + x2 + ch) / 10 in\nlet ones = (x1 + x2 + ch) mod 10 in\n([tens] , tens :: ones :: res)\nelse\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: res)\n\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nlet tens = x1 + x2 + carry / 10 in\nlet ones = x1 + x2 + carry mod 10 in\n(tens :: ones :: res)\nin\nlet base = ([0], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nlet tens = x1 + x2 + carry / 10 in\nlet ones = x1 + x2 + carry mod 10 in\n(tens :: ones :: res)\nin\nlet base = ([0], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nif carry <> [] then\nlet ch :: _ = carry in\nlet tens = (x1 + x2 + ch) / 10 in\nlet ones = (x1 + x2 + ch) mod 10 in\n([tens] , tens :: ones :: res)\nelse\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: res)\n\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nlet tens = x1 + x2 + carry / 10 in\nlet ones = x1 + x2 + carry mod 10 in\n(tens ,tens :: ones :: res)\nin\nlet base = ([0], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nlet tens = x1 + x2 + carry / 10 in\nlet ones = x1 + x2 + carry mod 10 in\n(tens ,tens :: ones :: res)\nin\nlet base = ([0], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nif carry <> [] then\nlet ch :: _ = carry in\nlet tens = (x1 + x2 + ch) / 10 in\nlet ones = (x1 + x2 + ch) mod 10 in\n([tens] , tens :: ones :: res)\nelse\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: res)\n\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nlet tens = x1 + x2 + carry / 10 in\nlet ones = x1 + x2 + carry mod 10 in\n(tens , tens :: ones :: res)\nin\nlet base = ([0], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nlet tens = x1 + x2 + carry / 10 in\nlet ones = x1 + x2 + carry mod 10 in\n(tens , tens :: ones :: res)\nin\nlet base = ([0], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nif carry <> [] then\nlet ch :: _ = carry in\nlet tens = (x1 + x2 + ch) / 10 in\nlet ones = (x1 + x2 + ch) mod 10 in\n([tens] , tens :: ones :: res)\nelse\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: res)\n\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nlet tens = x1 + x2 + carry / 10 in\nlet ones = x1 + x2 + carry mod 10 in\n(tens , tens :: ones :: res)\nin\nlet base = ([0], [0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nlet tens = x1 + x2 + carry / 10 in\nlet ones = x1 + x2 + carry mod 10 in\n(tens , tens :: ones :: res)\nin\nlet base = ([0], [0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nif carry <> [] then\nlet ch :: _ = carry in\nlet tens = (x1 + x2 + ch) / 10 in\nlet ones = (x1 + x2 + ch) mod 10 in\n([tens] , tens :: ones :: res)\nelse\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: res)\n\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nlet tens = x1 + x2 + carry / 10 in\nlet ones = x1 + x2 + carry mod 10 in\n([tens] , tens :: ones :: res)\nin\nlet base = ([0], [0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nlet tens = x1 + x2 + carry / 10 in\nlet ones = x1 + x2 + carry mod 10 in\n([tens] , tens :: ones :: res)\nin\nlet base = ([0], [0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nif carry <> [] then\nlet ch :: _ = carry in\nlet tens = (x1 + x2 + ch) / 10 in\nlet ones = (x1 + x2 + ch) mod 10 in\n([tens] , tens :: ones :: res)\nelse\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: res)\n\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nif carry <> [] then\nlet tens = (x1 + x2 + carry) / 10 in\nlet ones = (x1 + x2 + carry) mod 10 in\n([tens] , tens :: ones :: res)\nelse\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: res)\n\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nif carry <> [] then\nlet tens = (x1 + x2 + carry) / 10 in\nlet ones = (x1 + x2 + carry) mod 10 in\n([tens] , tens :: ones :: res)\nelse\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: res)\n\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nif res <> [] then\nlet lastTens :: rest = res in\nif carry <> [] then\nlet ch :: _ = carry in\nlet tens = (x1 + x2 + ch) / 10 in\nlet ones = (x1 + x2 + ch) mod 10 in\n([tens] , tens :: ones :: rest)\nelse\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: rest)\n\nelse \nif carry <> [] then\nlet ch :: _ = carry in\nlet tens = (x1 + x2 + ch) / 10 in\nlet ones = (x1 + x2 + ch) mod 10 in\n([tens] , tens :: ones :: res)\nelse\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: res)\n\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nif res <> [] then\nlet lastTens :: rest = res in\nelse let rest = res in\nif carry <> [] then\nlet ch :: _ = carry in\nlet tens = (x1 + x2 + ch) / 10 in\nlet ones = (x1 + x2 + ch) mod 10 in\n([tens] , tens :: ones :: rest)\nelse\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: rest)\n\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nif res <> [] then\nlet lastTens :: rest = res in\nelse let rest = res in\nif carry <> [] then\nlet ch :: _ = carry in\nlet tens = (x1 + x2 + ch) / 10 in\nlet ones = (x1 + x2 + ch) mod 10 in\n([tens] , tens :: ones :: rest)\nelse\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: rest)\n\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let rec mulByDigit i l = \nif i <> 0 then mulByDigit (i-1) (bigAdd l l)\nelse l", "bad": "let rec mulByDigit i l = \nif i <> 0 then mulByDigit (i-1) bigAdd l l\nelse l", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nif i <> 0 then mulByDigit (i-1) bigAdd l l\nelse l"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nmatch res with\n| h :: t -> \n(match carry with\n| h1 :: t1 ->\nlet tens = (x1 + x2 + h1) / 10 in\nlet ones = (x1 + x2 + h1) mod 10 in\n([tens], tens :: ones :: t)\n| [] ->\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: t)\n)\n| [] -> \n(match carry with\n| h1 :: t1 ->\nlet tens = (x1 + x2 + h1) / 10 in\nlet ones = (x1 + x2 + h1) mod 10 in\n([tens], tens :: ones :: res)\n| [] ->\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: res)\n)\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nmatch res with\n| h :: t -> \n(match carry with\n| h1 :: t1 ->\nlet tens = (x1 + x2 + h1) / 10 in\nlet ones = (x1 + x2 + h1) mod 10 in\n([tens], tens :: ones :: t)\n| [] ->\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: t)\n)\n| [] -> \n(match carry with\n| h1 :: t1 ->\nlet tens = (x1 + x2 + h1) / 10 in\nlet ones = (x1 + x2 + h1) mod 10 in\n([tens], tens :: ones :: res)\n| [] ->\nlet tens = (x1 + x2 + h1) / 10 in\nlet ones = (x1 + x2 + h1) mod 10 in\n([tens], tens :: ones :: res)\n)\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (carry, res) = a in\nmatch res with\n| h :: t -> \n(match carry with\n| h1 :: t1 ->\nlet tens = (x1 + x2 + h1) / 10 in\nlet ones = (x1 + x2 + h1) mod 10 in\n([tens], tens :: ones :: t)\n| [] ->\nlet tens = (x1 + x2) / 10 in\nlet ones = (x1 + x2) mod 10 in\n([tens], tens :: ones :: t)\n)\n| [] -> \n(match carry with\n| h1 :: t1 ->\nlet tens = (x1 + x2 + h1) / 10 in\nlet ones = (x1 + x2 + h1) mod 10 in\n([tens], tens :: ones :: res)\n| [] ->\nlet tens = (x1 + x2 + h1) / 10 in\nlet ones = (x1 + x2 + h1) mod 10 in\n([tens], tens :: ones :: res)\n)\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let rec mulByDigit i l = helper [0] i l", "bad": "let rec mulByDigit i l = helper 0 i l", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  helper 0 i l"}
{"fix": "let fixpoint (f,b) = \nlet h x = (f x, if f x = x then false else true) in\nwwhile (h ,b)", "bad": "let fixpoint (f,b) = \nlet h x = (f x, if f x = x then false else true)\nwwhile (h ,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet h x = (f x, if f x = x then false else true)\nwwhile (h ,b)"}
{"fix": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin\" ^ exprToString a\n| Cosine a -> \"cos\" ^ exprToString a\n| Average (a,b) -> exprToString a ^ \"/\" ^ exprToString b\n| Times (a,b) -> exprToString a ^ \"*\" ^ exprToString b\n| Thresh (a,b,c,d) -> exprToString a ^ \"<\" ^ exprToString b ^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d", "bad": "let rec exprToString e = \nstring x = e", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nstring x = e"}
{"fix": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin\" ^ exprToString a\n| Cosine a -> \"cos\" ^ exprToString a\n| Average (a,b) -> exprToString a ^ \"/\" ^ exprToString b\n| Times (a,b) -> exprToString a ^ \"*\" ^ exprToString b\n| Thresh (a,b,c,d) -> exprToString a ^ \"<\" ^ exprToString b ^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d", "bad": "let rec exprToString e = \nString x = e", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nString x = e"}
{"fix": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin\" ^ exprToString a\n| Cosine a -> \"cos\" ^ exprToString a\n| Average (a,b) -> exprToString a ^ \"/\" ^ exprToString b\n| Times (a,b) -> exprToString a ^ \"*\" ^ exprToString b\n| Thresh (a,b,c,d) -> exprToString a ^ \"<\" ^ exprToString b ^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d", "bad": "let rec exprToString e = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> \"sin\" ^ exprToString a\n| Cosine a -> \"cos\" ^ exprToString a\n| Average (a,b) -> exprToString a ^ \"/\" ^ exprToString b\n| Times (a,b) -> exprToString a ^ \"*\" ^ exprToString b\n| Thresh (a,b,c,d) -> exprToString a ^ \"<\" ^ exprToString b ^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> \"sin\" ^ exprToString a\n| Cosine a -> \"cos\" ^ exprToString a\n| Average (a,b) -> exprToString a ^ \"/\" ^ exprToString b\n| Times (a,b) -> exprToString a ^ \"*\" ^ exprToString b\n| Thresh (a,b,c,d) -> exprToString a ^ \"<\" ^ exprToString b ^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d"}
{"fix": "let rec eval (e,x,y) = \nmatch e with\n|VarX -> x\n|VarY -> y\n|Sine a -> sin (pi *. eval(a,x,y))\n|Cosine a -> cos (pi *. eval(a,x,y))\n|Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.\n|Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n|Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)", "bad": "let rec eval (e,x,y) = \nmatch e with\n|VarX -> x\n|VarY -> y\n|Sine a -> sin (pi *. eval(a,x,y))\n|Cosine a -> cos (pi *. eval(a,x,y))\n|Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2\n|Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n|Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with\n|VarX -> x\n|VarY -> y\n|Sine a -> sin (pi *. eval(a,x,y))\n|Cosine a -> cos (pi *. eval(a,x,y))\n|Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2\n|Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n|Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)"}
{"fix": "let rec build (rand, depth) = \nif depth = 0 then \nlet result = rand 0 1 in\nif result = 0 then \nbuildX() else\nbuildY()\nelse\nlet result = rand 0 6 in\nmatch result with\n|0 -> buildX()\n|1 -> buildY()\n|2 -> buildSine(build(rand,depth-1))\n|3 -> buildCosine(build(rand,depth-1))\n|4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n|_ -> buildX()", "bad": "let rec build (rand, depth) = \nif depth = 0 then \nlet result = rand 0 1 in\nif result = 0 then \nbuildX() else\nbuildY()\nelse\nlet result = rand 0 6 in\nmatch result with\n|0 -> buildX()\n|1 -> buildY()\n|2 -> buildSine(build(rand,depth-1))\n|3 -> buildCosine(build(rand,depth-1))\n|4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n|_ -> build()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0 then \nlet result = rand 0 1 in\nif result = 0 then \nbuildX() else\nbuildY()\nelse\nlet result = rand 0 6 in\nmatch result with\n|0 -> buildX()\n|1 -> buildY()\n|2 -> buildSine(build(rand,depth-1))\n|3 -> buildCosine(build(rand,depth-1))\n|4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n|_ -> build()"}
{"fix": "let rec eval (e,x,y) = \nmatch e with\n|VarX -> x\n|VarY -> y\n|Sine a -> sin (pi *. eval(a,x,y))\n|Cosine a -> cos (pi *. eval(a,x,y))\n|Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.\n|Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n|Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)\n|Inverse a -> let result  = eval(a,x,y) in\nif result = 0. then 0.\nelse\n1. /. result\n|Max (a,b) -> let aResult = eval(a,x,y) in\nlet bResult = eval(b,x,y) in\nif aResult > bResult then aResult\nelse bResult\n|Range (a,b,c) -> let aResult = eval(a,x,y) in\nlet bResult = eval(b,x,y) in\nlet cResult = eval(c,x,y) in\nif aResult < bResult then bResult else\nif aResult < cResult then cResult else\naResult", "bad": "let rec eval (e,x,y) = \nmatch e with\n|VarX -> x\n|VarY -> y\n|Sine a -> sin (pi *. eval(a,x,y))\n|Cosine a -> cos (pi *. eval(a,x,y))\n|Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.\n|Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n|Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)\n|Inverse a -> let result  = eval(a,x,y) in\nif result = 0. then 0.\nelse\n1 /. result\n|Max (a,b) -> let aResult = eval(a,x,y) in\nlet bResult = eval(b,x,y) in\nif aResult > bResult then aResult\nelse bResult\n|Range (a,b,c) -> let aResult = eval(a,x,y) in\nlet bResult = eval(b,x,y) in\nlet cResult = eval(c,x,y) in\nif aResult < bResult then bResult else\nif aResult < cResult then cResult else\naResult", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with\n|VarX -> x\n|VarY -> y\n|Sine a -> sin (pi *. eval(a,x,y))\n|Cosine a -> cos (pi *. eval(a,x,y))\n|Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.\n|Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n|Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)\n|Inverse a -> let result  = eval(a,x,y) in\nif result = 0. then 0.\nelse\n1 /. result\n|Max (a,b) -> let aResult = eval(a,x,y) in\nlet bResult = eval(b,x,y) in\nif aResult > bResult then aResult\nelse bResult\n|Range (a,b,c) -> let aResult = eval(a,x,y) in\nlet bResult = eval(b,x,y) in\nlet cResult = eval(c,x,y) in\nif aResult < bResult then bResult else\nif aResult < cResult then cResult else\naResult"}
{"fix": "let padZero l1 l2 = \nlet num1 = List.length l2 - List.length l1 in\nlet num2 = List.length l1 - List.length l2 in\n(clone 0 num1 @l1,clone 0 num2 @ l2)", "bad": "let padZero l1 l2 = \nlet num1 = List.length l2 - List.length l1 in\nlet num2 = List.length l1 - list.length l2 in\n(clone 0 num1 @l1,clone 0 num2 @ l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet num1 = List.length l2 - List.length l1 in\nlet num2 = List.length l1 - list.length l2 in\n(clone 0 num1 @l1,clone 0 num2 @ l2)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n|(z,y) -> let sum = z + y in\nif sum > 10 then let result = ((sum mod 10)::a) in\n1::result else\nsum::a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n|(z,y) -> let sum = z + y in\nif sum > 10 then let result = a @ sum mod 10 in\nresult @ 1 else\na @ result in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n|(z,y) -> let sum = z + y in\nif sum > 10 then let result = a @ sum mod 10 in\nresult @ 1 else\na @ result in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n|(z,y) -> let sum = z + y in\nif sum > 10 then let result = ((sum mod 10)::a) in\n1::result else\nsum::a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n|(z,y) -> let sum = z + y in\nif sum > 10 then let result = a @ (sum mod 10) in\nresult @ 1 else\na @ result in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n|(z,y) -> let sum = z + y in\nif sum > 10 then let result = a @ (sum mod 10) in\nresult @ 1 else\na @ result in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n|(z,y) -> let sum = z + y in\nif sum > 10 then let result = ((sum mod 10)::a) in\n1::result else\nsum::a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n|(z,y) -> let sum = z + y in\nif sum > 10 then let result = (a @ (sum mod 10)) in\nresult @ 1 else\na @ result in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n|(z,y) -> let sum = z + y in\nif sum > 10 then let result = (a @ (sum mod 10)) in\nresult @ 1 else\na @ result in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n|(z,y) -> let sum = z + y in\nif sum > 10 then let result = ((sum mod 10)::a) in\n1::result else\nsum::a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n|(z,y) -> let sum = z + y in\nif sum > 10 then let result = ((sum mod 10)::a) in\n1::result else\nsum::a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n|(z,y) -> let sum = z + y in\nif sum > 10 then let result = ((sum mod 10)::a) in\n1::result else\nsum::a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\nmatch x with\n|(z,y) -> (match a with\n|[] -> let sum = z + y in\nintlist sum\n|h::t -> let sum = h + z + y in\n(intlist sum) @ t) in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rec intlist x =\nif x < 10 then x \nelse (intlist (x / 10))::[x mod 10] in\nmatch x with\n|(z,y) -> (match a with\n|h -> let sum = h + z + y in\nintlist sum\n|h::t -> let sum = h + z + y in\n(intlist sum)::t) in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet rec intlist x =\nif x < 10 then x \nelse (intlist (x / 10))::[x mod 10] in\nmatch x with\n|(z,y) -> (match a with\n|h -> let sum = h + z + y in\nintlist sum\n|h::t -> let sum = h + z + y in\n(intlist sum)::t) in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\nmatch x with\n|(z,y) -> (match a with\n|[] -> let sum = z + y in\nintlist sum\n|h::t -> let sum = h + z + y in\n(intlist sum) @ t) in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10))::[x mod 10] in\nmatch x with\n|(z,y) -> (match a with\n|h -> let sum = h + z + y in\nintlist sum\n|h::t -> let sum = h + z + y in\n(intlist sum)::t) in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10))::[x mod 10] in\nmatch x with\n|(z,y) -> (match a with\n|h -> let sum = h + z + y in\nintlist sum\n|h::t -> let sum = h + z + y in\n(intlist sum)::t) in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\nmatch x with\n|(z,y) -> (match a with\n|[] -> let sum = z + y in\nintlist sum\n|h::t -> let sum = h + z + y in\n(intlist sum) @ t) in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\nmatch x with\n|(z,y) -> (match a with\n|h -> let sum = h + z + y in\nintlist sum\n|h::t -> let sum = h + z + y in\n(intlist sum) @ t) in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\nmatch x with\n|(z,y) -> (match a with\n|h -> let sum = h + z + y in\nintlist sum\n|h::t -> let sum = h + z + y in\n(intlist sum) @ t) in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\nmatch x with\n|(z,y) -> (match a with\n|[] -> let sum = z + y in\nintlist sum\n|h::t -> let sum = h + z + y in\nresult = (intlist sum) @ t in\nif sum < 10 then 0::result else result", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\nmatch x with\n|(z,y) -> (match a with\n|[] -> let sum = z + y in\nintlist sum\n|h::t -> let sum = h + z + y in\nresult = (intlist sum) @ t) in\nif sum < 10 then 0::result else result in \n\nlet base = [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\nmatch x with\n|(z,y) -> (match a with\n|[] -> let sum = z + y in\nintlist sum\n|h::t -> let sum = h + z + y in\nresult = (intlist sum) @ t) in\nif sum < 10 then 0::result else result in \n\nlet base = [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let rec mulByDigit i l =\nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\n\nmatch l with \n|[] -> 0\n|h::t -> let zeroList = (match t with \n|[] -> []\n|h'::t' -> let (_,zeroList') = padZero(t',[]) in zeroList') in\nlet mult = intlist h*i in\nlet res = mult @ zeroList in\nbigAdd res (mulByDigit t)", "bad": "let rec mulByDigit i l =\nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\n\nmatch l with \n|[] -> 0\n|h::t -> (match t with \n|[] -> let zeroList = []\n|h'::t' -> let (_,zeroList) = padZero(t',[])) in\nlet mult = intlist h*i in\nlet res = mult @ zeroList in\nbigAdd res (mulByDigit t)", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  -> \nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\n\nmatch l with \n|[] -> 0\n|h::t -> (match t with \n|[] -> let zeroList = []\n|h'::t' -> let (_,zeroList) = padZero(t',[])) in\nlet mult = intlist h*i in\nlet res = mult @ zeroList in\nbigAdd res (mulByDigit t)"}
{"fix": "let rec mulByDigit i l =\nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\n\nmatch l with \n|[] -> 0\n|h::t -> let zeroList = (match t with \n|[] -> []\n|h'::t' -> (match padZero(t' [0]) with \n|(a,b) -> b)) in\nlet mult = intlist h*i in\nlet res = mult @ zeroList in\nbigAdd res (mulByDigit t)", "bad": "let rec mulByDigit i l =\nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\n\nmatch l with \n|[] -> 0\n|h::t -> let zeroList = (match t with \n|[] -> []\n|h'::t' -> (match padZero((t',[0])) with \n|(a,b) -> b)) in\nlet mult = intlist h*i in\nlet res = mult @ zeroList in\nbigAdd res (mulByDigit t)", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  -> \nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\n\nmatch l with \n|[] -> 0\n|h::t -> let zeroList = (match t with \n|[] -> []\n|h'::t' -> (match padZero((t',[0])) with \n|(a,b) -> b)) in\nlet mult = intlist h*i in\nlet res = mult @ zeroList in\nbigAdd res (mulByDigit t)"}
{"fix": "let rec digitsOfInt n = \nmatch n > 0 with\n| true  -> digOfIntHelper n::[n mod 10] \n| false -> []", "bad": "let rec digitsOfInt n = \nmatch n > 0 with\n| true  -> digOfIntHelper::[n mod 10] \n| false -> []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nmatch n > 0 with\n| true  -> digOfIntHelper::[n mod 10] \n| false -> []"}
{"fix": "let rec digitsOfInt n = \nmatch n > 0 with\n| true  -> digOfIntHelper n::[n mod 10] \n| false -> []", "bad": "let rec digitsOfInt n = \nmatch n > 0 with\n| true  -> digOfIntHelper::[n % 10] \n| false -> []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nmatch n > 0 with\n| true  -> digOfIntHelper::[n % 10] \n| false -> []"}
{"fix": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "bad": "let rec digitsOfInt n = \nmatch n with\n| 0    -> []\n| [0]   -> []\n| 1     -> []\n| true  -> digOfIntHelper n::[]::[n mod 10] \n| false -> []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nmatch n with\n| 0    -> []\n| [0]   -> []\n| 1     -> []\n| true  -> digOfIntHelper n::[]::[n mod 10] \n| false -> []"}
{"fix": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "bad": "let rec digitsOfInt n = \nmatch n > 0 with\n| true  -> digOfIntHelper n::[]::[n mod 10] \n| false -> []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nmatch n > 0 with\n| true  -> digOfIntHelper n::[]::[n mod 10] \n| false -> []"}
{"fix": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "bad": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt n\n| true  -> digitsOfInt n mod 10", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt n\n| true  -> digitsOfInt n mod 10"}
{"fix": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: []\n| true  -> (n / 10) :: digitsOfInt (n mod 10)", "bad": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: []\n| true  -> digitsOfInt (n / 10) :: digitsOfInt (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: []\n| true  -> digitsOfInt (n / 10) :: digitsOfInt (n mod 10)"}
{"fix": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: []\n| true  -> n / 10 :: digitsOfInt (n / 10)", "bad": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: []\n| true  -> digitsOfInt (n / 10) ::  (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: []\n| true  -> digitsOfInt (n / 10) ::  (n mod 10)"}
{"fix": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> 1 :: 1", "bad": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> 1", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> 1"}
{"fix": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 )", "bad": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> 1 :: 2", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> 1 :: 2"}
{"fix": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> reverseHelper t h::revd \nin\nreverseHelper [] l", "bad": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> reverseHelper t h::revd \nin\nreverseHelper [] l", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> reverseHelper t h::revd \nin\nreverseHelper [] l"}
{"fix": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "bad": "let listReverse l =\nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> reverseHelper t h::revd \nin\nreverseHelper [] l", "annotated": "let listReverse : 'a list -> 'a list = fun  l  -> \nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> reverseHelper t h::revd \nin\nreverseHelper [] l"}
{"fix": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "bad": "let listReverse l =\nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> reverseHelper t (h::revd )\nin\nreverseHelper [] l", "annotated": "let listReverse : 'a list -> 'a list = fun  l  -> \nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> reverseHelper t (h::revd )\nin\nreverseHelper [] l"}
{"fix": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "bad": "let listReverse l =\nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nreverseHelper [] l", "annotated": "let listReverse : 'a list -> 'a list = fun  l  -> \nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nreverseHelper [] l"}
{"fix": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "bad": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nreverseHelper [] l", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nreverseHelper [] l"}
{"fix": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "bad": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nlistReverse[] l", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nlistReverse[] l"}
{"fix": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "bad": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nlistReverse [] l", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nlistReverse [] l"}
{"fix": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "bad": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nlistReverse l []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nlistReverse l []"}
{"fix": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "bad": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nlistReverse [] l", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nlistReverse [] l"}
{"fix": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "bad": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nreverseHelper []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nreverseHelper []"}
{"fix": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "bad": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nreverseHelper l", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nreverseHelper l"}
{"fix": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "bad": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::revd )\nin\nin\n\nlistReverse l []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::revd )\nin\nin\n\nlistReverse l []"}
{"fix": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "bad": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::revd )\nin\nlistReverse l []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::revd )\nin\nlistReverse l []"}
{"fix": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "bad": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::revd )\nin\nlistReverse [] l", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::revd )\nin\nlistReverse [] l"}
{"fix": "let rec listReverse l =\nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "bad": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::revd )\nin\nreverseHelper [] l", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::revd )\nin\nreverseHelper [] l"}
{"fix": "let rec listReverse l =\nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "bad": "let rec listReverse l =\nlet rec reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r )\nin\nlistReverse l []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet rec reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r )\nin\nlistReverse l []"}
{"fix": "let rec listReverse l =\nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "bad": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r )\nin\nlistReverse l []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r )\nin\nlistReverse l []"}
{"fix": "let rec listReverse l =\nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "bad": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r )", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r )"}
{"fix": "let rec listReverse l =\nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "bad": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r )", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r )"}
{"fix": "let rec listReverse l =\nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "bad": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r ) \nin\nlistReverse l []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r ) \nin\nlistReverse l []"}
{"fix": "let rec listReverse l =\nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "bad": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r ) \nin\nlistReverse [] []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r ) \nin\nlistReverse [] []"}
{"fix": "let rec listReverse l =\nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "bad": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nlistReverse [] []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nlistReverse [] []"}
{"fix": "let rec listReverse l =\nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "bad": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper l []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper l []"}
{"fix": "let rec listReverse l =\nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "bad": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []"}
{"fix": "let rec listReverse l =\nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "bad": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nr", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nr"}
{"fix": "let rec listReverse l =\nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "bad": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\n\n\nlet _ = listReverse [1; 2; 3; 4]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\n\n\nlet _ = listReverse [1; 2; 3; 4]"}
{"fix": "let rec listReverse l =\nlet rec reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> reverseHelper t ( h::r ) \nin\nreverseHelper []", "bad": "let rec listReverse l =\nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> reverseHelper t ( h::r ) \nin\nreverseHelper []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> reverseHelper t ( h::r ) \nin\nreverseHelper []"}
{"fix": "let rec digOfInt = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 )", "bad": "let rec digitsOfInt n = \nlet digOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 ) \nin\nlistReverse n", "annotated": "let rec digitsOfInt n = \nlet digOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 ) \nin\nlistReverse n"}
{"fix": "let rec digOfInt = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 )", "bad": "let rec digitsOfInt n = \nlet digOfInt n r = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 ) \nin\nlistReverse n r", "annotated": "let rec digitsOfInt n = \nlet digOfInt n r = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 ) \nin\nlistReverse n r"}
{"fix": "let rec digOfInt = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 )", "bad": "let rec digitsOfInt n = \nlet digOfInt n r = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 ) \nin\nlistReverse n r", "annotated": "let rec digitsOfInt n = \nlet digOfInt n r = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 ) \nin\nlistReverse n r"}
{"fix": "let rec digOfInt = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 )", "bad": "let rec digitsOfInt n = \nlet digOfInt n r = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 ) \nin\nlistReverse n", "annotated": "let rec digitsOfInt n = \nlet digOfInt n r = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 ) \nin\nlistReverse n"}
{"fix": "let rec digOfInt = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 )", "bad": "let rec digitsOfInt n = \nlet digOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 ) \nin\nlistReverse n", "annotated": "let rec digitsOfInt n = \nlet digOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 ) \nin\nlistReverse n"}
{"fix": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "bad": "let digitsOfInt n =  \nlet rec digOfIntHelper n l = \nif n > 0 \nthen (\nmatch n > 9 with\n| false -> n :: l\n| true  -> digOfIntHelper (n / 10) ((n mod 10)::l))\nelse ( \n[] )\nin\ndigOfIntHelper n []", "annotated": "let digitsOfInt : int -> int list = fun  n  ->   \nlet rec digOfIntHelper n l = \nif n > 0 \nthen (\nmatch n > 9 with\n| false -> n :: l\n| true  -> digOfIntHelper (n / 10) ((n mod 10)::l))\nelse ( \n[] )\nin\ndigOfIntHelper n []"}
{"fix": "let rec palindrome w = \nmatch w with\n| []    -> \n(match listReverse(w) with\n| []  -> true\n| _   -> false)\n| h::t  ->\n(match listReverse(w) with\n| []      -> true\n| h2::t2  -> if (h2 = h)\nthen (\npalindrome t )\nelse (\nfalse ) )", "bad": "let palindrome w = \nmatch w with\n| []    -> \n(match listReverse(w) with\n| []  -> true\n| _   -> false)\n| h::t  ->\n(match listReverse(w) with\n| []      -> true\n| h2::t2  -> if (h2 = h)\nthen (\npalindrome t )\nelse (\nfalse ) )", "annotated": "let palindrome : string -> bool = fun  w  ->  \nmatch w with\n| []    -> \n(match listReverse(w) with\n| []  -> true\n| _   -> false)\n| h::t  ->\n(match listReverse(w) with\n| []      -> true\n| h2::t2  -> if (h2 = h)\nthen (\npalindrome t )\nelse (\nfalse ) )"}
{"fix": "let rec palindrome w = \nmatch w with\n| []    -> \n(match listReverse(w) with\n| []  -> true\n| _   -> false)\n| h::t  ->\n(match listReverse(w) with\n| []      -> true\n| h2::t2  -> if (h2 = h)\nthen (\npalindrome t )\nelse (\nfalse ) )", "bad": "let rec palindrome w = \nmatch w with\n| []    -> \n(match listReverse(w) with\n| []  -> true\n| _   -> false)\n| h::t  ->\n(match listReverse(w) with\n| []      -> true\n| h2::t2  -> if (h2 = h)\nthen (\npalindrome t )\nelse (\nfalse ) )", "annotated": "let rec palindrome : string -> bool = fun  w  ->  \nmatch w with\n| []    -> \n(match listReverse(w) with\n| []  -> true\n| _   -> false)\n| h::t  ->\n(match listReverse(w) with\n| []      -> true\n| h2::t2  -> if (h2 = h)\nthen (\npalindrome t )\nelse (\nfalse ) )"}
{"fix": "let rec palind w = \nmatch w with\n| []    -> \n(match listReverse(w) with\n| []  -> true\n| _   -> false)\n| h::t  ->\n(match listReverse(w) with\n| []      -> true\n| h2::t2  -> if (h2 = h)\nthen (\npalind t )\nelse (\nfalse ) )", "bad": "let palindrome w = palind (explode w)", "annotated": "let palindrome : string -> bool = fun  w  ->  palind (explode w)"}
{"fix": "let rec palind w = \nmatch w with\n| []    -> \n(match listReverse(w) with\n| []  -> true\n| _   -> false)\n| h::t  ->\n(match listReverse(w) with\n| []      -> true\n| h2::t2  -> if (h2 = h)\nthen (\npalind t )\nelse (\nfalse ) )", "bad": "let rec palind w = \nmatch w with\n| []    -> \n(match listReverse(w) with\n| []  -> true\n| _   -> false)\n| h::t  ->\n(match listReverse(w) with\n| []      -> true\n| h2::t2  -> if (h2 = h)\nthen (\npalind t )\nelse (\nfalse ) )", "annotated": "let rec palind w = \nmatch w with\n| []    -> \n(match listReverse(w) with\n| []  -> true\n| _   -> false)\n| h::t  ->\n(match listReverse(w) with\n| []      -> true\n| h2::t2  -> if (h2 = h)\nthen (\npalind t )\nelse (\nfalse ) )"}
{"fix": "let listReverse l = lReverse (l, [])", "bad": "let listReverse l =\nlet rec reverseHelper l rl = \nmatch l with\n| []    -> rl\n| h::t  -> reverseHelper t ( h::rl ) \nin\nreverseHelper l []", "annotated": "let listReverse : 'a list -> 'a list = fun  l  -> \nlet rec reverseHelper l rl = \nmatch l with\n| []    -> rl\n| h::t  -> reverseHelper t ( h::rl ) \nin\nreverseHelper l []"}
{"fix": "let rec assoc (d,k,l) = match l with\n| []        -> d\n| (n,v)::t  -> if k = n \nthen v\nelse assoc (d,k,t)", "bad": "let rec assoc (d,k,l) = match (d,k,l with\n| []        -> d\n| (n,v)::t  -> if k = n \nthen v\nelse assoc (d,k,t)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match (d,k,l with\n| []        -> d\n| (n,v)::t  -> if k = n \nthen v\nelse assoc (d,k,t)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = let (b', c) =  (f(b), f(b)<>b)\nin\nwwhile ((b', c) ,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let (b', c)  ->   (f(b), f(b)<>b)\nin\nwwhile ((b', c) ,b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile (f ,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (f ,b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile ( (b, b<>f(b)) ,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( (b, b<>f(b)) ,b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = let b' = f(b) \nin\n(b', f(b)<>b)\nin\nwwhile ( f ,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let b'  ->  f(b) \nin\n(b', f(b)<>b)\nin\nwwhile ( f ,b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = let b' = f(b) \nin\n(b', f(b)<>b)\nin\nwwhile ( f ,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let b'  ->  f(b) \nin\n(b', f(b)<>b)\nin\nwwhile ( f ,b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = let b' = f(b) \nin\n(b', f(b)<>b)\nin\nwwhile ( f ,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let b'  ->  f(b) \nin\n(b', f(b)<>b)\nin\nwwhile ( f ,b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = let f b = let b' = f(b) \nin\n(b', f(b)<>b)\nin\nwwhile (f ,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let f b = let b'  ->  f(b) \nin\n(b', f(b)<>b)\nin\nwwhile (f ,b)"}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = \nVarX\t\t      -> \"x\"\n| VarY\t\t\t-> \"y\"\n| Sine(x)\t\t-> \"sin(pi*\" ^ (exprToString x) ^ \")\"\n| Cosine(x)\t\t-> \"cos(pi*\" ^ (exprToString x) ^ \")\"\n| Average(x1,x2)\t-> \"((\" ^ (exprToString x1) ^ \"+\" ^ (exprToString x2) ^ \")/2)\"\n| Times(x1,x2)\t\t-> (exprToString x1) ^ \"*\" ^ (exprToString x2)\n| Thresh(x1,x2,x3,x4)\t-> \"(\" ^ (exprToString x1) ^ \"<\" ^ (exprToString x2) \n^ \"?\" ^ (exprToString x3) ^ \":\" ^ (exprToString x4)", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nVarX\t\t      -> \"x\"\n| VarY\t\t\t-> \"y\"\n| Sine(x)\t\t-> \"sin(pi*\" ^ (exprToString x) ^ \")\"\n| Cosine(x)\t\t-> \"cos(pi*\" ^ (exprToString x) ^ \")\"\n| Average(x1,x2)\t-> \"((\" ^ (exprToString x1) ^ \"+\" ^ (exprToString x2) ^ \")/2)\"\n| Times(x1,x2)\t\t-> (exprToString x1) ^ \"*\" ^ (exprToString x2)\n| Thresh(x1,x2,x3,x4)\t-> \"(\" ^ (exprToString x1) ^ \"<\" ^ (exprToString x2) \n^ \"?\" ^ (exprToString x3) ^ \":\" ^ (exprToString x4)"}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = \nVarX _ \t\t      -> \"x\"\n| VarY _\t\t-> \"y\"\n| Sine(x)\t\t-> \"sin(pi*\" ^ (exprToString x) ^ \")\"\n| Cosine(x)\t\t-> \"cos(pi*\" ^ (exprToString x) ^ \")\"\n| Average(x1,x2)\t-> \"((\" ^ (exprToString x1) ^ \"+\" ^ (exprToString x2) ^ \")/2)\"\n| Times(x1,x2)\t\t-> (exprToString x1) ^ \"*\" ^ (exprToString x2)\n| Thresh(x1,x2,x3,x4)\t-> \"(\" ^ (exprToString x1) ^ \"<\" ^ (exprToString x2) \n^ \"?\" ^ (exprToString x3) ^ \":\" ^ (exprToString x4)", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nVarX _ \t\t      -> \"x\"\n| VarY _\t\t-> \"y\"\n| Sine(x)\t\t-> \"sin(pi*\" ^ (exprToString x) ^ \")\"\n| Cosine(x)\t\t-> \"cos(pi*\" ^ (exprToString x) ^ \")\"\n| Average(x1,x2)\t-> \"((\" ^ (exprToString x1) ^ \"+\" ^ (exprToString x2) ^ \")/2)\"\n| Times(x1,x2)\t\t-> (exprToString x1) ^ \"*\" ^ (exprToString x2)\n| Thresh(x1,x2,x3,x4)\t-> \"(\" ^ (exprToString x1) ^ \"<\" ^ (exprToString x2) \n^ \"?\" ^ (exprToString x3) ^ \":\" ^ (exprToString x4)"}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = match e with\nVarX   \t\t      -> \"x\"\n| VarY  \t\t-> \"y\"\n| Sine(x)\t\t-> \"sin(pi*\" ^ (exprToString x) ^ \")\"\n| Cosine(x)\t\t-> \"cos(pi*\" ^ (exprToString x) ^ \")\"\n| Average(x1,x2)\t-> \"((\" ^ (exprToString x1) ^ \"+\" ^ (exprToString x2) ^ \")/2)\"\n| Times(x1,x2)\t\t-> (exprToString x1) ^ \"*\" ^ (exprToString x2)\n| Thresh(x1,x2,x3,x4)\t-> \"(\" ^ (exprToString x1) ^ \"<\" ^ (exprToString x2) \n^ \"?\" ^ (exprToString x3) ^ \":\" ^ (exprToString x4)", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\nVarX   \t\t      -> \"x\"\n| VarY  \t\t-> \"y\"\n| Sine(x)\t\t-> \"sin(pi*\" ^ (exprToString x) ^ \")\"\n| Cosine(x)\t\t-> \"cos(pi*\" ^ (exprToString x) ^ \")\"\n| Average(x1,x2)\t-> \"((\" ^ (exprToString x1) ^ \"+\" ^ (exprToString x2) ^ \")/2)\"\n| Times(x1,x2)\t\t-> (exprToString x1) ^ \"*\" ^ (exprToString x2)\n| Thresh(x1,x2,x3,x4)\t-> \"(\" ^ (exprToString x1) ^ \"<\" ^ (exprToString x2) \n^ \"?\" ^ (exprToString x3) ^ \":\" ^ (exprToString x4)"}
{"fix": "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.", "bad": "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x)\t\t-> sin (eval (pi *. x) )\n| Cosine(x)\t\t-> cos (pi *. (eval x) )\n| Average(x1,x2)\t-> ( (eval x1) +. (eval x2) ) /. 2.", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x)\t\t-> sin (eval (pi *. x) )\n| Cosine(x)\t\t-> cos (pi *. (eval x) )\n| Average(x1,x2)\t-> ( (eval x1) +. (eval x2) ) /. 2."}
{"fix": "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.", "bad": ") \n", "annotated": ") \n"}
{"fix": "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.", "bad": "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y ) ) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y ) ) )\n| Average(x1,x2)\t-> ( (eval x1) +. (eval x2) ) /. 2.", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y ) ) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y ) ) )\n| Average(x1,x2)\t-> ( (eval x1) +. (eval x2) ) /. 2."}
{"fix": "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.", "bad": ") \n", "annotated": ") \n"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> \"(\" ^ (exprToString x1) ^ \"<\" ^ (exprToString x2) \n^ \"?\" ^ (exprToString x3) ^ \":\" ^ (exprToString x4) ^ \")\"", "annotated": "| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> \"(\" ^ (exprToString x1) ^ \"<\" ^ (exprToString x2) \n^ \"?\" ^ (exprToString x3) ^ \":\" ^ (exprToString x4) ^ \")\""}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> \"(\" ^ (exprToString x1) ^ \"<\" ^ (exprToString x2) \n^ \"?\" ^ (exprToString x3) ^ \":\" ^ (exprToString x4) ^ \")\"", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> \"(\" ^ (exprToString x1) ^ \"<\" ^ (exprToString x2) \n^ \"?\" ^ (exprToString x3) ^ \":\" ^ (exprToString x4) ^ \")\""}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> (eval (x1,x,y )) < (eval (x2,x,y )) \n? (eval (x3,x,y )) : (eval (x4,x,y ))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> (eval (x1,x,y )) < (eval (x2,x,y )) \n? (eval (x3,x,y )) : (eval (x4,x,y ))"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> (eval (x1,x,y )) < (eval (x2,x,y )) ? (eval (x3,x,y )) : (eval (x4,x,y ))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> (eval (x1,x,y )) < (eval (x2,x,y )) ? (eval (x3,x,y )) : (eval (x4,x,y ))"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> ((eval (x1,x,y )) < (eval (x2,x,y )) \n? (eval (x3,x,y )) : (eval (x4,x,y )))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> ((eval (x1,x,y )) < (eval (x2,x,y )) \n? (eval (x3,x,y )) : (eval (x4,x,y )))"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> (eval (x1,x,y )) <. (eval (x2,x,y )) \n? (eval (x3,x,y )) : (eval (x4,x,y ))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> (eval (x1,x,y )) <. (eval (x2,x,y )) \n? (eval (x3,x,y )) : (eval (x4,x,y ))"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> (eval (x1,x,y )) < (eval (x2,x,y )) \n? eval (x3,x,y ) : (eval (x4,x,y ))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> (eval (x1,x,y )) < (eval (x2,x,y )) \n? eval (x3,x,y ) : (eval (x4,x,y ))"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> (eval (x1,x,y )) < (eval (x2,x,y )) \n? eval (x3,x,y ) : eval (x4,x,y )", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> (eval (x1,x,y )) < (eval (x2,x,y )) \n? eval (x3,x,y ) : eval (x4,x,y )"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> (eval (x1,x,y )) < (eval (x2,x,y )) \n? eval (x3,x,y ) : eval (x4,x,y )", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> (eval (x1,x,y )) < (eval (x2,x,y )) \n? eval (x3,x,y ) : eval (x4,x,y )"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> if (eval (x1,x,y )) < (eval (x2,x,y )) \nthen eval (x3,x,y ) \nelse eval (x4,x,y )", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> if (eval (x1,x,y )) < (eval (x2,x,y )) \nthen eval (x3,x,y ) \nelse eval (x4,x,y )"}
{"fix": "let rec build (rand, depth) = match depth with\n| 0   -> ( match (rand 1 3 ) with\n| 1 -> buildX()\n| 2 -> buildY() \n)\n| _   -> ( match (rand 1 5 ) with\n| 1 -> buildSine(build(rand,depth-1))\n| 2 -> buildCosine(build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),\nbuild(rand,depth-1),build(rand,depth-1))\n)", "bad": "let rec build (rand, depth) = match depth with\n| 0   -> ( match (rand 1 3 ) with\n| 1 -> buildX()\n| 2 -> buildY() \n)\n| _   -> ( match (rand 1 4 ) with\n| 1 -> buildThresh(build(rand,depth-1),build(rand,depth-1),\nbuild(rand,depth-1),build(rand,depth-1))\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCos(build(rand,depth-1))\n| 4 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n| 0   -> ( match (rand 1 3 ) with\n| 1 -> buildX()\n| 2 -> buildY() \n)\n| _   -> ( match (rand 1 4 ) with\n| 1 -> buildThresh(build(rand,depth-1),build(rand,depth-1),\nbuild(rand,depth-1),build(rand,depth-1))\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCos(build(rand,depth-1))\n| 4 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n)"}
{"fix": "let rec build (rand, depth) = match depth with\n| 0   -> ( match (rand 1 3 ) with\n| 1 -> buildX()\n| 2 -> buildY() \n)\n| _   -> ( match (rand 1 5 ) with\n| 1 -> buildSine(build(rand,depth-1))\n| 2 -> buildCosine(build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),\nbuild(rand,depth-1),build(rand,depth-1))\n)", "bad": "let rec build (rand, depth) = match depth with\n| 0   -> ( match (rand 1 3 ) with\n| 1 -> buildX()\n| 2 -> buildY() \n)\n| _   -> ( match (rand 1 4 ) with\n| 1 -> buildThresh(build(rand,depth-1),build(rand,depth-1),\nbuild(rand,depth-1),build(rand,depth-1))\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n| 0   -> ( match (rand 1 3 ) with\n| 1 -> buildX()\n| 2 -> buildY() \n)\n| _   -> ( match (rand 1 4 ) with\n| 1 -> buildThresh(build(rand,depth-1),build(rand,depth-1),\nbuild(rand,depth-1),build(rand,depth-1))\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n)"}
{"fix": "let rec build (rand, depth) = match depth with\n| 0   -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildY() \n)\n| _   -> ( match (rand (1,5) ) with\n| 1 -> buildSine(build (rand,depth-1) )\n| 2 -> buildCosine(build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),\nbuild(rand,depth-1),build(rand,depth-1))\n)", "bad": "let rec build (rand, depth) = match depth with\n| 0   -> ( match (rand 1 3 ) with\n| 1 -> buildX()\n| _ -> buildY() \n)\n| _   -> ( match (rand 1 5 ) with\n| 1 -> buildSine(build (rand,depth-1) )\n| 2 -> buildCosine(build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),\nbuild(rand,depth-1),build(rand,depth-1))\n)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n| 0   -> ( match (rand 1 3 ) with\n| 1 -> buildX()\n| _ -> buildY() \n)\n| _   -> ( match (rand 1 5 ) with\n| 1 -> buildSine(build (rand,depth-1) )\n| 2 -> buildCosine(build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),\nbuild(rand,depth-1),build(rand,depth-1))\n)"}
{"fix": "let rec exprToString e = match e with\nVarX   \t\t      -> \"x\"\n| VarY  \t\t-> \"y\"\n| Sine(x)\t\t-> \"sin(pi*\" ^ (exprToString x) ^ \")\"\n| Cosine(x)\t\t-> \"cos(pi*\" ^ (exprToString x) ^ \")\"\n| Average(x1,x2)\t-> \"((\" ^ (exprToString x1) ^ \"+\" ^ (exprToString x2) ^ \")/2)\"\n| Times(x1,x2)\t\t-> (exprToString x1) ^ \"*\" ^ (exprToString x2)\n| Thresh(x1,x2,x3,x4)\t-> \"(\" ^ (exprToString x1) ^ \"<\" ^ (exprToString x2) \n^ \"?\" ^ (exprToString x3) ^ \":\" ^ (exprToString x4) ^ \")\"\n| CosE(x1,x2,x3)\t-> \"cos(pi*\" ^ (exprToString x1) ^ \"*\" ^ (exprToString x2) ^ \")e^(-pi*\" \n^ (exprToString x3) ^ \"^2)\"", "bad": "let rec exprToString e = match e with\nVarX   \t\t      -> \"x\"\n| VarY  \t\t-> \"y\"\n| Sine(x)\t\t-> \"sin(pi*\" ^ (exprToString x) ^ \")\"\n| Cosine(x)\t\t-> \"cos(pi*\" ^ (exprToString x) ^ \")\"\n| Average(x1,x2)\t-> \"((\" ^ (exprToString x1) ^ \"+\" ^ (exprToString x2) ^ \")/2)\"\n| Times(x1,x2)\t\t-> (exprToString x1) ^ \"*\" ^ (exprToString x2)\n| Thresh(x1,x2,x3,x4)\t-> \"(\" ^ (exprToString x1) ^ \"<\" ^ (exprToString x2) \n^ \"?\" ^ (exprToString x3) ^ \":\" ^ (exprToString x4) ^ \")\"\n| CosE(x1,x2,x3)\t-> \"cos(pi*\" ^ (exprToString x1) ^ \"*\" ^ (exprToString x1) ^ \")e^(-pi*\" \n^ (exprToString x1) ^ \"^2)\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\nVarX   \t\t      -> \"x\"\n| VarY  \t\t-> \"y\"\n| Sine(x)\t\t-> \"sin(pi*\" ^ (exprToString x) ^ \")\"\n| Cosine(x)\t\t-> \"cos(pi*\" ^ (exprToString x) ^ \")\"\n| Average(x1,x2)\t-> \"((\" ^ (exprToString x1) ^ \"+\" ^ (exprToString x2) ^ \")/2)\"\n| Times(x1,x2)\t\t-> (exprToString x1) ^ \"*\" ^ (exprToString x2)\n| Thresh(x1,x2,x3,x4)\t-> \"(\" ^ (exprToString x1) ^ \"<\" ^ (exprToString x2) \n^ \"?\" ^ (exprToString x3) ^ \":\" ^ (exprToString x4) ^ \")\"\n| CosE(x1,x2,x3)\t-> \"cos(pi*\" ^ (exprToString x1) ^ \"*\" ^ (exprToString x1) ^ \")e^(-pi*\" \n^ (exprToString x1) ^ \"^2)\""}
{"fix": "let rec build (rand, depth) = match depth with\n| 0 -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildY()\n)\n| _ -> ( match (rand (5,8) ) with\n| 1 -> buildSine( build (rand, depth-1) )\n| 2 -> buildCosine(  build (rand, depth-1) )\n| 3 -> buildTimes( build (rand, depth-1), build (rand, depth-1) )\n| 4 -> buildAverage(  build (rand, depth-1), build (rand, depth-1) )\n| 5 -> buildSine( build (rand, depth-1) )\n| 6 -> buildCosine(  build (rand, depth-1) )\n| 7 -> buildCosE(build (rand, depth-1), build (rand, depth-1), build (rand, depth-1) )\n)", "bad": "let rec build (rand, depth) = match depth with\n| 0 -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildY()\n)\n| _ -> ( match (rand (5,8) ) with\n| 1 -> buildSine( build (rand, depth-1) )\n| 2 -> buildCosine(  build (rand, depth-1) )\n| 3 -> buildTimes( build (rand, depth-1), build (rand, depth-1) )\n| 4 -> buildAverage(  build (rand, depth-1), build (rand, depth-1) )\n| 5 -> buildSine( build (rand, depth-1) )\n| 6 -> buildCosine(  build (rand, depth-1) )\n| 7 -> buildCosE(build (rand, depth-1), build (rand, depth-1), build (rand, depth-1) )\n)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n| 0 -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildY()\n)\n| _ -> ( match (rand (5,8) ) with\n| 1 -> buildSine( build (rand, depth-1) )\n| 2 -> buildCosine(  build (rand, depth-1) )\n| 3 -> buildTimes( build (rand, depth-1), build (rand, depth-1) )\n| 4 -> buildAverage(  build (rand, depth-1), build (rand, depth-1) )\n| 5 -> buildSine( build (rand, depth-1) )\n| 6 -> buildCosine(  build (rand, depth-1) )\n| 7 -> buildCosE(build (rand, depth-1), build (rand, depth-1), build (rand, depth-1) )\n)"}
{"fix": "let sqsum xs = \nlet f a x = x * x + a in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a * a + in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a * a + in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = base in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = base in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = + in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = + in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = _ in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = _ in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (+) in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (+) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = (_) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = (_) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (+) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base =  in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base =  in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x (a) in\nlet base = () in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x (a) in\nlet base = () in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x (a) in\nlet base = () in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x (a) in\nlet base = () in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = f in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = f in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x (a) in\nlet base = f in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = x (a) in\nlet base = f in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x (a) in\nlet base = (+) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x (a) in\nlet base = + in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x (a) in\nlet base = + in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x (a ) in\nlet base = fun x->x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x (a) in\nlet base = 0(+) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x (a) in\nlet base = 0(+) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x (a ) in\nlet base = fun x->x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x (a) in\nlet base = 0(+) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x (a) in\nlet base = 0(+) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x (a ) in\nlet base = fun x->x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x (a p) in\nlet base = p in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x (a p) in\nlet base = p in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x (a ) in\nlet base = fun x->x in\nList.fold_left f base fs", "bad": "let pipe fs p = \nlet f a x = x (a p) in\nlet base = p in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs p  ->  \nlet f a x = x (a p) in\nlet base = p in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun p -> x (a p) in\nlet base = fun x->x in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun p -> x (a p) in\nlet base = fun x->x in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sepConcat sep t  in\nlet base = h in\nlet l =  t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep  in\nlet base = h in\nlet l =  sepConcat sep t in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep  in\nlet base = h in\nlet l =  sepConcat sep t in\nList.fold_left f base l"}
{"fix": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l) ) ^ \"]\"", "bad": "let stringOfList f l = \"[\" ^ sepConcat \"; \" List.map f l ^ \"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\" ^ sepConcat \"; \" List.map f l ^ \"]\""}
{"fix": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l) ) ^ \"]\"", "bad": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" List.map f l) ^ \"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\" ^ (sepConcat \"; \" List.map f l) ^ \"]\""}
{"fix": "let rec clone x n = \nmatch n with \n| 0 -> []\n| _ -> x :: (clone x (n-1) )", "bad": "let rec clone x n = \nlet helper = \nmatch n with\n| 0 -> []\n| _ -> x :: clone x n-1", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nlet helper = \nmatch n with\n| 0 -> []\n| _ -> x :: clone x n-1"}
{"fix": "let rec clone x n = \nmatch n with \n| 0 -> []\n| _ -> x :: (clone x (n-1) )", "bad": "let rec clone x n = \nlet helper = \nmatch n with\n| 0 -> []\n| _ -> x :: clone x n-1\nin \nhelper n", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nlet helper = \nmatch n with\n| 0 -> []\n| _ -> x :: clone x n-1\nin \nhelper n"}
{"fix": "let rec clone x n = \nmatch n with \n| 0 -> []\n| _ -> x :: (clone x (n-1) )", "bad": "let rec clone x n = \nlet helper = \nmatch n with\n| 0 -> []\n| _ -> x :: clone x (n-1)\nin \nhelper n", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nlet helper = \nmatch n with\n| 0 -> []\n| _ -> x :: clone x (n-1)\nin \nhelper n"}
{"fix": "let rec clone x n = \nmatch n with \n| 0 -> []\n| _ -> x :: (clone x (n-1) )", "bad": "let rec clone x n = \nlet helper = \nmatch n with\n| 0 -> []\n| _ -> x :: helper n-1\nin \nhelper n", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nlet helper = \nmatch n with\n| 0 -> []\n| _ -> x :: helper n-1\nin \nhelper n"}
{"fix": "let rec clone x n = \nmatch n with \n| 0 -> []\n| _ -> x :: (clone x (n-1) )", "bad": "let rec clone x n = \nlet rec helper = \nmatch n with\n| 0 -> []\n| _ -> x :: helper n-1\nin \nhelper n", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nlet rec helper = \nmatch n with\n| 0 -> []\n| _ -> x :: helper n-1\nin \nhelper n"}
{"fix": "let rec clone x n = \nmatch n with \n| 0 -> []\n| _ -> x :: (clone x (n-1) )", "bad": "let rec clone x n = \nlet rec helper = \nmatch n with\n| 0 -> []\n| _ -> x :: (helper n-1)\nin \nhelper n", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nlet rec helper = \nmatch n with\n| 0 -> []\n| _ -> x :: (helper n-1)\nin \nhelper n"}
{"fix": "let rec clone x n = \nmatch n with \n| 0 -> []\n| _ -> x :: (clone x (n-1) )", "bad": "let rec clone x n = \nlet rec helper = \nmatch n with\n| 0 -> []\n| _ -> helper n-1\nin \nhelper n", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nlet rec helper = \nmatch n with\n| 0 -> []\n| _ -> helper n-1\nin \nhelper n"}
{"fix": "let rec clone x n = \nmatch n with \n| 0 -> []\n| _ -> x :: (clone x (n-1) )", "bad": "let rec clone x n = \nlet rec helper n = \nmatch n with\n| 0 -> []\n| _ -> helper n-1\nin \nhelper n", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nlet rec helper n = \nmatch n with\n| 0 -> []\n| _ -> helper n-1\nin \nhelper n"}
{"fix": "let rec clone x n = \nmatch n with \n| 0 -> []\n| _ -> x :: (clone x (n-1) )", "bad": "let rec clone x n = \nmatch n with \n| 0 -> []\n| _ -> x :: (clone x n-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nmatch n with \n| 0 -> []\n| _ -> x :: (clone x n-1)"}
{"fix": "let rec sumList xs = match xs with\n[] -> 0 \n| h::t -> h + sumList t", "bad": "let rec sumList xs = match sumList with\n| h::t -> h + sumList t", "annotated": "let rec sumList : int list -> int = fun  xs  ->  match sumList with\n| h::t -> h + sumList t"}
{"fix": "let rec sumList xs = match xs with\n[] -> 0 \n| h::t -> h + sumList t", "bad": "let rec sumList xs = match sumList with\n[] -> 0 \n| h::t -> h + sumList t", "annotated": "let rec sumList : int list -> int = fun  xs  ->  match sumList with\n[] -> 0 \n| h::t -> h + sumList t"}
{"fix": "let rec sumList xs = match xs with\n[] -> 0 \n| h::t -> h + sumList t", "bad": "let rec sumList xs = match sumList with\n[] -> 0 \n| h::t -> h + sumList t", "annotated": "let rec sumList : int list -> int = fun  xs  ->  match sumList with\n[] -> 0 \n| h::t -> h + sumList t"}
{"fix": "let _ = digitsOfInt (-2)", "bad": "let _ = digitsOfInt -2", "annotated": "let _ = digitsOfInt -2"}
{"fix": "let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "bad": "let rec digitsOfInt n = \nif n < 0 then []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []"}
{"fix": "let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "bad": "let rec digitsOfInt n = \nif n < 0 -> []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 -> []"}
{"fix": "let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "bad": "let rec digitsOfInt n = \nif n < 0 then -> []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then -> []"}
{"fix": "let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "bad": "let rec digitsOfInt n = \nwhen n < 0 -> []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nwhen n < 0 -> []"}
{"fix": "let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet rec loop n acc =\nif n = 0 then acc\nelse loop (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "bad": "let rec digitsOfInt n =\nif n < 0 then []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []"}
{"fix": "let additivePersistence n = \ndigits n", "bad": "let additivePersistence n = \nlet digits n = x in\nsumList x", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet digits n = x in\nsumList x"}
{"fix": "let additivePersistence n = \ndigits n", "bad": "let additivePersistence n = \ndigits n\nsumList n", "annotated": "let additivePersistence : int -> int = fun  n  ->  \ndigits n\nsumList n"}
{"fix": "let additivePersistence n = \nsumList (digits n)", "bad": "let additivePersistence n = \ndigits n = n", "annotated": "let additivePersistence : int -> int = fun  n  ->  \ndigits n = n"}
{"fix": "let rec digitalRoot n = \nif sumList (digits n) > 9\nthen digitalRoot (sumList (digits n))\nelse sumList (digits n)", "bad": "let digitalRoot n = \nlet x = sumList (digits n) in\nif x > 9\nthen digitalRoot x\nelse sumList x", "annotated": "let digitalRoot : int -> int = fun  n  ->  \nlet x = sumList (digits n) in\nif x > 9\nthen digitalRoot x\nelse sumList x"}
{"fix": "let rec digitalRoot n = \nif sumList (digits n) > 9\nthen digitalRoot (sumList (digits n))\nelse sumList (digits n)", "bad": "let rec digitalRoot n = \nlet x = sumList (digits n) in\nif x > 9\nthen digitalRoot x\nelse sumList x", "annotated": "let rec digitalRoot : int -> int = fun  n  ->  \nlet x = sumList (digits n) in\nif x > 9\nthen digitalRoot x\nelse sumList x"}
{"fix": "let listReverse l = \nlet rec aux acc = function\n| [] -> acc\n| h::t -> aux (h::acc) t in\naux [] l", "bad": "let listReverse l = \nlet rec aux acc = function\n| [] -> acc\n| h::t -> aux (h::acc) t in\naux [] list", "annotated": "let listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec aux acc = function\n| [] -> acc\n| h::t -> aux (h::acc) t in\naux [] list"}
{"fix": "let additivePersistence n = \nlet rec helper n count =\nlet rec digitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse count\nin digitalRoot n\nin helper n 0", "bad": "let additivePersistence n = \nlet rec helper n count = function\ndigitalRoot n", "annotated": "let additivePersistence n = \nlet rec helper n count = function\ndigitalRoot n"}
{"fix": "let additivePersistence n = \nlet rec helper n count =\nlet rec digitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse count\nin digitalRoot n\nin helper n 0", "bad": "let additivePersistence n = \nlet rec helper n count = \ndigitalRoot n", "annotated": "let additivePersistence n = \nlet rec helper n count = \ndigitalRoot n"}
{"fix": "let additivePersistence n = \nlet rec helper n count =\nlet rec digitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse count\nin digitalRoot n\nin helper n 0", "bad": "let additivePersistence n = \nlet rec helper n count = \nlet rec digitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse sumList (digits n)", "annotated": "let additivePersistence n = \nlet rec helper n count = \nlet rec digitalRoot : int -> int = fun  n  -> \nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse sumList (digits n)"}
{"fix": "let additivePersistence n = \nlet rec helper n count =\nlet rec digitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse count\nin digitalRoot n\nin helper n 0", "bad": "let additivePersistence n = \nlet rec helper n count = \nlet rec digitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse sumList (digits n)\nin helper n 0", "annotated": "let additivePersistence n = \nlet rec helper n count = \nlet rec digitalRoot : int -> int = fun  n  -> \nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse sumList (digits n)\nin helper n 0"}
{"fix": "let additivePersistence n = \nlet rec helper n count =\nlet rec digitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse count\nin digitalRoot n\nin helper n 0", "bad": "let additivePersistence n = \nlet rec helper n count = \nlet rec digitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse sumList (digits n)\nin helper n 0", "annotated": "let additivePersistence n = \nlet rec helper n count = \nlet rec digitalRoot : int -> int = fun  n  -> \nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse sumList (digits n)\nin helper n 0"}
{"fix": "let additivePersistence n = \nlet rec helper n count =\nlet rec digitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse count\nin digitalRoot n\nin helper n 0", "bad": "let additivePersistence n = \nlet rec helper n count = \nlet rec digitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse sumList (digits n)\nin helper n 0", "annotated": "let additivePersistence n = \nlet rec helper n count = \nlet rec digitalRoot : int -> int = fun  n  -> \nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse sumList (digits n)\nin helper n 0"}
{"fix": "let additivePersistence n = \nlet rec helper n count =\nlet rec digitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse count\nin digitalRoot n\nin helper n 0", "bad": "let additivePersistence n = \nlet rec helper n count = \nlet rec digitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse count\nin helper n 0", "annotated": "let additivePersistence n = \nlet rec helper n count = \nlet rec digitalRoot : int -> int = fun  n  -> \nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse count\nin helper n 0"}
{"fix": "let additivePersistence n = \nlet rec helper n count =\nlet rec digitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse count\nin digitalRoot n\nin helper n 0", "bad": "let additivePersistence n = \nlet rec helper n count = \ndigitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse count\nin helper n 0", "annotated": "let additivePersistence n = \nlet rec helper n count = \ndigitalRoot : int -> int = fun  n  -> \nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse count\nin helper n 0"}
{"fix": "let additivePersistence n = \nlet rec helper n count =\nlet rec digitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse count\nin digitalRoot n\nin helper n 0", "bad": "let additivePersistence n = \nlet rec helper n count = function\ndigitalRoot n =\nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse count\nin helper n 0", "annotated": "let additivePersistence n = \nlet rec helper n count = function\ndigitalRoot : int -> int = fun  n  -> \nif sumList (digits n) > 9\nthen helper (sumList (digits n)) (count+1)\nelse count\nin helper n 0"}
{"fix": "let listReverse l = \nlet rec helper xs = function\n| [] -> []\n| hd::tl -> helper (hd::xs) tl\nin helper [] l", "bad": "let listReverse l = \nlet rec helper xs = match xs with\n| [] -> []\n| hd::tl -> helper (hd::xs) tl\nin helper [] l", "annotated": "let listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec helper xs = match xs with\n| [] -> []\n| hd::tl -> helper (hd::xs) tl\nin helper [] l"}
{"fix": "let listReverse l = \nlet rec helper xs = function\n| [] -> xs\n| hd::tl -> helper (hd::xs) tl\nin helper [] l", "bad": "let listReverse l = \nlet rec helper xs = function\n| [] -> xs\n| hd::tl -> helper (hd::xs) \nin helper [] l", "annotated": "let listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec helper xs = function\n| [] -> xs\n| hd::tl -> helper (hd::xs) \nin helper [] l"}
{"fix": "let listReverse l = \nlet rec helper xs l  = match l with\n| [] -> []\n| hd::tl -> helper (hd::xs) l\nin helper [] l", "bad": "let listReverse l = \nlet rec helper xs n  = function\n| [] -> xs\n| hd::tl -> helper (hd::xs) tl\nin helper [] l", "annotated": "let listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec helper xs n  = function\n| [] -> xs\n| hd::tl -> helper (hd::xs) tl\nin helper [] l"}
{"fix": "let listReverse l = \nlet rec helper xs l  = match l with\n| [] -> []\n| hd::tl -> helper (hd::xs) l\nin helper [] l", "bad": "let listReverse l = \nlet rec helper xs l  = match n with\n| [] -> []\n| hd::tl -> helper (hd::xs) l\nin helper [] l", "annotated": "let listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec helper xs l  = match n with\n| [] -> []\n| hd::tl -> helper (hd::xs) l\nin helper [] l"}
{"fix": "let rec reverse res list = match list with\n| [] -> []\n| hd::tl -> reverse (hd::res) list", "bad": "let rec reverse res list = match list with\n| [] -> []\n| hd:tl -> reverse (hd::res) list", "annotated": "let rec reverse res list = match list with\n| [] -> []\n| hd:tl -> reverse (hd::res) list"}
{"fix": "let rec reverse res list = match list with\n| [] -> []\n| hd::tl -> reverse (hd::res) list", "bad": "let listReverse l = reverse [] list", "annotated": "let listReverse : 'a list -> 'a list = fun  l  ->  reverse [] list"}
{"fix": "let rec helper xs list  = match list with\n| [] -> []\n| hd::tl -> helper (hd::xs) \nin helper [] l", "bad": "let listReverse l = reverse [] l", "annotated": "let listReverse : 'a list -> 'a list = fun  l  ->  reverse [] l"}
{"fix": "let rec mylength xs = match xs with\n| [] -> 0\n| hd::tl -> 1 + mylength tl", "bad": "let digitsOfInt n =\nlet rec digits n x list =\nif n < 10 then n :: list\nelse digits (n/10 + n mod 10) (mylength n/10 + n mod 10) list\nin digits n (mylength n) []", "annotated": "let digitsOfInt : int -> int list = fun  n  -> \nlet rec digits n x list =\nif n < 10 then n :: list\nelse digits (n/10 + n mod 10) (mylength n/10 + n mod 10) list\nin digits n (mylength n) []"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/(10** numdig -1) mod 10 :: l\nelse numdig :: 1\nin digits n []", "annotated": "let digitsOfInt : int -> int list = fun  n  -> \nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/(10** numdig -1) mod 10 :: l\nelse numdig :: 1\nin digits n []"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/(int_of_float 10 ** numdig -1) mod 10 :: l\nelse numdig :: 1\nin digits n []", "annotated": "let digitsOfInt : int -> int list = fun  n  -> \nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/(int_of_float 10 ** numdig -1) mod 10 :: l\nelse numdig :: 1\nin digits n []"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/(float_of_int 10 ** numdig -1) mod 10 :: l\nelse numdig :: 1\nin digits n []", "annotated": "let digitsOfInt : int -> int list = fun  n  -> \nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/(float_of_int 10 ** numdig -1) mod 10 :: l\nelse numdig :: 1\nin digits n []"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: l\nelse numdig :: 1\nin digits n []", "annotated": "let digitsOfInt : int -> int list = fun  n  -> \nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: l\nelse numdig :: 1\nin digits n []"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: l\nelse numdig :: 1\nin digits n []", "annotated": "let digitsOfInt : int -> int list = fun  n  -> \nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: l\nelse numdig :: 1\nin digits n []"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: l\nelse numdig :: l\nin digits n []", "annotated": "let digitsOfInt : int -> int list = fun  n  -> \nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: l\nelse numdig :: l\nin digits n []"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let digitsOfInt n =\nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: \n(digits (x/10) l)\nelse numdig :: l\nin digits n []", "annotated": "let digitsOfInt : int -> int list = fun  n  -> \nlet rec digits x l =\nlet numdig = num_of_digits x in\nif numdig > 1\nthen x/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10 :: \n(digits (x/10) l)\nelse numdig :: l\nin digits n []"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let digitsOfInt n =\nif n < 10 then n :: []\nelse\n(digitsOfInt n/10) :: [n/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10]", "annotated": "let digitsOfInt : int -> int list = fun  n  -> \nif n < 10 then n :: []\nelse\n(digitsOfInt n/10) :: [n/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10]"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let digitsOfInt n =\nif n < 10 then n :: []\nelse\n(digitsOfInt (n/10)) :: [n/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10]", "annotated": "let digitsOfInt : int -> int list = fun  n  -> \nif n < 10 then n :: []\nelse\n(digitsOfInt (n/10)) :: [n/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10]"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let digitsOfInt n =\nif n < 10 then n :: []\nelse\n(digitsOfInt (n/10)) @ [n/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10]", "annotated": "let digitsOfInt : int -> int list = fun  n  -> \nif n < 10 then n :: []\nelse\n(digitsOfInt (n/10)) @ [n/int_of_float(float_of_int 10 ** float_of_int (numdig -1)) mod 10]"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let digitsOfInt n =\nif n < 10 then n :: []\nelse\n(digitsOfInt (n/10)) @ [n/int_of_float(float_of_int 10 ** float_of_int (num_of_digits x -1)) mod 10]", "annotated": "let digitsOfInt : int -> int list = fun  n  -> \nif n < 10 then n :: []\nelse\n(digitsOfInt (n/10)) @ [n/int_of_float(float_of_int 10 ** float_of_int (num_of_digits x -1)) mod 10]"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let digitsOfInt n =\nif n < 10 then n :: []\nelse\n(digitsOfInt (n/10)) @ [n/int_of_float(float_of_int 10 ** float_of_int (num_of_digits n -1)) mod 10]", "annotated": "let digitsOfInt : int -> int list = fun  n  -> \nif n < 10 then n :: []\nelse\n(digitsOfInt (n/10)) @ [n/int_of_float(float_of_int 10 ** float_of_int (num_of_digits n -1)) mod 10]"}
{"fix": "let _ = digitsOfInt 122", "bad": "let digitsOfInt n =\nif n < 10 then n :: []\nelse (digitsOfInt (n/10))\nmatch n with\n| hd::tl -> hd\n:: [n mod 10]", "annotated": "let digitsOfInt : int -> int list = fun  n  -> \nif n < 10 then n :: []\nelse (digitsOfInt (n/10))\nmatch n with\n| hd::tl -> hd\n:: [n mod 10]"}
{"fix": "let _ = digitsOfInt 122", "bad": "let digitsOfInt n =\nif n < 10 then n :: []\nelse match n with\n| hd::tl -> hd\n(digitsOfInt (n/10)) :: [n mod 10]", "annotated": "let digitsOfInt : int -> int list = fun  n  -> \nif n < 10 then n :: []\nelse match n with\n| hd::tl -> hd\n(digitsOfInt (n/10)) :: [n mod 10]"}
{"fix": "let _ = digitsOfInt 122", "bad": "let digitsOfInt n =\nif n < 10 then n :: []\nelse match n with\n| (digitsOfInt (n/10)) :: [n mod 10]", "annotated": "let digitsOfInt : int -> int list = fun  n  -> \nif n < 10 then n :: []\nelse match n with\n| (digitsOfInt (n/10)) :: [n mod 10]"}
{"fix": "let _ = digitsOfInt 122", "bad": "let digitsOfInt n =\nif n < 10 then n :: []\nelse\n(digitsOfInt (n/10)) :: [n mod 10]", "annotated": "let digitsOfInt : int -> int list = fun  n  -> \nif n < 10 then n :: []\nelse\n(digitsOfInt (n/10)) :: [n mod 10]"}
{"fix": "let _ = digitsOfInt 122", "bad": "let digitsOfInt n =\nlet rec recurse x l =\nif x < 10 then x :: l\nelse\nrecurse (x/10) [n mod 10]\nin recurse n []", "annotated": "let digitsOfInt : int -> int list = fun  n  -> \nlet rec recurse x l =\nif x < 10 then x :: l\nelse\nrecurse (x/10) [n mod 10]\nin recurse n []"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let listReverse l = \nlet rec recurse x xs = match x with\n| [] -> []\n| hd::tl -> recurse tl (hd::xs)\nin recurse l []", "annotated": "let listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec recurse x xs = match x with\n| [] -> []\n| hd::tl -> recurse tl (hd::xs)\nin recurse l []"}
{"fix": "let _ = removeDuplicates [1]", "bad": "let _ = removeDuplicates [1];\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "annotated": "let _ = removeDuplicates [1];\n\nlet _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen)\nthen (h :: seen)\nelse seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen)\nthen seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen)\nthen seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let buildX()                       = VarX", "bad": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> exprToString buildThresh(a,b,c,d)\n| Times (a,b) -> exprToString buildTimes(a,b)\n| Average (a,b) -> exprToString buildAverage(a,b)\n| Cosine (a) -> exprToString buildCosine(a)\n| Sine (a) -> exprToString buildSine(a)\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX\n| None -> 0", "annotated": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> exprToString buildThresh(a,b,c,d)\n| Times (a,b) -> exprToString buildTimes(a,b)\n| Average (a,b) -> exprToString buildAverage(a,b)\n| Cosine (a) -> exprToString buildCosine(a)\n| Sine (a) -> exprToString buildSine(a)\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX\n| None -> 0"}
{"fix": "let buildX()                       = VarX", "bad": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> exprToString buildThresh(a,b,c,d)\n| Times (a,b) -> exprToString buildTimes(a,b)\n| Average (a,b) -> exprToString buildAverage(a,b)\n| Cosine (a) -> exprToString buildCosine(a)\n| Sine (a) -> exprToString buildSine(a)\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX", "annotated": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> exprToString buildThresh(a,b,c,d)\n| Times (a,b) -> exprToString buildTimes(a,b)\n| Average (a,b) -> exprToString buildAverage(a,b)\n| Cosine (a) -> exprToString buildCosine(a)\n| Sine (a) -> exprToString buildSine(a)\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX"}
{"fix": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> let e' = buildThresh(a,b,c,d) in exprToString e'\n| Times (a,b) -> let e' = buildTimes(a,b) in exprToString e'\n| Average (a,b) -> let e' = buildAverage(a,b) in exprToString e'\n| Cosine (a) -> let e' = buildCosine(a) in exprToString e'\n| Sine (a) -> let e' = buildSine(a) in exprToString e'\n| VarY -> exprToString VarX\n| VarX -> exprToString VarY", "bad": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> exprToString Thresh a,b,c,d\n| Times (a,b) -> exprToString buildTimes(a,b)\n| Average (a,b) -> exprToString buildAverage(a,b)\n| Cosine (a) -> exprToString buildCosine(a)\n| Sine (a) -> exprToString buildSine(a)\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX", "annotated": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> exprToString Thresh a,b,c,d\n| Times (a,b) -> exprToString buildTimes(a,b)\n| Average (a,b) -> exprToString buildAverage(a,b)\n| Cosine (a) -> exprToString buildCosine(a)\n| Sine (a) -> exprToString buildSine(a)\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX"}
{"fix": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> let e' = buildThresh(a,b,c,d) in exprToString e'\n| Times (a,b) -> let e' = buildTimes(a,b) in exprToString e'\n| Average (a,b) -> let e' = buildAverage(a,b) in exprToString e'\n| Cosine (a) -> let e' = buildCosine(a) in exprToString e'\n| Sine (a) -> let e' = buildSine(a) in exprToString e'\n| VarY -> exprToString VarX\n| VarX -> exprToString VarY", "bad": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> exprToString Thresh (a,b,c,d)\n| Times (a,b) -> exprToString buildTimes(a,b)\n| Average (a,b) -> exprToString buildAverage(a,b)\n| Cosine (a) -> exprToString buildCosine(a)\n| Sine (a) -> exprToString buildSine(a)\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX", "annotated": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> exprToString Thresh (a,b,c,d)\n| Times (a,b) -> exprToString buildTimes(a,b)\n| Average (a,b) -> exprToString buildAverage(a,b)\n| Cosine (a) -> exprToString buildCosine(a)\n| Sine (a) -> exprToString buildSine(a)\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX"}
{"fix": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> let e' = buildThresh(a,b,c,d) in exprToString e'\n| Times (a,b) -> let e' = buildTimes(a,b) in exprToString e'\n| Average (a,b) -> let e' = buildAverage(a,b) in exprToString e'\n| Cosine (a) -> let e' = buildCosine(a) in exprToString e'\n| Sine (a) -> let e' = buildSine(a) in exprToString e'\n| VarY -> exprToString VarX\n| VarX -> exprToString VarY", "bad": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> exprToString Thresh(a *b*c*d)\n| Times (a,b) -> exprToString buildTimes(a,b)\n| Average (a,b) -> exprToString buildAverage(a,b)\n| Cosine (a) -> exprToString buildCosine(a)\n| Sine (a) -> exprToString buildSine(a)\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX", "annotated": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> exprToString Thresh(a *b*c*d)\n| Times (a,b) -> exprToString buildTimes(a,b)\n| Average (a,b) -> exprToString buildAverage(a,b)\n| Cosine (a) -> exprToString buildCosine(a)\n| Sine (a) -> exprToString buildSine(a)\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX"}
{"fix": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> let e' = buildThresh(a,b,c,d) in exprToString e'\n| Times (a,b) -> let e' = buildTimes(a,b) in exprToString e'\n| Average (a,b) -> let e' = buildAverage(a,b) in exprToString e'\n| Cosine (a) -> let e' = buildCosine(a) in exprToString e'\n| Sine (a) -> let e' = buildSine(a) in exprToString e'\n| VarY -> exprToString VarX\n| VarX -> exprToString VarY", "bad": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> exprToString buildThresh(a,b,c,d)\n| Times (a,b) -> exprToString buildTimes(a,b)\n| Average (a,b) -> exprToString buildAverage(a,b)\n| Cosine (a) -> exprToString buildCosine(a)\n| Sine (a) -> exprToString buildSine(a)\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX", "annotated": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> exprToString buildThresh(a,b,c,d)\n| Times (a,b) -> exprToString buildTimes(a,b)\n| Average (a,b) -> exprToString buildAverage(a,b)\n| Cosine (a) -> exprToString buildCosine(a)\n| Sine (a) -> exprToString buildSine(a)\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX"}
{"fix": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> let e' = buildThresh(a,b,c,d) in exprToString e'\n| Times (a,b) -> let e' = buildTimes(a,b) in exprToString e'\n| Average (a,b) -> let e' = buildAverage(a,b) in exprToString e'\n| Cosine (a) -> let e' = buildCosine(a) in exprToString e'\n| Sine (a) -> let e' = buildSine(a) in exprToString e'\n| VarY -> exprToString VarX\n| VarX -> exprToString VarY", "bad": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> let a = buildThresh(a,b,c,d) in exprToString a\n| Times (a,b) -> exprToString buildTimes(a,b)\n| Average (a,b) -> exprToString buildAverage(a,b)\n| Cosine (a) -> exprToString buildCosine(a)\n| Sine (a) -> exprToString buildSine(a)\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX", "annotated": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> let a = buildThresh(a,b,c,d) in exprToString a\n| Times (a,b) -> exprToString buildTimes(a,b)\n| Average (a,b) -> exprToString buildAverage(a,b)\n| Cosine (a) -> exprToString buildCosine(a)\n| Sine (a) -> exprToString buildSine(a)\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX"}
{"fix": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> let e' = buildThresh(a,b,c,d) in exprToString e'\n| Times (a,b) -> let e' = buildTimes(a,b) in exprToString e'\n| Average (a,b) -> let e' = buildAverage(a,b) in exprToString e'\n| Cosine (a) -> let e' = buildCosine(a) in exprToString e'\n| Sine (a) -> let e' = buildSine(a) in exprToString e'\n| VarY -> exprToString VarX\n| VarX -> exprToString VarY", "bad": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> let e' = buildThresh(a,b,c,d) in exprToString e'\n| Times (a,b) -> let e' = buildTimes(a,b) in exprToString e'\n| Average (a,b) -> let e' = buildAverage(a,b) in exprToString e'\n| Cosine (a) -> let e' = buildCosine(a) in exprToString e'\n| Sine (a) -> let e' = buildSine(a) in exprToString e'\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX", "annotated": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> let e' = buildThresh(a,b,c,d) in exprToString e'\n| Times (a,b) -> let e' = buildTimes(a,b) in exprToString e'\n| Average (a,b) -> let e' = buildAverage(a,b) in exprToString e'\n| Cosine (a) -> let e' = buildCosine(a) in exprToString e'\n| Sine (a) -> let e' = buildSine(a) in exprToString e'\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX"}
{"fix": "let sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "bad": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b ^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d ^ \")\"\n| Times (a,b) -> exprToString a ^ \"*\" ^ exprToString b\n| Average (a,b) -> \"((\" ^ exprToString a ^ \"+\" ^ exprToString b ^ \")/20\"\n| Cosine (a) -> \"cos(pi*\" ^ exprToString a ^ \")\"\n| Sine (a) -> \"sin(pi*\" ^ exprToString a ^ \")\"\n| VarY -> \"x\"\n| VarX -> \"y\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b ^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d ^ \")\"\n| Times (a,b) -> exprToString a ^ \"*\" ^ exprToString b\n| Average (a,b) -> \"((\" ^ exprToString a ^ \"+\" ^ exprToString b ^ \")/20\"\n| Cosine (a) -> \"cos(pi*\" ^ exprToString a ^ \")\"\n| Sine (a) -> \"sin(pi*\" ^ exprToString a ^ \")\"\n| VarY -> \"x\"\n| VarX -> \"y\""}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, t))/2\n| Cosine (a) -> cos ( pi * eval (a,x,y) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY -> x\n| VarX -> y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, t))/2\n| Cosine (a) -> cos ( pi * eval (a,x,y) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY -> x\n| VarX -> y"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos ( pi * eval (a,x,y) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY -> x\n| VarX -> y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos ( pi * eval (a,x,y) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY -> x\n| VarX -> y"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos ( pi * eval (a,x,y) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY -> float_of_int x\n| VarX -> float_of_int y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos ( pi * eval (a,x,y) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY -> float_of_int x\n| VarX -> float_of_int y"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos ( pi * float_of_int eval (a,x,y) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos ( pi * float_of_int eval (a,x,y) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos ( pi * float_of_int (eval (a,x,y)) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos ( pi * float_of_int (eval (a,x,y)) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> int_of_float cos ( pi * float_of_int (eval (a,x,y)) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> int_of_float cos ( pi * float_of_int (eval (a,x,y)) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> int_of_float cos( pi * float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> int_of_float cos( pi * float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) ->  cos( pi * float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) ->  cos( pi * float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos( pi * pi)\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos( pi * pi)\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos( pi )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos( pi )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) ( *.) eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) ( *.) eval (b, x, y))/2\n| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) ( *.) eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) ( *.) eval (b, x, y))/2\n| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) ( *.) (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y) ( *.) eval (b, x, y))/2\n| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) ( *.) (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y) ( *.) eval (b, x, y))/2\n| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y) ( *.) eval (b, x, y))/2\n| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y) ( *.) eval (b, x, y))/2\n| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y))/2\n| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y))/2\n| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y)) /. 2.0\n| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y)) /. 2.0\n| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y)) /. 2.0\n| Cosine (a) -> cos( pi * (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y)) /. 2.0\n| Cosine (a) -> cos( pi * (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y)) /. 2.0\n| Cosine (a) -> cos( pi ** (eval (a,x,y)))\n| Sine (a) -> sin (pi ** eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y)) /. 2.0\n| Cosine (a) -> cos( pi ** (eval (a,x,y)))\n| Sine (a) -> sin (pi ** eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y"}
{"fix": "let _ = eval (Average(VarX,VarY), 0.5, 0.0)", "bad": "let _ = eval (Sine(0.0))", "annotated": "let _ = eval (Sine(0.0))"}
{"fix": "let _ = eval (Average(VarX,VarY), 0.5, 0.0)", "bad": "let _ = eval (Sine(VarX ** VarY), 0.0, 0.0)", "annotated": "let _ = eval (Sine(VarX ** VarY), 0.0, 0.0)"}
{"fix": "let _ = eval (Average(VarX,VarY), 0.5, 0.0)", "bad": "let _ = eval (Average(VarX,VarY)), 0.0, 0.0", "annotated": "let _ = eval (Average(VarX,VarY)), 0.0, 0.0"}
{"fix": "let _ = eval (Average(VarX,VarY), 0.5, 0.0)", "bad": "let _ = eval (Average(VarX,VarY), 0.0, 0.0)", "annotated": "let _ = eval (Average(VarX,VarY), 0.0, 0.0)"}
{"fix": "let _ = eval (Times(VarX,VarY), 3.0, 2.0)", "bad": "let _ = eval (Times(VarX,VarY), 1.0, 2.0)", "annotated": "let _ = eval (Times(VarX,VarY), 1.0, 2.0)"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let rec wwhile (f,b) = \nlet f b -> (b',c')\nif f b = (b',c')\nthen wwhile(f,b)\nelse wwhile(f,b)", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet f b -> (b',c')\nif f b = (b',c')\nthen wwhile(f,b)\nelse wwhile(f,b)"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let rec wwhile (f,b) = \nlet x = f b", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet x = f b"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let rec wwhile (f,b) = \nlet (b',c') = f b in", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet (b',c') = f b in"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let rec wwhile (f,b) = \nlet (b',c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet (b',c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'"}
{"fix": "let g1 () = failwith \"to be implemented\"", "bad": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(0,1) in match x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet x = rand(5,10) in match x with\n| 5 -> buildSine( build (rand, depth - 1) )\n| 6 -> buildCosine( build (rand, depth - 1) )\n| 7 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 9 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0\nthen let x = rand(0,1) in match x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet x = rand(5,10) in match x with\n| 5 -> buildSine( build (rand, depth - 1) )\n| 6 -> buildCosine( build (rand, depth - 1) )\n| 7 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 9 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )"}
{"fix": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 -> buildX()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "bad": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,3) in match x with\n| 1 -> buildX()\n| 2 -> buildY()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0\nthen let x = rand(1,3) in match x with\n| 1 -> buildX()\n| 2 -> buildY()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )"}
{"fix": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 -> buildX()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "bad": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,3) in match x with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildX()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0\nthen let x = rand(1,3) in match x with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildX()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )"}
{"fix": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 -> buildX()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "bad": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 2 | 3 -> buildY()\n| 1 -> buildX()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 2 | 3 -> buildY()\n| 1 -> buildX()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )"}
{"fix": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 -> buildX()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "bad": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 -> buildX()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 -> buildX()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )"}
{"fix": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 -> buildX()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "bad": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 | 0 -> buildX()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 | 0 -> buildX()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )"}
{"fix": "let g1 () = failwith \"to be implemented\"", "bad": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 -> buildX()\nelse\nlet x = rand(1,10) in match x with\n| 6 | 1 -> buildSine( build (rand, depth - 1) )\n| 7 | 2 -> buildCosine( build (rand, depth - 1) )\n| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 -> buildX()\nelse\nlet x = rand(1,10) in match x with\n| 6 | 1 -> buildSine( build (rand, depth - 1) )\n| 7 | 2 -> buildCosine( build (rand, depth - 1) )\n| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )"}
{"fix": "let g1 () = failwith \"to be implemented\"", "bad": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 .. 5 -> buildY()\n| 6 .. 10 -> buildX()\nelse\nlet x = rand(1,10) in match x with\n| 6 | 1 -> buildSine( build (rand, depth - 1) )\n| 7 | 2 -> buildCosine( build (rand, depth - 1) )\n| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 .. 5 -> buildY()\n| 6 .. 10 -> buildX()\nelse\nlet x = rand(1,10) in match x with\n| 6 | 1 -> buildSine( build (rand, depth - 1) )\n| 7 | 2 -> buildCosine( build (rand, depth - 1) )\n| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )"}
{"fix": "let g1 () = failwith \"to be implemented\"", "bad": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in \nif x < 5 then buildY()\nelse buildX()\nelse\nlet x = rand(1,10) in match x with\n| 6 | 1 -> buildSine( build (rand, depth - 1) )\n| 7 | 2 -> buildCosine( build (rand, depth - 1) )\n| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0\nthen let x = rand(1,10) in \nif x < 5 then buildY()\nelse buildX()\nelse\nlet x = rand(1,10) in match x with\n| 6 | 1 -> buildSine( build (rand, depth - 1) )\n| 7 | 2 -> buildCosine( build (rand, depth - 1) )\n| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )"}
{"fix": "let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))", "bad": "let _ = \nlet g = makeRand (19,25) in\nlet e1 = build (g, 3) in Format.printf \"red   = %s \\n\" (exprToString e1)", "annotated": "let _ = \nlet g = makeRand (19,25) in\nlet e1 = build: ((int * int -> int) * int) -> expr = fun  (g, 3) in Format.printf \"red    ->  %s \\n\" (exprToString e1)"}
{"fix": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 -> buildX()\nelse\nlet x = rand(1,10) in match x with\n| 6 | 1 -> buildSine( build (rand, depth - 1) )\n| 7 | 2 -> buildCosine( build (rand, depth - 1) )\n| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "bad": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in \nif x < 5 then buildY()\nelse buildX()\nelse\nlet x = rand(1,10) in match x with\n| 6 | 1 -> buildSine( build (rand, depth - 1) )\n| 7 | 2 -> buildCosine( build (rand, depth - 1) )\n| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0\nthen let x = rand(1,10) in \nif x < 5 then buildY()\nelse buildX()\nelse\nlet x = rand(1,10) in match x with\n| 6 | 1 -> buildSine( build (rand, depth - 1) )\n| 7 | 2 -> buildCosine( build (rand, depth - 1) )\n| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )"}
{"fix": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "bad": "let rec assoc (d,k,l) = \nlet rec helper (a,b,c) = match c with\n| [] -> a\n| (n,v)::t -> \nif n = b then v\nelse helper (a,b,t)\nin helper (d,k,l)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  \nlet rec helper (a,b,c) = match c with\n| [] -> a\n| (n,v)::t -> \nif n = b then v\nelse helper (a,b,t)\nin helper (d,k,l)"}
{"fix": "let _ = assoc (0, \"hi\", [(\"hi\",3)])", "bad": "let _ = assoc (0, \"hi\", [])", "annotated": "let _ = assoc (0, \"hi\", [])"}
{"fix": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "bad": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (n,v)::t -> \nif n = k then v\nelse assoc (d,k,t)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with\n| [] -> d\n| (n,v)::t -> \nif n = k then v\nelse assoc (d,k,t)"}
{"fix": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = [] in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a*a + x in\nlet base = [] in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a**2 + x in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a**2 + x in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a^2 + x in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a^2 + x in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a^^2 + x in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a^^2 + x in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let pipe fs = \nlet f a x = match x with\n| x::xs' -> x a\nin\nlet base = (fun _ x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = match x with\n| [] -> (fun b -> b)\nin\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = match x with\n| [] -> (fun b -> b)\nin\nlet base = 0 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = match x with\n| x::xs' -> ( fun z d -> x d)\nin\nlet base = (fun _ y -> y) in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = (fun b a -> a x)in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = (fun y -> a x)in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = (fun y -> a x)in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (fun b c -> a x)in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (fun b c -> a x)in\nlet base = (fun y -> y) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (fun y -> a x) in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = ( fun c -> x ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = (fun y -> y) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = (fun y -> y) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = ( fun c -> x ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = ( fun c -> y ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = ( fun c -> y ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = ( fun c -> x ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "bad": "let (o) f g = fun x -> f (g x)", "annotated": "let (o) f g = fun x -> f (g x)"}
{"fix": "let pipe fs = \nlet f a x = ( fun c -> x ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "bad": "let foo   = (fun x -> x + 1) o (fun y -> 2 * y)", "annotated": "let foo   = (fun x -> x + 1) o (fun y -> 2 * y)"}
{"fix": "let pipe fs = \nlet f a x = ( fun c -> x ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "bad": "let ans  = foo 10", "annotated": "let ans  = foo 10"}
{"fix": "let pipe fs = \nlet f a x = ( fun y -> a (x y) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = ( fun c -> f a x ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = ( fun c -> f a x ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = ( fun y -> a (x y) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = ( fun c -> f (a x) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = ( fun c -> f (a x) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = ( fun y -> a (x y) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = ( fun c -> fun d -> (a x) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = ( fun c -> fun d -> (a x) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = ( fun y -> a (x y) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = ( fun x -> f (g x) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = ( fun x -> f (g x) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = ( fun y -> a (x y) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = ( fun y -> a (y x) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = ( fun y -> a (y x) ) in\nlet base = (fun b -> b) in\nList.fold_left f base fs"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (fun acc x -> x ^ cc) in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (fun acc x -> x ^ cc) in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (fun acc x -> x ^ acc) in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (fun acc x -> x ^ acc) in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (fun acc x -> x ^ acc) in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (fun acc x -> x ^ acc) in\nlet base = h in\nlet l = t in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (fun acc x -> x ^ acc) in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (fun acc x -> x ^ acc) in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" ^ h ^ \"\" in\nlet l = t in\nList.fold_left f base l", "bad": "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "annotated": "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]"}
{"fix": "let stringOfList f l = \n\"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"", "bad": "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "annotated": "let _ = stringOfList string_of_int [1;2;3;4;5;6]"}
{"fix": "let stringOfList f l = \n\"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"", "bad": "let stringOfList f l = \nList.map f (sepConcat \";\") l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \nList.map f (sepConcat \";\") l"}
{"fix": "let rec clone x n = match n with\n| 0 -> []\n| _ -> clone x (n-1) @ [x]", "bad": "let rec clone x n = match n with\n| 0 -> []\n| _ -> clone x (n-1) :: [h]", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with\n| 0 -> []\n| _ -> clone x (n-1) :: [h]"}
{"fix": "let rec clone x n = match n with\n| 0 -> []\n| _ -> clone x (n-1) @ [x]", "bad": "let rec clone x n = match n with\n| 0 -> []\n| _ -> clone x (n-1) :: [x]", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with\n| 0 -> []\n| _ -> clone x (n-1) :: [x]"}
{"fix": "let rec clone x n = match n with\n| 0 -> []\n| _ -> clone x (n-1) @ [x]", "bad": "let rec clone x n = match n with\n| 0 -> []\n| 1 -> clone x (n-1) :: [x]", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with\n| 0 -> []\n| 1 -> clone x (n-1) :: [x]"}
{"fix": "let rec removeZero l = match l with\n| [] -> l\n| h::t ->\nif h = 0 \nthen removeZero t\nelse l", "bad": "let rec removeZero l = match l with\n| [] -> l\n| h::t -> if h = 0 then removeZero t", "annotated": "let rec removeZero : int list -> int list = fun  l  ->  match l with\n| [] -> l\n| h::t -> if h = 0 then removeZero t"}
{"fix": "let rec removeZero l = match l with\n| [] -> l\n| h::t ->\nif h = 0 \nthen removeZero t\nelse l", "bad": "let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h = 0 then removeZero t", "annotated": "let rec removeZero : int list -> int list = fun  l  ->  match l with\n| [] -> []\n| h::t -> if h = 0 then removeZero t"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet a = h::t in \nmatch x with\n| (x1,x2) -> if x1 + x2 + h > 9 then 1 :: (h = x1 + x2 + h mod 10)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet a = h::t in \nmatch x with\n| (x1,x2) -> if x1 + x2 + h > 9 then 1 :: (h = x1 + x2 + h mod 10)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch a, x with\n| h::t, (x1,x2) -> if x1 + x2 + h > 9 then 1 :: (h = x1 + x2 + h mod 10)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nmatch a, x with\n| h::t, (x1,x2) -> if x1 + x2 + h > 9 then 1 :: (h = x1 + x2 + h mod 10)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch a, x with\n| h::t, (x1,x2) -> if x1 + x2 + h > 9 then 1 :: (x1 + x2 + h mod 10)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nmatch a, x with\n| h::t, (x1,x2) -> if x1 + x2 + h > 9 then 1 :: (x1 + x2 + h mod 10)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch a, x with\n| h::t, (x1,x2) -> if x1 + x2 + h > 9 then (1 :: (x1 + x2 + h mod 10))\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nmatch a, x with\n| h::t, (x1,x2) -> if x1 + x2 + h > 9 then (1 :: (x1 + x2 + h mod 10))\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch a, x with\n| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 1 :: (x1 + x2 + h mod 10)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nmatch a, x with\n| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 1 :: (x1 + x2 + h mod 10)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch a, x with\n| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9(*1 :: (x1 + x2 + h mod 10) *)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nmatch a, x with\n| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9(*1 :: (x1 + x2 + h mod 10) *)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch a, x with\n| h::t -> a * x\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nmatch a, x with\n| h::t -> a * x\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch a, x with\n| h::t, (x,y) -> a * x\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nmatch a, x with\n| h::t, (x,y) -> a * x\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| (h1,h2)::t -> [h1]\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| (h1,h2)::t -> [h1]\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nlet carry =\nmatch a with\n| (x,y) -> x in\nmatch x with\n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| (h1,h2)::t -> 9\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| (h1,h2)::t -> 9\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nlet carry =\nmatch a with\n| (x,y) -> x in\nmatch x with\n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| (h1,h2)::t -> [h1]\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| (h1,h2)::t -> [h1]\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nlet carry =\nmatch a with\n| (x,y) -> x in\nmatch x with\n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| h1::t -> [h1]\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| h1::t -> [h1]\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nlet carry =\nmatch a with\n| (x,y) -> x in\nmatch x with\n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| h1::t -> []\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| h1::t -> []\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nlet carry =\nmatch a with\n| (x,y) -> x in\nmatch x with\n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| h1 -> []\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| h1 -> []\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nlet carry =\nmatch a with\n| (x,y) -> x in\nmatch x with\n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| h1::t -> []\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| h1::t -> []\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nlet carry =\nmatch a with\n| (x,y) -> x in\nmatch x with\n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| h::t -> []\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| h::t -> []\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nlet carry =\nmatch a with\n| (x,y) -> x in\nmatch x with\n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| (h1,h2)::t -> []\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| (h1,h2)::t -> []\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nlet carry =\nmatch a with\n| (x,y) -> x in\nmatch x with\n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| h::t -> []\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| h::t -> []\n(*| h::t, (x1,x2)::t2 -> if x1 + x2 + h > 9 then 9 (*1 :: (x1 + x2 + h mod 10) *)*)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nlet carry =\nmatch a with\n| (x,y) -> x in\nmatch x with\n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| h::t -> []\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nmatch x with\n| h::t -> []\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nlet carry =\nmatch a with\n| (x,y) -> x in\nmatch x with\n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| h -> []\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| h -> []\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nlet carry =\nmatch a with\n| (x,y) -> x in\nmatch x with\n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1,h1) -> []\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1,h1) -> []\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nlet carry =\nmatch a with\n| (x,y) -> x in\nmatch x with\n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1,h2) -> []\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1,h2) -> []\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nlet carry =\nmatch a with\n| (x,y) -> x in\nmatch x with\n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1,h2) -> (h2,h1)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1,h2) -> (h2,h1)\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nlet carry =\nmatch a with\n| (x,y) -> x in\nmatch x with\n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1,h2) -> [h2]\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1,h2) -> [h2]\nin\nlet base =  [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 =\nlet add (l1, l2) =\nlet f a x =\nlet carry =\nmatch a with\n| (x,y) -> x in\nmatch x with\n| (addend_a,addend_b) -> let new_carry = (carry + addend_a + addend_b) /10 in\nlet digit = (carry + addend_a + addend_b) mod 10 in\nmatch a with\n| (x,y) -> (new_carry, digit::y) in\nlet base = (0,[]) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1,h2) -> [h2]\nin\nlet base =  [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1,h2) -> [h2]\nin\nlet base =  [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  f + g + carry mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet digit = match x with\n| (f,g)::t -> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)::t) else (0, (f+g+carry mod 10)::t)\nin digit\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet digit = match x with\n| (f,g)::t -> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)::t) else (0, (f+g+carry mod 10)::t)\nin digit\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  f + g + carry mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet digit = match x with\n| (f,g)-> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)::t) else (0, (f+g+carry mod 10)::t)\nin digit\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet digit = match x with\n| (f,g)-> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)::t) else (0, (f+g+carry mod 10)::t)\nin digit\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  f + g + carry mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet digit = match x with\n| (f,g)-> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)) else (0, (f+g+carry mod 10))\nin digit\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet digit = match x with\n| (f,g)-> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)) else (0, (f+g+carry mod 10))\nin digit\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  f + g + carry mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,[g])-> f\nin\nlet digit = match x with\n| (f,g)-> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)) else (0, (f+g+carry mod 10))\nin digit\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,[g])-> f\nin\nlet digit = match x with\n| (f,g)-> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)) else (0, (f+g+carry mod 10))\nin digit\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  f + g + carry mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet digit = match x with\n| (f,g)-> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)) else (0, (f+g+carry mod 10))\nin digit\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet digit = match x with\n| (f,g)-> if (f + g + carry) > 9 then (1,(f + g + carry mod 10)) else (0, (f+g+carry mod 10))\nin digit\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  f + g + carry mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  f + g + carry mod 10\nin \nmatch a with\n| (o,p) -> (newcarry, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  f + g + carry mod 10\nin \nmatch a with\n| (o,p) -> (newcarry, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\n| []   -> carry\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g)-> f\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\n| []   -> carry\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g) -> f\n| (f',g'::h)-> g'\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g) ->\n| (f',g'::h)-> g\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet carry = match a with\n| (f,g) ->\n| (f',g'::h)-> g\nin\nlet newc = match x with\n| (f,g) -> if (f + g + carry) > 9 then 1 else 0 \nin\nlet digit = match x with\n| (f,g)->  (f + g + carry) mod 10\nin \nmatch a with\n| (o,p) -> (newc, digit::p)\nin\nlet base = (0,[]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let rec mulByDigit i l = \nif i = 0 then l\nelse\nlet a = i :: [] in\nbigAdd (mulByDigit (i-1) l) (mulByDigit (i-1) l)", "bad": "let rec mulByDigit i l = \nif i = 0 then l\nelse\nlet a = i :: [] in\nbigAdd (mulByDigit i-1 l) (mulByDigit i-1 l)", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nif i = 0 then l\nelse\nlet a = i :: [] in\nbigAdd (mulByDigit i-1 l) (mulByDigit i-1 l)"}
{"fix": "let bigMul l1 l2 = \nlet f a x = match a with\n| (_,y) -> (0, bigAdd y x) in\nlet base = (0,[]) in\nlet args = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h b) :: acc) a t\nin\nconstructargs [] l1 (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = [] in\nlet args = match x with in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = failwith \"to be implemented\" in\nlet base = [] in\nlet args = match x with in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = match a with\n| (_,y) -> (0, bigAdd y x) in\nlet base = (0,[]) in\nlet args = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h b) :: acc) a t\nin\nconstructargs [] l1 (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = [] in\nlet args = match l2 with\nin\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = failwith \"to be implemented\" in\nlet base = [] in\nlet args = match l2 with\nin\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = match a with\n| (_,y) -> (0, bigAdd y x) in\nlet base = (0,[]) in\nlet args = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h b) :: acc) a t\nin\nconstructargs [] l1 (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = bigAdd a x in\nlet base = [] in\nlet args = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h b) :: acc) a t\nin\nconstructargs [] l1 (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = bigAdd a x in\nlet base = [] in\nlet args = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h b) :: acc) a t\nin\nconstructargs [] l1 (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = match a with\n| (_,y) -> (0, bigAdd y x) in\nlet base = (0,[]) in\nlet args = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h b) :: acc) a t\nin\nconstructargs [] l1 (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = match a with\n| (_,y) -> (0, bigAdd a x) in\nlet base = (0,[]) in\nlet args = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h b) :: acc) a t\nin\nconstructargs [] l1 (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match a with\n| (_,y) -> (0, bigAdd a x) in\nlet base = (0,[]) in\nlet args = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h b) :: acc) a t\nin\nconstructargs [] l1 (List.rev l2)\nin\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let unzeroed = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h a) :: acc) a t\nin\nconstructargs [] [1;2;3] (List.rev [4;5;6])\nin \nlet rec addZeroes num somelist = match num with\n| 0 -> somelist \n| _ -> addZeroes (num-1) (List.append somelist [0])\nin\nlet rec addZeroesWhole acc a = match a with\n| [] -> acc\n| h::t -> addZeroesWhole ( (addZeroes (List.length t) h) :: acc ) t\nin\naddZeroesWhole [] unzeroed", "bad": "let unzeroed = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h a) :: acc) a t\nin\nconstructargs [] [1;2;3] (List.rev [4;5;6])\nin \nlet rec addZeroes num somelist = match num with\n| 0 -> somelist \n| _ -> addZeroes (num-1) (List.append somelist 0)\nin\nlet rec addZeroesWhole acc a = match a with\n| [] -> acc\n| h::t -> addZeroesWhole ( (addZeroes (List.length t) h) :: acc ) t\nin\naddZeroesWhole [] unzeroed", "annotated": "let unzeroed = \nlet rec constructargs acc a b = match b with\n| [] -> acc\n| h::t -> constructargs ((mulByDigit h a) :: acc) a t\nin\nconstructargs [] [1;2;3] (List.rev [4;5;6])\nin \nlet rec addZeroes num somelist = match num with\n| 0 -> somelist \n| _ -> addZeroes (num-1) (List.append somelist 0)\nin\nlet rec addZeroesWhole acc a = match a with\n| [] -> acc\n| h::t -> addZeroesWhole ( (addZeroes (List.length t) h) :: acc ) t\nin\naddZeroesWhole [] unzeroed"}
{"fix": "let rec mulByDigit i l = \nif i <= 0 then [0] else\nif i = 1 then l\nelse\nbigAdd (mulByDigit (i-1) l)  l", "bad": "let rec mulByDigit i l = \nif i <= 0 then 0 else\nif i = 1 then l\nelse\nbigAdd (mulByDigit (i-1) l)  l", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nif i <= 0 then 0 else\nif i = 1 then l\nelse\nbigAdd (mulByDigit (i-1) l)  l"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse let x = n/10 and y = n mod 10\nin digitsOfInt x @ y", "bad": "let rec digitsOfInt n = \nlet x = n/10 \nand y = n mod 10\nand if y = 0 && x = 0 then []::resultList\nelse y::resultList -> digitsOfInt x", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet x = n/10 \nand y = n mod 10\nand if y = 0 && x = 0 then []::resultList\nelse y::resultList -> digitsOfInt x"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse let x = n/10 and y = n mod 10\nin digitsOfInt x @ y", "bad": "let rec digitsOfInt n = \nlet x = n/10 \nand y = n mod 10 in\nif y = 0 && x = 0 then []::resultList\nelse y::resultList -> digitsOfInt x", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet x = n/10 \nand y = n mod 10 in\nif y = 0 && x = 0 then []::resultList\nelse y::resultList -> digitsOfInt x"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse let x = n/10 and y = n mod 10\nin digitsOfInt x @ y", "bad": "let rec digitsOfInt n = \nlet x = n/10 \nand y = n mod 10 in\nif y = 0 && x = 0 then []::resultList\nelse y::resultList -> y :: digitsOfInt x", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet x = n/10 \nand y = n mod 10 in\nif y = 0 && x = 0 then []::resultList\nelse y::resultList -> y :: digitsOfInt x"}
{"fix": "let _ = digitsOfInt (-300)", "bad": "let _ = digitsOfInt (digits -300)", "annotated": "let _ = digitsOfInt (digits -300)"}
{"fix": "let _ = digitsOfInt (-300)", "bad": "let _ = digitsOfInt (digits (-300))", "annotated": "let _ = digitsOfInt (digits (-300))"}
{"fix": "let x = sumList (digitsOfInt 10)", "bad": "let x = sumList digitsOfInt 10", "annotated": "let x = sumList digitsOfInt 10"}
{"fix": "let x = sumList (digitsOfInt 10)", "bad": "let x = sumList digitsOfInt 10", "annotated": "let x = sumList digitsOfInt 10"}
{"fix": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse l'", "bad": "let rec listReverse l = \n| [] -> 0\n| x :: l' -> listReverse l' @ [x]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \n| [] -> 0\n| x :: l' -> listReverse l' @ [x]"}
{"fix": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse l'", "bad": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse l' @ [x]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse l' @ [x]"}
{"fix": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse l'", "bad": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse [l'] @ [x]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse [l'] @ [x]"}
{"fix": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse l'", "bad": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse [l'] @ [x]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse [l'] @ [x]"}
{"fix": "let rec listReverse l = \nmatch l with\n| [] -> []\n| head::tail -> listReverse tail @ head", "bad": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse l'::x", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse l'::x"}
{"fix": "let rec listReverse l = \nmatch l with\n| [] -> []\n| head::tail -> listReverse tail @ head", "bad": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse l'::[x]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse l'::[x]"}
{"fix": "let rec listReverse l = \nmatch l with\n| [] -> []\n| head::tail -> listReverse tail @ head", "bad": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> \n\n(* uncomment and run AFTER you have implemented listReverse\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n*)\n\n(* explode : string -> char list \n* (explode s) is the list of characters in the string s in the order in \n*   which they appear\n* e.g.  (explode \"Hello\") is ['H';'e';'l';'l';'o']\n*)\nlet explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> 0\n| x :: l' -> \n\n(* uncomment and run AFTER you have implemented listReverse\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n*)\n\n(* explode : string -> char list \n* (explode s) is the list of characters in the string s in the order in \n*   which they appear\n* e.g.  (explode \"Hello\") is ['H';'e';'l';'l';'o']\n*)\nlet explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0"}
{"fix": "let rec listReverse l = \nmatch l with\n| [] -> []\n| head::tail -> listReverse tail @ head", "bad": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: xl -> listReverse x :: []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> 0\n| x :: xl -> listReverse x :: []"}
{"fix": "let rec listReverse l = \nmatch l with\n| [] -> []\n| head::tail -> listReverse tail @ head", "bad": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: xl -> listReverse xl :: []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> 0\n| x :: xl -> listReverse xl :: []"}
{"fix": "let rec listReverse l = \nmatch l with\n| [] -> []\n| head::tail -> listReverse tail @ head", "bad": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| head::tail -> tail", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> 0\n| head::tail -> tail"}
{"fix": "let rec listReverse l = \nmatch l with\n| [] -> []\n| head::tail -> listReverse tail @ head", "bad": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| head :: tail -> tail", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> 0\n| head :: tail -> tail"}
{"fix": "let palindrome w = \n(listReverse (explode w))", "bad": "let palindrome w = \nif listReverse explode w = w then true\nelse false", "annotated": "let palindrome : string -> bool = fun  w  ->  \nif listReverse explode w = w then true\nelse false"}
{"fix": "let palindrome w = \n(listReverse (explode w))", "bad": "let palindrome w = \nif (listReverse (explode w)) = w then true\nelse false", "annotated": "let palindrome : string -> bool = fun  w  ->  \nif (listReverse (explode w)) = w then true\nelse false"}
{"fix": "let palindrome w = \nif (listReverse (explode w)) = explode w then true\nelse false", "bad": "let palindrome w = \nif (listReverse (explode w)) = w then 1\nelse 0", "annotated": "let palindrome : string -> bool = fun  w  ->  \nif (listReverse (explode w)) = w then 1\nelse 0"}
{"fix": "let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::third -> head::[tail]", "bad": "let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::t::s -> s::t::tail::head", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::t::s -> s::t::tail::head"}
{"fix": "let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::third -> head::[tail]", "bad": "let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::t::s -> s::t::tail::head", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::t::s -> s::t::tail::head"}
{"fix": "let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::third -> head::[tail]", "bad": "let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::t::s = l -> s::t::tail::head", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::t::s = l -> s::t::tail::head"}
{"fix": "let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::third -> head::[tail]", "bad": "let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::t::s::l -> s::t::tail::head", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::t::s::l -> s::t::tail::head"}
{"fix": "let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::third -> head::[tail]", "bad": "let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::third -> head::tail", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::third -> head::tail"}
{"fix": "let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::third::fourth::fifth -> fourth::third::tail::[head]", "bad": "let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::third::fourth -> fourth::third::tail::[head]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail::third::fourth -> fourth::third::tail::[head]"}
{"fix": "let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail -> head::listReverse tail", "bad": "let rec listReverse l = \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail -> head::listReverse tail::tail", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> []\n| [x] -> [x]\n| head::tail -> head::listReverse tail::tail"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverseInt n 0/10 \nand y = reverseInt n 0 mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet m = n", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse \nlet m = n"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverseInt n 0/10 \nand y = reverseInt n 0 mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "bad": "let x = m/10 \nand y = m mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "annotated": "let x = m/10 \nand y = m mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverseInt n 0/10 \nand y = reverseInt n 0 mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet m = n \nand x = m/10 \nand y = m mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse \nlet m = n \nand x = m/10 \nand y = m mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverseInt n 0/10 \nand y = reverseInt n 0 mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet m = n \nand x = m/10 \nand y = m mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse \nlet m = n \nand x = m/10 \nand y = m mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverseInt n 0/10 \nand y = reverseInt n 0 mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet m = n \nand x = m/10 \nand y = m mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse \nlet m = n \nand x = m/10 \nand y = m mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverseInt n 0/10 \nand y = reverseInt n 0 mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet m = reverseInt n\nand x = m/10 \nand y = m mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse \nlet m = reverseInt n\nand x = m/10 \nand y = m mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverseInt n 0/10 \nand y = reverseInt n 0 mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet m = reverseInt n\nin let x = m/10 \nand y = m mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse \nlet m = reverseInt n\nin let x = m/10 \nand y = m mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverseInt n 0/10 \nand y = reverseInt n 0 mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverseInt n/10 \nand y = reverseInt n mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse \nlet x = reverseInt n/10 \nand y = reverseInt n mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverseInt n 0/10 \nand y = reverseInt n 0 mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverseInt n 0/10 \nand y = reverseInt n mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse \nlet x = reverseInt n 0/10 \nand y = reverseInt n mod 10 in \nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverse (string_of_int n) \nand y= x /10 \nand z = x mod 10 in \nif y = 0 && z = 0 then []\nelse z::digitsOfInt y", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse \nlet x = reverse (string_of_int n) \nand y= x /10 \nand z = x mod 10 in \nif y = 0 && z = 0 then []\nelse z::digitsOfInt y"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverse (string_of_int n) \nand y= x /10 \nand z = x mod 10 in \nif y = 0 && z = 0 then []\nelse z::digitsOfInt y", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse \nlet x = reverse (string_of_int n) \nand y= x /10 \nand z = x mod 10 in \nif y = 0 && z = 0 then []\nelse z::digitsOfInt y"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverse (string_of_int n) \nand y= x /10 \nand z = x mod 10 in \nif y = 0 && z = 0 then []\nelse z::digitsOfInt y", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse \nlet x = reverse (string_of_int n) \nand y= x /10 \nand z = x mod 10 in \nif y = 0 && z = 0 then []\nelse z::digitsOfInt y"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = reverse (string_of_int n) \nand y= x /10 \nand z = x mod 10 in \nif y = 0 && z = 0 then []\nelse z::digitsOfInt y", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse \nlet x = reverse (string_of_int n) \nand y= x /10 \nand z = x mod 10 in \nif y = 0 && z = 0 then []\nelse z::digitsOfInt y"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet x = int_of_string reverse (string_of_int n) \nand y= x /10 \nand z = x mod 10 in \nif y = 0 && z = 0 then []\nelse z::digitsOfInt y", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse \nlet x = int_of_string reverse (string_of_int n) \nand y= x /10 \nand z = x mod 10 in \nif y = 0 && z = 0 then []\nelse z::digitsOfInt y"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet s = reverse (string_of_int n) \nand n2 = int_of_string s  \nand z = x mod 10 in \nif y = 0 && z = 0 then []\nelse z::digitsOfInt y", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse \nlet s = reverse (string_of_int n) \nand n2 = int_of_string s  \nand z = x mod 10 in \nif y = 0 && z = 0 then []\nelse z::digitsOfInt y"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet s = reverse (string_of_int n) in\nlet n2 = int_of_string s  \nand z = x mod 10 in \nif y = 0 && z = 0 then []\nelse z::digitsOfInt y", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse \nlet s = reverse (string_of_int n) in\nlet n2 = int_of_string s  \nand z = x mod 10 in \nif y = 0 && z = 0 then []\nelse z::digitsOfInt y"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse \nlet s = reverse (string_of_int n) in\nlet n2 = int_of_string s  in\nlet x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse \nlet s = reverse (string_of_int n) in\nlet n2 = int_of_string s  in\nlet x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 and let n2 = reverse n in z = z+1", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse if z = 0 and let n2 = reverse n in z = z+1"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "annotated": "let x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse if z = 0"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let n2 = reverse n in z = z+1", "annotated": "let n2 = reverse n in z = z+1"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "annotated": "let x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then let n2 = reverse n in z = z+1", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse if z = 0 then let n2 = reverse n in z = z+1"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "annotated": "let x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then let n2 = reverse (string_of_int n) in z = z+1", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse if z = 0 then let n2 = reverse (string_of_int n) in z = z+1"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "annotated": "let x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then let n2 = reverse (string_of_int n) in z+1", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse if z = 0 then let n2 = reverse (string_of_int n) in z+1"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "annotated": "let x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then let n2 = reverse (string_of_int n)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse if z = 0 then let n2 = reverse (string_of_int n)"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "annotated": "let x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitOfInt n2", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse if z = 0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitOfInt n2"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "annotated": "let x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse if z = 0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "annotated": "let x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2;\nlet x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse if z = 0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2;\nlet x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2;\nelse \nlet x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse if z = 0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2;\nelse \nlet x = n2/10 \nand y = n2 mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse if z = 0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}
{"fix": "let rec digitsOfInt n =\nlet s = string_of_int n in\nlet s2 = String.length s in\nfor i=0 to (s2-1)/2 do\nlet c = s.[i] in\ns.[i] <- s.[n-i-1];\ns.[n-i-1] <- c;\ndone;\nint_of_string s", "bad": "let rec digitsOfInt n =\nlet s = string_of_int n in\nlet s2 = String.length s in\nfor i=0 to (s2-1)/2 do\nlet c = s2.[i] in\ns2.[i] <- s2.[n-i-1];\ns2.[n-i-1] <- c;\ndone;\nint_of_string s2", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nlet s = string_of_int n in\nlet s2 = String.length s in\nfor i=0 to (s2-1)/2 do\nlet c = s2.[i] in\ns2.[i] <- s2.[n-i-1];\ns2.[n-i-1] <- c;\ndone;\nint_of_string s2"}
{"fix": "let rec digitsOfInt n =\nlet s = string_of_int n in\nlet s2 = String.length s in\nfor i=0 to (s2-1)/2 do\nlet c = s.[i] in\ns.[i] <- s.[n-i-1];\ns.[n-i-1] <- c;\ndone;\nint_of_string s", "bad": "let rec digitsOfInt n =\nlet s = string_of_int n in\nlet s2 = String.length s in\nfor i=0 to (s2-1)/2 do\nlet c = s2.[i] in\ns2.[i] <- s2.[n-i-1];\ns2.[n-i-1] <- c;\ndone;\nint_of_string s2", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nlet s = string_of_int n in\nlet s2 = String.length s in\nfor i=0 to (s2-1)/2 do\nlet c = s2.[i] in\ns2.[i] <- s2.[n-i-1];\ns2.[n-i-1] <- c;\ndone;\nint_of_string s2"}
{"fix": "let rec digitsOfInt n =\nlet s = string_of_int n in\nlet s2 = String.length s in\nfor i=0 to (s2-1)/2 do\nlet c = s.[i] in\ns.[i] <- s.[n-i-1];\ns.[n-i-1] <- c;\ndone;\nint_of_string s", "bad": "let rec digitsOfInt n =\nlet s = string_of_int n in\nlet s2 = String.length s in\nfor i=0 to (s2-1)/2 do\nlet c = s2.[i] in\ns2.[i] <- s2.[n-i-1];\ns2.[n-i-1] <- c;\ndone;\nint_of_string s2", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nlet s = string_of_int n in\nlet s2 = String.length s in\nfor i=0 to (s2-1)/2 do\nlet c = s2.[i] in\ns2.[i] <- s2.[n-i-1];\ns2.[n-i-1] <- c;\ndone;\nint_of_string s2"}
{"fix": "let rec digitsOfInt n =\nlet s = string_of_int n in\nlet s2 = String.length s in\nfor i=0 to (s2-1)/2 do\nlet c = s.[i] in\ns.[i] <- s.[n-i-1];\ns.[n-i-1] <- c;\ndone;\nint_of_string s", "bad": "let rec reverse s2 = \nelse let x = s2/10 \nand y = s2 mod 10 in\nif x = 0 & y = 0 then []\nelse y::reverse x", "annotated": "let rec reverse s2 = \nelse let x = s2/10 \nand y = s2 mod 10 in\nif x = 0 & y = 0 then []\nelse y::reverse x"}
{"fix": "let rec digitsOfInt n =\nlet s = string_of_int n in\nlet s2 = String.length s in\nfor i=0 to (s2-1)/2 do\nlet c = s.[i] in\ns.[i] <- s.[n-i-1];\ns.[n-i-1] <- c;\ndone;\nint_of_string s", "bad": "let rec digitsOfInt n =\nlet s = string_of_int n in\nlet s2 = String.length s in\nfor i=0 to (s2-1)/2 do\nlet c = s2.[i] in\ns2.[i] <- s2.[n-i-1];\ns2.[n-i-1] <- c;\ndone;\nint_of_string s2", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nlet s = string_of_int n in\nlet s2 = String.length s in\nfor i=0 to (s2-1)/2 do\nlet c = s2.[i] in\ns2.[i] <- s2.[n-i-1];\ns2.[n-i-1] <- c;\ndone;\nint_of_string s2"}
{"fix": "let rec digitsOfInt n =\nlet s = string_of_int n in\nlet s2 = String.length s in\nfor i=0 to (s2-1)/2 do\nlet c = s.[i] in\ns.[i] <- s.[n-i-1];\ns.[n-i-1] <- c;\ndone;\nint_of_string s", "bad": "let rec reverse s2 = \nelse let x = s2/10 \nand y = s2 mod 10 in\nif x = 0 & y = 0 then []\nelse y::reverse x", "annotated": "let rec reverse s2 = \nelse let x = s2/10 \nand y = s2 mod 10 in\nif x = 0 & y = 0 then []\nelse y::reverse x"}
{"fix": "let z = 0", "bad": "let z = 0;\n\nlet rec digitsOfInt n = \nif n < 0 then []\nelse if z = 0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "annotated": "let z = 0;\n\nlet rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse if z = 0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}
{"fix": "let rec digitsOfInt n z= \nif n < 0 then []\nelse if z=0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "bad": "let _ = digitsOfInt 3124", "annotated": "let _ = digitsOfInt 3124"}
{"fix": "let rec digitsOfInt n z= \nif n < 0 then []\nelse if z=0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "bad": "let _ = digitsOfInt 352663", "annotated": "let _ = digitsOfInt 352663"}
{"fix": "let rec digitsOfInt n z= \nif n < 0 then []\nelse if z=0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "bad": "let _ = digitsOfInt (-42313)", "annotated": "let _ = digitsOfInt (-42313)"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "bad": "let rec digitsOfInt n z= \nif n < 0 then []\nelse if z=0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "annotated": "let rec digitsOfInt : int -> int list = fun  n z ->  \nif n < 0 then []\nelse if z=0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "bad": "let rec digitsOfInt n z= \nif n < 0 then []\nelse if z=0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2 0;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "annotated": "let rec digitsOfInt : int -> int list = fun  n z ->  \nif n < 0 then []\nelse if z=0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2 0;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "bad": "let rec digitsOfInt n z= \nif n < 0 then []\nelse if z=0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2 0;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x 0", "annotated": "let rec digitsOfInt : int -> int list = fun  n z ->  \nif n < 0 then []\nelse if z=0 then \nlet n2 = reverse (string_of_int n)\nand z = 1 in \ndigitsOfInt n2 0;\nelse \nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x 0"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "bad": "let _ = digitsOfInt 3124", "annotated": "let _ = digitsOfInt 3124"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "bad": "let _ = digitsOfInt 352663", "annotated": "let _ = digitsOfInt 352663"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "bad": "let _ = digitsOfInt (-42313)", "annotated": "let _ = digitsOfInt (-42313)"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nlet x = n/10 \nand y = n mod 10 in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "bad": "let _ = digitsOfInt (-42313)", "annotated": "let _ = digitsOfInt (-42313)"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n)\nand rest = n. - 1.*(10.**s.) in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n)\nand rest = n. - 1.*(10.**s.) in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n)\nand rest = float_of_int n - 1.*(10.** float_of_int s) in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n)\nand rest = float_of_int n - 1.*(10.** float_of_int s) in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n)\nand rest = (float_of_int n) - 1.*(10.** float_of_int s) in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n)\nand rest = (float_of_int n) - 1.*(10.** float_of_int s) in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n)\nand rest = n - 1* int_of_float (10 ** float_of_int s) in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n)\nand rest = n - 1* int_of_float (10 ** float_of_int s) in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n)\nand rest = n - 1* int_of_float (10. ** float_of_int s) in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n)\nand rest = n - 1* int_of_float (10. ** float_of_int s) in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n) in\nlet rest = n - 1* int_of_float (10. ** float_of_int s) in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n) in\nlet rest = n - 1* int_of_float (10. ** float_of_int s) in\nif x = 0 && y = 0 then []\nelse y::digitsOfInt x"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n) in\nlet rest = n - 1* int_of_float (10. ** float_of_int s) in\nhead::digitsOfInt rest", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n) in\nlet rest = n - 1* int_of_float (10. ** float_of_int s) in\nhead::digitsOfInt rest"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n) in\nlet rest = head - 1* int_of_float (10. ** float_of_int s) in\nhead::digitsOfInt rest", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n) in\nlet rest = head - 1* int_of_float (10. ** float_of_int s) in\nhead::digitsOfInt rest"}
{"fix": "let rec rev s =\nlet n = String.length s in\nfor i=0 to (n - 1) / 2 do\nlet c = s.[i] in\ns.[i] <- s.[n-i-1];\ns.[n-i-1] <- c;\ndone;\nint_of_string s", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n) in\nlet rest = head - 1* int_of_float (10. ** float_of_int s);\nhead::digitsOfInt rest", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n) in\nlet rest = head - 1* int_of_float (10. ** float_of_int s);\nhead::digitsOfInt rest"}
{"fix": "let rec rev s =\nlet n = String.length s in\nfor i=0 to (n - 1) / 2 do\nlet c = s.[i] in\ns.[i] <- s.[n-i-1];\ns.[n-i-1] <- c;\ndone;\nint_of_string s", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n) in\nlet rest = head - 1* int_of_float (10. ** float_of_int s) in\nhead::digitsOfInt rest", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse if n < 10 then [n]\nelse \nlet head = getFirst n\nand s = String.length (string_of_int n) in\nlet rest = head - 1* int_of_float (10. ** float_of_int s) in\nhead::digitsOfInt rest"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (a,i)::t -> \nif a = k then i \nelse \nassoc (d,k,t)", "bad": "let fixpoint (f,b) = wwhile (f,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (f,b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile (f b,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (f b,b)"}
{"fix": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sine(pi*\" ^ exprToString e1 ^ \")\"", "bad": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine -> \"sine(pi*\" ^ exprToString e ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine -> \"sine(pi*\" ^ exprToString e ^ \")\""}
{"fix": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sine(pi*\" ^ exprToString e1 ^ \")\"", "bad": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sine(pi*\" ^ exprToString e1 ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sine(pi*\" ^ exprToString e1 ^ \")\""}
{"fix": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\" ^ exprToString e1 ^ \")\"\n| Cosine e2 -> \"cos(pi*\" ^ exprToString e2 ^ \")\"\n| Average (e3,e4) -> \"((\" ^ exprToString e3 ^ \"+\" ^ exprToString e4 ^ \")/2)\"\n| Times (e5,e6) -> exprToString e5 ^ \"*\" ^ exprToString e6\n| Thresh (e7,e8,e9,e10) -> \"(\" ^ exprToString e7 ^ \"<\" ^ exprToString e8 ^ \"?\" ^ exprToString e9 ^ \":\" ^ exprToString e10 ^ \")\"", "bad": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\" ^ exprToString e1 ^ \")\"\n| Cosine e2 -> \"cos(pi*\" ^ exprToString e2 ^ \")\"\n| Average (e3,e4) -> \"((\" ^ exprToString e3 ^ \"+\" ^ exprToString e4 ^ \")/2)\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\" ^ exprToString e1 ^ \")\"\n| Cosine e2 -> \"cos(pi*\" ^ exprToString e2 ^ \")\"\n| Average (e3,e4) -> \"((\" ^ exprToString e3 ^ \"+\" ^ exprToString e4 ^ \")/2)\""}
{"fix": "let _ = eval (Sine(Varx),1,1)", "bad": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))"}
{"fix": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/2", "bad": "let _ = eval (Sine(VarX),1,1)", "annotated": "let _ = eval (Sine(VarX),1,1)"}
{"fix": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/2", "bad": "let _ = eval (Sine(VarX),1.0,1.0)", "annotated": "let _ = eval (Sine(VarX),1.0,1.0)"}
{"fix": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.\n| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)", "bad": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> float_of_int x\n| VarY -> float_of_int y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> float_of_int (eval(e1,x,y) + eval(e2,x,y))/2", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with\n| VarX -> float_of_int x\n| VarY -> float_of_int y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> float_of_int (eval(e1,x,y) + eval(e2,x,y))/2"}
{"fix": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.\n| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)", "bad": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) + eval(e2,x,y))/.2", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) + eval(e2,x,y))/.2"}
{"fix": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.\n| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)", "bad": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) + eval(e2,x,y))/.2", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) + eval(e2,x,y))/.2"}
{"fix": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.\n| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)", "bad": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2"}
{"fix": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.\n| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)", "bad": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2"}
{"fix": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.\n| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)", "bad": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2."}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (a,i)::t -> \nif a = k then i \nelse \nassoc (d,k,t)", "bad": "let fixpoint (f,b) = wwhile (fun y b -> (f b, true),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (fun y b -> (f b, true),b)"}
{"fix": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (a,i)::t -> \nif a = k then i \nelse \nassoc (d,k,t)", "bad": "let fixpoint (f,b) = wwhile ((fun y b -> (f b, true)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((fun y b -> (f b, true)),b)"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let fixpoint (f,b) = wwhile ((f b, f b = b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((f b, f b  ->  b),b)"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let fixpoint (f,b) = wwhile (fun y = (f b, f b = b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun y = (f b, f b  ->  b),b)"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let fixpoint (f,b) = wwhile (fun y -> (f b, f b = b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun y -> (f b, f b  ->  b),b)"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let fixpoint (f,b) = wwhile (fun y -> (f b, f b != b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun y -> (f b, f b ! ->  b),b)"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let fixpoint (f,b) = wwhile (fun y b-> (f b, f b != b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun y b-> (f b, f b ! ->  b),b)"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let fixpoint (f,b) = wwhile (fun y -> \nlet x = f b in\nif x = b then (x, true)\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (fun y -> \nlet x = f b in\nif x = b then (x, true)\n,b)"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let fixpoint (f,b) = wwhile (fun y b-> \nlet x = f b in\nif x = b then (x, true)\nelse y x \n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (fun y b-> \nlet x = f b in\nif x = b then (x, true)\nelse y x \n,b)"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let fixpoint (f,b) = wwhile (let y x = \nlet z = f x in\nif z = b then (x, true)\nelse y z,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let y x  ->  \nlet z = f x in\nif z = b then (x, true)\nelse y z,b)"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let fixpoint (f,b) = wwhile (let y x = \nlet z = f x in\nif z = b then (x, true)\nelse y z\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let y x  ->  \nlet z = f x in\nif z = b then (x, true)\nelse y z\n,b)"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let fixpoint (f,b) = wwhile (let y x = \nlet z = f x in\nif z = b then (x, true)\nelse y z\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let y x  ->  \nlet z = f x in\nif z = b then (x, true)\nelse y z\n,b)"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let fixpoint (f,b) = wwhile (fun y x -> \nlet z = f x in\nif z = b then (x, true)\nelse y z\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (fun y x -> \nlet z = f x in\nif z = b then (x, true)\nelse y z\n,b)"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let fixpoint (f,b) = wwhile (fun y x -> \nlet z = f x in\nif z = b then (x, true)\nelse y z in wwhile(y, x)\n,b", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (fun y x -> \nlet z = f x in\nif z = b then (x, true)\nelse y z in wwhile(y, x)\n,b"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": ")", "annotated": ")"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let fixpoint (f,b) = wwhile (fun y x -> \nlet z = f x in\nif z = b then (x, true)\nelse y z in wwhile(y, b)\n,b", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (fun y x -> \nlet z = f x in\nif z = b then (x, true)\nelse y z in wwhile(y, b)\n,b"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": ")", "annotated": ")"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let fixpoint (f,b) = wwhile ((fun y x -> \nlet z = f x in\nif z = b then (x, true)\nelse y z in wwhile(y, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((fun y x -> \nlet z = f x in\nif z = b then (x, true)\nelse y z in wwhile(y, b)"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": ")\n,b", "annotated": ")\n,b"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": ")", "annotated": ")"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let fixpoint (f,b) = wwhile (let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let f x = let xx  ->  x*x*x in (xx, xx < 100) in\nwwhile (f, 2),b)"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let fixpoint (f,b) = wwhile (let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let f x = let xx  ->  x*x*x in (xx, xx < 100) in\nwwhile (f, 2),b)"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let fixpoint (f,b) = wwhile (let f x = let xx = x*x*x in (xx, xx < 100),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let f x = let xx  ->  x*x*x in (xx, xx < 100),b)"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let fixpoint (f,b) = wwhile (let y x = let xx = x*x*x in (xx, xx < 100),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let y x = let xx  ->  x*x*x in (xx, xx < 100),b)"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let fixpoint (f,b) = wwhile ((let y x = let xx = x*x*x in (xx, xx < 100)), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let y x = let xx  ->  x*x*x in (xx, xx < 100)), b)"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let fixpoint (f,b) = wwhile (fun y x-> (f x, f x != b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun y x-> (f x, f x ! ->  b), b)"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let fixpoint (f,b) = wwhile ((fun y x-> (f x, f x != b)), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun y x-> (f x, f x ! ->  b)), b)"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let fixpoint (f,b) = wwhile (fun y -> (f b, f b != b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun y -> (f b, f b ! ->  b), b)"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let fixpoint (f,b) = wwhile (fun y -> ((f b), (f b) != b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun y -> ((f b), (f b) ! ->  b), b)"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let fixpoint (f,b) = wwhile (fun y b-> (f b, f b != b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (fun y b-> (f b, f b ! ->  b), b)"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let fixpoint (f,b) = wwhile (let y b =\nlet xx = f b in\n(xx, xx != b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let y b  -> \nlet xx = f b in\n(xx, xx != b), b)"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let fixpoint (f,b) = wwhile (let y b1 =\nlet xx = f b1 in\n(xx, xx != b), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let y b1  -> \nlet xx = f b1 in\n(xx, xx != b), b)"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let fixpoint (f,b) = wwhile (let y b1 =\nlet xx = f b1 in\n(xx, xx != b1), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let y b1  -> \nlet xx = f b1 in\n(xx, xx != b1), b)"}
{"fix": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "bad": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(******************* Functions you need to write **********)\n\n(* build: (int*int->int) * int -> Expr \nBuild an expression tree.  The second argument is the depth, \nthe first is a random function.  A call to rand(2,5) will give\nyou a random number in the range [2,5].\n\nYour code should call buildX, buildSine, etc. to construct\nthe expression.\n*)\n\nmakeRand(1,2)", "annotated": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(******************* Functions you need to write **********)\n\n(* build: (int*int->int) * int -> Expr \nBuild an expression tree.  The second argument is the depth, \nthe first is a random function.  A call to rand(2,5) will give\nyou a random number in the range [2,5].\n\nYour code should call buildX, buildSine, etc. to construct\nthe expression.\n*)\n\nmakeRand(1,2)"}
{"fix": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "bad": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(******************* Functions you need to write **********)\n\n(* build: (int*int->int) * int -> Expr \nBuild an expression tree.  The second argument is the depth, \nthe first is a random function.  A call to rand(2,5) will give\nyou a random number in the range [2,5].\n\nYour code should call buildX, buildSine, etc. to construct\nthe expression.\n*)\n\n\n\nmakeRand(1,2)", "annotated": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))\n\n\n(******************* Functions you need to write **********)\n\n(* build: (int*int->int) * int -> Expr \nBuild an expression tree.  The second argument is the depth, \nthe first is a random function.  A call to rand(2,5) will give\nyou a random number in the range [2,5].\n\nYour code should call buildX, buildSine, etc. to construct\nthe expression.\n*)\n\n\n\nmakeRand(1,2)"}
{"fix": "let rec build (rand, depth) = \nlet rand = makeRand (1,7) in\nlet x = rand(1,7) in x", "bad": "let rec build (rand, depth) = \nlet rand = makeRand (1,7) in\nlet x = rand(1,7)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet rand = makeRand (1,7) in\nlet x = rand(1,7)"}
{"fix": "let rec build (rand, depth) = \nlet rand = makeRand (1,7) in\nlet x = rand(1,7) in x", "bad": "let rec build (rand, depth) = \nlet rand = makeRand (1,7) in\nlet x = rand(1,7) in rand", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet rand = makeRand (1,7) in\nlet x = rand(1,7) in rand"}
{"fix": "let rand = makeRand(1,7)", "bad": "let rec build (rand, depth) = \nlet rand = makeRand (1,7) in\nlet x = rand(1,7) in x", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet rand = makeRand (1,7) in\nlet x = rand(1,7) in x"}
{"fix": "let rec build (rand, depth) = \nlet x = rand(0,6) in \nmatch x with \n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 3 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))", "bad": "let rec build (rand, depth) = \nlet x = rand(1,7) in \nmatch x with \n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 4 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet x = rand(1,7) in \nmatch x with \n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 4 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))"}
{"fix": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.\n| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh(e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then \neval(e3,x,y)\nelse eval(e4,x,y)\n| Power(e1,e2) -> eval(e1,x,y) ** eval(e2,x,y)\n| AddThree(e1,e2,e3) -> eval(e1,x,y) +. eval(e2,x,y) +. eval(e3,x,y)", "bad": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.\n| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh(e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then \neval(e3,x,y)\nelse eval(e4,x,y)\n| Power(e1,e2) -> eval(e1,x,y) ** eval(e2,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(pi*.eval(e,x,y))\n| Cosine(e) -> cos(pi*.eval(e,x,y))\n| Average(e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y))/.2.\n| Times(e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh(e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then \neval(e3,x,y)\nelse eval(e4,x,y)\n| Power(e1,e2) -> eval(e1,x,y) ** eval(e2,x,y)"}
{"fix": "let _ = eval (AddThree(VarX,VarY,VarX),1.,5.)", "bad": "let _ = eval (AddThree(VarX,VarY,VarX),1.,2.,3.)", "annotated": "let _ = eval (AddThree(VarX,VarY,VarX),1.,2.,3.)"}
{"fix": "let _ = eval (AddThree(VarX,VarY,VarX),1.,5.)", "bad": "let _ = eval (AddThree(VarX,VarY,VarX),1.,2.)", "annotated": "let _ = eval (AddThree(VarX,VarY,VarX),1.,2.)"}
{"fix": "let g1 () = 20,8,9", "bad": "let _ = eval (Power(VarX,VarY),3.,2.)", "annotated": "let _ = eval (Power(VarX,VarY),3.,2.)"}
{"fix": "let g1 () = 20,8,9", "bad": "let _ = eval (AddThree(VarX,VarY,VarX),2.,5.)", "annotated": "let _ = eval (AddThree(VarX,VarY,VarX),2.,5.)"}
{"fix": "let g1 () = 20,8,9", "bad": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "annotated": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}
{"fix": "let g1 () = 20,8,9", "bad": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "annotated": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))"}
{"fix": "let g1 () = 20,8,9", "bad": "let _ = eval (sampleExpr,0.5,0.2)", "annotated": "let _ = eval (sampleExpr,0.5,0.2)"}
{"fix": "let g1 () = 20,8,9", "bad": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "annotated": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))"}
{"fix": "let g1 () = 20,8,9", "bad": "let rec build (rand, depth) = \nlet x = rand(0,7) in \nmatch x with \n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 3 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 4 -> if depth = 0 then build(rand,depth)\nelse buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 5 -> if depth = 0 then build(rand,depth)\nelse buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 6 -> if depth = 0 then build(rand,depth)\nelse buildPower(build(rand,depth-1),build(rand,depth-1))\n| 7 -> if depth = 0 then build(rand,depth)\nelse buildAddThree(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ -> buildX()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet x = rand(0,7) in \nmatch x with \n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> if depth = 0 then build(rand,depth) \nelse buildSine(build(rand,depth-1))\n| 3 -> if depth = 0 then build(rand,depth)\nelse buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 4 -> if depth = 0 then build(rand,depth)\nelse buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 5 -> if depth = 0 then build(rand,depth)\nelse buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 6 -> if depth = 0 then build(rand,depth)\nelse buildPower(build(rand,depth-1),build(rand,depth-1))\n| 7 -> if depth = 0 then build(rand,depth)\nelse buildAddThree(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| _ -> buildX()"}
{"fix": "(* UNCOMMENT AFTE", "bad": "\n\r\nlet pipe fs = \nlet f a x = x a in\nlet b", "annotated": "\n\r\nlet pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet b"}
{"fix": "(* UNCOMMENT AFTE", "bad": "\n\r\nlet pipe fs = \nlet f a x = x a in\nlet b", "annotated": "\n\r\nlet pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet b"}
{"fix": "(* UNCOMMENT AFTE", "bad": "\n\r\nlet pipe fs = \nlet f a x = x a in\nlet b", "annotated": "\n\r\nlet pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet b"}
{"fix": "(* UNCOMMENT AFTE", "bad": "\n\r\nlet pipe fs = \nlet f a x = x a in\nlet b", "annotated": "\n\r\nlet pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet b"}
{"fix": "(* UNCOMMENT AFTE", "bad": "\n\r\nlet pipe fs y = \nlet f a x = x a in\nlet b", "annotated": "\n\r\nlet pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs y  ->  \nlet f a x = x a in\nlet b"}
{"fix": "(* UNCOMMENT AFTE", "bad": "\n\r\nlet pipe fs  = function \nlet f a x = x a in\nlet b", "annotated": "\n\r\nlet pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs   ->  function \nlet f a x = x a in\nlet b"}
{"fix": "(* UNCOMMENT AFTE", "bad": "\n\r\nlet pipe fs  y=  \nlet f a x = x a in\nlet b", "annotated": "\n\r\nlet pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  y ->   \nlet f a x = x a in\nlet b"}
{"fix": "(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*", "bad": "\n\r\nlet rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = \"\" in\nlet l ", "annotated": "\n\r\nlet rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = \"\" in\nlet l "}
{"fix": "(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*", "bad": "\n\r\nlet rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ \"x\" in\nlet base = \"\" in\nlet l ", "annotated": "\n\r\nlet rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ \"x\" in\nlet base = \"\" in\nlet l "}
{"fix": "(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*", "bad": "\n\r\nlet rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l ", "annotated": "\n\r\nlet rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l "}
{"fix": "(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*", "bad": "\n\r\nlet rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep ^ x in\nlet base = \"\" in\nlet l ", "annotated": "\n\r\nlet rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep ^ x in\nlet base = \"\" in\nlet l "}
{"fix": "(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*", "bad": "\n\r\nlet rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"h\" in\nlet l", "annotated": "\n\r\nlet rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"h\" in\nlet l"}
{"fix": "(* UNCOMMENT AFTER IMPLEMENTING THE ABOVE*", "bad": "\n\r\nlet rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l =", "annotated": "\n\r\nlet rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l ="}
{"fix": "\n\r\nlet pipe fs =  \nlet f a x = x a in\nlet b", "bad": "\n\r\nlet pipe fs y=  \nlet f a x = x a in\nlet b", "annotated": "\n\r\nlet pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs y ->   \nlet f a x = x a in\nlet b"}
{"fix": "(* UNCOMMENT AFTE", "bad": "\n\r\nlet _ = pipe [(fun x -> x+x);", "annotated": "\n\r\nlet _ = pipe [(fun x -> x+x);"}
{"fix": "(* UNCOMMENT AFTE", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "(* UNCOMMENT AFTE", "bad": "\n\r\nlet _ = pipe [(fun x -> x+x);", "annotated": "\n\r\nlet _ = pipe [(fun x -> x+x);"}
{"fix": "(* UNCOMMENT AFTE", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "(* UNCOMMENT AFTE", "bad": "let pipe fs =  \nlet f a x = x a in\nlet b", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->   \nlet f a x = x a in\nlet b"}
{"fix": "(* UNCOMMENT AFTE", "bad": "\n\r\nlet pipe fs =  \nlet f a x = x base in\nle", "annotated": "\n\r\nlet pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->   \nlet f a x = x base in\nle"}
{"fix": "(* UNCOMMENT AFTE", "bad": "\n\r\nlet pipe fs =  \nlet f a x = x' (x a)  in", "annotated": "\n\r\nlet pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->   \nlet f a x = x' (x a)  in"}
{"fix": "(* UNCOMMENT AFTE", "bad": "\n\r\nlet pipe fs =  \nlet f a x = fun (x a)  i", "annotated": "\n\r\nlet pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->   \nlet f a x = fun (x a)  i"}
{"fix": "(* UNCOMMENT AFTE", "bad": "\n\r\nlet pipe fs =  \nlet f a x = fun x' ->  x", "annotated": "\n\r\nlet pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->   \nlet f a x = fun x' ->  x"}
{"fix": "(* UNCOMMENT AFTE", "bad": "\n\r\nlet pipe fs y=  \nlet f a x = x a  in\nlet ", "annotated": "\n\r\nlet pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs y ->   \nlet f a x = x a  in\nlet "}
{"fix": ";;", "bad": "let sqsum xs = \nlet f a x = x * x + a in", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = x * x + a in"}
{"fix": ";;", "bad": "let sqsum xs = \nlet f a x = x * x + a in", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = x * x + a in"}
{"fix": "let sqsum xs = \nlet f a x = (x * x + a)", "bad": "let sqsum xs = \nlet f a x = (x * x + a) ", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = (x * x + a) "}
{"fix": "\n\nlet sqsum xs = \nlet f a x = x * x + a in", "bad": "let sqsum xs = \nlet f a x = x * x + a in", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = x * x + a in"}
{"fix": "let _ = mulByDigit 9 [9;9;9;9]", "bad": "let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nif i = 0 then []\nelse if i = 1 then l\nelse bigAdd (mulByDigit (i-2) l) (mulByDigit (i-2) l)"}
{"fix": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "bad": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (x*10 * List.length res) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (x*10 * List.length res) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "bad": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x) *. 10. ** (float_of_int List.length res)) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x) *. 10. ** (float_of_int List.length res)) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "bad": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x) *. 10. ** (float_of_int (List.length res))) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (int_of_float (float_of_int x) *. 10. ** (float_of_int (List.length res))) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "bad": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (int_of_float ((float_of_int x) *. 10. ** (float_of_int (List.length res)))) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match a with\n| (list1, res) -> (list1, mulByDigit (int_of_float ((float_of_int x) *. 10. ** (float_of_int (List.length res)))) list1) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "bad": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*List.lengh res) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*List.lengh res) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "bad": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*List.length res) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*List.length res) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "bad": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**List.length res))) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**List.length res))) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "bad": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**float_of_int List.length res))) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**float_of_int List.length res))) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "bad": "let bigMul l1 l2 = \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**float_of_int (List.length res)))) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match a with\n| (list1, res) -> (list1, bigAdd res (mulByDigit (x*(int_of_float (10.**float_of_int (List.length res)))) list1)) in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let rec sumList xs =\nmatch xs with\n[] -> 0 | h::t -> h + sumList t", "bad": "let rec sumList xs =\nmatch xs with\n[] -> 0 | h::t -> h + sumList", "annotated": "let rec sumList : int list -> int = fun  xs  -> \nmatch xs with\n[] -> 0 | h::t -> h + sumList"}
{"fix": "let rec sumList xs =\nmatch xs with\n[] -> 0 \n| h::t -> h + sumList t", "bad": "let rec digitsOfInt n =\nmatch n with\nn/10 == 0 -> [n] | digitsOfInt n/10 -> n%10 :: []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nmatch n with\nn/10 == 0 -> [n] | digitsOfInt n/10 -> n%10 :: []"}
{"fix": "let rec sumList xs =\nmatch xs with\n[] -> 0 \n| h::t -> h + sumList t", "bad": "let rec digitsOfInt n =\nmatch n with\n0 -> [] | digitsOfInt n/10 -> n%10 :: []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nmatch n with\n0 -> [] | digitsOfInt n/10 -> n%10 :: []"}
{"fix": "let rec sumList xs =\nmatch xs with\n[] -> 0 \n| h::t -> h + sumList t", "bad": "let rec digitsOfInt n =\nmatch n with\n0 -> [] | digitsOfInt (n/10) -> n%10 :: []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nmatch n with\n0 -> [] | digitsOfInt (n/10) -> n%10 :: []"}
{"fix": "let rec sumList xs =\nmatch xs with\n[] -> 0 \n| h::t -> h + sumList t", "bad": "let rec digitsOfInt n =\nmatch n with\n0 -> [] | digitsOfInt n -> n%10 :: []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nmatch n with\n0 -> [] | digitsOfInt n -> n%10 :: []"}
{"fix": "let rec sumList xs =\nmatch xs with\n[] -> 0 \n| h::t -> h + sumList t", "bad": "let rec digitsOfInt n =\nmatch n with\n0 -> [] | n -> digitsOfInt n/10 n%10 :: []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nmatch n with\n0 -> [] | n -> digitsOfInt n/10 n%10 :: []"}
{"fix": "let rec sumList xs =\nmatch xs with\n[] -> 0 \n| h::t -> h + sumList t", "bad": "let rec digitsOfInt n =\nmatch n with\n0 -> [] | n -> digitsOfInt n/10 :: []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nmatch n with\n0 -> [] | n -> digitsOfInt n/10 :: []"}
{"fix": "let rec sumList xs =\nmatch xs with\n[] -> 0 \n| h::t -> h + sumList t", "bad": "let rec digitsOfInt n =\nmatch n with\n0 -> [] | n -> digitsOfInt n :: []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nmatch n with\n0 -> [] | n -> digitsOfInt n :: []"}
{"fix": "let rec sumList xs =\nmatch xs with\n[] -> 0 \n| h::t -> h + sumList t", "bad": "let rec digitsOfInt n =\nmatch n with\n0 -> [] | n -> [digitsOfInt n/10]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nmatch n with\n0 -> [] | n -> [digitsOfInt n/10]"}
{"fix": "let rec sumList xs =\nmatch xs with\n[] -> 0 \n| h::t -> h + sumList t", "bad": "let rec digitsOfInt n =\nmatch n with\n0 -> [] | n/10 -> [digitsOfInt n]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nmatch n with\n0 -> [] | n/10 -> [digitsOfInt n]"}
{"fix": "let rec sumList xs =\nmatch xs with\n[] -> 0 \n| h::t -> h + sumList t", "bad": "let rec digitsOfInt n =\nmatch n with\n0 -> [] | (n/10) -> [digitsOfInt n]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nmatch n with\n0 -> [] | (n/10) -> [digitsOfInt n]"}
{"fix": "let rec digitsOfInt n =\nmatch n with\n0  -> [] \n| _  -> digitsOfInt (n/10) @  [n mod 10]", "bad": "let rec digitsOfInt n =\nmatch n with\n0  -> [] \n| _  -> digitsOfInt (n/10) @  [n%10]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nmatch n with\n0  -> [] \n| _  -> digitsOfInt (n/10) @  [n%10]"}
{"fix": "let rec digitsOfInt n =\n_ -> digitsOfInt (n/10) @  [n mod 10]", "bad": "let rec digitsOfInt n =\nn -> digitsOfInt (n/10) @  [n mod 10]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nn -> digitsOfInt (n/10) @  [n mod 10]"}
{"fix": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse hDigitsofInt n", "bad": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse let rec hDigitsofInt n = \nmatch n with\n0  -> [] \n| _  -> cat (digitsOfInt (n/10)) (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n = 0 then [0]\nelse let rec hDigitsofInt n = \nmatch n with\n0  -> [] \n| _  -> cat (digitsOfInt (n/10)) (n mod 10)"}
{"fix": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse hDigitsofInt n", "bad": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse let rec hDigitsofInt n = \nmatch n with\n0  -> [] \n| _  -> cat (hDigitsOfInt (n/10)) (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n = 0 then [0]\nelse let rec hDigitsofInt n = \nmatch n with\n0  -> [] \n| _  -> cat (hDigitsOfInt (n/10)) (n mod 10)"}
{"fix": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse hDigitsofInt n", "bad": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse let rec hDigitsofInt n = \nmatch n with\n0  -> [] \n| _  -> cat (hDigitsOfInt (n/10)) (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n = 0 then [0]\nelse let rec hDigitsofInt n = \nmatch n with\n0  -> [] \n| _  -> cat (hDigitsOfInt (n/10)) (n mod 10)"}
{"fix": "let rec digitsOfInt n =\nmatch n with\n0  -> [] \n| _  -> cat (digitsOfInt (n/10)) (n mod 10)", "bad": "let rec digitsOfInt n =\nmatch n with\n0  -> [] \n| _  -> cat (digitsOfInt (n/10)) (n mod 10)\nif n = 0 then [0]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nmatch n with\n0  -> [] \n| _  -> cat (digitsOfInt (n/10)) (n mod 10)\nif n = 0 then [0]"}
{"fix": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse\nmatch n with\n0  -> [] \n| _  -> cat (digitsOfInt (n/10)) (n mod 10)", "bad": "let rec digitsOfInt n =\nif n = 0 then [0]\nmatch n with\n0  -> [] \n| _  -> cat (digitsOfInt (n/10)) (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n = 0 then [0]\nmatch n with\n0  -> [] \n| _  -> cat (digitsOfInt (n/10)) (n mod 10)"}
{"fix": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse let rec help n =\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "bad": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse let rec help n =\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n = 0 then [0]\nelse let rec help n =\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)"}
{"fix": "let rec help n =\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "bad": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse let rec help n =\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n = 0 then [0]\nelse let rec help n =\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)"}
{"fix": "let rec help n =\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "bad": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse let rec help n = fun\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n = 0 then [0]\nelse let rec help n = fun\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)"}
{"fix": "let rec help n =\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "bad": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse let rec help n = fun\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n = 0 then [0]\nelse let rec help n = fun\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)"}
{"fix": "let rec help n =\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "bad": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse let rec help n = fun\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n = 0 then [0]\nelse let rec help n = fun\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)"}
{"fix": "let rec help n =\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "bad": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse let rec help num = fun\nmatch num with\n0  -> [] \n| _  -> cat (help (num/10)) (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n = 0 then [0]\nelse let rec help num = fun\nmatch num with\n0  -> [] \n| _  -> cat (help (num/10)) (n mod 10)"}
{"fix": "let rec help n =\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "bad": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse let rec help n = fun |\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n = 0 then [0]\nelse let rec help n = fun |\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)"}
{"fix": "let rec help n =\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "bad": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse let rec help n = fun \nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n = 0 then [0]\nelse let rec help n = fun \nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)"}
{"fix": "let rec help n =\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "bad": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse let rec help n = \nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n = 0 then [0]\nelse let rec help n = \nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)"}
{"fix": "let rec help n =\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "bad": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse let rec help n in \nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n = 0 then [0]\nelse let rec help n in \nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)"}
{"fix": "let rec help n =\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "bad": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse fun rec help n   ->\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n = 0 then [0]\nelse fun rec help n   ->\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)"}
{"fix": "let rec help n =\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "bad": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse fun help n  ->\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n = 0 then [0]\nelse fun help n  ->\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)"}
{"fix": "let rec help n =\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "bad": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse let rec help n  ->\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n = 0 then [0]\nelse let rec help n  ->\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)"}
{"fix": "let rec help n =\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "bad": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse let rec help n  =\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n = 0 then [0]\nelse let rec help n  =\nmatch n with\n0  -> [] \n| _  -> cat (help (n/10)) (n mod 10)"}
{"fix": "let rec listReverse l = \nmatch l with\n[]   -> []\n| h::t -> listReverse (t::(cat l h))", "bad": "let rec listReverse l = \nmatch l with\n[]   -> []\n| h::t -> listReverse ((cat l h)::t)", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n[]   -> []\n| h::t -> listReverse ((cat l h)::t)"}
{"fix": "let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0", "bad": "let palindrome w = \nlet l = explode w", "annotated": "let palindrome : string -> bool = fun  w  ->  \nlet l = explode w"}
{"fix": "let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0", "bad": "let reverse = listReverse l", "annotated": "let reverse = listReverse l"}
{"fix": "let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0", "bad": "let palindrome w = \nlet l = explode w", "annotated": "let palindrome : string -> bool = fun  w  ->  \nlet l = explode w"}
{"fix": "let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0", "bad": "let reverse = listReverse l", "annotated": "let reverse = listReverse l"}
{"fix": "let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0", "bad": "let palindrome w = \nlet l = explode w", "annotated": "let palindrome : string -> bool = fun  w  ->  \nlet l = explode w"}
{"fix": "let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0", "bad": "let reverse = listReverse l", "annotated": "let reverse = listReverse l"}
{"fix": "let _ = additivePersistence 9999", "bad": "let _ = additivePersistence (-9999)", "annotated": "let _ = additivePersistence (-9999)"}
{"fix": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| h::t -> \nif k = h then 10 else assoc (d,k,t)", "bad": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| h::t -> assoc (d,k,l) in\nif k = h then 10 else assoc (d,k,t)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with\n[]   -> d\n| h::t -> assoc (d,k,l) in\nif k = h then 10 else assoc (d,k,t)"}
{"fix": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "bad": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "bad": "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "annotated": "let _ = assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h::seen else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem (h,t) then h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem (h,t) then h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h::seen else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem (h) then h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem (h) then h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h::seen else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem (h , t) then h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem (h , t) then h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h::seen else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h::seen else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then h::[] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then h::[] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h::seen else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then h@[] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then h@[] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h::seen else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then [] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then [] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h::seen else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h::seen else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then h::[] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then h::[] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h::seen else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then (h::[]) in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then (h::[]) in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h::seen else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h@seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h@seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h::seen else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let rec wwhile (f,b) = match f with\n(num, b00l)-> if b00l then num else wwhile (f, num)", "bad": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "annotated": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}
{"fix": "let rec wwhile (f,b) = match f with\n(num, b00l)-> if b00l then num else wwhile (f, num)", "bad": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "annotated": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}
{"fix": "let rec wwhile (f,b) = match f with\n(num, b00l)-> if b00l then num else wwhile (f, num)", "bad": "let rec wwhile (f,b) = match f with\nf(num, b00l)-> if b00l then num else wwhile (f, num)", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match f with\nf(num, b00l)-> if b00l then num else wwhile (f, num)"}
{"fix": "let rec wwhile (f,b) = match f b with\n(num, b00l)-> if b00l then num else wwhile (f, num)", "bad": "let rec wwhile (f,b) = let f b in match t with\n()-> if b00l then num else wwhile (f, num)", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  let f b in match t with\n()-> if b00l then num else wwhile (f, num)"}
{"fix": "let rec wwhile (f,b) = match f b with\n(num, b00l)-> if b00l then num else wwhile (f, num)", "bad": "let rec wwhile (f,b) = fun f b in match t with\n()-> if b00l then num else wwhile (f, num)", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  fun f b in match t with\n()-> if b00l then num else wwhile (f, num)"}
{"fix": "let rec wwhile (f,b) = match f b with\n(num, b00l)-> if b00l then num else wwhile (f, num)", "bad": "let rec wwhile (f,b) = fun f b match t with\n()-> if b00l then num else wwhile (f, num)", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  fun f b match t with\n()-> if b00l then num else wwhile (f, num)"}
{"fix": "let rec wwhile (f,b) = match f b with\n(num, b00l)-> if b00l then num else wwhile (f, num)", "bad": "let rec wwhile (f,b) = match f b with\n()-> if b00l then num else wwhile (f, num)", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match f b with\n()-> if b00l then num else wwhile (f, num)"}
{"fix": "let fixpoint (f,b) = wwhile (f b,b)", "bad": "let fixpoint (f,b) = wwhile (fixpoint(f,b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (fixpoint(f,b),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((f b),b)", "bad": "let fixpoint (f,b) = wwhile (b,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (b,b)"}
{"fix": "let fixpoint (f,b) = wwhile ((f b),b)", "bad": "let fixpoint (f,b) = wwhile (fixpoint (f,b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (fixpoint (f,b),b)"}
{"fix": "let fixpoint (f,b) = wwhile (match f with num -> num,b)", "bad": "let fixpoint (f,b) = wwhile (match f with num,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (match f with num,b)"}
{"fix": "93", "bad": "let fixpoint (f,b) = wwhile ((),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((fun x -> let y = (f x) in (y, y != x)),b)", "bad": "let fixpoint (f,b) = wwhile ((fun x -> let y = (f,x) in (y, y != b)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((fun x -> let y = (f,x) in (y, y ! ->  b)),b)"}
{"fix": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin (pi*\" ^ exprToString e ^\")\"", "bad": "let rec exprToString e = match e with\nThresh (a,b,c,d) -> exprToString a b c d", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\nThresh (a,b,c,d) -> exprToString a b c d"}
{"fix": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin (pi*\" ^ exprToString e ^\")\"", "bad": "let rec exprToString e = match e with\nThresh (a,b,c,d) -> \n(exprToString a, exprToString b,exprToString c,exprToString d)", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\nThresh (a,b,c,d) -> \n(exprToString a, exprToString b,exprToString c,exprToString d)"}
{"fix": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin (pi*\" ^ exprToString e ^\")\"", "bad": "let rec exprToString e = match e with\nVarX x -> \"x\"\n| VarY y -> \"y\"\n| Sine s -> \"sin (pi*\" ^ exprString e ^\")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\nVarX x -> \"x\"\n| VarY y -> \"y\"\n| Sine s -> \"sin (pi*\" ^ exprString e ^\")\""}
{"fix": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin (pi*\" ^ exprToString e ^\")\"", "bad": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin (pi*\" ^ exprString e ^\")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin (pi*\" ^ exprString e ^\")\""}
{"fix": "let rec exprToString e = match e with\nVarX           -> \"x\"\n| VarY           -> \"y\"\n| Sine e         -> \"sin (pi*\" ^ exprToString e ^\")\"\n| Cosine e       -> \"cos (pi*\" ^ exprToString e ^\")\"\n| Average (e,f)  -> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)  -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"", "bad": "let rec exprToString e = match e with\nVarX     -> \"x\"\n| VarY     -> \"y\"\n| Sine e   -> \"sin (pi*\" ^ exprToString e ^\")\"\n| Cosine e -> \"cos (pi*\" ^ exprToString e ^\")\"\n| Averages -> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString e ^ \")/2)\"\n| Times    -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString e ^ \")\"\n| Thresh   \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString e ^ \"?\" ^ exprToString e ^ \":\" ^ exprToString e ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\nVarX     -> \"x\"\n| VarY     -> \"y\"\n| Sine e   -> \"sin (pi*\" ^ exprToString e ^\")\"\n| Cosine e -> \"cos (pi*\" ^ exprToString e ^\")\"\n| Averages -> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString e ^ \")/2)\"\n| Times    -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString e ^ \")\"\n| Thresh   \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString e ^ \"?\" ^ exprToString e ^ \":\" ^ exprToString e ^ \")\""}
{"fix": "let rec exprToString e = match e with\nVarX           -> \"x\"\n| VarY           -> \"y\"\n| Sine e         -> \"sin (pi*\" ^ exprToString e ^\")\"\n| Cosine e       -> \"cos (pi*\" ^ exprToString e ^\")\"\n| Average (e,f)  -> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)  -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"", "bad": "let rec exprToString e = match e with\nVarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e    -> \"sin (pi*\" ^ exprToString e ^\")\"\n| Cosine e  -> \"cos (pi*\" ^ exprToString e ^\")\"\n| Average e -> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString e ^ \")/2)\"\n| Times e   -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString e ^ \")\"\n| Thresh e  \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString e ^ \"?\" ^ exprToString e ^ \":\" ^ exprToString e ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\nVarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e    -> \"sin (pi*\" ^ exprToString e ^\")\"\n| Cosine e  -> \"cos (pi*\" ^ exprToString e ^\")\"\n| Average e -> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString e ^ \")/2)\"\n| Times e   -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString e ^ \")\"\n| Thresh e  \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString e ^ \"?\" ^ exprToString e ^ \":\" ^ exprToString e ^ \")\""}
{"fix": "let rec exprToString e = match e with\nVarX           -> \"x\"\n| VarY           -> \"y\"\n| Sine e         -> \"sin (pi*\" ^ exprToString e ^\")\"\n| Cosine e       -> \"cos (pi*\" ^ exprToString e ^\")\"\n| Average (e,f)  -> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)  -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"", "bad": "let rec exprToString e = match e with\nVarX       -> \"x\"\n| VarY       -> \"y\"\n| Sine e     -> \"sin (pi*\" ^ exprToString e ^\")\"\n| Cosine e   -> \"cos (pi*\" ^ exprToString e ^\")\"\n| Average e e-> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString e ^ \")/2)\"\n| Times e e  -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString e ^ \")\"\n| Thresh e e e e \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString e ^ \"?\" ^ exprToString e ^ \":\" ^ exprToString e ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\nVarX       -> \"x\"\n| VarY       -> \"y\"\n| Sine e     -> \"sin (pi*\" ^ exprToString e ^\")\"\n| Cosine e   -> \"cos (pi*\" ^ exprToString e ^\")\"\n| Average e e-> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString e ^ \")/2)\"\n| Times e e  -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString e ^ \")\"\n| Thresh e e e e \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString e ^ \"?\" ^ exprToString e ^ \":\" ^ exprToString e ^ \")\""}
{"fix": "let rec exprToString e = match e with\nVarX           -> \"x\"\n| VarY           -> \"y\"\n| Sine e         -> \"sin (pi*\" ^ exprToString e ^\")\"\n| Cosine e       -> \"cos (pi*\" ^ exprToString e ^\")\"\n| Average (e,f)  -> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)  -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"", "bad": "let rec exprToString e = match e with\nVarX       -> \"x\"\n| VarY       -> \"y\"\n| Sine e     -> \"sin (pi*\" ^ exprToString e ^\")\"\n| Cosine e   -> \"cos (pi*\" ^ exprToString e ^\")\"\n| Average e f-> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times e f  -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh e f g h \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\nVarX       -> \"x\"\n| VarY       -> \"y\"\n| Sine e     -> \"sin (pi*\" ^ exprToString e ^\")\"\n| Cosine e   -> \"cos (pi*\" ^ exprToString e ^\")\"\n| Average e f-> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times e f  -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh e f g h \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\""}
{"fix": "let rec exprToString e = match e with\nVarX           -> \"x\"\n| VarY           -> \"y\"\n| Sine e         -> \"sin (pi*\" ^ exprToString e ^\")\"\n| Cosine e       -> \"cos (pi*\" ^ exprToString e ^\")\"\n| Average (e,f)  -> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)  -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"", "bad": "let rec exprToString e = match e with\nVarX       -> \"x\"\n| VarY       -> \"y\"\n| Sine e     -> \"sin (pi*\" ^ exprToString e ^\")\"\n| Cosine e   -> \"cos (pi*\" ^ exprToString e ^\")\"\n| Average (e,f)-> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times (e,f)  -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh e f g h \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\nVarX       -> \"x\"\n| VarY       -> \"y\"\n| Sine e     -> \"sin (pi*\" ^ exprToString e ^\")\"\n| Cosine e   -> \"cos (pi*\" ^ exprToString e ^\")\"\n| Average (e,f)-> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times (e,f)  -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh e f g h \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\""}
{"fix": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> failwith \"sad\"", "bad": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (x,y)    -> (eval (e,x,y) +. eval(e,x,y))/.2.0\n| Times   (x,y)    -> eval(e,x,y) *. eval(e,x,y)\n| Thresh (e1,e2,e3,e4) -> failwith \"sad\"", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (x,y)    -> (eval (e,x,y) +. eval(e,x,y))/.2.0\n| Times   (x,y)    -> eval(e,x,y) *. eval(e,x,y)\n| Thresh (e1,e2,e3,e4) -> failwith \"sad\""}
{"fix": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)", "bad": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y) )", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y) )"}
{"fix": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)", "bad": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y) )", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y) )"}
{"fix": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)", "bad": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n( eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y) )", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n( eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y) )"}
{"fix": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)", "bad": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n( eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : e4 )", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n( eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : e4 )"}
{"fix": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)", "bad": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n( eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y) )", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n( eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y) )"}
{"fix": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)", "bad": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y) )", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y) )"}
{"fix": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)", "bad": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e3,x,y) )", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e3,x,y) )"}
{"fix": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)", "bad": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) )", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) )"}
{"fix": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)", "bad": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \neval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \neval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y)"}
{"fix": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)", "bad": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \neval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \neval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y)"}
{"fix": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)", "bad": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n(val(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n(val(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y))"}
{"fix": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)", "bad": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y))"}
{"fix": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)", "bad": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \neval(e1,x,y) < eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \neval(e1,x,y) < eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y)"}
{"fix": "let rec build (rand, depth) = \nif(depth > 0) then\nif rand mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rand mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "bad": "let rec build (rand, depth) = \nif(depth > 0) then\nif rand%5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand%5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand%5 = 2 then buildAverage(buildX(),buildY())\nelse if rand%5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand%2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif(depth > 0) then\nif rand%5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand%5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand%5 = 2 then buildAverage(buildX(),buildY())\nelse if rand%5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand%2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"}
{"fix": "let rec build (rand, depth) = \nif(depth > 0) then\nif rand mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rand mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "bad": "let rec build (rand, depth) = \nif(depth > 0) then\nif rand%.5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand%5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand%5 = 2 then buildAverage(buildX(),buildY())\nelse if rand%5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand%2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif(depth > 0) then\nif rand%.5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand%5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand%5 = 2 then buildAverage(buildX(),buildY())\nelse if rand%5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand%2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"}
{"fix": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand 0 100 in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand 0 100 in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "bad": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand 0 100 in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand 0 100 in\nif rand mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif(depth > 0) then\nlet rnd = rand 0 100 in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand 0 100 in\nif rand mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"}
{"fix": "let rec build (rand, depth) = \nFormat.sprintf \"%d\" depth in\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "bad": "let rec build (rand, depth) = \nFormat.sprintf \"%d\" depth\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nFormat.sprintf \"%d\" depth\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"}
{"fix": "let rec build (rand, depth) = \n\nif(depth > 0) then\nFormat.printf \"%d\" depth", "bad": "let rec build (rand, depth) = \n\nif(depth > 0) then\nFormat.sprintf \"%d\" depth", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \n\nif(depth > 0) then\nFormat.sprintf \"%d\" depth"}
{"fix": "let rec build (rand, depth) = \nlet _ = Format.printf \"%d\" depth in\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "bad": "let rec build (rand, depth) = \n\nif(depth > 0) then\nFormat.printf \"%d\" depth in\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \n\nif(depth > 0) then\nFormat.printf \"%d\" depth in\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"}
{"fix": "let rec build (rand, depth) = \nlet _ = Format.printf \"%d\" depth in\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "bad": "let rec build (rand, depth) = \nFormat.printf \"%d\" depth\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nFormat.printf \"%d\" depth\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"}
{"fix": "let rec build (rand, depth) = \nlet _ = Format.printf \"%d\" depth in\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "bad": "let rec build (rand, depth) = \nlet _ = Format.printf \"%d\" depth\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet _ = Format.printf \"%d\" depth\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"}
{"fix": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) +. cos(pi*.eval(e,x,y)))*.cos(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/.cos(pi*.eval(e,x,y))", "bad": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) +. cos(pi*.eval(e,x,y)))*cos(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/cos(pi*.eval(e,x,y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) +. cos(pi*.eval(e,x,y)))*cos(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/cos(pi*.eval(e,x,y))"}
{"fix": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 5) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse (*if rnd mod 7=5 then*)\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\n(*else\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))*)\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "bad": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 5) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse (*if rnd mod 7=5 then*)\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\n(*else\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))*)\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif(depth > 0) then\nlet rnd = rand (0, 5) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse (*if rnd mod 7=5 then*)\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\n(*else\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))*)\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()"}
{"fix": "let pipe fs = \nlet f a x = a+x in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = 0 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = a+x in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = a+x in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = a+x in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let pipe fs = \nlet f a x =  fun a -> x  in\nlet base =  fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  a + x  in\nlet base =  fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  a + x  in\nlet base =  fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =  (fun a->x) a  in\nlet base =  fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  fun x -> a  in\nlet base =  fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  fun x -> a  in\nlet base =  fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =  (fun a->x) a  in\nlet base =  fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  f (fun a->x)-> a  in\nlet base =  fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  f (fun a->x)-> a  in\nlet base =  fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =  (fun a->x) a  in\nlet base =  fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  f (fun a->x) a  in\nlet base =  fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  f (fun a->x) a  in\nlet base =  fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =   (fun a->x) x in\nlet base =  fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  a (fun a->x) in\nlet base =  fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  a (fun a->x) in\nlet base =  fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =   (fun a->x) a in\nlet base =  fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =   (fun a>x) a in\nlet base =  fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =   (fun a>x) a in\nlet base =  fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =   (fun x->a) a in\nlet base =  0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =   (fun x->a) a in\nlet base =  x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =   (fun x->a) a in\nlet base =  x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x =   (fun x->a) a in\nlet base =  0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =   (fun x->a) a in\nlet base =  a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =   (fun x->a) a in\nlet base =  a in\nList.fold_left f base fs"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep  in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x (a^sep)  in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x (a^sep)  in\nlet base = h in\nlet l = t in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^sep  in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep  in\nlet base = h in\nlet l = x in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep  in\nlet base = h in\nlet l = x in\nList.fold_left f base l"}
{"fix": "let stringOfList f l =  List.map f l", "bad": "let stringOfList f l = f (pipe List.map l)", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  f (pipe List.map l)"}
{"fix": "let stringOfList f l =  sepConcat \"\" (List.map f l)", "bad": "let stringOfList f l =  sepConcat f (List.map f l)", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->   sepConcat f (List.map f l)"}
{"fix": "let stringOfList f l =  sepConcat \"[]\" (List.map f l)", "bad": "let stringOfList f l =  sepConcat (List.map f l) l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->   sepConcat (List.map f l) l"}
{"fix": "let stringOfList f l =  sepConcat \"\" (List.map f l)", "bad": "let stringOfList f l = (List.map f (sepConcat \"\" l))", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  (List.map f (sepConcat \"\" l))"}
{"fix": "let rec clone x n = match n with\n0    -> []\n| _ ->  x::clone x (n-1)", "bad": "let rec clone x n = match n with\n0    -> []\n| h::t ->  x::clone x (n-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with\n0    -> []\n| h::t ->  x::clone x (n-1)"}
{"fix": "let rec clone x n = if n <= 0 then [] else x::clone x (n-1)", "bad": "let rec clone x n = match n with\nn <= 0 -> []\n| _      ->  x::clone x (n-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with\nn <= 0 -> []\n| _      ->  x::clone x (n-1)"}
{"fix": "let rec clone x n = if n <= 0 then [] else x::clone x (n-1)", "bad": "let rec clone x n = match n with\nn < 0 -> []\n| _      ->  x::clone x (n-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with\nn < 0 -> []\n| _      ->  x::clone x (n-1)"}
{"fix": "let rec clone x n = if n <= 0 then [] else x::clone x (n-1)", "bad": "let rec clone x n = match n with\nn = 0 -> []\n| _      ->  x::clone x (n-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with\nn = 0 -> []\n| _      ->  x::clone x (n-1)"}
{"fix": "let padZero l1 l2 =\nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) \nelse if (s2<s1) then (l1, (clone 0 (s1-s2))@l2)\nelse (l1,l2)", "bad": "let padZero l1 l2 =\nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif (s1<s2) then (clone 0 l1, l2) \nelse if (s2<s1) then (l1, clone 0 l2)\nelse (l1,l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif (s1<s2) then (clone 0 l1, l2) \nelse if (s2<s1) then (l1, clone 0 l2)\nelse (l1,l2)"}
{"fix": "let padZero l1 l2 =\nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) \nelse if (s2<s1) then (l1, (clone 0 (s1-s2))@l2)\nelse (l1,l2)", "bad": "let padZero l1 l2 =\nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) \nelse if (s2<s1) then (l1, (clone 0 s1-s2)@l2)\nelse (l1,l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) \nelse if (s2<s1) then (l1, (clone 0 s1-s2)@l2)\nelse (l1,l2)"}
{"fix": "let rec removeZero l = match l with\n[]  -> []\n| h1::h2::t-> if(h1=0 && h2!=0) then removeZero t else h1::removeZero t", "bad": "let rec removeZero l = match l with\nh   -> if (h != 0) then []\n| h::t-> if(h=0) then removeZero t else h::removeZero t", "annotated": "let rec removeZero : int list -> int list = fun  l  ->  match l with\nh   -> if (h != 0) then []\n| h::t-> if(h=0) then removeZero t else h::removeZero t"}
{"fix": "let rec removeZero l = match l with\n[]  -> []\n| h1::h2::t-> if(h1=0 && h2!=0) then removeZero t else h1::removeZero t", "bad": "let rec removeZero l = match l with\n[]  -> []\n| h1::h2::t-> if(h1=0 && h2!=0) then removeZero t else h::removeZero t", "annotated": "let rec removeZero : int list -> int list = fun  l  ->  match l with\n[]  -> []\n| h1::h2::t-> if(h1=0 && h2!=0) then removeZero t else h::removeZero t"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"\"\nin\nlet base = ([],[]) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"\"\nin\nlet base = [] in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"\"\nin\nlet base = [] in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"\"\nin\nlet base = ([],[]) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n[]   -> []\n| h::t -> []\nin\nlet base = ([],[]) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n[]   -> []\n| h::t -> []\nin\nlet base = ([],[]) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"\"\nin\nlet base = ([],[]) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n[]   -> []\n| h::t -> []\nin\nlet base = [] in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n[]   -> []\n| h::t -> []\nin\nlet base = [] in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n[]   -> ([],[])\n| h::t -> ([],[])\nin\nlet base = ([],[]) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n[]   -> ([],[])\n| h::t -> ([],[])\nin\nlet base = ([],[]) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n([],[])   -> []\nin\nlet base = ([],[]) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n([],[])   -> []\nin\nlet base = ([],[]) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"\"\nin\nlet base =  ([], []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n[]   -> []\nin\nlet base = ([],[]) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n[]   -> []\nin\nlet base = ([],[]) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"\"\nin\nlet base =  ([], []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"\"\nin\nlet base =  [] in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"\"\nin\nlet base =  [] in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\n([], []) -> []\nin\nlet base =  ([], []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =\n([], []) -> []\nin\nlet base =  ([], []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n([], []) -> []\nin\nlet base =  ([], []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n([], []) -> []\nin\nlet base =  ([], []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n([], []) -> []\nin\nlet base =  ([], []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n([], []) -> []\nin\nlet base =  ([], []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n[] -> []\nin\nlet base =  ([], []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n[] -> []\nin\nlet base =  ([], []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n[] -> []\nin\nlet base =  ([], []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n[] -> []\nin\nlet base =  ([], []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n[] -> ([], [])\nin\nlet base =  ([], []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n[] -> ([], [])\nin\nlet base =  ([], []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n[] -> ([], [])\nin\nlet base =  ([], []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n[] -> ([], [])\nin\nlet base =  ([], []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"\"\nin\nlet base =  [] in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"\"\nin\nlet base =  [] in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"\"\nin\nlet base =  fun x -> x in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"\"\nin\nlet base =  fun x -> x in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match (snd a) with\n[]  -> (fst x + snd x, ((fst x + snd x)/10)::[(fst x + snd x) mod 10]) \n|h::t -> (0, [] )\nin\nlet base =  (0, []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n(c, h::t) -> []\nin\nlet base =  (0, []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n(c, h::t) -> []\nin\nlet base =  (0, []) in\nlet args =  List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let rec mulByDigit i l = match i with\n0 -> []\n| 1 -> l\n| 2 -> bigAdd l l\n| _ -> bigAdd (mulByDigit (i-2) l) (mulByDigit i l)", "bad": "let rec mulByDigit i l = \nlet lr = List.rev l in\nmatch lr with\n(_,[])   -> ((fst x * snd x)/10, [(fst x * snd x) mod 10]) \n| (c,h::t) -> \nlet sum = c + (fst x * snd x) in\n(sum/10, (sum mod 10)::(snd a))", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet lr = List.rev l in\nmatch lr with\n(_,[])   -> ((fst x * snd x)/10, [(fst x * snd x) mod 10]) \n| (c,h::t) -> \nlet sum = c + (fst x * snd x) in\n(sum/10, (sum mod 10)::(snd a))"}
{"fix": "let rec mulByDigit i l = match i with\n0 -> []\n| 1 -> l\n| 2 -> bigAdd l l\n| _ -> bigAdd (mulByDigit (i-2) l) (mulByDigit i l)", "bad": "let rec mulByDigit i l = match i with\n0 -> []\n| 1 -> l\n| 2 -> bigAdd l l\n| _ -> bigAdd (mulByDigit (i-2) l) (mulBydigit i l)", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match i with\n0 -> []\n| 1 -> l\n| 2 -> bigAdd l l\n| _ -> bigAdd (mulByDigit (i-2) l) (mulBydigit i l)"}
{"fix": "let _ = mulByDigit 9999999999999 [9;9;9;9]", "bad": "let _ = mulByDigit 99999999999999999999 [9;9;9;9]", "annotated": "let _ = mulByDigit 99999999999999999999 [9;9;9;9]"}
{"fix": "let bigMul l1 l2 = \nlet f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) x)) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x =  match a with\n(_,[])   -> mulByDigit (fst x) l1\n|(c, h::t) -> (c, mulByDigit h x)\nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x =  match a with\n(_,[])   -> mulByDigit (fst x) l1\n|(c, h::t) -> (c, mulByDigit h x)\nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) x)) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x =  match a with\n(_,[])   -> mulByDigit (fst x) l1\nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x =  match a with\n(_,[])   -> mulByDigit (fst x) l1\nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) x)) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = (fst a, bigAdd () ()) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = (fst a, bigAdd () ()) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) x )) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "annotated": "let _ = bigMul [9;9;9;9] [9;9;9;9]"}
{"fix": "let bigMul l1 l2 = \nlet f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) x )) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]", "annotated": "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]"}
{"fix": "let bigMul l1 l2 = \nlet f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) x )) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = ((fst a)+1, bigAdd snd x (mulByDigit (fst a) x )) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = ((fst a)+1, bigAdd snd x (mulByDigit (fst a) x )) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) (x@ clone 0 (fst a)) )) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) (snd x) )) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) (snd x) )) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) (l1@ clone 0 (fst a)) )) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "annotated": "let _ = bigMul [9;9;9;9] [9;9;9;9]"}
{"fix": "let bigMul l1 l2 = \nlet f a x = ((fst a)+1, bigAdd x (mulByDigit (fst a) (l1@ clone 0 (fst a)) )) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]", "annotated": "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \n((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) )) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = ((fst a)+1, bigAdd x (mulByDigit x (l1@ clone 0 (fst a)) )) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = ((fst a)+1, bigAdd x (mulByDigit x (l1@ clone 0 (fst a)) )) \nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = match a with\n(0, [])   -> (0, mulByDigit x (l1@ clone 0 0))\n| (c, a) -> (c+1, bigAdd a (mulByDigit x (l1@clone 0 c)))\n(*((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) ))*)\n\nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = match a with\n(0, [])   -> (0, mulByDigit x (l1@ clone 0 []))\n| (c, a) -> (c+1, bigAdd a (mulByDigit x (l1@clone 0 c))\n(*((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) ))*)\n\nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match a with\n(0, [])   -> (0, mulByDigit x (l1@ clone 0 []))\n| (c, a) -> (c+1, bigAdd a (mulByDigit x (l1@clone 0 c))\n(*((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) ))*)\n\nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = match a with\n(0, [])   -> (0, mulByDigit x (l1@ clone 0 0))\n| (c, a) -> (c+1, bigAdd a (mulByDigit x (l1@clone 0 c)))\n(*((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) ))*)\n\nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = match a with\n(0, [])   -> (0, mulByDigit x (l1@ clone 0 []))\n| (c, a) -> (c+1, bigAdd a (mulByDigit x (l1@clone 0 c)))\n(*((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) ))*)\n\nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match a with\n(0, [])   -> (0, mulByDigit x (l1@ clone 0 []))\n| (c, a) -> (c+1, bigAdd a (mulByDigit x (l1@clone 0 c)))\n(*((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) ))*)\n\nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = match a with\n(((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) ))\n\nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = match a with\n((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) ))\n\nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match a with\n((fst a)+1, bigAdd (snd a) (mulByDigit x (l1@ clone 0 (fst a)) ))\n\nin\nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0", "bad": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList List.tl xs\nelse\n0", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nif List.length xs>0 then\nList.hd xs + sumList List.tl xs\nelse\n0"}
{"fix": "let _ = sumList [1; 3; 5; 7; 9; 11]", "bad": "let _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n5 mod 4", "annotated": "let _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n5 mod 4"}
{"fix": "let _ = sumList [1; 3; 5; 7; 9; 11]", "bad": "let _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n5 mod 4", "annotated": "let _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n5 mod 4"}
{"fix": "let _ = sumList [1; 3; 5; 7; 9; 11]", "bad": "let _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n5 mod 4", "annotated": "let _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n5 mod 4"}
{"fix": "let rec digitsOfInt n = \nif n>0 then\n[2]\nelse\n[1]", "bad": "let rec digitsOfInt n = \nif n>0 then\ndigitOfInt n/10 @ ( n mod 10 ::[])\nelse\n[]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>0 then\ndigitOfInt n/10 @ ( n mod 10 ::[])\nelse\n[]"}
{"fix": "let rec digitsOfInt n = \nif n>0 then\n[2]\nelse\n[1]", "bad": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10 @ ( n mod 10 ::[])\nelse\n[]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>0 then\ndigitsOfInt n/10 @ ( n mod 10 ::[])\nelse\n[]"}
{"fix": "let rec digitsOfInt n = \nif n>0 then\n[2]\nelse\n[1]", "bad": "let rec digitsOfInt n = \nif n>0 then\n(digitsOfInt n/10) @ ( n mod 10 ::[])\nelse\n[]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>0 then\n(digitsOfInt n/10) @ ( n mod 10 ::[])\nelse\n[]"}
{"fix": "let rec digitsOfInt n = \nif n>0 then\n[2]\nelse\n[1]", "bad": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10 \nelse\n[]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>0 then\ndigitsOfInt n/10 \nelse\n[]"}
{"fix": "let rec digitsOfInt n = \nif n>0 then\n[2]\nelse\n[1]", "bad": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10 \nelse\n[1;]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>0 then\ndigitsOfInt n/10 \nelse\n[1;]"}
{"fix": "let rec digitsOfInt n = \nif n>0 then\n[2]\nelse\n[1]", "bad": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10 \nelse\n[1]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>0 then\ndigitsOfInt n/10 \nelse\n[1]"}
{"fix": "let rec digitsOfInt n = \nif n>0 then\n[2]\nelse\n[1]", "bad": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10 \nelse\n[1]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>0 then\ndigitsOfInt n/10 \nelse\n[1]"}
{"fix": "let rec digitsOfInt n = \nif n>0 then\n[5]@ digitsOfInt (n/10)\nelse\n[1]", "bad": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10\nelse\n[]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>0 then\ndigitsOfInt n/10\nelse\n[]"}
{"fix": "let rec digitsOfInt n = \nif n>0 then\n[5]@ digitsOfInt (n/10)\nelse\n[1]", "bad": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10\nelse\n[]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>0 then\ndigitsOfInt n/10\nelse\n[]"}
{"fix": "let rec digitsOfInt n = \nif n>0 then\n[5]@ digitsOfInt (n/10)\nelse\n[1]", "bad": "let rec digitsOfInt n = \nif n>0 then\n[5]@ digitsOfInt n/10\nelse\n[1]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>0 then\n[5]@ digitsOfInt n/10\nelse\n[1]"}
{"fix": "let rec additivePersistence n =\nif n>0 then\n1+ additivePersistence (help n)\nelse\n0", "bad": "let rec additivePersistence n =\nif n>0 then\n1+ additivePersistence help  n\nelse\n0", "annotated": "let rec additivePersistence : int -> int = fun  n  -> \nif n>0 then\n1+ additivePersistence help  n\nelse\n0"}
{"fix": "let rec listReverse l = \nif List.length l >0 then\n(List.hd l ::[])\nelse\n[]", "bad": "let rec listReverse l = \nif List.length>0 then\n(listReverse List.tl l) @ (List.hd l ::[])\nelse\n[]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nif List.length>0 then\n(listReverse List.tl l) @ (List.hd l ::[])\nelse\n[]"}
{"fix": "let rec listReverse l = \nif List.length l >0 then\n(List.hd l ::[])\nelse\n[]", "bad": "let rec listReverse l = \nif List.length l >0 then\n(listReverse List.tl l) @ (List.hd l ::[])\nelse\n[]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nif List.length l >0 then\n(listReverse List.tl l) @ (List.hd l ::[])\nelse\n[]"}
{"fix": "let rec sumList xs = match xs with\n[]->0\n| h::x -> h+(sumList x)", "bad": "let rec sumList xs = match xs with\n[]->0\n|List.hd xs + sumList (List.tl xs)", "annotated": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n[]->0\n|List.hd xs + sumList (List.tl xs)"}
{"fix": "let rec sumList xs = match xs with\n[]->0\n| h::x -> h+(sumList x)", "bad": "let rec sumList xs = match xs with\n[]->0\n| List.hd xs + sumList (List.tl xs)", "annotated": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n[]->0\n| List.hd xs + sumList (List.tl xs)"}
{"fix": "let rec listReverse l = match l with\n[]->[]\n|h::x->(listReverse x) @ h", "bad": "let rec listReverse l = match l with\n[]->[]\n|h:x->(listReverse x) @ h", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n[]->[]\n|h:x->(listReverse x) @ h"}
{"fix": "let rec digitsOfInt n = \nif n>10 then\n(n mod 10):: (digitsOfInt (n/10))\nelse\n[n]", "bad": "let rec digitsOfInt n = \nif n>10 then\n(n mod 10):: (digitsOfInt (n/10)\nelse\n[n]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>10 then\n(n mod 10):: (digitsOfInt (n/10)\nelse\n[n]"}
{"fix": "let rec digitsOfInt n = \nif n>=100 then\n[n mod 10]\nelse\n[n]", "bad": "let rec digitsOfInt n = \nif n>10 then\n(digitsOfInt (n/10))::[n mod 10]\nelse\nn", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>10 then\n(digitsOfInt (n/10))::[n mod 10]\nelse\nn"}
{"fix": "let rec digitsOfInt n = \nif n>=100 then\n[n mod 10]\nelse\n[n]", "bad": "let rec digitsOfInt n = \nif n>10 then\nn::[n mod 10]\nelse\nn", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>10 then\nn::[n mod 10]\nelse\nn"}
{"fix": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10])\nelse\n[n]", "bad": "let rec digitsOfInt n = \nif n>10 then\napp ((digitsOfInt (n/10)) [n mod 10])\nelse\n[n]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>10 then\napp ((digitsOfInt (n/10)) [n mod 10])\nelse\n[n]"}
{"fix": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10])\nelse\n[n]", "bad": "let rec digitsOfInt n = \nif n>10 then\napp ((digitsOfInt (n/10)) [n mod 10])\nelse\n[n]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>10 then\napp ((digitsOfInt (n/10)) [n mod 10])\nelse\n[n]"}
{"fix": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10])\nelse\n[n]", "bad": "let rec digitsOfInt n = \nif n>=10 then\napp ((digitsOfInt (n/10)) [n mod 10])\nelse\nn::[]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>=10 then\napp ((digitsOfInt (n/10)) [n mod 10])\nelse\nn::[]"}
{"fix": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10])\nelse\n[n]", "bad": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10])\nelse\n\n\n\n\n(* uncomment and run AFTER you have implemented digitsOfInt *)\nlet _ = digitsOfInt 3124", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10])\nelse\n\n\n\n\n(* uncomment and run AFTER you have implemented digitsOfInt *)\nlet _ = digitsOfInt 3124"}
{"fix": "let rec digitsOfInt n = \nif n>=10 then\ndigitsOfInt (n/10) @ [n mod 10]\nelse\n[n]", "bad": "let rec digitsOfInt n = \nif n>=10 then\napp digitsOfInt (n/10) [n mod 10]\nelse\n[n]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>=10 then\napp digitsOfInt (n/10) [n mod 10]\nelse\n[n]"}
{"fix": "let rec digitsOfInt n = \nif n>=10 then\n(digitsOfInt (n/10)) @ ([n mod 10])\nelse\n[n]", "bad": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10])\nelse\n[n]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10])\nelse\n[n]"}
{"fix": "let rec digitsOfInt n = \nif n>=10 then\n(digitsOfInt (n/10)) @ ([n mod 10])\nelse\n[n]", "bad": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10])\nelse\nn", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10])\nelse\nn"}
{"fix": "let rec digitsOfInt n = \nif n>=10 then\n(digitsOfInt (n/10)) @ ([n mod 10])\nelse\n[n]", "bad": "let rec digitsOfInt n = \nif n>=10 then\napp ((digitsOfInt (n/10)) ([n mod 10]))\nelse\n[n]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>=10 then\napp ((digitsOfInt (n/10)) ([n mod 10]))\nelse\n[n]"}
{"fix": "let rec digitsOfInt n = \nif n>=10 then\n(digitsOfInt (n/10)) @ ([n mod 10])\nelse\n[n]", "bad": "let rec digitsOfInt n = \nif n>=10 then\napp ((digitsOfInt (n/10)) ([n mod 10]))\nelse\n[n+0]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>=10 then\napp ((digitsOfInt (n/10)) ([n mod 10]))\nelse\n[n+0]"}
{"fix": "let rec digitsOfInt n = \nif n>=10 then\n(n/(helpFac n 1))::digitsOfInt (n/10)\nelse\n[n]", "bad": "let rec digitsOfInt n = \nif n>=10 then\n(n/(help n 1))::digitsOfInt (n/10)\nelse\n[n]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>=10 then\n(n/(help n 1))::digitsOfInt (n/10)\nelse\n[n]"}
{"fix": "let rec digitsOfInt n = \nif n>=10 then\napp [5] [n mod 10] \nelse\napp [3] [8]", "bad": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10]) \nelse\n[n]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10]) \nelse\n[n]"}
{"fix": "let rec digitsOfInt n = \nif n>=10 then\napp [5] [n mod 10] \nelse\napp [3] [8]", "bad": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10]) \nelse\napp [n] []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10]) \nelse\napp [n] []"}
{"fix": "let rec digitsOfInt n = \nif n>=10 then\napp [5] [n mod 10] \nelse\napp [3] [8]", "bad": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10]) \nelse\napp [n] [8]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10]) \nelse\napp [n] [8]"}
{"fix": "let rec digitsOfInt n = \nif n>=10 then\napp [5] [n mod 10] \nelse\napp [3] [8]", "bad": "let rec digitsOfInt n = \nif n>=10 then\napp ([n/10] [n mod 10]) \nelse\napp [3] [8]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>=10 then\napp ([n/10] [n mod 10]) \nelse\napp [3] [8]"}
{"fix": "let rec digitsOfInt n = \nif n>=10 then\napp [5] [n mod 10] \nelse\napp [3] [8]", "bad": "let rec digitsOfInt n = \nif n>=10 then\napp ([(n/10)] [n mod 10]) \nelse\napp [3] [8]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>=10 then\napp ([(n/10)] [n mod 10]) \nelse\napp [3] [8]"}
{"fix": "let rec digitsOfInt n = \nif n>=10 then\napp [5] [n mod 10] \nelse\napp [3] [8]", "bad": "let rec digitsOfInt n = \nif n>=10 then\napp ([n/10] [n mod 10]) \nelse\napp [3] [8]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>=10 then\napp ([n/10] [n mod 10]) \nelse\napp [3] [8]"}
{"fix": "let rec digitsOfInt n = \nif n>=10 then\napp [5] [n mod 10] \nelse\napp [3] [8]", "bad": "let rec digitsOfInt n = \nif n>=10 then\napp ([n / 10] [n mod 10]) \nelse\napp [3] [8]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>=10 then\napp ([n / 10] [n mod 10]) \nelse\napp [3] [8]"}
{"fix": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10)) [n mod 10] \nelse\napp [3] [8]", "bad": "let rec digitsOfInt n = \nif n>=10 then\napp digitsOfInt n/10 [n mod 10] \nelse\napp [3] [8]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>=10 then\napp digitsOfInt n/10 [n mod 10] \nelse\napp [3] [8]"}
{"fix": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10)) [n mod 10] \nelse\napp [3] [8]", "bad": "let rec digitsOfInt n = \nif n>=10 then\napp digitsOfInt (n/10) [n mod 10] \nelse\napp [3] [8]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>=10 then\napp digitsOfInt (n/10) [n mod 10] \nelse\napp [3] [8]"}
{"fix": "let _ = digitsOfInt 3124", "bad": "let _ = digitsOfInt 3124let _ =digitsOfInt 1001", "annotated": "let _ = digitsOfInt : int -> int list = fun  3124let _  -> digitsOfInt 1001"}
{"fix": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) (n mod 10::ls)\nelse\n[n]\nin\ndriver n []", "bad": "let digitsOfInt n = \nlet driver n ls=\nif n>=10 then\ndriver n/10 (n mod 10::ls)\nelse\n[n]\nin\ndriver n []", "annotated": "let digitsOfInt : int -> int list = fun  n  ->  \nlet driver n ls=\nif n>=10 then\ndriver n/10 (n mod 10::ls)\nelse\n[n]\nin\ndriver n []"}
{"fix": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) (n mod 10::ls)\nelse\n[n]\nin\ndriver n []", "bad": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver n/10 (n mod 10::ls)\nelse\n[n]\nin\ndriver n []", "annotated": "let digitsOfInt : int -> int list = fun  n  ->  \nlet rec driver n ls=\nif n>=10 then\ndriver n/10 (n mod 10::ls)\nelse\n[n]\nin\ndriver n []"}
{"fix": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) ((n mod 10)::ls)\nelse\nls\nin\ndriver (n*10) []", "bad": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) ((n mod 10)::ls)\nelse\nls\nin\ndriver n*10 []", "annotated": "let digitsOfInt : int -> int list = fun  n  ->  \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) ((n mod 10)::ls)\nelse\nls\nin\ndriver n*10 []"}
{"fix": "let additivePersistence n =let rec county n=\nif n>=10 then\n1+ additivePersistence (help n)\nelse\n0\nin \ncounty n", "bad": "let additivePersistence n =let rec county=\nif n>=10 then\n1+ additivePersistence (help n)\nelse\n0\nin \ncounty n", "annotated": "let additivePersistence : int -> int = fun  n =let rec county -> \nif n>=10 then\n1+ additivePersistence (help n)\nelse\n0\nin \ncounty n"}
{"fix": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "bad": " _=(removeDuplicates [1,6,2,4,12,2,13,6,9])", "annotated": " _=(removeDuplicates [1,6,2,4,12,2,13,6,9])"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then\nseen \nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \n\nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem seen h) then\nseen \nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \n\nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem seen h) then\nseen \nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \n\nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then\nseen \nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \n\nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then\nseen \nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \n\nin\nList.rev helper ([],l)", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then\nseen \nelse\nh::seen\nin\nlet rest' = t in \nhelper (seen',rest') \n\nin\nList.rev helper ([],l)"}
{"fix": "let rec wwhile (f,b) = match f b with\n|(a,c)->if not c then\na\nelse\nwwhile (f,a)", "bad": "let rec wwhile (f,b) = match f b with\n|(a,c)->if not c then\na\nelse\nwwhile f a", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match f b with\n|(a,c)->if not c then\na\nelse\nwwhile f a"}
{"fix": "let fixpoint (f,b) = wwhile (let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)", "bad": "let fixpoint (f,b) = wwhile ((let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x)\n\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g y x -> \nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x)\n\n,b)"}
{"fix": "let fixpoint (f,b) = wwhile (let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)", "bad": "let fixpoint (f,b) = wwhile ((let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\n(sec (y x) x) )\n\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g y x -> \nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\n(sec (y x) x) )\n\n,b)"}
{"fix": "let fixpoint (f,b) = wwhile (let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)", "bad": "let fixpoint (f,b) = wwhile (let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\n(sec (y x) x)\n\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x -> \nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\n(sec (y x) x)\n\n,b)"}
{"fix": "let fixpoint (f,b) = wwhile (let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)", "bad": "let fixpoint (f,b) = wwhile ((let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\n(sec (y x) x))\n\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let g y x -> \nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\n(sec (y x) x))\n\n,b)"}
{"fix": "let fixpoint (f,b) = wwhile (let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)", "bad": "let fixpoint (f,b) = wwhile (let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\n\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x -> \nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\n\n,b)"}
{"fix": "let fixpoint (f,b) = wwhile (let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)", "bad": "let fixpoint (f,b) = wwhile (let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\n\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x -> \nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\n\n,b)"}
{"fix": "let fixpoint (f,b) = wwhile (let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)", "bad": "let fixpoint (f,b) = wwhile (let g y x=\n(let sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) )\nin\nsec (y x) x\n\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x -> \n(let sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) )\nin\nsec (y x) x\n\n,b)"}
{"fix": "let fixpoint (f,b) = wwhile (let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)", "bad": "let fixpoint (f,b) = wwhile (let g y x=f b\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x -> f b\n,b)"}
{"fix": "let fixpoint (f,b) = wwhile (let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)", "bad": "let fixpoint (f,b) = wwhile (let g y x=y b in\ng y b\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x -> y b in\ng y b\n,b)"}
{"fix": "let fixpoint (f,b) = wwhile (let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)", "bad": "let fixpoint (f,b) = wwhile (let g y x=y b in\ng f b\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x -> y b in\ng f b\n,b)"}
{"fix": "let fixpoint (f,b) = wwhile (let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)", "bad": "let fixpoint (f,b) = wwhile (let g y x=\n\nin\ng f b\n\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x -> \n\nin\ng f b\n\n,b)"}
{"fix": "let fixpoint (f,b) = wwhile (let g y x=\nlet sec s fi m=\nif s=fi then\n(s,s=(m s))\nelse\n(s,false) \nin\nsec (y x) x\nin\ng f b\n\n,b)", "bad": "let fixpoint (f,b) = wwhile (let g y x= y x\n\nin\ng f b\n\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x ->  y x\n\nin\ng f b\n\n,b)"}
{"fix": "let fixpoint (f,b) = wwhile (let g x=\n\nin\n(g (f b),false)\n\n,b)", "bad": "let fixpoint (f,b) = wwhile (let g y x=\n((y x),false)\nin\ng f b\n\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g y x -> \n((y x),false)\nin\ng f b\n\n,b)"}
{"fix": "let fixpoint (f,b) = wwhile (let g x=\n\nin\n(g (f b),false)\n\n,b)", "bad": "let fixpoint (f,b) = wwhile (let g x=\n(x,false)\nin\ng f b\n\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g x -> \n(x,false)\nin\ng f b\n\n,b)"}
{"fix": "let fixpoint (f,b) = wwhile (let g x=\n\nin\n(g (f b),false)\n\n,b)", "bad": "let fixpoint (f,b) = wwhile (let g x=\n(x,false)\nin\ng (f b)\n\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g x -> \n(x,false)\nin\ng (f b)\n\n,b)"}
{"fix": "let fixpoint (f,b) = wwhile (let g x=\n\nin\n(g (f b),false)\n\n,b)", "bad": "let fixpoint (f,b) = wwhile (let g x=\nx,false\nin\ng (f b)\n\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g x -> \nx,false\nin\ng (f b)\n\n,b)"}
{"fix": "let fixpoint (f,b) = wwhile (let g x=\n\nin\n(g (f b),false)\n\n,b)", "bad": "let fixpoint (f,b) = wwhile (let g x=\nx\nin\ng (f b)\n\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g x -> \nx\nin\ng (f b)\n\n,b)"}
{"fix": "let g x y= ((y x),false)", "bad": "let fixpoint (f,b) = wwhile (let g x y= ((y x),false)\nin g b f\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let g x y ->  ((y x),false)\nin g b f\n,b)"}
{"fix": "let h q x y=q x y", "bad": "let fixpoint (f,b) = wwhile (g b f\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (g b f\n,b)"}
{"fix": "let f x = let xx = x*x*x in (xx,xx<100)", "bad": "let fixpoint (f,b) = wwhile (let h x b= b x in h f b", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let h x b ->  b x in h f b"}
{"fix": "let f x = let xx = x*x*x in (xx,xx<100)", "bad": ",\n,b)", "annotated": ",\n,b)"}
{"fix": "let f x = let xx = x*x*x in (xx,xx<100)", "bad": "let fixpoint (f,b) = wwhile ((let h x b= b x in h f b),\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let h x b ->  b x in h f b),\n,b)"}
{"fix": "let f x = let xx = x*x*x in (xx,xx<100)", "bad": "let fixpoint (f,b) = wwhile ((h x b = b x \nin h f b", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((h x b  ->  b x \nin h f b"}
{"fix": "let h x y = ((y x),x<100)", "bad": "let fixpoint (f,b) = wwhile (let h x y = ((y x),x=x) in\nh b f\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let h x y = ((y x),x -> x) in\nh b f\n,b)"}
{"fix": "let h x y = ((y x),x<100)", "bad": "let fixpoint (f,b) = wwhile (let h x y = ((y x),x<100) in\nh b f\n,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let h x y  ->  ((y x),x<100) in\nh b f\n,b)"}
{"fix": "let h x=(x*x,x<100)", "bad": "let fixpoint (f,b) = wwhile (h b f,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (h b f,b)"}
{"fix": "let h x=(x*x,x<100)", "bad": "let fixpoint (f,b) = wwhile (f,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (f,b)"}
{"fix": "let fixpoint (f,b) = wwhile (let h a= f a\nin h b,b)", "bad": "let fixpoint (f,b) = wwhile (let h = f\nin (h,false),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let h  ->  f\nin (h,false),b)"}
{"fix": "let fixpoint (f,b) = wwhile (let h a= f a\nin h b,b)", "bad": "let fixpoint (f,b) = wwhile (let h a= f\nin h a,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let h a ->  f\nin h a,b)"}
{"fix": "let fixpoint (f,b) = wwhile (let h a= f a\nin h b,b)", "bad": "let fixpoint (f,b) = wwhile (let h a= f\nin h b,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let h a ->  f\nin h b,b)"}
{"fix": "let fixpoint (f,b) = wwhile (let h x= (f x,(f x)=x) in\nh,b)", "bad": "let fixpoint (f,b) = wwhile (let h x= (f x,false),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let h x ->  (f x,false),b)"}
{"fix": "let fixpoint (f,b) = wwhile (let h x= (f x,(f x)=x) in\nh,b)", "bad": "let fixpoint (f,b) = wwhile (let h x= (f x,false) in\nh,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let h x ->  (f x,false) in\nh,b)"}
{"fix": "let rec assoc (d,k,l) = match (d ,k,l) with\n|(x,y,[])->x\n|(x,y,(a,b)::t)->if a=y then\nb\nelse\nassoc (x,y,t)", "bad": "let fixpoint (f,b) = wwhile (let h x= let first =f x in\nlet second =f first in \nlet third = f second \nin  (second,not ((first=second)&&(second=third)\n&&(third=first))\nin\nh,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let h x= let first  -> f x in\nlet second =f first in \nlet third = f second \nin  (second,not ((first=second)&&(second=third)\n&&(third=first))\nin\nh,b)"}
{"fix": "let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/. 2\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)", "bad": "let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  -> match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)"}
{"fix": "let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/. 2\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)", "bad": "let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  -> match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)"}
{"fix": "let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)", "bad": "let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/2\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  -> match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/2\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)"}
{"fix": "let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)", "bad": "let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  -> match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)"}
{"fix": "let _ = eval (sampleExpr1,0.5,0.2)", "bad": "let _ = eval (sampleExpr1,0.5,0.2)", "annotated": "let _ = eval (sampleExpr1,0.5,0.2)"}
{"fix": "let rec build (rand, depth) = let res=rand(0,4) in match depth with\n0-> if (res mod 2)=0 then\nbuildX()\nelse\nbuildY()\n|_ ->let nd=depth-1 in\nmatch res with\n|0->buildAverage(build(rand,nd),build(rand,nd))\n|1->buildThresh(build(rand,nd),build(rand,nd),\nbuild(rand,nd),build(rand,nd))\n|2->buildTimes(build(rand,nd),build(rand,nd))\n|3->buildSine(build(rand,nd))\n|4->buildCosine(build(rand,nd))\n|_->buildX()", "bad": "let rec build (rand, depth) = let res=rand(0,4) in match depth with\n0-> if (res mod 2)=0 then\nbuildX()\nelse\nbuildY()\n|_ ->let nd=depth-1 in\nmatch res with\n|0->buildAverage(build(rand,nd),build(rand,nd))\n|1->buildThresh(build(rand,nd),build(rand,nd),\nbuild(rand,nd),build(rand,nd))\n|2->buildTimes(build(rand,nd),build(rand,nd))\n|3->buildSine(build(rand,nd))\n|4->buildCosine(build(rand,nd))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth) = let res -> rand(0,4) in match depth with\n0-> if (res mod 2)=0 then\nbuildX()\nelse\nbuildY()\n|_ ->let nd=depth-1 in\nmatch res with\n|0->buildAverage(build(rand,nd),build(rand,nd))\n|1->buildThresh(build(rand,nd),build(rand,nd),\nbuild(rand,nd),build(rand,nd))\n|2->buildTimes(build(rand,nd),build(rand,nd))\n|3->buildSine(build(rand,nd))\n|4->buildCosine(build(rand,nd))"}
{"fix": "et rec exprToString e = match e \nwith  \nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine  expr -> \"sin(pi*\"^(exprToString expr)^\")\"\n| Cosine expr-> \"cos(pi*\"^(exprToString expr)^\")\"\n| Average (expr,expr1)->\"((\"^(exprToString expr)^\"+\"\n^(exprToString expr1)^\")/2)\"\n|Times   (expr,expr1)->(exprToString expr)^\"*\"^(exprToString expr1)\n|Nom (expr1,expr2,expr3)->let res1,res2,res3=(exprToString expr1),\n(exprToString expr2),\n(exprToString expr3) \nin\n\"(\"^res1^\"+\"^res2^\"+\"^res3^\")/(abs(\"^res1^\")+abs(\"^res2^\")+abs(\"\n^res3^\"))\"\n\n|Squa expr -> let res=exprToString expr in\n\"abs(\"^res^\")/(abs\"^res^\"+\"^res^\"^2)\"\n| Thresh  (expr,expr1,expr2,expr3)->\"(\"^(exprToString expr)^\"<\"\n^(exprToString expr1)^\"?\"\n^(exprToString expr2)^\":\"^\n(exprToString expr3)", "bad": "let rec exprToString e = match e \nwith  \nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine  expr -> \"sin(pi*\"^(exprToString expr)^\")\"\n| Cosine expr-> \"cos(pi*\"^(exprToString expr)^\")\"\n| Average (expr,expr1)->\"((\"^(exprToString expr)^\"+\"\n^(exprToString expr1)^\")/2)\"\n|Times   (expr,expr1)->(exprToString expr)^\"*\"^(exprToString expr1)\n|Nom (expr1,expr2,expr3)->let res1,res2,res3=(exprToString expr1),\n(exprToString expr2),\n(exprToString expr3) \nin\n\"(\"^res1^\"+\"^res2^\"+\"^res3^\")/(abs(\"^res1^\")+abs(\"^res2^\")+abs(\"\n^res3^\"))\"\n\n|Squa expr -> let res=exprToString expr in\n\"abs(\"^res^\")/(abs\"^res^\"+\"^res^\"^2)\"\n| Thresh  (expr,expr1,expr2,expr3)->\"(\"^(exprToString expr)^\"<\"\n^(exprToString expr1)^\"?\"\n^(exprToString expr2)^\":\"^\n(exprToString expr3)", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e \nwith  \nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine  expr -> \"sin(pi*\"^(exprToString expr)^\")\"\n| Cosine expr-> \"cos(pi*\"^(exprToString expr)^\")\"\n| Average (expr,expr1)->\"((\"^(exprToString expr)^\"+\"\n^(exprToString expr1)^\")/2)\"\n|Times   (expr,expr1)->(exprToString expr)^\"*\"^(exprToString expr1)\n|Nom (expr1,expr2,expr3)->let res1,res2,res3=(exprToString expr1),\n(exprToString expr2),\n(exprToString expr3) \nin\n\"(\"^res1^\"+\"^res2^\"+\"^res3^\")/(abs(\"^res1^\")+abs(\"^res2^\")+abs(\"\n^res3^\"))\"\n\n|Squa expr -> let res=exprToString expr in\n\"abs(\"^res^\")/(abs\"^res^\"+\"^res^\"^2)\"\n| Thresh  (expr,expr1,expr2,expr3)->\"(\"^(exprToString expr)^\"<\"\n^(exprToString expr1)^\"?\"\n^(exprToString expr2)^\":\"^\n(exprToString expr3)"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Squa expr->let res=eval(expr,x,y) in res /. ((abs_float res )+. 1.0)\n| Nom (expr,expr1,expr2)-> let r1,r2,r3=(eval(expr,x,y),eval(expr1,x,y),\neval(expr2,x,y)) in\n(r1 +. r2 +. r3) /. ((abs_float r1)+.(abs_float r2)+.(abs_float r3))\n\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  -> match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Squa expr->let res=eval(expr,x,y) in res /. ((abs_float res )+. 1.0)\n| Nom (expr,expr1,expr2)-> let r1,r2,r3=(eval(expr,x,y),eval(expr1,x,y),\neval(expr2,x,y)) in\n(r1 +. r2 +. r3) /. ((abs_float r1)+.(abs_float r2)+.(abs_float r3))\n\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)"}
{"fix": "let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Squa expr->let res=eval(expr,x,y) in res /. ((abs_float res )+. 1.0)\n| Nom (expr,expr1,expr2)-> let r1,r2,r3=(eval(expr,x,y),eval(expr1,x,y),\neval(expr2,x,y)) in\n(r1 +. r2 +. r3) /. ((abs_float r1)+.(abs_float r2)+.(abs_float r3))\n\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)", "bad": "let_=eval (Sine(Average(VarX,VarY)),0.3,0.3)", "annotated": "let_=eval (Sine(Average(VarX,VarY)),0.3,0.3)"}
{"fix": "let rec eval (e,x,y) =match e with\nVarX -> x\n| VarY -> y\n| Sine  expr -> sin(pi*.(eval (expr, x ,y)))\n| Cosine expr-> cos(pi*.(eval (expr, x ,y)))\n| Average (expr,expr1)->((eval (expr, x ,y)) +. (eval (expr1 ,x, y)))/.2.\n| Times   (expr,expr1)->((eval (expr, x ,y))*. (eval (expr1 ,x ,y)))\n| Squa expr->let res=eval(expr,x,y) in res /. ((abs_float res )+. 1.0)\n| Nom (expr,expr1,expr2)-> let r1,r2,r3=(eval(expr,x,y),eval(expr1,x,y),\neval(expr2,x,y)) in\n(r1 +. r2 +. r3) /. ((abs_float r1)+.(abs_float r2)+.(abs_float r3))\n\n| Thresh  (expr,expr1,expr2,expr3)-> if (eval (expr ,x ,y))<\n(eval (expr1 ,x, y))\nthen\neval (expr2 ,x ,y)\nelse\neval (expr3 ,x ,y)", "bad": "let _=eval (Sine(Average(VarX,VarY)),0.3,0.3)", "annotated": "let _=eval (Sine(Average(VarX,VarY)),0.3,0.3)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x))", "bad": "let fixpoint (f,b) = wwhile (let h x= let first =x in\nlet second =f first \nin  (second,not ((first=second)))\nin\nh,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile (let h x= let first  -> x in\nlet second =f first \nin  (second,not ((first=second)))\nin\nh,b)"}
{"fix": "let buildNom(e,e1,e2)\t\t   = Nom(e,e1,e2)", "bad": "let buildNom(e,e1,e2)\t\t   = Nom(e,e1,e2)", "annotated": "let build: ((int * int -> int) * int) -> expr = fun Nom(e,e1,e2)\t\t    ->  Nom(e,e1,e2)"}
{"fix": "let _=  (build(makeRand(3,4),3))", "bad": "let _= exprToString (build(makeRand(3,4),2))", "annotated": "let _= exprToString (build(makeRand(3,4),2))"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (fun j y->y) in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = (fun j y->y) in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = (fun j y->y) in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (fun y->y) in \nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (fun y->y) in \nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)]", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)]"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (fun y->y) in \nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (fun y->y) in \nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (fun y->y) in \nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3", "annotated": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (fun z->z) in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = y in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = y in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = a in\nlet base = fun z->z in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x =  in\nlet base = fun z->z in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x =  in\nlet base = fun z->z in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun z->z in \nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base = (fun a->a) in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base =  (fun y->y) in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base =  a in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base =  a in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base =  (fun y->y) in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base =  x in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base =  x in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base =  (fun y->y) in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base =  fs in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base =  fs in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base =  (fun y->y) in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base =  *1 in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base =  *1 in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base =  (fun x _->x) in \nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base =  (fun x _->x) in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base =  (fun x->x) in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base =  (fun x->x) in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x a in\nlet base =  (fun x _->x) in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base =  (fun x->x) in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base =  (fun x->x) in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = x in\nlet base =  (fun x ->x) in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base =  (fun x ->x) in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base =  (fun x ->x) in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun j->fun y-> x a in\nlet base =  (fun x ->x) in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun j->fun x-> a in\nlet base =  (fun x ->x) in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun j->fun x-> a in\nlet base =  (fun x ->x) in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun j->a x  in\nlet base =  (fun x ->x) in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun j->a-> x  in\nlet base =  (fun x ->x) in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun j->a-> x  in\nlet base =  (fun x ->x) in \nList.fold_left f base fs"}
{"fix": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = sepConcat sep t in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = sepConcat sep t in\nList.fold_left f base l"}
{"fix": "let stringOfList f l = List.map f l", "bad": "let stringOfList f l = map f l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  map f l"}
{"fix": "let stringOfList f l = List.map f l", "bad": "let stringOfList f l = map f l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  map f l"}
{"fix": "let stringOfList f l = List.map f l", "bad": "let stringOfList f l = map f l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  map f l"}
{"fix": "let stringOfList f l =\"[\"^ (sepConcat \"; \" (List.map f l) )^\"]\"", "bad": "let stringOfList f l =\"[\"^ (sepConcat \"; \" sepList.map f l) ^\"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  -> \"[\"^ (sepConcat \"; \" sepList.map f l) ^\"]\""}
{"fix": "let stringOfList f l =\"[\"^ (sepConcat \"; \" (List.map f l) )^\"]\"", "bad": "let stringOfList f l =\"[\"^ (sepConcat \"; \" (sepList.map f l) )^\"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  -> \"[\"^ (sepConcat \"; \" (sepList.map f l) )^\"]\""}
{"fix": "let rec clone x n = let rec  helper xs sub depth=match depth with\n0->xs\n|_->helper (sub::xs) sub (depth-1)\nin helper [] x n", "bad": "let rec clone x n = let helper xs sub depth=match depth with\n0->xs\n|_->help (sub::xs) sub (depth -1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n = let helper xs sub depth -> match depth with\n0->xs\n|_->help (sub::xs) sub (depth -1)"}
{"fix": "let rec clone x n = let rec  helper xs sub depth=match depth with\n0->xs\n|_->helper (sub::xs) sub (depth-1)\nin helper [] x n", "bad": "let rec clone x n = let helper xs sub depth=match depth with\n0->xs\n|_->help (sub::xs) sub (depth-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n = let helper xs sub depth -> match depth with\n0->xs\n|_->help (sub::xs) sub (depth-1)"}
{"fix": "let rec clone x n = let rec  helper xs sub depth=match depth with\n0->xs\n|_->helper (sub::xs) sub (depth-1)\nin helper [] x n", "bad": "let rec clone x n = let helper xs sub depth=match depth with\n0->xs\n|_->helper (sub::xs) sub (depth-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n = let helper xs sub depth -> match depth with\n0->xs\n|_->helper (sub::xs) sub (depth-1)"}
{"fix": "let rec clone x n = let rec  helper xs sub depth=match depth with\n0->xs\n|_->helper (sub::xs) sub (depth-1)\nin helper [] x n", "bad": "let rec clone x n = let helper xs sub depth=match depth with\n0->xs\n|_->helper (sub::xs) sub (depth-1)\nin helper [] x n", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n = let helper xs sub depth -> match depth with\n0->xs\n|_->helper (sub::xs) sub (depth-1)\nin helper [] x n"}
{"fix": "let rec padZero l1 l2 = let sizeDif= (List.length l1)-(List.length l2) in\nlet appendS=(clone ( abs  sizeDif ) 0) in\nif sizeDif<0 then ( appendS@l1,l2)\nelse (l1,appendS@l2)", "bad": "let rec padZero l1 l2 = let sizeDif= (List.length l1)-(List.length l2) in\nlet appendS=(clone ( abs  sizeDif ) 0) in\nif sizeDif<0 then ( appendS@l1,l2)\nelse then (l1,appendS@l2)", "annotated": "let rec padZero : int list -> int list -> int list  * int list = fun  l1 l2 = let sizeDif ->  (List.length l1)-(List.length l2) in\nlet appendS=(clone ( abs  sizeDif ) 0) in\nif sizeDif<0 then ( appendS@l1,l2)\nelse then (l1,appendS@l2)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in \nlet car,res=(res/10),(res mod 10) in\nlet c1,c2=a in\nmatch c1 with\n[]->([car],res::c2)\n|y::s->(car::s,(res+y)::c2) in\nlet base = ([],[]) in\nlet args = List.combine (List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in \nlet car,res=(res/10),(res%10) in\nlet c1,c2=a in\nmatch c1 with\n[]->([car],res::c2)\n|y::s->(car::s,(res+y)::c2)", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in \nlet car,res=(res/10),(res%10) in\nlet c1,c2=a in\nmatch c1 with\n[]->([car],res::c2)\n|y::s->(car::s,(res+y)::c2)"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in \nlet car,res=(res/10),(res mod 10) in\nlet c1,c2=a in\nmatch c1 with\n[]->([car],res::c2)\n|y::s->(car::s,(res+y)::c2) in\nlet base = ([],[]) in\nlet args = List.combine (List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = ([10],[10])", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = ([10],[10])"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in \nlet car,res=(res/10),(res mod 10) in\nlet c1,c2=a in\nmatch c1 with\n[]->([car],res::c2)\n|y::s->(car::s,(res+y)::c2) in\nlet base = ([],[]) in\nlet args = List.combine (List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in \nlet car,res=(res/10),(res%10) in\nlet c1,c2=a in\nmatch c1 with\n[]->([car],res::c2)\n|y::s->(car::s,(res+y)::c2) in\nlet base = ([],[]) in\nlet args = List.combine List.rev l1 List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in \nlet car,res=(res/10),(res%10) in\nlet c1,c2=a in\nmatch c1 with\n[]->([car],res::c2)\n|y::s->(car::s,(res+y)::c2) in\nlet base = ([],[]) in\nlet args = List.combine List.rev l1 List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in \nlet car,res=(res/10),(res mod 10) in\nlet c1,c2=a in\nmatch c1 with\n[]->([car],res::c2)\n|y::s->(car::s,(res+y)::c2) in\nlet base = ([],[]) in\nlet args = List.combine (List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in \nlet car,res=(res/10),(res mod 10) in\nlet c1,c2=a in\nmatch c1 with\n[]->([car],res::c2)\n|y::s->(car::s,(res+y)::c2) in\nlet base = ([],[]) in\nlet args = List.combine List.rev l1 List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in \nlet car,res=(res/10),(res mod 10) in\nlet c1,c2=a in\nmatch c1 with\n[]->([car],res::c2)\n|y::s->(car::s,(res+y)::c2) in\nlet base = ([],[]) in\nlet args = List.combine List.rev l1 List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in \nlet car,re=(res/10),(res mod 10) in\nlet c1,c2=a in\nmatch c1 with\n[]->([car],re::c2)\n|y::s->((car::s),((re+y)mod 10)::c2) in\nlet base = ([],[]) in\nlet args = List.combine (List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in \nlet car,re=(res/10),(res mod 10) in\nlet c1,c2=a in\nmatch c1 with\n[]->([car],re::c2)\n|y::s->((((re+y)/10)+car)::s),((re+y)mod 10)::c2", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in \nlet car,re=(res/10),(res mod 10) in\nlet c1,c2=a in\nmatch c1 with\n[]->([car],re::c2)\n|y::s->((((re+y)/10)+car)::s),((re+y)mod 10)::c2"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in \nlet car,re=(res/10),(res mod 10) in\nlet c1,c2=a in\nmatch c1 with\n[]->([car],re::c2)\n|y::s->((car::s),((re+y)mod 10)::c2) in\nlet base = ([],[]) in\nlet args = List.combine (List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": ") in\nlet base = ([],[]) in\nlet args = List.combine (List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": ") in\nlet base = ([],[]) in\nlet args = List.combine (List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in \nlet car,re=(res/10),(res mod 10) in\nlet c1,c2=a in\nmatch c1 with\n[]->([car],re::c2)\n|y::s->let sub=re+y in( ((sub /10) +car)::s),\n((sub mod 10)::c2) in\nlet base = ([],[]) in\nlet args = List.combine (List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in \nlet car,re=(res/10),(res mod 10) in\nlet c1,c2=a in\nmatch c1 with\n[]->([car],re::c2)\n|y::s->let sub=re+y in ((((sub /10 )+car)::s),\n((sub mod 10)::c2) in\nlet base = ([],[]) in\nlet args = List.combine (List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in \nlet car,re=(res/10),(res mod 10) in\nlet c1,c2=a in\nmatch c1 with\n[]->([car],re::c2)\n|y::s->let sub=re+y in ((((sub /10 )+car)::s),\n((sub mod 10)::c2) in\nlet base = ([],[]) in\nlet args = List.combine (List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in\nlet p1,p2=a in\nmatch p2 with \n[]->(p1,(res/10)::(res mod 10)::[])\n|a::b->let re=a+(res mod 10)  in\n(p1,(re/10)::(re mod 10)::b )in\nlet base = ([],[]) in\nlet args = List.combine (List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in\nlet p1,p2=a in\nmatch p2 with \n[]->(res/10)::(res mod 10)::[]\n|a::b->let re=a+(res mod 10)  in\n(re/10)::(re mod 10)::b in\n\nlet base = ([],[]) in\nlet args = List.combine (List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in\nlet p1,p2=a in\nmatch p2 with \n[]->(res/10)::(res mod 10)::[]\n|a::b->let re=a+(res mod 10)  in\n(re/10)::(re mod 10)::b in\n\nlet base = ([],[]) in\nlet args = List.combine (List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigMul l1 l2 = \nlet f a x = s in\nlet base =([0],[0]) in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = s in\nlet base =([0],[0]) in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = let b,c=a in match b with \nd::t-> ((d*10)::t, t)\n|_    ->a\nin\n\nlet base =(1::l2,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = let b,c=a in match b with \nd::t-> ((d*10)::t,bigAdd((mulByDigit (d*x) t) c))\n|_    ->a\nin\n\nlet base =(1::l2,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let b,c=a in match b with \nd::t-> ((d*10)::t,bigAdd((mulByDigit (d*x) t) c))\n|_    ->a\nin\n\nlet base =(1::l2,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let _ = fixpoint (collatz, 1)", "annotated": "let _ = fixpoint (collatz, 1)"}
{"fix": "let fixpoint (f,b) = wwhile(if f b = b then f, b)", "bad": "let fixpoint (f,b) = wwhile((f::(f b = b)), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile((f::(f b  ->  b)), b)"}
{"fix": "let fixpoint (f,b) = wwhile((fun b ->  (f, (f b) != b)), b)", "bad": "let _ = fixpoint (collatz, 3)", "annotated": "let _ = fixpoint (collatz, 3)"}
{"fix": "let fixpoint (f,b) = wwhile((fun b ->  (f, (f b) != b)), b)", "bad": "let _ = fixpoint (collatz, 48)", "annotated": "let _ = fixpoint (collatz, 48)"}
{"fix": "let fixpoint (f,b) = wwhile((fun b ->  (f, (f b) != b)), b)", "bad": "let _ = fixpoint (collatz, 107)", "annotated": "let _ = fixpoint (collatz, 107)"}
{"fix": "let fixpoint (f,b) = wwhile(fun b ->  f b, (f b != b), b)", "bad": "let _ = fixpoint (collatz, 3)", "annotated": "let _ = fixpoint (collatz, 3)"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX -> sprintf\"%s\" e", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> sprintf\"%s\" e"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX -> sprintf(%s) e", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> sprintf(%s) e"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX -> sprintf(\"%s\") e", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> sprintf(\"%s\") e"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX -> Output.sprintf(\"%s\") e", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> Output.sprintf(\"%s\") e"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX -> Module.sprintf(\"%s\") e", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> Module.sprintf(\"%s\") e"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX     -> \"%s\" e\n| VarY     -> \"\"\n| Sine  \n| Cosine   \n| Average  \n| Times    \n| Thresh", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX     -> \"%s\" e\n| VarY     -> \"\"\n| Sine  \n| Cosine   \n| Average  \n| Times    \n| Thresh"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX     -> \"%s\" e\n| VarY     -> \"%s\" e\n| Sine     ->\n| Cosine   ->\n| Average  ->\n| Times    ->\n| Thresh   ->", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX     -> \"%s\" e\n| VarY     -> \"%s\" e\n| Sine     ->\n| Cosine   ->\n| Average  ->\n| Times    ->\n| Thresh   ->"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX     -> \"%s\" e\n| VarY     -> \"%s\" e\n| Sine     -> \"%s\" e\n| Cosine   -> \"%s\" e\n| Average  -> \"%s\" e\n| Times    -> \"%s\" e\n| Thresh   -> \"%s\" e", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX     -> \"%s\" e\n| VarY     -> \"%s\" e\n| Sine     -> \"%s\" e\n| Cosine   -> \"%s\" e\n| Average  -> \"%s\" e\n| Times    -> \"%s\" e\n| Thresh   -> \"%s\" e"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX     -> \"%s\" e\n| VarY     -> \"%s\" e\n| Sine     -> \"%s %s\" e e\n| Cosine   -> \"%s\" e\n| Average  -> \"%s\" e\n| Times    -> \"%s\" e\n| Thresh   -> \"%s\" e", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX     -> \"%s\" e\n| VarY     -> \"%s\" e\n| Sine     -> \"%s %s\" e e\n| Cosine   -> \"%s\" e\n| Average  -> \"%s\" e\n| Times    -> \"%s\" e\n| Thresh   -> \"%s\" e"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX     -> \"%s\" e\n| VarY     -> \"%s\" e\n| Sine     -> \"%s %s\" e \n| Cosine   -> \"%s\" e\n| Average  -> \"%s\" e\n| Times    -> \"%s\" e\n| Thresh   -> \"%s\" e", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX     -> \"%s\" e\n| VarY     -> \"%s\" e\n| Sine     -> \"%s %s\" e \n| Cosine   -> \"%s\" e\n| Average  -> \"%s\" e\n| Times    -> \"%s\" e\n| Thresh   -> \"%s\" e"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX              -> \"%s\" e\n| VarY              -> \"%s\" e\n| Sine (e)          -> \"%s\" e \n| Cosine (e)        -> \"%s\" e\n| Average (e,e)     -> \"%s\" e\n| Times (e,e)       -> \"%s\" e\n| Thresh (e,e,e,e)  -> \"%s\" e", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX              -> \"%s\" e\n| VarY              -> \"%s\" e\n| Sine (e)          -> \"%s\" e \n| Cosine (e)        -> \"%s\" e\n| Average (e,e)     -> \"%s\" e\n| Times (e,e)       -> \"%s\" e\n| Thresh (e,e,e,e)  -> \"%s\" e"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX              -> \"%s\" e\n| VarY              -> \"%s\" e\n| Sine (e1)          -> \"%s\" e1 \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX              -> \"%s\" e\n| VarY              -> \"%s\" e\n| Sine (e1)          -> \"%s\" e1 \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX              -> sprintf\"%s\" e\n| VarY              -> \"%s\" e\n| Sine (e1)          -> \"%s\" e1 \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX              -> sprintf\"%s\" e\n| VarY              -> \"%s\" e\n| Sine (e1)          -> \"%s\" e1 \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\" e\n| VarY              -> \"%s\" e\n| Sine (e1)          -> \"%s\" e1 \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX              -> Printf.sprintf\"%s\" e\n| VarY              -> \"%s\" e\n| Sine (e1)          -> \"%s\" e1 \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> \"%s\" e\n| Sine (e1)          -> \"%s\" e1 \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> \"%s\" e\n| Sine (e1)          -> \"%s\" e1 \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"%s\" e1 \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"%s\" e1 \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"e1\"\n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"e1\"\n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.printf\"e1\"\n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.printf\"e1\"\n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"%d\" e1\n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"%d\" e1\n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"%x\" e1\n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"%x\" e1\n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"e1\" \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"e1\" \n| Cosine (e2)        -> \"%s\" e2\n| Average (e3,e4)     -> \"%s %s\" e3 e4\n| Times (e5,e6)       -> \"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> \"%s %s %s %s\" e7 e8 e9 e0"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"e1\" \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"e1\" \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX              -> Printf.sprintf\"%s\"\n| VarY              -> Printf.sprintf\"%s\" \n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\""}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX x             -> x\n| VarY y             -> y\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX x             -> x\n| VarY y             -> y\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\""}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX              -> e\n| VarY y             -> y\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX              -> e\n| VarY y             -> y\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\""}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX              -> e\n| VarY y             -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX              -> e\n| VarY y             -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\""}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX              -> e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX              -> e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\""}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX              -> e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX              -> e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\""}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX              -> Printf.sprintf\"%s\" e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX              -> Printf.sprintf\"%s\" e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\""}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX e          -> e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX e          -> e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" e2\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" e3 e4\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" e5 e6\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" e7 e8 e9 e0\n| _ -> \"\""}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX e          -> e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX e          -> e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\""}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX           -> e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX           -> e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\""}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX           -> \"\"::e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX           -> \"\"::e\n| VarY              -> e\n| Sine (e1)          -> Printf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2)        -> Printf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4)     -> Printf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6)       -> Printf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0)  -> Printf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\""}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX -> \n\"%d\" e\n| VarY -> \ne\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \n\"%d\" e\n| VarY -> \ne\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\""}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX -> \nPrintf.sprintf\"%d\" e\n| VarY -> \ne\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \nPrintf.sprintf\"%d\" e\n| VarY -> \ne\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\""}
{"fix": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)", "bad": "let rec exprToString e = match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \n\"x\"\n| VarY -> \n\"y\"\n| Sine (e1) ->\nPrintf.sprintf\"%s\" (exprToString e1) \n| Cosine (e2) -> \nPrintf.sprintf\"%s\" (exprToString e2)\n| Average (e3,e4) ->\nPrintf.sprintf\"%s %s\" (exprToString e3)(exprToString e4)\n| Times (e5,e6) ->\nPrintf.sprintf\"%s %s\" (exprToString e5)(exprToString e6)\n| Thresh (e7,e8,e9,e0) -> \nPrintf.sprintf\"%s %s %s %s\" (exprToString e7)(exprToString e8)(exprToString e9)(exprToString e0)\n| _ -> \"\""}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(eval e0)\n| Cosine e1 ->\ncos(eval e1)\n| Average (e2,e3)->\n((eval e2)+(eval e3))/2\n| Times (e4,e5) ->\n(eval e4)*(eval e5)\n| Thresh (e6, e7, e8, e9) ->\nif (eval e6)<(eval e7) then (eval e8)\nelse (eval e9)", "bad": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(eval e0)\n| Cosine e1 ->\ncos(eval e1)\n| Average (e2,e3)->\n((eval e2)+(eval e3))/2\n| Times (e4,e5) ->\n(eval e4)*(eval e5)\n| Thresh (e6, e7, e8, e9) ->\n(eval e6)<(eval e7)?(eval e8):(eval e9)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(eval e0)\n| Cosine e1 ->\ncos(eval e1)\n| Average (e2,e3)->\n((eval e2)+(eval e3))/2\n| Times (e4,e5) ->\n(eval e4)*(eval e5)\n| Thresh (e6, e7, e8, e9) ->\n(eval e6)<(eval e7)?(eval e8):(eval e9)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX ->\nx\n| VarY ->\ny\n| Sine e0 ->\nsin(eval e0)\n| Cosine e1 ->\ncos(eval e1)\n| Average (e2,e3)->\n((eval e2)+(eval e3))/2\n| Times (e4,e5) ->\n(eval e4)*(eval e5)\n| Thresh (e6, e7, e8, e9) ->\nif (eval e6)<(eval e7) then (eval e8)\nelse (eval e9)", "bad": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)"}
{"fix": "let rec build (rand, depth) =\nfailwith \"ugh\"", "bad": "let rec build (rand, depth) =\nif depth = 0 then \nif (rand mod 2) = 0 then buildX()\nelse buildY()\nelse if (rand mod 5) = 0 then \nbuildSine(build(rand, depth - 1))\nelse if (rand mod 5) = 1 then \nbuildCosine(build(rand, depth - 1))\nelse if (rand mod 5) = 2 then \nbuildAverage(build(rand, depth - 1),build(rand, depth - 1))\nelse if (rand mod 5) = 3 then \nbuildAverage(build(rand, depth - 1))\nelse if (rand mod 5) = 4 then \nbuildThresh(build(rand, depth -1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nif depth = 0 then \nif (rand mod 2) = 0 then buildX()\nelse buildY()\nelse if (rand mod 5) = 0 then \nbuildSine(build(rand, depth - 1))\nelse if (rand mod 5) = 1 then \nbuildCosine(build(rand, depth - 1))\nelse if (rand mod 5) = 2 then \nbuildAverage(build(rand, depth - 1),build(rand, depth - 1))\nelse if (rand mod 5) = 3 then \nbuildAverage(build(rand, depth - 1))\nelse if (rand mod 5) = 4 then \nbuildThresh(build(rand, depth -1))"}
{"fix": "let rec build (rand, depth) =\nfailwith \"ugh\"", "bad": "let rec build (rand, depth) =\nif depth = 0 then \nif (rand mod 2) = 0 then buildX()\nelse buildY()\nelse if (rand mod 5) = 0 then \nbuildSine(build(rand, depth - 1))\nelse if (rand mod 5) = 1 then \nbuildCosine(build(rand, depth - 1))\nelse if (rand mod 5) = 2 then \nbuildAverage(build(rand, depth - 1),build(rand, depth - 1))\nelse if (rand mod 5) = 3 then \nbuildTimes(build(rand, depth - 1),build(rand, depth - 1))\nelse if (rand mod 5) = 4 then \nbuildThresh(build(rand, depth -1),build(rand, depth - 1),build(rand, depth - 1),build(rand, depth - 1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nif depth = 0 then \nif (rand mod 2) = 0 then buildX()\nelse buildY()\nelse if (rand mod 5) = 0 then \nbuildSine(build(rand, depth - 1))\nelse if (rand mod 5) = 1 then \nbuildCosine(build(rand, depth - 1))\nelse if (rand mod 5) = 2 then \nbuildAverage(build(rand, depth - 1),build(rand, depth - 1))\nelse if (rand mod 5) = 3 then \nbuildTimes(build(rand, depth - 1),build(rand, depth - 1))\nelse if (rand mod 5) = 4 then \nbuildThresh(build(rand, depth -1),build(rand, depth - 1),build(rand, depth - 1),build(rand, depth - 1))"}
{"fix": "let _ = eval (sampleExpr,0.5,0.2)", "bad": "let _ = eval (sampleExpr,0.5,0.2)", "annotated": "let _ = eval (sampleExpr,0.5,0.2)"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)", "annotated": "let _ = eval (Sine(Average(VarX,VarY)),0.3,0.3)"}
{"fix": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), build(rand, depth - 2))\n| 3 ->\nbuildTimes(build(rand, depth - 2), build(rand, depth - 2))\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))\n| _ -> buildY()", "bad": "let rand = \n\nlet rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), build(rand, depth - 2))\n| 3 ->\nbuildTimes(build(rand depth - 2), build(rand,depth - 2))\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth -4))", "annotated": "let rand = \n\nlet rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth <= 0 then buildX()\nelse match rand with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), build(rand, depth - 2))\n| 3 ->\nbuildTimes(build(rand depth - 2), build(rand,depth - 2))\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth -4))"}
{"fix": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), build(rand, depth - 2))\n| 3 ->\nbuildTimes(build(rand, depth - 2), build(rand, depth - 2))\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))\n| _ -> buildY()", "bad": "let rand = \n\nlet rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), build(rand, depth - 2))\n| 3 ->\nbuildTimes(build(rand, depth - 2), build(rand, depth - 2))\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))", "annotated": "let rand = \n\nlet rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth <= 0 then buildX()\nelse match rand with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), build(rand, depth - 2))\n| 3 ->\nbuildTimes(build(rand, depth - 2), build(rand, depth - 2))\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))"}
{"fix": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), build(rand, depth - 2))\n| 3 ->\nbuildTimes(build(rand, depth - 2), build(rand, depth - 2))\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))\n| _ -> buildY()", "bad": "let rec build (rand, depth) = \nif depth <= 0 then buildX()\nelse match rand with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), build(rand, depth - 2))\n| 3 ->\nbuildTimes(build(rand, depth - 2), build(rand, depth - 2))\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth <= 0 then buildX()\nelse match rand with \n| 0 -> \nbuildSine(build(rand, depth - 1))\n| 1 -> \nbuildCosine(build(rand, depth - 1))\n| 2 -> \nbuildAverage(build(rand, depth - 2), build(rand, depth - 2))\n| 3 ->\nbuildTimes(build(rand, depth - 2), build(rand, depth - 2))\n| 4 ->\nbuildThresh(build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4), build(rand, depth - 4))"}
{"fix": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| h::t -> f h h\n| [] -> fun x -> x in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| (b, c)::t -> f b c\n| [] -> fun x -> x in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| (b, c)::t -> f b c\n| [] -> fun x -> x in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| h::t -> f h h\n| [] -> fun x -> x in \nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| h::t -> f h h\n| [] -> fun x -> x in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| h::t -> f h t\n| [] -> fun x -> x in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| h::t -> f h t\n| [] -> fun x -> x in \nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| h::t -> f h h\n| [] -> fun x -> x in \nList.fold_left f base fs", "bad": "let _ = pipe [] 3", "annotated": "let _ = pipe [] 3"}
{"fix": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| h::t -> f (fun x -> x) h\n| [] -> fun x -> x in \nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun g -> x (a g) in\nlet base = match fs with \n| (fun b -> c)::t -> f (fun x -> x) h\n| [] -> fun x -> x in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun g -> x (a g) in\nlet base = match fs with \n| (fun b -> c)::t -> f (fun x -> x) h\n| [] -> fun x -> x in \nList.fold_left f base fs"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = h in\nlet l = h in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = h in\nlet l = h in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "bad": "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]", "annotated": "let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]"}
{"fix": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet g a x = a ^ \";\" ^ x in\nlet base = f h in \nlet x = t in\nList.fold_left g base l", "bad": "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "annotated": "let _ = stringOfList string_of_int [1;2;3;4;5;6]"}
{"fix": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet g a x = a ^ \";\" ^ x in\nlet base = f h in \nlet x = t in\nList.fold_left g base l", "bad": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet g a x = a ^ \";\" ^ x in\nlet base = f h in \nlet x = f t in\nList.fold_left g base x", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  match l with \n| [] -> \"\"\n| h :: t ->\nlet g a x = a ^ \";\" ^ x in\nlet base = f h in \nlet x = f t in\nList.fold_left g base x"}
{"fix": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet g a x = a ^ \";\" ^ x in\nlet base = f h in \nlet x = t in\nList.fold_left g base l", "bad": "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "annotated": "let _ = stringOfList string_of_int [1;2;3;4;5;6]"}
{"fix": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet m b = \"[\" ^ b ^ \"]\" in\nlet n a x = a ^ \" ;\" ^ x in\nlet base = f h in \nList.fold_left n base t", "bad": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet m b = \"[\" ^ b ^ \"]\" in\nlet n a x = a ^ \" ;\" ^ x in\nlet base = f h in \nList.fold_left g base t", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  match l with \n| [] -> \"\"\n| h :: t ->\nlet m b = \"[\" ^ b ^ \"]\" in\nlet n a x = a ^ \" ;\" ^ x in\nlet base = f h in \nList.fold_left g base t"}
{"fix": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet m b = \"[\" ^ b ^ \"]\" in\nlet n a x = a ^ \" ;\" ^ x in\nlet base = f h in \nList.fold_left n base t", "bad": "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "annotated": "let _ = stringOfList string_of_int [1;2;3;4;5;6]"}
{"fix": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet m a b = \"[\" ^ a ^ \";\" ^ b ^ \"]\" in\nlet base = f h in \nList.fold_left m base l", "bad": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet m a b = \"[\" ^ a ^ \";\" b ^ \"]\" in\nlet base = f h in \nList.fold_left m base l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  match l with \n| [] -> \"\"\n| h :: t ->\nlet m a b = \"[\" ^ a ^ \";\" b ^ \"]\" in\nlet base = f h in \nList.fold_left m base l"}
{"fix": "let stringOfList f l = match l with \n| [] -> \"\"\n| h :: t ->\nlet m a b = \"[\" ^ a ^ \";\" ^ b ^ \"]\" in\nlet base = f h in \nList.fold_left m base l", "bad": "let _ = stringOfList (fun x -> x) [\"foo\"]", "annotated": "let _ = stringOfList (fun x -> x) [\"foo\"]"}
{"fix": "let _ = stringOfList (fun x -> x) [\"foo\"]", "bad": "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]", "annotated": "let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"}
{"fix": "let _ = stringOfList (fun x -> x) [\"foo\"]", "bad": "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "annotated": "let _ = stringOfList string_of_int [1;2;3;4;5;6]"}
{"fix": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "bad": "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "annotated": "let _ = stringOfList string_of_int [1;2;3;4;5;6]"}
{"fix": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "bad": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" f l) ^ \"]\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\" ^ (sepConcat \"; \" f l) ^ \"]\""}
{"fix": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "bad": "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "annotated": "let _ = stringOfList string_of_int [1;2;3;4;5;6]"}
{"fix": "let padZero l1 l2 = \nif List.length l1 < List.length l2 then\n(clone 0 (List.length l2 - List.length l1)::l1),l2\nelse if List.length l2 > List.length l2 then\nl1, (clone 0 (List.length l1 - List.length l2)::l2)\nelse \nl1, l2", "bad": "let padZero l1 l2 = \nif l1 < l2 then 0", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif l1 < l2 then 0"}
{"fix": "let padZero l1 l2 = \nlet first = List.length l1 in\nlet sec = List.length l2 in\nif first < sec then\nList.append (clone 0 (sec - first)) l1, l2\nelse if first > sec then\nl1, List.append (clone 0 (first - sec)) l2\nelse \nl1, l2", "bad": "let padZero l1 l2 = \nlet first = List.length l1 in\nlet sec = List.length l2 in\nif first < sec then\n((clone 0 (sec - first))::l1)\nelse if first > sec then\nl1, ((clone 0 (first - sec))::l2)\nelse \nl1, l2", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet first = List.length l1 in\nlet sec = List.length l2 in\nif first < sec then\n((clone 0 (sec - first))::l1)\nelse if first > sec then\nl1, ((clone 0 (first - sec))::l2)\nelse \nl1, l2"}
{"fix": "let padZero l1 l2 = \nlet first = List.length l1 in\nlet sec = List.length l2 in\nif first < sec then\nList.append (clone 0 (sec - first)) l1, l2\nelse if first > sec then\nl1, List.append (clone 0 (first - sec)) l2\nelse \nl1, l2", "bad": "let padZero l1 l2 = \nlet first = List.length l1 in\nlet sec = List.length l2 in\nif first < sec then\nList.append (clone 0 (sec - first)) l1, l2\nelse if first > sec then\nList.append l1 ((clone 0 (first - sec))::l2)\nelse \nl1, l2", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet first = List.length l1 in\nlet sec = List.length l2 in\nif first < sec then\nList.append (clone 0 (sec - first)) l1, l2\nelse if first > sec then\nList.append l1 ((clone 0 (first - sec))::l2)\nelse \nl1, l2"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in \nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (i,j)::t -> \nif (i + j) > 9 then (1, (i + j - 10)) else (0 , i + j)\n| [] -> \n(0,0) in \nlet base = (0,0) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (i,j)::t -> \nif (i + j) > 9 then (1, (i + j - 10)) else (0 , i + j)\n| [] -> \n(0,0) in \nlet base = (0,0) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in\nif (i + j) > 9 then (1, (i + j - 10)) \nelse if (i + j) <= 9 then (0 , i + j) in\nlet base = (0,0) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in\nif (i + j) > 9 then (1, (i + j - 10)) \nelse if (i + j) <= 9 then (0 , i + j) in\nlet base = (0,0) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in\nif (i + j) > 9 then (1, (i + j - 10)) \nelse if (i + j) <= 9 then (0 , i + j) in\nlet base = (0,0) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in\n((i+j+a)/10, (i+j+a)%10) in \nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in\nif (i + j) > 9 then (1, (i + j - 10)) \nelse if (i + j) <= 9 then (0 , i + j) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (i,j) = x in\nif (i + j) > 9 then (1, (i + j - 10)) \nelse if (i + j) <= 9 then (0 , i + j) in\nlet base = (0,[]) in\nlet args = \nList.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in\nmultiplier (float_of_int i) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\n((List.length l1) -1,(mulByDigit x*(10**i) l2)::j)in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x =  \nlet (i, j) = a in\n((List.length l1) -1,(mulByDigit x*(10**i) l2)::j)in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in\nmultiplier (float_of_int i) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\n((List.length l1) -1,(mulByDigit (x*(10**i)) l2)::j)in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x =  \nlet (i, j) = a in\n((List.length l1) -1,(mulByDigit (x*(10**i)) l2)::j)in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in\nmultiplier (float_of_int i) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\n((List.length l1) -1,(mulByDigit (x*((float_of_int 10)**i)) l2)::j)in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x =  \nlet (i, j) = a in\n((List.length l1) -1,(mulByDigit (x*((float_of_int 10)**i)) l2)::j)in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in\nmultiplier (float_of_int i) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\n((List.length l1) -1,(mulByDigit (x*int_of_float((float_of_int 10)**i)) l2)::j)in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x =  \nlet (i, j) = a in\n((List.length l1) -1,(mulByDigit (x*int_of_float((float_of_int 10)**i)) l2)::j)in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in\nmultiplier (float_of_int i) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\n((List.length l1) -1,(mulByDigit (x*(int_of_float((float_of_int 10)**i))) l2)::j)in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x =  \nlet (i, j) = a in\n((List.length l1) -1,(mulByDigit (x*(int_of_float((float_of_int 10)**i))) l2)::j)in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in\nmultiplier (float_of_int i) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**i))) l2)::n) in\nmultipler (float_of_int i) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**i))) l2)::n) in\nmultipler (float_of_int i) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in\nmultiplier (float_of_int i) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**i))) l2)::n) in\nmultiplier (float_of_int i) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**i))) l2)::n) in\nmultiplier (float_of_int i) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**10.0))) l2)::n) in\nmultiplier (float_of_int i) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**10))) l2)::n) in\nmultiplier (float_of_int i) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n((List.length l1) - 1, (mulByDigit (x*(int_of_float(m**10))) l2)::n) in\nmultiplier (float_of_int i) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(i-1, (mulByDigit x l2)::(clone 0 m)::n) in\nmultiplier ((List.length l1)-1) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(i-1, ((mulByDigit x l2)*(int_of_float(10**m)))::n) in\nmultiplier (float_of_int ((List.length l1)-1)) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(i-1, ((mulByDigit x l2)*(int_of_float(10**m)))::n) in\nmultiplier (float_of_int ((List.length l1)-1)) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(i-1, (mulByDigit x l2)::(clone 0 m)::n) in\nmultiplier ((List.length l1)-1) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(i-1, (mulByDigit x l2)::(clone 0 m)::n) in\nmultiplier (float_of_int ((List.length l1)-1)) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x =  \nlet (i, j) = a in\nlet multiplier m n = \n(i-1, (mulByDigit x l2)::(clone 0 m)::n) in\nmultiplier (float_of_int ((List.length l1)-1)) j in\nlet base = (0, []) in\nlet args = \nl1 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let rec sumList xs =\nmatch xs with\n| [] -> 0\n| x::s -> x + sumList s", "bad": "let rec sumList xs =\nmatch xs with\n| [] -> 0\n| x:s -> x + sumList s", "annotated": "let rec sumList : int list -> int = fun  xs  -> \nmatch xs with\n| [] -> 0\n| x:s -> x + sumList s"}
{"fix": "let _ = sumList [1; 3; 5; 7; 9; 11]", "bad": "let _ = sumList [1; 3; 5; 7; 9; 11]\n\n55 / 10", "annotated": "let _ = sumList [1; 3; 5; 7; 9; 11]\n\n55 / 10"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse n mod 10 :: digitsOfInt (n/10)", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse n % 10 :: digitsOfInt (n\\10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse n % 10 :: digitsOfInt (n\\10)"}
{"fix": "let rec digitsOfInt n = \nif n < 0 then []\nelse n mod 10 :: digitsOfInt (n/10)", "bad": "let rec digitsOfInt n = \nif n < 0 then []\nelse n % 10 :: digitsOfInt (n/10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n < 0 then []\nelse n % 10 :: digitsOfInt (n/10)"}
{"fix": "let rec digitsOfInt n = \nif n <= 0 then []\nelse n mod 10 :: digitsOfInt (n/10)", "bad": "let rec digitsOfInt n = \nif n <= 0 then []\nelse digitsOfInt (n/10) :: n mod 10", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n <= 0 then []\nelse digitsOfInt (n/10) :: n mod 10"}
{"fix": "let rec digitsOfIntHelper n = \nif n > 0 then digitsOfIntHelper (n/10) @ [n mod 10] \nelse []", "bad": "let rec digitsOfIntHelper n = \nif n > 0 digitsOfIntHelper (n/10) @ [n mod 10] \nelse []", "annotated": "let rec digitsOfInt : int -> int list = fun Helper n  ->  \nif n > 0 digitsOfIntHelper (n/10) @ [n mod 10] \nelse []"}
{"fix": "let rec additivePersistence n = \nif n = 0 then 0\nelse 1 + additivePersistence (sumList (digits n))", "bad": "let rec additivePersistence n = \nif n = 0 then 0\nelse 1 + additivePersistence sumList (digits n)", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif n = 0 then 0\nelse 1 + additivePersistence sumList (digits n)"}
{"fix": "let rec additivePersistence n = \nif n = 0 then 0\nelse 1 + additivePersistence (sumList (digits n))", "bad": "let rec additivePersistence n = \nif n = 0 then 0\nelse 1 + additivePersistence (sumList digits n)", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif n = 0 then 0\nelse 1 + additivePersistence (sumList digits n)"}
{"fix": "let rec digitsOfInt n = \nif n > 0 then \nlet k = digitsOfInt (n/10) in\n(n mod 10) :: k\nelse []", "bad": "let rec digitsOfInt n = \nif n > 0 then \nlet k = digitsOfInt (n/10) in\nk :: (n mod 10)\nelse []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n > 0 then \nlet k = digitsOfInt (n/10) in\nk :: (n mod 10)\nelse []"}
{"fix": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t else false\n| _ -> false)\n| _ -> false", "bad": "let palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x == y then palindromeHelper s t\n| _ -> false)\n| _ -> false", "annotated": "let palindrome : string -> bool = fun Helper w r  ->  \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x == y then palindromeHelper s t\n| _ -> false)\n| _ -> false"}
{"fix": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t else false\n| _ -> false)\n| _ -> false", "bad": "let palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then palindromeHelper s t\n| _ -> false)", "annotated": "let palindrome : string -> bool = fun Helper w r  ->  \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then palindromeHelper s t\n| _ -> false)"}
{"fix": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t else false\n| _ -> false)\n| _ -> false", "bad": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then  palindromeHelper s t\n| _ -> false)", "annotated": "let rec palindrome : string -> bool = fun Helper w r  ->  \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then  palindromeHelper s t\n| _ -> false)"}
{"fix": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t else false\n| _ -> false)\n| _ -> false", "bad": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then  palindromeHelper s t\n| _ -> false)", "annotated": "let rec palindrome : string -> bool = fun Helper w r  ->  \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then  palindromeHelper s t\n| _ -> false)"}
{"fix": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t else false\n| _ -> false)\n| _ -> false", "bad": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then palindromeHelper s t\n| _ -> false)", "annotated": "let rec palindrome : string -> bool = fun Helper w r  ->  \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then palindromeHelper s t\n| _ -> false)"}
{"fix": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t else false\n| _ -> false)\n| _ -> false", "bad": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then palindromeHelper s t\n| _ -> false)\n| _ -> false", "annotated": "let rec palindrome : string -> bool = fun Helper w r  ->  \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then palindromeHelper s t\n| _ -> false)\n| _ -> false"}
{"fix": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t else false\n| _ -> false)\n| _ -> false", "bad": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t\n| _ -> false)\n| _ -> false", "annotated": "let rec palindrome : string -> bool = fun Helper w r  ->  \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t\n| _ -> false)\n| _ -> false"}
{"fix": "let palindrome w = \nlet wl = explode w in\nlet rl = listReverse wl in\npalindromeHelper wl rl", "bad": "let _ = palindrome \"malayalam\"", "annotated": "let _ = palindrome \"malayalam\""}
{"fix": "let rec digitsOfInt n = \nlet result = [] in \nlet rec digitsOfIntHelper n result = \nif n > 0 then (n mod 10) :: digitsOfIntHelper (n/10) result \nelse result in []", "bad": "let rec digitsOfInt n = \nlet result = [] in \nlet rec digitsOfIntHelper n result = \nif n > 0 then (n mod 10) :: digitsOfIntHelper (n/10) result \nelse result", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet result = [] in \nlet rec digitsOfInt : int -> int list = fun  n  ->  \nif n > 0 then (n mod 10) :: digitsOfIntHelper (n/10) result \nelse result"}
{"fix": "let rec digitsOfInt n = \nlet result = [] in \nlet rec digitsOfIntHelper n result = \nif n > 0 then (n mod 10) :: digitsOfIntHelper (n/10) result \nelse result in []", "bad": "let rec digitsOfInt n = \nlet result = [] in \nlet rec digitsOfIntHelper n result = \nif n > 0 then (n mod 10) :: digitsOfIntHelper (n/10) result \nelse result in \n\n\nlet _ = digitsOfInt 100", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet result = [] in \nlet rec digitsOfInt : int -> int list = fun  n  ->  \nif n > 0 then (n mod 10) :: digitsOfIntHelper (n/10) result \nelse result in \n\n\nlet _ = digitsOfInt 100"}
{"fix": "let rec digitsOfInt n = \nlet rec digitsOfIntHelper n result = \nif n > 0 then digitsOfIntHelper (n/10) (n mod 10 :: result)\nelse result in \ndigitsOfIntHelper n []", "bad": "let rec digitsOfInt n = \nlet rec digitsOfIntHelper n result = \nif n > 0 then digitsOfIntHelper (n/10) (n mod 10) :: result\nelse result in \ndigitsOfIntHelper n []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet rec digitsOfInt : int -> int list = fun  n  ->  \nif n > 0 then digitsOfIntHelper (n/10) (n mod 10) :: result\nelse result in \ndigitsOfIntHelper n []"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))\n\nremoveDuplicates\n[1;6;2;4;12;2;13;6;9]\n[1;6;2;4;12;13;9]", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then seen else h :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))\n\nremoveDuplicates\n[1;6;2;4;12;2;13;6;9]\n[1;6;2;4;12;13;9]"}
{"fix": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\"  ^ exprToString x ^ \"*\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b \n^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d", "bad": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" + exprToString x + \")\"\n| Cosine x -> \"cos(pi*\" + exprToString x + \")\"\n| Average x y -> \"((\"  + exprToString x + \"*\" + exprToString y + \")/2)\"\n| Times x y -> exprToString x + \"*\" + exprToString y\n| Thresh a b c d -> \"(\" + exprToString a + \"<\" + exprToString b \n+ \"?\" exprToString c + \":\" + exprToString d", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" + exprToString x + \")\"\n| Cosine x -> \"cos(pi*\" + exprToString x + \")\"\n| Average x y -> \"((\"  + exprToString x + \"*\" + exprToString y + \")/2)\"\n| Times x y -> exprToString x + \"*\" + exprToString y\n| Thresh a b c d -> \"(\" + exprToString a + \"<\" + exprToString b \n+ \"?\" exprToString c + \":\" + exprToString d"}
{"fix": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\"  ^ exprToString x ^ \"*\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b \n^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d", "bad": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" + exprToString x + \")\"\n| Cosine x -> \"cos(pi*\" + exprToString x + \")\"\n| Average (x,y) -> \"((\"  + exprToString x + \"*\" + exprToString y + \")/2)\"\n| Times x y -> exprToString x + \"*\" + exprToString y\n| Thresh a b c d -> \"(\" + exprToString a + \"<\" + exprToString b \n+ \"?\" exprToString c + \":\" + exprToString d", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" + exprToString x + \")\"\n| Cosine x -> \"cos(pi*\" + exprToString x + \")\"\n| Average (x,y) -> \"((\"  + exprToString x + \"*\" + exprToString y + \")/2)\"\n| Times x y -> exprToString x + \"*\" + exprToString y\n| Thresh a b c d -> \"(\" + exprToString a + \"<\" + exprToString b \n+ \"?\" exprToString c + \":\" + exprToString d"}
{"fix": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\"  ^ exprToString x ^ \"*\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b \n^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d", "bad": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" + exprToString x + \")\"\n| Cosine x -> \"cos(pi*\" + exprToString x + \")\"\n| Average (x,y) -> \"((\"  + exprToString x + \"*\" + exprToString y + \")/2)\"\n| Times (x,y) -> exprToString x + \"*\" + exprToString y\n| Thresh (a,b,c,d) -> \"(\" + exprToString a + \"<\" + exprToString b \n+ \"?\" exprToString c + \":\" + exprToString d", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" + exprToString x + \")\"\n| Cosine x -> \"cos(pi*\" + exprToString x + \")\"\n| Average (x,y) -> \"((\"  + exprToString x + \"*\" + exprToString y + \")/2)\"\n| Times (x,y) -> exprToString x + \"*\" + exprToString y\n| Thresh (a,b,c,d) -> \"(\" + exprToString a + \"<\" + exprToString b \n+ \"?\" exprToString c + \":\" + exprToString d"}
{"fix": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\"  ^ exprToString x ^ \"*\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b \n^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d", "bad": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\"  ^ exprToString x ^ \"*\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b \n^ \"?\" exprToString c ^ \":\" ^ exprToString d", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\"  ^ exprToString x ^ \"*\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b \n^ \"?\" exprToString c ^ \":\" ^ exprToString d"}
{"fix": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\"  ^ exprToString x ^ \"*\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b \n^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d", "bad": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\"  ^ exprToString x ^ \"*\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x + \"*\" ^ exprToString y\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b \n^\"?\" exprToString c ^ \":\" ^ exprToString d", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\"  ^ exprToString x ^ \"*\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x + \"*\" ^ exprToString y\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b \n^\"?\" exprToString c ^ \":\" ^ exprToString d"}
{"fix": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\"  ^ exprToString x ^ \"*\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b \n^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d", "bad": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\"  ^ exprToString x ^ \"*\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b \n^\"?\" exprToString c ^ \":\" ^ exprToString d", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with \n| VarX -> \"x\"\n| VarY -> \"y\" \n| Sine x -> \"sin(pi*\" ^ exprToString x ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString x ^ \")\"\n| Average (x,y) -> \"((\"  ^ exprToString x ^ \"*\" ^ exprToString y ^ \")/2)\"\n| Times (x,y) -> exprToString x ^ \"*\" ^ exprToString y\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b \n^\"?\" exprToString c ^ \":\" ^ exprToString d"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> sin (pi *. (eval u))\n| Cos u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> ((eval s) < (eval t) ? (eval u) : (eval v))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> sin (pi *. (eval u))\n| Cos u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> ((eval s) < (eval t) ? (eval u) : (eval v))"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> sin (pi *. (eval u))\n| Cos u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> ((eval s) < (eval t)) ? (eval u) : (eval v)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> sin (pi *. (eval u))\n| Cos u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> ((eval s) < (eval t)) ? (eval u) : (eval v)"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> sin (pi *. (eval u))\n| Cos u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> ((eval s) < (eval t)) ? eval u : eval v", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> sin (pi *. (eval u))\n| Cos u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> ((eval s) < (eval t)) ? eval u : eval v"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> sin (pi *. (eval u))\n| Cos u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> (eval s) < (eval t) ? eval u : eval v", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> sin (pi *. (eval u))\n| Cos u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> (eval s) < (eval t) ? eval u : eval v"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> sin (pi *. (eval u))\n| Cos u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> sin (pi *. (eval u))\n| Cos u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> sin (pi *. (eval u))\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> sin (pi *. (eval u))\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. (eval u)\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. (eval u)\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval u\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval u\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi \n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi \n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. (eval u)\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. (eval u)\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi .* (eval u)\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi .* (eval u)\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi * (eval u)\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi * (eval u)\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. (eval u)\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. (eval u)\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. (eval u) * 1 * 1\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. (eval u) * 1 * 1\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v"}
{"fix": "let rec build (rand,depth) = \nif depth = 1 then \nif rand(0,1) = 0 then VarX\nelse VarY\nelse (* depth > 1 *)\nmatch rand(0,4) with\n| 0 -> Sine (build (rand, depth-1))\n| 1 -> Cosine (build (rand, depth-1))\n| 2 -> Average ((build (rand, depth-1)), (build (rand, depth-1)))\n| 3 -> Times ((build (rand, depth-1)), (build (rand, depth-1)))\n| 4 -> Thresh ((build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)))", "bad": "let rec build (rand,depth) = \nif depth = 1 then \nif rand(0,1) = 0 then VarX\nelse VarY\nelse (* depth > 1 *)\nmatch rand(0,4) with\n| 0 -> Sine (build (rand, depth-1))\n| 1 -> Cosine (build (rand, depth-1))\n| 2 -> Average (build (rand, depth-1)), (build (rand, depth-1))\n| 3 -> Times (build (rand, depth-1)) (build (rand, depth-1))\n| 4 -> Thresh (build (rand, depth-1)) (build (rand, depth-1)) (build (rand, depth-1)) (build (rand, depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand,depth)  ->  \nif depth = 1 then \nif rand(0,1) = 0 then VarX\nelse VarY\nelse (* depth > 1 *)\nmatch rand(0,4) with\n| 0 -> Sine (build (rand, depth-1))\n| 1 -> Cosine (build (rand, depth-1))\n| 2 -> Average (build (rand, depth-1)), (build (rand, depth-1))\n| 3 -> Times (build (rand, depth-1)) (build (rand, depth-1))\n| 4 -> Thresh (build (rand, depth-1)) (build (rand, depth-1)) (build (rand, depth-1)) (build (rand, depth-1))"}
{"fix": "let rec build (rand,depth) = \nif depth = 1 then \nif rand(0,1) = 0 then VarX\nelse VarY\nelse (* depth > 1 *)\nmatch rand(0,4) with\n| 0 -> Sine (build (rand, depth-1))\n| 1 -> Cosine (build (rand, depth-1))\n| 2 -> Average ((build (rand, depth-1)), (build (rand, depth-1)))\n| 3 -> Times ((build (rand, depth-1)), (build (rand, depth-1)))\n| 4 -> Thresh ((build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)))", "bad": "let rec build (rand,depth) = \nif depth = 1 then \nif rand(0,1) = 0 then VarX\nelse VarY\nelse (* depth > 1 *)\nmatch rand(0,4) with\n| 0 -> Sine (build (rand, depth-1))\n| 1 -> Cosine (build (rand, depth-1))\n| 2 -> Average (build (rand, depth-1)), (build (rand, depth-1))\n| 3 -> Times (build (rand, depth-1)), (build (rand, depth-1))\n| 4 -> Thresh (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand,depth)  ->  \nif depth = 1 then \nif rand(0,1) = 0 then VarX\nelse VarY\nelse (* depth > 1 *)\nmatch rand(0,4) with\n| 0 -> Sine (build (rand, depth-1))\n| 1 -> Cosine (build (rand, depth-1))\n| 2 -> Average (build (rand, depth-1)), (build (rand, depth-1))\n| 3 -> Times (build (rand, depth-1)), (build (rand, depth-1))\n| 4 -> Thresh (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1))"}
{"fix": "let rec build (rand,depth) = \nif depth = 1 then \nif rand(0,1) = 0 then VarX\nelse VarY\nelse (* depth > 1 *)\nmatch rand(0,4) with\n| 0 -> Sine (build (rand, depth-1))\n| 1 -> Cosine (build (rand, depth-1))\n| 2 -> Average ((build (rand, depth-1)), (build (rand, depth-1)))\n| 3 -> Times ((build (rand, depth-1)), (build (rand, depth-1)))\n| 4 -> Thresh ((build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)))", "bad": "let rec build (rand,depth) = \nif depth = 1 then \nif rand(0,1) = 0 then VarX\nelse VarY\nelse (* depth > 1 *)\nmatch rand(0,4) with\n| 0 -> Sine (build (rand, depth-1))\n| 1 -> Cosine (build (rand, depth-1))\n| 2 -> Average ((build (rand, depth-1)), (build (rand, depth-1)))\n| 3 -> Times (build (rand, depth-1)), (build (rand, depth-1))\n| 4 -> Thresh (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand,depth)  ->  \nif depth = 1 then \nif rand(0,1) = 0 then VarX\nelse VarY\nelse (* depth > 1 *)\nmatch rand(0,4) with\n| 0 -> Sine (build (rand, depth-1))\n| 1 -> Cosine (build (rand, depth-1))\n| 2 -> Average ((build (rand, depth-1)), (build (rand, depth-1)))\n| 3 -> Times (build (rand, depth-1)), (build (rand, depth-1))\n| 4 -> Thresh (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1)), (build (rand, depth-1))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = sum + x*x in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = sum + x*x in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let pipe fs = \nlet f a x = a in\nlet base = [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = f x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = f x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = a in\nlet base = [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = let f x = x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = let f x = x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = a in\nlet base = [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = f -> x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = f -> x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = a in\nlet base = [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = a in\nlet base = [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = f x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = f x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = a in\nlet base = [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = a in\nlet base = [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = fun x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = fun x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = a in\nlet base = [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = a in\nlet base = [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = (fun x) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = (fun x) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = a in\nlet base = [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = a in\nlet base = [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = f in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = f in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = a in\nlet base = [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = 0 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = a in\nlet base = [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = [] in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = [] in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = a in\nlet base = [] in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = [] in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = [] in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = fun f x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = [] in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a -> x in\nlet base = [] in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = fun f x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a -> x in\nlet base = x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = fun f x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = a in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a -> x in\nlet base = a in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = fun f x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a -> x in\nlet base = fun f x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a -> x in\nlet base = fun f x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = fun f x  in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a -> x in\nlet base = fun f x  in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a -> x in\nlet base = x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = [] in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a -> x in\nlet base = [] in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a -> a x in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a -> a x in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = x in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = fun c -> x (a c) in\nlet base =  fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun y -> fun a -> x in\nlet base =  fun a -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun y -> fun a -> x in\nlet base =  fun a -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun c -> x (a c) in\nlet base =  fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun y -> fun a -> x in\nlet base =  fun f -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun y -> fun a -> x in\nlet base =  fun f -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun c -> x (a c) in\nlet base =  fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun y -> fun a -> x in\nlet base =  fun f in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun y -> fun a -> x in\nlet base =  fun f in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun c -> x (a c) in\nlet base =  fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun y -> fun a -> x in\nlet base =  f x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun y -> fun a -> x in\nlet base =  f x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun c -> x (a c) in\nlet base =  fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun y -> fun a -> x in\nlet base =  fun a -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun y -> fun a -> x in\nlet base =  fun a -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun c -> x (a c) in\nlet base =  fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun x -> a in\nlet base =  fun a -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x -> a in\nlet base =  fun a -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun c -> x (a c) in\nlet base =  fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a -> a x in\nlet base =  fun a -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a -> a x in\nlet base =  fun a -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun c -> x (a c) in\nlet base =  fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a -> a x in\nlet base =  0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a -> a x in\nlet base =  0 in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun c -> x (a c) in\nlet base =  fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = fun a -> a x in\nlet base =  f -> b in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun a -> a x in\nlet base =  f -> b in\nList.fold_left f base fs"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = [] in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = fun c -> a ^ sep ^ x in\nlet base = \"\" in\nlet l = l in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = fun c -> a ^ sep ^ x in\nlet base = \"\" in\nlet l = l in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = [] in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = fun c -> a ^ sep ^ x in\nlet base = \"\" in\nlet l = \"\" in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = fun c -> a ^ sep ^ x in\nlet base = \"\" in\nlet l = \"\" in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = [] in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = \"\" in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = \"\" in\nlet l = \"\" in\nList.fold_left f base l"}
{"fix": "let padZero l1 l2 = \nlet leng1 = List.length l1 in\nlet leng2 = List.length l2 in\n(clone 0 (leng1-leng2) @ l1 , clone 0 (leng2-leng1) @ l2)", "bad": "let padZero l1 l2 = \nlet leng1 = List.length l1 in\nlet leng2 = List.length l2 in\n(clone 0 leng1-leng2 @ l1 , clone 0 leng2-leng1 @ l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet leng1 = List.length l1 in\nlet leng2 = List.length l2 in\n(clone 0 leng1-leng2 @ l1 , clone 0 leng2-leng1 @ l2)"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = l1  in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = l1  in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = l1  in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = l1  in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = [] in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = [] in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = [] in\nlet args = ([], []) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = [] in\nlet args = ([], []) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = ([], []) in\nlet args = ([], []) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = ([], []) in\nlet args = ([], []) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = ([], []) in\nlet args = 0 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = ([], []) in\nlet args = 0 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = ([], []) in\nlet args = [[],[]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = ([], []) in\nlet args = [[],[]] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigAdd [9;9] [1;0;0;2]", "annotated": "let _ = bigAdd [9;9] [1;0;0;2]"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigAdd [9;9;9;9] [9;9;9]", "annotated": "let _ = bigAdd [9;9;9;9] [9;9;9]"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigAdd [9;9] [1;0;0;2]", "annotated": "let _ = bigAdd [9;9] [1;0;0;2]"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigAdd [9;9;9;9] [9;9;9]", "annotated": "let _ = bigAdd [9;9;9;9] [9;9;9]"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = ([]) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = ([]) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigAdd [9;9] [1;0;0;2]", "annotated": "let _ = bigAdd [9;9] [1;0;0;2]"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigAdd [9;9;9;9] [9;9;9]", "annotated": "let _ = bigAdd [9;9;9;9] [9;9;9]"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  x in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigAdd [9;9] [1;0;0;2]", "annotated": "let _ = bigAdd [9;9] [1;0;0;2]"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigAdd [9;9;9;9] [9;9;9]", "annotated": "let _ = bigAdd [9;9;9;9] [9;9;9]"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  x.first in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  x.first in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigAdd [9;9] [1;0;0;2]", "annotated": "let _ = bigAdd [9;9] [1;0;0;2]"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigAdd [9;9;9;9] [9;9;9]", "annotated": "let _ = bigAdd [9;9;9;9] [9;9;9]"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  (a.first + x.first, a.second + x.second) in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  (a.first + x.first, a.second + x.second) in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  (a, a) in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  (a, a) in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  (a, x) in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  (a, x) in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  a in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a + x in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  a + x in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a + x.first in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  a + x.first in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a + x in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  a + x in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  a in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  [a] in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  [a] in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a + 1 in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  a + 1 in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  (a, a) in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  (a, a) in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  ([a], a) in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  ([a], a) in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a[0] in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  a[0] in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  a in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigAdd [9;9] [1;0;0;2]", "annotated": "let _ = bigAdd [9;9] [1;0;0;2]"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigAdd [9;9;9;9] [9;9;9]", "annotated": "let _ = bigAdd [9;9;9;9] [9;9;9]"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a in\nlet base = ([], []) in\nlet args = [0] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  a in\nlet base = ([], []) in\nlet args = [0] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigAdd [9;9] [1;0;0;2]", "annotated": "let _ = bigAdd [9;9] [1;0;0;2]"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigAdd [9;9;9;9] [9;9;9]", "annotated": "let _ = bigAdd [9;9;9;9] [9;9;9]"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a in\nlet base = ([], []) in\nlet args = 0 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  a in\nlet base = ([], []) in\nlet args = 0 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a in\nlet base = ([], []) in\nlet args = [0] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  a in\nlet base = ([], []) in\nlet args = [0] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a + 1 in\nlet base = ([], []) in\nlet args = [0] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  a + 1 in\nlet base = ([], []) in\nlet args = [0] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a + 1 in\nlet base = 5 in\nlet args = [0] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  a + 1 in\nlet base = 5 in\nlet args = [0] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  a in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  [5],[5] in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  [5],[5] in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigAdd [9;9] [1;0;0;2]", "annotated": "let _ = bigAdd [9;9] [1;0;0;2]"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigAdd [9;9;9;9] [9;9;9]", "annotated": "let _ = bigAdd [9;9;9;9] [9;9;9]"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a.first,a.second in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  a.first,a.second in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a.fst,a.snd in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  a.fst,a.snd in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  (fst a), (snd a) in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  (fst a), (snd a) in\nlet base = ([], []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigAdd [9;9] [1;0;0;2]", "annotated": "let _ = bigAdd [9;9] [1;0;0;2]"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigAdd [9;9;9;9] [9;9;9]", "annotated": "let _ = bigAdd [9;9;9;9] [9;9;9]"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  (fst a), (snd a) in\nlet base = (List.rev l1, List.rev l2) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  (fst a), (snd a) in\nlet base = (List.rev l1, List.rev l2) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigAdd [9;9] [1;0;0;2]", "annotated": "let _ = bigAdd [9;9] [1;0;0;2]"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigAdd [9;9;9;9] [9;9;9]", "annotated": "let _ = bigAdd [9;9;9;9] [9;9;9]"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  (fst a), (snd a) in\nlet base = (List.rev l1, []) in\nlet args = [List.rev l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  (fst a), (snd a) in\nlet base = (List.rev l1, []) in\nlet args = [List.rev l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigAdd [9;9] [1;0;0;2]", "annotated": "let _ = bigAdd [9;9] [1;0;0;2]"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let _ = bigAdd [9;9;9;9] [9;9;9]", "annotated": "let _ = bigAdd [9;9;9;9] [9;9;9]"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| []  -> []. snd a\n| h:t -> t, ((fst h + snd h) % 10 :: snd a) in\nlet base = (List.combine (rev l1, rev l2), []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| []  -> []. snd a\n| h:t -> t, ((fst h + snd h) % 10 :: snd a) in\nlet base = (List.combine (rev l1, rev l2), []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| []  -> []. snd a\n| h::t -> t, ((fst h + snd h) % 10 :: snd a) in\nlet base = (List.combine (rev l1, rev l2), []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| []  -> []. snd a\n| h::t -> t, ((fst h + snd h) % 10 :: snd a) in\nlet base = (List.combine (rev l1, rev l2), []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| []  -> [], snd a\n| h::t -> t, ((fst h + snd h) % 10 :: snd a) in\nlet base = (List.combine (rev l1, rev l2), []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| []  -> [], snd a\n| h::t -> t, ((fst h + snd h) % 10 :: snd a) in\nlet base = (List.combine (rev l1, rev l2), []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| []  -> [], snd snd a\n| h::t -> t, ((fst h + snd h) % 10 :: snd a) in\nlet base = (List.combine (rev l1, rev l2), []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| []  -> [], snd snd a\n| h::t -> t, ((fst h + snd h) % 10 :: snd a) in\nlet base = (List.combine (rev l1, rev l2), []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match snd a with\n| []  -> [], snd a\n| h::t -> t, ((fst h + snd h) % 10 :: snd a) in\nlet base = (List.combine (rev l1, rev l2), []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match snd a with\n| []  -> [], snd a\n| h::t -> t, ((fst h + snd h) % 10 :: snd a) in\nlet base = (List.combine (rev l1, rev l2), []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match snd a with\n| []  -> [], snd a\n| h::t -> t, ((fst h + snd h) mod 10 :: snd a) in\nlet base = (List.combine (rev l1, rev l2), []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match snd a with\n| []  -> [], snd a\n| h::t -> t, ((fst h + snd h) mod 10 :: snd a) in\nlet base = (List.combine (rev l1, rev l2), []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match snd a with\n| []  -> [], snd a\n| h::t -> t, ((fst h + snd h) mod 10 :: snd a) in\nlet base = (List.combine (rev l1, rev l2), []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match snd a with\n| []  -> [], snd a\n| h::t -> t, ((fst h + snd h) mod 10 :: snd a) in\nlet base = (List.combine (rev l1, rev l2), []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match fst a with\n| []  -> [], snd a\n| h::t -> t, ((fst h + snd h) mod 10 :: snd a) in\nlet base = (List.combine (rev l1, rev l2), []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match fst a with\n| []  -> [], snd a\n| h::t -> t, ((fst h + snd h) mod 10 :: snd a) in\nlet base = (List.combine (rev l1, rev l2), []) in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = List.combine l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = ([], []) in\nlet args = List.rev (List.combine (l1, l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = ([], []) in\nlet args = List.rev (List.combine (l1, l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = List.combine l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = ([], []) in\nlet args = List.rev (List.combine (l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = ([], []) in\nlet args = List.rev (List.combine (l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = List.combine l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = ([], []) in\nlet args = (List.combine (l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = ([], []) in\nlet args = (List.combine (l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = List.combine l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = ([], []) in\nlet args = List.combine (l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = ([], []) in\nlet args = List.combine (l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = List.combine l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = ([], []) in\nlet args = List.combine (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = ([], []) in\nlet args = List.combine (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = List.combine l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = ([], []) in\nlet args = [List.combine (l1, l2)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = ([], []) in\nlet args = [List.combine (l1, l2)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = List.combine l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = [List.combine (l1, l2)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = [List.combine (l1, l2)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = List.combine l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = [List.combine (l1, l2)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = [List.combine (l1, l2)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = List.combine l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = [List.combine l1] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = [List.combine l1] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = [List.combine (l1, l2)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = List.combine l1, l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = List.combine l1, l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = [List.combine (l1, l2)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = [0, 0] in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = failwith \"to be implemeneted\" in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> a\n| h::t  -> ( (fst h + snd h) / 10, (fst h + snd h) mod 10 :: t )in \nlet base = (0, []) in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = (0, 0) in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = (0, 0) in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> a\n| h::t  -> ( (fst h + snd h) / 10, (fst h + snd h) mod 10 :: t )in \nlet base = (0, []) in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = (0, []) in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in \nlet base = (0, []) in\nlet args = [List.combine l1, l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let _ = bigAdd [9;9] [1;0;0;2]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> a\n| h::t  -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> a\n| h::t  -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2"}
{"fix": "let _ = bigAdd [9;9] [1;0;0;2]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> a\n| h::t  -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\n(*let (_, res) = List.fold_left f base args in\nres*)\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> a\n| h::t  -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\n(*let (_, res) = List.fold_left f base args in\nres*)\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let _ = bigAdd [9;9] [1;0;0;2]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> a\n| h::t  -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\n(*let (_, res) = List.fold_left f base args in\nres*)\n(*in*) \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> a\n| h::t  -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\n(*let (_, res) = List.fold_left f base args in\nres*)\n(*in*) \nremoveZero (add (padZero l1 l2))"}
{"fix": "let _ = bigAdd [9;9] [1;0;0;2]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> a\n| h::t  -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| []    -> a\n| h::t  -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let _ = bigAdd [9;9] [1;0;0;2]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"3232\" in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"3232\" in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| [] -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| _ -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (fst x + snd x) / 10, ((fst x + snd x) mod 10 :: snd a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| () -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| () -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (fst x + snd x) / 10, ((fst x + snd x) mod 10 :: snd a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| [] -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| [] -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (fst x + snd x) / 10, ((fst x + snd x) mod 10 :: snd a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| ([]) -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| ([]) -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (fst x + snd x) / 10, ((fst x + snd x) mod 10 :: snd a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| 5 -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| 5 -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (fst x + snd x) / 10, ((fst x + snd x) mod 10 :: snd a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| 'a' -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| 'a' -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (fst x + snd x) / 10, ((fst x + snd x) mod 10 :: snd a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (_, _) -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| (_, _) -> a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let _ = bigAdd [9;9] [1;0;0;2]", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (fst x + snd x) / 10, (fst x + snd x) mod 10 :: snd a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = (fst x + snd x) / 10, (fst x + snd x) mod 10 :: snd a in \nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"fix": "let _ = mulByDigit 9 [9;9;9;9]", "bad": "let rec mulByDigit i l = \nlet f x a = let digitRes = (x * i) + fst a in\ndigitRes / 10, (digitRes mod 10) :: snd a in\nlet base  = (0, []) in\nlet (_, result) = List.fold_right f (0 :: l) base in\nresult", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet f x a = let digitRes = (x * i) + fst a in\ndigitRes / 10, (digitRes mod 10) :: snd a in\nlet base  = (0, []) in\nlet (_, result) = List.fold_right f (0 :: l) base in\nresult"}
{"fix": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet value = mulByDigit l1 x in\n0, bigAdd value snd a in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet value = mulByDigit l1 x in\n0, bigAdd value snd a in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet value = mulByDigit l1 x in\n0, bigAdd value (snd a) in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet value = mulByDigit l1 x in\n0, bigAdd value (snd a) in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet value = mulByDigit l1 x in\n0, bigAdd value x in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet value = mulByDigit l1 x in\n0, bigAdd value x in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet value = mulByDigit l1 x in\n0, bigAdd value x :: snd a in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet value = mulByDigit l1 x in\n0, bigAdd value x in \nlet base = ([], []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet value = mulByDigit l1 x in\n0, bigAdd value x in \nlet base = ([], []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet value = mulByDigit l1 x in\n0, bigAdd value x :: snd a in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "annotated": "let _ = bigMul [9;9;9;9] [9;9;9;9]"}
{"fix": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet value = mulByDigit x l1 in\n0, bigAdd value x :: snd a in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet value = mulByDigit x l1 in\n0, bigAdd value x :: snd a in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "bad": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "annotated": "let _ = bigMul [9;9;9;9] [9;9;9;9]"}
{"fix": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet value = mulByDigit x l1 in\n0, bigAdd x value :: snd a in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet value = mulByDigit x l1 in\n0, bigAdd x value :: snd a in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "bad": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "annotated": "let _ = bigMul [9;9;9;9] [9;9;9;9]"}
{"fix": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet value = mulByDigit x l1 in\n0, bigAdd value snd a in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet value = mulByDigit x l1 in\n0, bigAdd value snd a in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "bad": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "annotated": "let _ = bigMul [9;9;9;9] [9;9;9;9]"}
{"fix": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet value = mulByDigit x l1 in\n0, bigAdd value (snd a) in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet value = mulByDigit x l1 in\n0, bigAdd value (snd a) in \nlet base = (0, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let rec sumList xs =\nmatch xs with\n[] -> []\n| head::tail -> head + (sumList tail)", "bad": "let rec sumList xs =\nmatch xs with\n[] -> []\n| head::tail- > head + (sumList tail)", "annotated": "let rec sumList : int list -> int = fun  xs  -> \nmatch xs with\n[] -> []\n| head::tail- > head + (sumList tail)"}
{"fix": "let rec sumList xs =\nmatch xs with\n[] -> 0\n| head::tail -> head + (sumList tail)", "bad": "let _ = sumList [1; 2; 3; 4]", "annotated": "let _ = sumList [1; 2; 3; 4]"}
{"fix": "let rec listReverse l = \nmatch l with \n[] -> []\n| head::tail -> listReverse tail @ [head]", "bad": "let _ = listReverse [1; 2; 3; 4]", "annotated": "let _ = listReverse [1; 2; 3; 4]"}
{"fix": "let rec listReverse l = \nmatch l with \n[] -> []\n| head::tail -> listReverse tail @ [head]", "bad": "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]", "annotated": "let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]"}
{"fix": "let rec append_new xs1 xs2= \nmatch xs1 with\n[] -> xs2\n| head::tail -> head::(append_new tail xs2)", "bad": " _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "annotated": " _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"}
{"fix": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0\n| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "bad": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*(eval(var2, x, y)))\n| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> (eval(var7, x, y) < (eval(var8, x, y)) ? (eval(var9, x, y)):(eval(var0, x, y)))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*(eval(var2, x, y)))\n| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> (eval(var7, x, y) < (eval(var8, x, y)) ? (eval(var9, x, y)):(eval(var0, x, y)))"}
{"fix": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0\n| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "bad": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*(eval(var2, x, y)))\n| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> (eval(var7, x, y) < (eval(var8, x, y)) ? (eval(var9, x, y)) : (eval(var0, x, y)))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*(eval(var2, x, y)))\n| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> (eval(var7, x, y) < (eval(var8, x, y)) ? (eval(var9, x, y)) : (eval(var0, x, y)))"}
{"fix": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0\n| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "bad": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*(eval(var2, x, y)))\n| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if ((eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*(eval(var2, x, y)))\n| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if ((eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))"}
{"fix": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0\n| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "bad": ")", "annotated": ")"}
{"fix": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0\n| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "bad": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*(eval(var2, x, y)))\n| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if ((eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*(eval(var2, x, y)))\n| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if ((eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))"}
{"fix": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0\n| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "bad": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*(eval(var2, x, y)))\n| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*(eval(var2, x, y)))\n| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))"}
{"fix": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0\n| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "bad": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))"}
{"fix": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0\n| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "bad": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((eval(var3, x, y) + eval(var4, x, y))/2)\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((eval(var3, x, y) + eval(var4, x, y))/2)\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))"}
{"fix": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0\n| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "bad": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> (.(eval(var3, x, y) + (.eval(var4, x, y)))/2)\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> (.(eval(var3, x, y) + (.eval(var4, x, y)))/2)\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))"}
{"fix": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0\n| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "bad": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((.(eval(var3, x, y)) + (.eval(var4, x, y)))/2)\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((.(eval(var3, x, y)) + (.eval(var4, x, y)))/2)\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))"}
{"fix": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0\n| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "bad": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> .((.(eval(var3, x, y)) + (.eval(var4, x, y)))/2)\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> .((.(eval(var3, x, y)) + (.eval(var4, x, y)))/2)\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))"}
{"fix": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0\n| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "bad": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> (.(eval(var3, x, y)) + eval(var4, x, y))/2\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> (.(eval(var3, x, y)) + eval(var4, x, y))/2\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))"}
{"fix": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0\n| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "bad": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((eval(var3, x, y)) + eval(var4, x, y))/2\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((eval(var3, x, y)) + eval(var4, x, y))/2\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))"}
{"fix": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0\n| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "bad": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2\n| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2\n| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))"}
{"fix": "let rec build (rand, depth) = \nif (depth<1) then let base = (rand 0 2) in match base with \n| 0 -> buildX()\n| 1 -> buildY()\nelse let recurse = (rand 0 5) in match recurse with\n| 0 -> buildSine(build(rand, depth-1))\n| 1 -> buildCosine(build(rand, depth-1))\n| 2 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 3 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "bad": "let rec build (rand, depth) = \nif (depth<1) then let base = (rand 0 2) in match base with \n| 0 -> buildX\n| 1 -> buildY", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif (depth<1) then let base = (rand 0 2) in match base with \n| 0 -> buildX\n| 1 -> buildY"}
{"fix": "let rec build (rand, depth) = \nif (depth<1) then let base = (rand 0 2) in match base with \n| 0 -> buildX()\n| 1 -> buildY()\nelse let recurse = (rand 0 5) in match recurse with\n| 0 -> buildSine(build(rand, depth-1))\n| 1 -> buildCosine(build(rand, depth-1))\n| 2 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 3 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "bad": "let rec build (rand, depth) = \nif (depth<1) then let base = (rand 0 2) in match base with \n| 0 -> buildX()\n| 1 -> buildY()\nelse \n(*\ncall rand get some number\nswitch statement to choose\n1 then return expr x\n0 then return expr y\n*)\n\n\n(* g1,g2,g3,c1,c2,c3 : unit -> int * int * int\n* these functions should return the parameters needed to create your \n* top three color / grayscale pictures.\n* they should return (depth,seed1,seed2)\n*)\n\nlet g1 () = failwith \"to be implemented\"", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif (depth<1) then let base = (rand 0 2) in match base with \n| 0 -> buildX()\n| 1 -> buildY()\nelse \n(*\ncall rand get some number\nswitch statement to choose\n1 then return expr x\n0 then return expr y\n*)\n\n\n(* g1,g2,g3,c1,c2,c3 : unit -> int * int * int\n* these functions should return the parameters needed to create your \n* top three color / grayscale pictures.\n* they should return (depth,seed1,seed2)\n*)\n\nlet g1 () = failwith \"to be implemented\""}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet index = fst a in\nlet newIn = index + 1 in\n(newIn, bigAdd (snd a) (mulByDigit x (l1@(clone 0 index)))) in\nlet base = (0, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = \nlet index = fst a in\nlet newIn = index + 1 in\n(newIn, bigAdd (snd a) (mulByDigit x (l1@(clone 0 index))))", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = \nlet index = fst a in\nlet newIn = index + 1 in\n(newIn, bigAdd (snd a) (mulByDigit x (l1@(clone 0 index))))"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet index = fst a in\nlet newIn = index + 1 in\n(newIn, bigAdd (snd a) (mulByDigit x (l1@(clone 0 index)))) in\nlet base = (0, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let base = (0, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let base = (0, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet index = fst a in\nlet newIn = index + 1 in\n(newIn, bigAdd (snd a) (mulByDigit x (l1@(clone 0 index)))) in\nlet base = (0, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "annotated": "let _ = bigMul [9;9;9;9] [9;9;9;9]"}
{"fix": "let bigMul l1 l2 = \nlet f a x = \nlet index = fst a in\nlet newIn = index + 1 in\n(newIn, bigAdd (snd a) (mulByDigit x (l1@(clone 0 index)))) in\nlet base = (0, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]", "annotated": "let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]"}
{"fix": "let padZero l1 l2 = \nlet lenl1 = List.length l1 in \nlet lenl2 = List.length l2 in \n((List.append(clone 0 (lenl1 - lenl2)) l1), (List.append (clone 0 (lenl1 - lenl2)) l2))", "bad": "let padZero l1 l2 = \nlet lenl1 = List.length l1 in \nlet lenl2 = List.length l2 in \n(List.append(clone 0 (lenl1 - lenl2) l1, (List.append (clone 0 (lenl1 - lenl2)) l2)))", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet lenl1 = List.length l1 in \nlet lenl2 = List.length l2 in \n(List.append(clone 0 (lenl1 - lenl2) l1, (List.append (clone 0 (lenl1 - lenl2)) l2)))"}
{"fix": "let rec digitsOfInt n = \nif n<=0 then []\nelse explode (string_of_int n)", "bad": "let rec digitsOfInt n = match n with\n| isNotP n ->[]\n| explode (string_of_int n)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  match n with\n| isNotP n ->[]\n| explode (string_of_int n)"}
{"fix": "let rec digitsOfInt n = \nif n<=0 then []\nelse explode (string_of_int n)", "bad": "let rec digitsOfInt n = match n with\n| if isNotP n ->[]\n| explode (string_of_int n)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  match n with\n| if isNotP n ->[]\n| explode (string_of_int n)"}
{"fix": "let rec digitsOfInt n = \nif n<=0 then []\nelse explode (string_of_int n)", "bad": "let rec digitsOfInt n = match n with\n| if isNotP n then n->[]\n| explode (string_of_int n)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  match n with\n| if isNotP n then n->[]\n| explode (string_of_int n)"}
{"fix": "let rec digitsOfInt n = \nif n<=0 then []\nelse explode (string_of_int n)", "bad": "let rec digitsOfInt n = match n with\n| isNotP n then n->[]\n| explode (string_of_int n)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  match n with\n| isNotP n then n->[]\n| explode (string_of_int n)"}
{"fix": "let rec digitsOfInt n = \nif n<=0 then []\nelse explode (string_of_int n)", "bad": "let rec digitsOfInt n = match n with\n| if isNotP n then []\n| explode (string_of_int n)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  match n with\n| if isNotP n then []\n| explode (string_of_int n)"}
{"fix": "let rec digitsOfInt n = \nif n<=0 then []\nelse explode (string_of_int n)", "bad": "let rec digitsOfInt n = match n with\n| if isNotP n =true then []\n| explode (string_of_int n)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  match n with\n| if isNotP n =true then []\n| explode (string_of_int n)"}
{"fix": "let rec digitsOfInt n = \nif n<=0 then []\nelse explode (string_of_int n)", "bad": "let rec digitsOfInt n = match n with\n| if n<=0 then []\n| explode (string_of_int n)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  match n with\n| if n<=0 then []\n| explode (string_of_int n)"}
{"fix": "let rec digitsOfInt n = \nif n<=0 then []\nelse explode (string_of_int n)", "bad": "let rec digitsOfInt n = match n with\n| if n<=0 then []\n| else explode (string_of_int n)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  match n with\n| if n<=0 then []\n| else explode (string_of_int n)"}
{"fix": "let rec digitsOfInt n = \nif n<=0 then []\nelse explode (string_of_int n)", "bad": "let rec digitsOfInt n = \n| if n<=0 then []\n| else explode (string_of_int n)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \n| if n<=0 then []\n| else explode (string_of_int n)"}
{"fix": "let rec additivePersistence n = \n\nsumList (digitsOfInt n)", "bad": "let rec additivePersistence n = sumList digitOfInt n", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  sumList digitOfInt n"}
{"fix": "let rec additivePersistence n = \n\nsumList (digitsOfInt n)", "bad": "let rec additivePersistence n = \n\nsumList (digitOfInt n)", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \n\nsumList (digitOfInt n)"}
{"fix": "let rec additivePersistence n = \nif n<10 then a\nelse  additivePersistence (sumList (digitsOfInt n))", "bad": "let rec additivePersistence n = match n with\nif n<10 then n\nelse  _=sumList (digitsOfInt n)", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  match n with\nif n<10 then n\nelse  _=sumList (digitsOfInt n)"}
{"fix": "let rec additivePersistence n = \nif n<10 then a\nelse  additivePersistence (sumList (digitsOfInt n))", "bad": "let rec additivePersistence n = match n with\nif n<10 then n\nelse  n=sumList (digitsOfInt n)", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  match n with\nif n<10 then n\nelse  n=sumList (digitsOfInt n)"}
{"fix": "let rec additivePersistence n = \nif n<10 then a\nelse  additivePersistence (sumList (digitsOfInt n))", "bad": "let rec additivePersistence n = \nif n<10 then n\nelse  n=sumList (digitsOfInt n) in \nmatch n with \n|0->0\n|_->n", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif n<10 then n\nelse  n=sumList (digitsOfInt n) in \nmatch n with \n|0->0\n|_->n"}
{"fix": "let rec additivePersistence n = \nif n<10 then a\nelse  additivePersistence (sumList (digitsOfInt n))", "bad": "let rec additivePersistence n = \nif n<10 then n\nelse  sumList (digitsOfInt n) in \nmatch n with \n|0->0\n|_->n", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nif n<10 then n\nelse  sumList (digitsOfInt n) in \nmatch n with \n|0->0\n|_->n"}
{"fix": "let rec additivePersistence n = \nif n<10 then a\nelse  additivePersistence (sumList (digitsOfInt n))", "bad": "let rec additivePersistence n a= \nif n<10 then a\nelse  sumList (digitsOfInt n) in \nmatch n with \n|0->0\n|_->n", "annotated": "let rec additivePersistence : int -> int = fun  n a ->  \nif n<10 then a\nelse  sumList (digitsOfInt n) in \nmatch n with \n|0->0\n|_->n"}
{"fix": "let rec additivePersistence n = \nlet c=0 in\nlet rec break(num,count)=\nif num>9 then\nbreak(sumList(digitsOfInt(num)),(count+1))\nelse\ncount\nin\nbreak(n,c)", "bad": "let rec additivePersistence n = \nlet c=0 in\nlet rec break(num,count)=\nif num>9\nbreak(sumList(digitsOfInt(num)),(count+1))\nelse\ncount\nin\nbreak(n,c)", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet c=0 in\nlet rec break(num,count)=\nif num>9\nbreak(sumList(digitsOfInt(num)),(count+1))\nelse\ncount\nin\nbreak(n,c)"}
{"fix": "let rec listReverse l = \nlet rec a acc=function\n|[]-> acc\n|h::t -> a(h::acc) t in\na [] l", "bad": "let rec listReverse l = \nlet rec a acc=function\n|[]-> acc\n|h::t -> a(h::acc) t in\na [] list", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec a acc=function\n|[]-> acc\n|h::t -> a(h::acc) t in\na [] list"}
{"fix": "let palindrome w = \nif explode w = listReverse (explode w) then true\nelse false", "bad": "let palindrome w = \nif explode w = listReverse (explode w)", "annotated": "let palindrome : string -> bool = fun  w  ->  \nif explode w = listReverse (explode w)"}
{"fix": "let rec assoc (d,k,l) = match l with\n|(s,n)::t -> if s=k then n\nelse assoc(d,k,t)\n|[]->d", "bad": "et _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "annotated": "et _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"}
{"fix": "let rec wwhile (f,b) = match f with\n| (x,true)->x", "bad": "let rec wwhile (f,b) = match f with\n| (x,true) -> f x\n| (x,false) -> x", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match f with\n| (x,true) -> f x\n| (x,false) -> x"}
{"fix": "let rec wwhile (f,b) = match f with\n| (x,true)->x", "bad": "let rec wwhile (f,b) = match f with\n|(x,true) -> wwhile(f x)\n| (x,false) -> x", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match f with\n|(x,true) -> wwhile(f x)\n| (x,false) -> x"}
{"fix": "let rec wwhile (f,b) = match f with\n| (x,true)->x", "bad": "let rec wwhile (f,b) = match f with\nlet (n,boo) = f b\n| boo=true -> wwhile(f,n)\n| boo=false -> n", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match f with\nlet (n,boo) = f b\n| boo=true -> wwhile(f,n)\n| boo=false -> n"}
{"fix": "let rec wwhile (f,b) = match f with\n| (x,true)->x", "bad": "let rec wwhile (f,b) = match f with\n(n,boo) -> f b\n| boo=true -> wwhile(f,n)\n| boo=false -> n", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match f with\n(n,boo) -> f b\n| boo=true -> wwhile(f,n)\n| boo=false -> n"}
{"fix": "let rec wwhile (f,b) = match f with\n| (x,true)->x", "bad": "let rec wwhile (f,b) = match f with\n(n,boo) -> f b\nif boo= true then wwhile(f,n)\nelse n", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match f with\n(n,boo) -> f b\nif boo= true then wwhile(f,n)\nelse n"}
{"fix": "let rec wwhile (f,b) = match f with\n| (x,true)->x", "bad": "let rec wwhile (f,b) = match f with\n(n,boo) -> f b", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match f with\n(n,boo) -> f b"}
{"fix": "let rec wwhile (f,b) = match f b with\n| (x,true) -> wwhile(f,x)\n| (x,false)-> x", "bad": "let rec wwhile (f,b) = match f with \nlet (i,r) = f b in\n| r=true -> wwhile (f,i)\n| r=false ->i", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match f with \nlet (i,r) = f b in\n| r=true -> wwhile (f,i)\n| r=false ->i"}
{"fix": "let rec wwhile (f,b) = match f b with\n| (x,true) -> wwhile(f,x)\n| (x,false)-> x", "bad": "let rec wwhile (f,b) = match f with \nlet rec (i,r) = f b in\n| r=true -> wwhile (f,i)\n| r=false ->i", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match f with \nlet rec (i,r) = f b in\n| r=true -> wwhile (f,i)\n| r=false ->i"}
{"fix": "let rec wwhile (f,b) = match f b with\n| (x,true) -> wwhile(f,x)\n| (x,false)-> x", "bad": "let rec wwhile (f,b) = \nlet  (x,y) = f b in\nmatch (x,y) with \n| y=true -> wwhile (f,x)\n| y=false -> x", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet  (x,y) = f b in\nmatch (x,y) with \n| y=true -> wwhile (f,x)\n| y=false -> x"}
{"fix": "let rec wwhile (f,b) = match f b with\n| (x,true) -> wwhile(f,x)\n| (x,false)-> x", "bad": "let rec wwhile (f,b) = \nlet  (x,y) = f b in\nmatch (x,y) with \n| y -> wwhile (f,x)\n| !y -> x", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet  (x,y) = f b in\nmatch (x,y) with \n| y -> wwhile (f,x)\n| !y -> x"}
{"fix": "let rec wwhile (f,b) = match f b with\n| (x,true) -> wwhile(f,x)\n| (x,false)-> x", "bad": "let rec wwhile (f,b) = \nlet  (x,y) = f b in\nmatch (x,y) with \nif y then wwhile (f,x)\nelse x", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet  (x,y) = f b in\nmatch (x,y) with \nif y then wwhile (f,x)\nelse x"}
{"fix": "let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,x<>b)in a),b)", "bad": "let fixpoint (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true)=f b-1 then (b,false)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true) -> f b-1 then (b,false)),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,x<>b)in a),b)", "bad": "let fixpoint (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true)=f b-1 then (b,false) in f),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true) -> f b-1 then (b,false) in f),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,x<>b)in a),b)", "bad": "let fixpoint (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true)=f (b-1) then (b,false) in ),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true) -> f (b-1) then (b,false) in ),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,x<>b)in a),b)", "bad": "let fixpoint (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true)=f (b-1) then (b,false) in f),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let f f b = if f b = (b,true) && (b,true) -> f (b-1) then (b,false) in f),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,x<>b)in a),b)", "bad": "let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x<>b && (x,y)<>f (b-1))),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let (x,y) ->  f b in (x, x<>b && (x,y)<>f (b-1))),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,x<>b)in a),b)", "bad": "let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x<>b)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let (x,y) ->  f b in (x, x<>b)),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,x<>b)in a),b)", "bad": "let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x!=b)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let (x,y)= f b in (x, x! -> b)),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,x<>b)in a),b)", "bad": "let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x>b||x<b)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let (x,y) ->  f b in (x, x>b||x<b)),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((let a x = let xx=(f x) in (xx,x<>b)in a),b)", "bad": "let fixpoint (f,b) = wwhile ((let (x,y)= f b in (x, x<100)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = wwhile ((let (x,y) ->  f b in (x, x<100)),b)"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  exprToString e\n| Cosine e-> exprToString e", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine -> VarY\"/\"VarX\n| Cosine -> VarX\"/\"VarY", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine -> VarY\"/\"VarX\n| Cosine -> VarX\"/\"VarY"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  exprToString e\n| Cosine e-> exprToString e", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine -> VarY@\"/\"@VarX\n| Cosine -> VarX@\"/\"@VarY", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine -> VarY@\"/\"@VarX\n| Cosine -> VarX@\"/\"@VarY"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  exprToString e\n| Cosine e-> exprToString e", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine -> VarY^\"/\"^VarX\n| Cosine -> VarX^\"/\"^VarY", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine -> VarY^\"/\"^VarX\n| Cosine -> VarX^\"/\"^VarY"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  exprToString e\n| Cosine e-> exprToString e", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ->  exprToString e\n| Cosine -> exprToString e", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ->  exprToString e\n| Cosine -> exprToString e"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  exprToString e\n| Cosine e-> exprToString e", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ->  exprToString e\n| Cosine -> exprToString e", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ->  exprToString e\n| Cosine -> exprToString e"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  exprToString e\n| Cosine e-> exprToString e", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ->  exprToString VarX\n| Cosine -> exprToString e", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ->  exprToString VarX\n| Cosine -> exprToString e"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  exprToString e\n| Cosine e-> exprToString e", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  exprToString e\n| Cosine -> exprToString e", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  exprToString e\n| Cosine -> exprToString e"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e)^\"+\"^(exprToString e)^\")/2\"", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average e1 e2 ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\")/2\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average e1 e2 ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\")/2\""}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e)^\"+\"^(exprToString e)^\")/2\"", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average e1 e ->\"(\"^(exprToString e1)^\"+\"^(exprToString e)^\")/2\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average e1 e ->\"(\"^(exprToString e1)^\"+\"^(exprToString e)^\")/2\""}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e)^\"+\"^(exprToString e)^\")/2\"", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average e e ->\"(\"^(exprToString e)^\"+\"^(exprToString e)^\")/2\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average e e ->\"(\"^(exprToString e)^\"+\"^(exprToString e)^\")/2\""}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e)^\"+\"^(exprToString e)^\")/2\"", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average e ->\"(\"^(exprToString e)^\"+\"^(exprToString e)^\")/2\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average e ->\"(\"^(exprToString e)^\"+\"^(exprToString e)^\")/2\""}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e)^\"+\"^(exprToString e)^\")/2\"\n| Times (e1,e2) -> exprToString e1 ^\"*\"^exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\"", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e)^\"+\"^(exprToString e)^\")/2\"\n| Times (e1,e2) -> exprToString e1 ^\"*\"^exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e)^\"+\"^(exprToString e)^\")/2\"\n| Times (e1,e2) -> exprToString e1 ^\"*\"^exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"exprToString e2^\" ? \"^exprToString e3^\" : \"^exprToString e4^\")\""}
{"fix": "let aa =exprToString VarX", "bad": "let aa = exprToString Average(VarX, VarY)", "annotated": "let aa = exprToString Average(VarX, VarY)"}
{"fix": "let aa =exprToString VarX", "bad": "let aa =exprToString Average(VarX, VarY)", "annotated": "let aa =exprToString Average(VarX, VarY)"}
{"fix": "let aa =exprToString VarX", "bad": "let aa =exprToString VarX;\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "annotated": "let aa =exprToString VarX;\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))"}
{"fix": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e->  \"sin(pi*\"^ exprToString e^\")\"\n| Cosine e-> \"cos(pi*\"^ exprToString e^\")\"\n| Average (e1,e2) ->\"(\"^(exprToString e1)^\"+\"^(exprToString e2)^\")/2\"\n| Times (e1,e2) -> exprToString e1 ^\"*\"^exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"", "bad": "let aa =exprToString Average(VarY,VarX)", "annotated": "let aa =exprToString Average(VarY,VarX)"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine -> buildSine(e)", "annotated": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine -> buildSine(e)"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine e-> buildSine(e)", "annotated": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine e-> buildSine(e)"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine e-> buildSine(x)", "annotated": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine e-> buildSine(x)"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine e1-> buildSine(e1)", "annotated": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine e1-> buildSine(e1)"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine e1-> buildSine(e1)", "annotated": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine e1-> buildSine(e1)"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine e-> 0.34*e", "annotated": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine e-> 0.34*e"}
{"fix": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine e-> build(pi*e)", "annotated": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine e-> build(pi*e)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*x\n| Cosine e-> pi*y\n| Average (e1,e2)-> (e1+e2)/2\n| Times (e1, e2)-> e1*e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*x\n| Cosine e-> pi*y\n| Average (e1,e2)-> (e1+e2)/2\n| Times (e1, e2)-> e1*e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y", "bad": "let rec eval (e,x,y) = (-:float) match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*x\n| Cosine e-> pi*y\n| Average (e1,e2)-> (e1+e2)/2\n| Times (e1, e2)-> e1*e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  (-:float) match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*x\n| Cosine e-> pi*y\n| Average (e1,e2)-> (e1+e2)/2\n| Times (e1, e2)-> e1*e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y", "bad": "let rec eval (e,x,y) = (float) match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*x\n| Cosine e-> pi*y\n| Average (e1,e2)-> (e1+e2)/2\n| Times (e1, e2)-> e1*e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  (float) match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*x\n| Cosine e-> pi*y\n| Average (e1,e2)-> (e1+e2)/2\n| Times (e1, e2)-> e1*e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y", "bad": "let rec eval (e,x,y) = match e with\n| (float) VarX -> x\n| VarY -> y\n| Sine e -> pi*x\n| Cosine e-> pi*y\n| Average (e1,e2)-> (e1+e2)/2\n| Times (e1, e2)-> e1*e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| (float) VarX -> x\n| VarY -> y\n| Sine e -> pi*x\n| Cosine e-> pi*y\n| Average (e1,e2)-> (e1+e2)/2\n| Times (e1, e2)-> e1*e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x:float\n| VarY -> y\n| Sine e -> pi*x\n| Cosine e-> pi*y\n| Average (e1,e2)-> (e1+e2)/2\n| Times (e1, e2)-> e1*e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x:float\n| VarY -> y\n| Sine e -> pi*x\n| Cosine e-> pi*y\n| Average (e1,e2)-> (e1+e2)/2\n| Times (e1, e2)-> e1*e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x of float\n| VarY -> y\n| Sine e -> pi*x\n| Cosine e-> pi*y\n| Average (e1,e2)-> (e1+e2)/2\n| Times (e1, e2)-> e1*e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x of float\n| VarY -> y\n| Sine e -> pi*x\n| Cosine e-> pi*y\n| Average (e1,e2)-> (e1+e2)/2\n| Times (e1, e2)-> e1*e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2)-> (e1+.e2)/2\n| Times (e1, e2)-> e1*.e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2)-> (e1+.e2)/2\n| Times (e1, e2)-> e1*.e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2)-> (e1.+.e2.)/2\n| Times (e1, e2)-> e1*.e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2)-> (e1.+.e2.)/2\n| Times (e1, e2)-> e1*.e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2)-> (float)(e1+e2)/2\n| Times (e1, e2)-> e1*.e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2)-> (float)(e1+e2)/2\n| Times (e1, e2)-> e1*.e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2)-> (float_of_int e1+. float_of_int e2)/2\n| Times (e1, e2)-> float_of_int e1*.float_of_int e2\n| Thresh (e1,e2,e3,e4)->(float_of_int e1<float_of_int e2 ? float_of_int e3:float_of_int e4)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2)-> (float_of_int e1+. float_of_int e2)/2\n| Times (e1, e2)-> float_of_int e1*.float_of_int e2\n| Thresh (e1,e2,e3,e4)->(float_of_int e1<float_of_int e2 ? float_of_int e3:float_of_int e4)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2)-> if e1=VarX then e1=x else e1=y if e2=VarX then e2=x else e2=y -> (e1+e2)/2\n| Times (e1, e2)-> e1*.e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2)-> if e1=VarX then e1=x else e1=y if e2=VarX then e2=x else e2=y -> (e1+e2)/2\n| Times (e1, e2)-> e1*.e2\n| Thresh (e1,e2,e3,e4)->(e1<e2 ? e3:e4)"}
{"fix": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x.\n| Cosine e-> pi*.y.\n| Average (e1,e2) -> buildAverage(e1,e2)", "bad": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x.\n| VarY -> y.\n| Sine e -> pi*.x.\n| Cosine e-> pi*.y.\n| Average (e1,e2) -> buildAverage(e1,e2)", "annotated": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x.\n| VarY -> y.\n| Sine e -> pi*.x.\n| Cosine e-> pi*.y.\n| Average (e1,e2) -> buildAverage(e1,e2)"}
{"fix": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)", "bad": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> ((e1*1.00)+(e2*1.00))/.2.0", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  -> \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> ((e1*1.00)+(e2*1.00))/.2.0"}
{"fix": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)", "bad": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> ((e1*1.00)+.(e2*1.00))/.2.0", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  -> \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> ((e1*1.00)+.(e2*1.00))/.2.0"}
{"fix": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)", "bad": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.evail(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.evail(e2,x,y)\n| Thresh (e1,e2,e3,e4) ->((eval(e1,x,y))<(eval(e2,x,y)) ? (eval(e3,x,y)) : (eval(e4,x,y))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  -> \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.evail(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.evail(e2,x,y)\n| Thresh (e1,e2,e3,e4) ->((eval(e1,x,y))<(eval(e2,x,y)) ? (eval(e3,x,y)) : (eval(e4,x,y))\n\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)"}
{"fix": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)", "bad": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.evail(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.evail(e2,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  -> \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.evail(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.evail(e2,x,y)"}
{"fix": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "bad": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1,e2) -> eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  -> \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1,e2) -> eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : eval(e4,x,y)"}
{"fix": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "bad": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1,e2) -> eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y):eval(e4,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  -> \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1,e2) -> eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y):eval(e4,x,y)"}
{"fix": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "bad": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1,e2) -> (eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y) : eval(e4,x,y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  -> \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1,e2) -> (eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y) : eval(e4,x,y))"}
{"fix": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "bad": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> (eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y) : eval(e4,x,y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  -> \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> (eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y) : eval(e4,x,y))"}
{"fix": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "bad": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> (eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y) : eval( e4,x,y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  -> \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> (eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y) : eval( e4,x,y))"}
{"fix": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "bad": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> (eval(e1,x,y)<eval(e2,x,y)?(eval(e3,x,y)):(eval(e4,x,y))\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  -> \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> (eval(e1,x,y)<eval(e2,x,y)?(eval(e3,x,y)):(eval(e4,x,y))\nlet _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)"}
{"fix": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "bad": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y):eval(e4,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  -> \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y):eval(e4,x,y)"}
{"fix": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "bad": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> (eval(e1,x,y)<.eval(e2,x,y)?.eval(e3,x,y):.eval(e4,x,y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  -> \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> (eval(e1,x,y)<.eval(e2,x,y)?.eval(e3,x,y):.eval(e4,x,y))"}
{"fix": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "bad": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> (eval(e1,x,y)<.eval(e2,x,y)?.eval(e3,x,y) : eval(e4,x,y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  -> \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> (eval(e1,x,y)<.eval(e2,x,y)?.eval(e3,x,y) : eval(e4,x,y))"}
{"fix": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "bad": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y) : eval(e4,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  -> \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> pi*.x\n| Cosine e-> pi*.y\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> eval(e1,x,y)<eval(e2,x,y)?eval(e3,x,y) : eval(e4,x,y)"}
{"fix": "let _ = assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)])", "bad": "let rec assoc (d,k,l) = \nlet rec helper(d1,k1,l1) = match l1 with\n|(s,n)::t -> if s=k1 then n\nelse assoc(d1,k1,t)\n|[]->d1\nin helper(d,k,l)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  \nlet rec helper(d1,k1,l1) = match l1 with\n|(s,n)::t -> if s=k1 then n\nelse assoc(d1,k1,t)\n|[]->d1\nin helper(d,k,l)"}
{"fix": "let _ = eval (sampleExpr,0.5,0.2)", "bad": "let _ = eval (sampleExpr1,0.5,0.2)", "annotated": "let _ = eval (sampleExpr1,0.5,0.2)"}
{"fix": "let _ = eval (sampleExpr,0.5,0.2)", "bad": "let rec build (rand, depth) = match rand depth with", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match rand depth with"}
{"fix": "let _ = eval (sampleExpr,0.5,0.2)", "bad": "let rec build (rand, depth) = \nmatch rand depth with\n| (1,d) -> d=(d-1) && buildX()\n| (2,d) -> d=(d-1) && buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nmatch rand depth with\n| (1,d) -> d=(d-1) && buildX()\n| (2,d) -> d=(d-1) && buildY()"}
{"fix": "let _ = eval (sampleExpr,0.5,0.2)", "bad": "let rec build (rand, depth) = match rand depth with", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match rand depth with"}
{"fix": "let _ = eval (sampleExpr,0.5,0.2)", "bad": "let rec build (rand, depth) = \nlet build(r) = if r=1 then buildX() else buildY() in (depth-1,depth>0)\nin build(r)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 1 then buildX() else buildY() in (depth-1,depth>0)\nin build(r)"}
{"fix": "let _ = eval (sampleExpr,0.5,0.2)", "bad": "let rec build (rand, depth) = match rand depth with\nif r=1 then buildX() else buildY() in (depth-1,depth>0)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match rand depth with\nif r=1 then buildX() else buildY() in (depth-1,depth>0)"}
{"fix": "let _ = eval (sampleExpr,0.5,0.2)", "bad": "let rec build (rand, depth) = match rand depth with\nif rand=1 then buildX() else buildY() in (depth-1,depth>0)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match rand depth with\nif rand=1 then buildX() else buildY() in (depth-1,depth>0)"}
{"fix": "let rec assoc (d,k,l) = \nlet rec helper(d1,k1,l1) = match l1 with\n|(s,n)::t -> if s=k1 then n\nelse assoc(d1,k1,t)\n|[]->d1\nin helper(d,k,l)", "bad": "let rec build (rand, depth) = match rand depth with\n|(r,depth)-> match r(0,6) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|6->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match rand depth with\n|(r,depth)-> match r(0,6) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|6->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1))"}
{"fix": "let rec build (rand, depth) = match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "bad": "let rec build (rand, depth) = match (rand,depth) with\n|(r,depth)-> match r(0,6) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|6->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth) with\n|(r,depth)-> match r(0,6) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|6->build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 0)"}
{"fix": "let rec build (rand, depth) = match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "bad": "let rec build (rand, depth) = match (rand,depth) with\n|(r,depth)-> match r(0,7) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|6->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth) with\n|(r,depth)-> match r(0,7) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|6->build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 0)"}
{"fix": "let rec build (rand, depth) = match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "bad": "let rec build (rand, depth) = match (rand,depth) with\n|(r,depth)-> match r(0,7) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|_->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth) with\n|(r,depth)-> match r(0,7) with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|_->build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 0)"}
{"fix": "let rec build (rand, depth) = match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "bad": "let rec build (rand, depth) = match (rand,depth) with\n|(r,depth)-> let r = rand(0,7) in match with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|_->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth) with\n|(r,depth)-> let r = rand(0,7) in match with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|_->build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 0)"}
{"fix": "let rec build (rand, depth) = match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "bad": "let rec build (rand, depth) = match (rand,depth) with\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|_->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth) with\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|_->build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 0)"}
{"fix": "let rec build (rand, depth) = match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "bad": "let rec build (rand, depth) = match (rand,depth) with\n|(_,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|_->buildThresh(build(r,depth-1),build(r,depth-1),build(r,depth-1),build(r,depth-1)) in (depth, depth>=0)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth) with\n|(_,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(r,depth-1))\n|3->buildCosine(build(r,depth-1))\n|4->buildAverage(build(r,depth-1),build(r,depth-1))\n|5->buildTimes(build(r,depth-1),build(r,depth-1))\n|_->build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 0)"}
{"fix": "let rec build (rand, depth) = match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "bad": "let rec build (rand, depth) = match (rand,depth) with\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|_->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1)) in (depth, depth>=0)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth) with\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|_->build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> 0)"}
{"fix": "let rec build (rand, depth) = match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|6->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "bad": "let rec build (rand, depth) = match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|_->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth) with\n|(r,0)-> if r(0,1)=0 then buildX() else buildY()\n|(r,depth)-> let r = rand(0,7) in match r with\n|0->buildX()\n|1->buildY()\n|2->buildSine(build(rand,depth-1))\n|3->buildCosine(build(rand,depth-1))\n|4->buildAverage(build(rand,depth-1),build(rand,depth-1))\n|5->buildTimes(build(rand,depth-1),build(rand,depth-1))\n|_->buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^a in\nlet base = h^sep in\nlet l = sl in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = List.rev x^a in\nlet base = sep in\nlet l = sl in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = List.rev x^a in\nlet base = sep in\nlet l = sl in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^a in\nlet base = h^sep in\nlet l = sl in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = List.rev t^a in\nlet base = h^sep in\nlet l = sl in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = List.rev t^a in\nlet base = h^sep in\nlet l = sl in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ (x^a)in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ (sepConcat a x)in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ (sepConcat a x)in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l"}
{"fix": "let _ = sumList [1; 3; 5; 7; 9; 11];\n\nstring_of_int(32)", "bad": "let _ = sumList [1; 3; 5; 7; 9; 11]\n\nint_of_string(32)", "annotated": "let _ = sumList [1; 3; 5; 7; 9; 11]\n\nint_of_string(32)"}
{"fix": "let _ = sumList [1; 3; 5; 7; 9; 11];\n\nstring_of_int(32)", "bad": "let _ = sumList [1; 3; 5; 7; 9; 11];\n\nint_of_string(32)", "annotated": "let _ = sumList [1; 3; 5; 7; 9; 11];\n\nint_of_string(32)"}
{"fix": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> [] @ [(n mod 10)]", "bad": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> [] @ (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n <= 0 \nthen []\nelse match n with\n| n -> [] @ (n mod 10)"}
{"fix": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> [] @ [(n mod 10)]", "bad": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> [] :: (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n <= 0 \nthen []\nelse match n with\n| n -> [] :: (n mod 10)"}
{"fix": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> [] @ [(n mod 10)]", "bad": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> [] @ (n mod 10)", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n <= 0 \nthen []\nelse match n with\n| n -> [] @ (n mod 10)"}
{"fix": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> n mod 10 :: []", "bad": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> digitsOfInt(n % 10) :: []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n <= 0 \nthen []\nelse match n with\n| n -> digitsOfInt(n % 10) :: []"}
{"fix": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> n mod 10 :: []", "bad": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> digitsOfInt(n mod 10) :: []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n <= 0 \nthen []\nelse match n with\n| n -> digitsOfInt(n mod 10) :: []"}
{"fix": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> n mod 10 :: []", "bad": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> digitsOfInt(n mod 10) :: []", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n <= 0 \nthen []\nelse match n with\n| n -> digitsOfInt(n mod 10) :: []"}
{"fix": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n = 0 then []\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> addDigit n []", "bad": "let digitsOfInt n = \nlet rec addDigit next n = \nif n < 0 then []\nelse addDigit ((n mod 10)::next) (n/10)", "annotated": "let digitsOfInt : int -> int list = fun  n  ->  \nlet rec addDigit next n = \nif n < 0 then []\nelse addDigit ((n mod 10)::next) (n/10)"}
{"fix": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n = 0 then []\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> addDigit n []", "bad": ") in \naddDigit [] n", "annotated": ") in \naddDigit [] n"}
{"fix": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n = 0 then []\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> addDigit n []", "bad": "let _ = digitsOfInt 3124", "annotated": "let _ = digitsOfInt 3124"}
{"fix": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n = 0 then []\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> addDigit n []", "bad": "let digitsOfInt n = \nlet rec addDigit next n = \nif n < 0 then []\nelse addDigit ((n mod 10)::next) (n/10)", "annotated": "let digitsOfInt : int -> int list = fun  n  ->  \nlet rec addDigit next n = \nif n < 0 then []\nelse addDigit ((n mod 10)::next) (n/10)"}
{"fix": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n = 0 then []\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> addDigit n []", "bad": "let _ = digitsOfInt 3124", "annotated": "let _ = digitsOfInt 3124"}
{"fix": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n = 0 then []\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> addDigit n []", "bad": "let digitsOfInt n = \nlet rec addDigit next n = \nif n < 10 then n::next\nelse addDigit ((n mod 10)::next) (n/10)", "annotated": "let digitsOfInt : int -> int list = fun  n  ->  \nlet rec addDigit next n = \nif n < 10 then n::next\nelse addDigit ((n mod 10)::next) (n/10)"}
{"fix": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n = 0 then []\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> addDigit n []", "bad": "let _ = digitsOfInt 3124", "annotated": "let _ = digitsOfInt 3124"}
{"fix": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n = 0 then []\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> addDigit n []", "bad": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n = 0 then []\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "annotated": "let digitsOfInt : int -> int list = fun  n  ->  \nlet rec addDigit n acc = \nif n = 0 then []\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []"}
{"fix": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n = 0 then []\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> addDigit n []", "bad": "let _ = digitsOfInt 3124", "annotated": "let _ = digitsOfInt 3124"}
{"fix": "let digitsOfInt n = \nif n <= 0 then []\nelse let rec addDigit n acc = \nif n <= 0 then acc\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> addDigit n []", "bad": "let _ = digitsOfInt 3124", "annotated": "let _ = digitsOfInt 3124"}
{"fix": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n <= 0 then acc\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> addDigit n []", "bad": "let _ = digitsOfInt (-3124)", "annotated": "let _ = digitsOfInt (-3124)"}
{"fix": "let rec additivePersistence n = \nmatch n with\n| 0 -> 0\n| _ -> (sumList (digitsOfInt n))", "bad": "let rec additivePersistence n = \nmatch n with\n| 0 -> 0\n| _ -> additivePersistence sumList (digitsOfInt n)", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nmatch n with\n| 0 -> 0\n| _ -> additivePersistence sumList (digitsOfInt n)"}
{"fix": "let rec additivePersistence n = \nmatch n with\n| 0 -> 0\n| _ -> (sumList (digitsOfInt n))", "bad": "let rec additivePersistence n = \nmatch n with\n| 0 -> 0\n| _ -> additivePersistence (sumList (digitsOfInt n))", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nmatch n with\n| 0 -> 0\n| _ -> additivePersistence (sumList (digitsOfInt n))"}
{"fix": "let rec additivePersistence n = \nmatch n with\n| 0 -> 0\n| _ -> (sumList (digitsOfInt n))", "bad": "let _ = additivePersistence 9876", "annotated": "let _ = additivePersistence 9876"}
{"fix": "let rec lengthOfList xs count =\nmatch xs with\n| [] -> 0\n| hd::tl -> lengthOfList tl count+1", "bad": "let _ = additivePersistence 9876", "annotated": "let _ = additivePersistence 9876"}
{"fix": "let rec lengthOfList xs count =\nmatch xs with\n| [] -> 0\n| hd::tl -> lengthOfList tl count+1", "bad": "let rec additivePersistence n = \nmatch n with\n| _ -> (sumList (digitsOfInt n))", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nmatch n with\n| _ -> (sumList (digitsOfInt n))"}
{"fix": "let rec lengthOfList xs count =\nmatch xs with\n| [] -> 0\n| hd::tl -> lengthOfList tl count+1", "bad": "let _ = additivePersistence 9876", "annotated": "let _ = additivePersistence 9876"}
{"fix": "let rec lengthOfList xs count =\nmatch xs with\n| [] -> 0\n| hd::tl -> lengthOfList tl count+1", "bad": "let rec additivePersistence n = \nmatch n with\n| _ -> additivePersistence(sumList (digitsOfInt n))", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nmatch n with\n| _ -> additivePersistence(sumList (digitsOfInt n))"}
{"fix": "let rec lengthOfList xs count =\nmatch xs with\n| [] -> 0\n| hd::tl -> lengthOfList tl count+1", "bad": "let _ = additivePersistence 9876", "annotated": "let _ = additivePersistence 9876"}
{"fix": "let digitsOfInt n = \nlet rec lastDigit n acc = \nif n <= 0 then acc\nelse lastDigit (n/10) (n mod 10::acc) in\nmatch n with\n| _ -> lastDigit n []", "bad": "let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additivePersistence sumDigits n count+1\nelse count\nin count = 0", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additivePersistence sumDigits n count+1\nelse count\nin count = 0"}
{"fix": "let digitsOfInt n = \nlet rec lastDigit n acc = \nif n <= 0 then acc\nelse lastDigit (n/10) (n mod 10::acc) in\nmatch n with\n| _ -> lastDigit n []", "bad": "let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additivePersistence sumDigits n (count+1)\nelse count\nin count = 0", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additivePersistence sumDigits n (count+1)\nelse count\nin count = 0"}
{"fix": "let digitsOfInt n = \nlet rec lastDigit n acc = \nif n <= 0 then acc\nelse lastDigit (n/10) (n mod 10::acc) in\nmatch n with\n| _ -> lastDigit n []", "bad": "let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additivePersistence (sumDigits n) count+1\nelse count\nin count = 0", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additivePersistence (sumDigits n) count+1\nelse count\nin count = 0"}
{"fix": "let digitsOfInt n = \nlet rec lastDigit n acc = \nif n <= 0 then acc\nelse lastDigit (n/10) (n mod 10::acc) in\nmatch n with\n| _ -> lastDigit n []", "bad": "let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additiveSequence sumDigits n count+1\nelse count\nin count = 0", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additiveSequence sumDigits n count+1\nelse count\nin count = 0"}
{"fix": "let digitsOfInt n = \nlet rec lastDigit n acc = \nif n <= 0 then acc\nelse lastDigit (n/10) (n mod 10::acc) in\nmatch n with\n| _ -> lastDigit n []", "bad": "let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additiveSequence (sumDigits n) count+1\nelse count\nin count = 0", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additiveSequence (sumDigits n) count+1\nelse count\nin count = 0"}
{"fix": "let digitsOfInt n = \nlet rec lastDigit n acc = \nif n <= 0 then acc\nelse lastDigit (n/10) (n mod 10::acc) in\nmatch n with\n| _ -> lastDigit n []", "bad": "let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additiveSequence (sumDigits n) count+1\nelse count", "annotated": "let additivePersistence : int -> int = fun  n  ->  \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additiveSequence (sumDigits n) count+1\nelse count"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let listReverse l = \nlet rec reverse l acc = \nreverse l acc in\nmatch l with\n| [] -> []\n| hd::tl -> reverse l []", "annotated": "let listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec reverse l acc = \nreverse l acc in\nmatch l with\n| [] -> []\n| hd::tl -> reverse l []"}
{"fix": "let digitsOfInt n = \nlet rec lastDigit n accu = \nif n <= 0 then accu\nelse lastDigit (n/10) (n mod 10::accu) in\nmatch n with\n| _ -> lastDigit n []", "bad": "let rec digitalRoot n =\nmatch n with\n| _ -> \nif lengthOfList (digitsOfInt n) 0 = 1 then n\nelse digitalRoot (sumList (digitsOfInt n))", "annotated": "let rec digitalRoot n =\nmatch n with\n| _ -> \nif lengthOfList (digitsOfInt n) 0 = 1 then n\nelse digitalRoot (sumList (digitsOfInt n))"}
{"fix": "let digitsOfInt n = \nlet rec lastDigit n accu = \nif n <= 0 then accu\nelse lastDigit (n/10) (n mod 10::accu) in\nmatch n with\n| _ -> lastDigit n []", "bad": "let _ = digitalRoot 9876", "annotated": "let _ = digitalRoot 9876"}
{"fix": "let digitsOfInt n = \nlet rec lastDigit n accu = \nif n <= 0 then accu\nelse lastDigit (n/10) (n mod 10::accu) in\nmatch n with\n| _ -> lastDigit n []", "bad": "let listReverse l = \nlet rec accReverse l acc =\nmatch l with\n| [] -> acc\n| hd::tl -> accReverse tl (hd::acc)", "annotated": "let listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec accReverse l acc =\nmatch l with\n| [] -> acc\n| hd::tl -> accReverse tl (hd::acc)"}
{"fix": "let _ = listReverse [1; 2; 3; 4]", "bad": "let listReverse l = \nlet rec accReverse l accu =\nmatch l with\n| [] -> accu\n| hd::tl -> accReverse tl (hd::accu)\nin accReverse l []", "annotated": "let listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec accReverse l accu =\nmatch l with\n| [] -> accu\n| hd::tl -> accReverse tl (hd::accu)\nin accReverse l []"}
{"fix": "let _ = palindrome \"malayalam\"", "bad": "let palindrome w = fun x -> (explode s = listReverse(explode s))", "annotated": "let palindrome : string -> bool = fun  w = fun x -> (explode s  ->  listReverse(explode s))"}
{"fix": "let _ = palindrome \"malayalam\"", "bad": "let palindrome w = fun x -> (explode w = listReverse(explode w))", "annotated": "let palindrome : string -> bool = fun  w = fun x -> (explode w  ->  listReverse(explode w))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif List.mem h seen then\nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif List.mem h seen then\nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif List.mem h seen then\nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif List.mem h seen then\nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "l", "annotated": "l"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "l", "annotated": "l"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif not List.mem seen h then\nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": " _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "annotated": " _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif not (List.mem seen h) then\nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif not (List.mem seen h) then\nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "l", "annotated": "l"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif not (List.mem seen h) then\nlet seen' = h::rest in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif not (List.mem seen h) then\nlet seen' = h::rest in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "l", "annotated": "l"}
{"fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif List.mem h seen then\nlet seen' = seen' in\nlet rest' = t in\nelse\nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "et _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "annotated": "et _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"}
{"fix": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "bad": "let rec assoc (d,k,l) = match l with\n| (s,i):t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with\n| (s,i):t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d"}
{"fix": "let wwhile (f,b) =\nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f,x) (x,y)\n| false -> x\nin helper (f,b) (b, true)", "bad": "let wwhile (f,b) =\nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f, x)\n| false -> x\nin (f,b) (b, true)", "annotated": "let wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> \nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f, x)\n| false -> x\nin (f,b) (b, true)"}
{"fix": "let wwhile (f,b) =\nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f,x) (x,y)\n| false -> x\nin helper (f,b) (b, true)", "bad": "let wwhile (f,b) =\nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f,x) (x,y)\n| false -> x\nin (f,b) (b, true)", "annotated": "let wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> \nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f,x) (x,y)\n| false -> x\nin (f,b) (b, true)"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let wwhile (f,b) =\nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f,x) f b\n| false -> x\nin helper (f,b) (b, true)", "annotated": "let wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> \nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f,x) f b\n| false -> x\nin helper (f,b) (b, true)"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let wwhile (f,b) =\nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f,x) f b\n| false -> x\nin helper (f,b) (b, true)", "annotated": "let wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> \nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f,x) f b\n| false -> x\nin helper (f,b) (b, true)"}
{"fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "bad": "let wwhile (f,b) =\nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f,x) (f b)\n| false -> x\nin helper (f,b) (b, true)", "annotated": "let wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> \nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f,x) (f b)\n| false -> x\nin helper (f,b) (b, true)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = wwhile (f,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (f,b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "annotated": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1"}
{"fix": "let fixpoint (f,b) = wwhile ((f f b),b)", "bad": "let fixpoint (f,b) = wwhile ((f b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((f b),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((f b),b)", "bad": "let fixpoint (f,b) = wwhile ((f (f b)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((f (f b)),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((f b),b)", "bad": "let fixpoint (f,b) = wwhile ((f b),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((f b),b)"}
{"fix": "let fixpoint (f,b) = wwhile ((f b),b)", "bad": "let fixpoint (f,b) = wwhile (f,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (f,b)"}
{"fix": "let fixpoint (f,b) = wwhile (f,f b)", "bad": "let fixpoint (f,b) = wwhile ((wwhile (f b)),b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((wwhile (f b)),b)"}
{"fix": "let fixpoint (f,b) = wwhile (f,b)", "bad": "let fixpoint (f,b) = wwhile (f,(f b))", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (f,(f b))"}
{"fix": "let fixpoint (f,b) = wwhile (f,b)", "bad": "let fixpoint (f,b) = wwhile (f,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (f,b)"}
{"fix": "let fixpoint (f,b) = \nwwhile (f, if b = (f b) then b else b)", "bad": "let fixpoint (f,b) = \nlet f x = xx = (f x) in (xx, xx != b) in f in\nwwhile (f,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet f x = xx = (f x) in (xx, xx != b) in f in\nwwhile (f,b)"}
{"fix": "let fixpoint (f,b) = \nwwhile (f, if b = (f b) then b else b)", "bad": "let fixpoint (f,b) = \nlet f x = xx = (f x) in (xx, xx != b) in f\nwwhile (f,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet f x = xx = (f x) in (xx, xx != b) in f\nwwhile (f,b)"}
{"fix": "let fixpoint (f,b) = \nwwhile (f, if b = (f b) then b else b)", "bad": "let fixpoint (f,b) = \nlet f x = let xx = (f x) in (xx, xx != b) in f\nwwhile (f,b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet f x = let xx = (f x) in (xx, xx != b) in f\nwwhile (f,b)"}
{"fix": "let fixpoint (f,b) = \nwwhile (f, if b = (f b) then b else b)", "bad": "let fixpoint (f,b) = \nlet f x = let xx = (f x) in (xx, xx != b) in f", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet f x = let xx = (f x) in (xx, xx != b) in f"}
{"fix": "let f b = f -> f;\nlet fixpoint (f,b) = \nwwhile (\n, b)", "bad": "let fixpoint (f,b) = \nwwhile (f, if b = (f(b)) then b else b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile (f, if b = (f(b)) then b else b)"}
{"fix": "let f b = f -> f;\nlet fixpoint (f,b) = \nwwhile (\n, b)", "bad": "let fixpoint (f,b) = wwhile (f, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (f, b)"}
{"fix": "let fixpoint (f,b) = \nlet g b = (b, (f b)) in \nwwhile (g, b)", "bad": "let fixpoint (f,b) = \nlet g b = b in \nwwhile ((g), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet g b = b in \nwwhile ((g), b)"}
{"fix": "let fixpoint (f,b) = \nlet g b = (b, (f b)) in \nwwhile (g, b)", "bad": "let fixpoint (f,b) = \nlet g b = b in \nwwhile (g, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet g b = b in \nwwhile (g, b)"}
{"fix": "let fixpoint (f,b) = \nlet g b = (b, (f b)) in \nwwhile (g, b)", "bad": "let fixpoint (f,b) = \nlet g b = b in \nwwhile ((g,true), b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet g b = b in \nwwhile ((g,true), b)"}
{"fix": "let fixpoint (f,b) = \nlet g b = (b, (f b)) in \nwwhile (g, b)", "bad": "let fixpoint (f,b) = \nlet g b = b, (f b) in \nwwhile (g, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet g b = b, (f b) in \nwwhile (g, b)"}
{"fix": "let fixpoint (f,b) = \nif b != f b then\nlet f b = b, (f b) in\nwwhile(f, b)\nelse b", "bad": "let fixpoint (f,b) = \nlet g x = b, (f b) in (b = (f b)) in \nwwhile (g, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet g x = b, (f b) in (b = (f b)) in \nwwhile (g, b)"}
{"fix": "let fixpoint (f,b) = \nif b != f b then\nlet f b = b, (f b) in\nwwhile(f, b)\nelse b", "bad": "let fixpoint (f,b) = \nif b != f b then\nlet f x = b, (f b) in\nwwhile(f, b)\nelse b", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nif b != f b then\nlet f x = b, (f b) in\nwwhile(f, b)\nelse b"}
{"fix": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "bad": "let fixpoint (f,b) = \nif b != f b then\nlet b = f b in\nwwhile(f, b)\nelse b", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nif b != f b then\nlet b = f b in\nwwhile(f, b)\nelse b"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) =\nif b != f b then\nwwhile(f, f b)\nelse\nb", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nif b != f b then\nwwhile(f, f b)\nelse\nb"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) =\nif b != (f b) then\nwwhile(f, f b)\nelse\nb", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nif b != (f b) then\nwwhile(f, f b)\nelse\nb"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) =\nif b != (f b) then\nlet f = (f, true) in\nwwhile(f, f b)\nelse\nb", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nif b != (f b) then\nlet f = (f, true) in\nwwhile(f, f b)\nelse\nb"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) =\nif b != (f b) then\nlet f = (f b, true) in\nwwhile(f, f b)\nelse\nb", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nif b != (f b) then\nlet f = (f b, true) in\nwwhile(f, f b)\nelse\nb"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) =\nif b != (f b) then\nlet f b = (b, true) in\nwwhile(f, f b)\nelse\nb", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nif b != (f b) then\nlet f b = (b, true) in\nwwhile(f, f b)\nelse\nb"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) =\nif b != (f b) then\nlet f b = (b, true) in\nwwhile(f, f b)\nelse\nwwhile(f b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nif b != (f b) then\nlet f b = (b, true) in\nwwhile(f, f b)\nelse\nwwhile(f b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) =\nif b = f b then\nf b\nelse\nlet g b = (f b, true) in\nwwhile(g, f b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nif b = f b then\nf b\nelse\nlet g b = (f b, true) in\nwwhile(g, f b)"}
{"fix": "let fixpoint (f,b) =\nlet g b = (f b, (b = f b)) in\nwwhile(g, f b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let collatz n = match n with 1 -> 1 | _ when n mod 2 = 0 -> n/2 | _ -> 3*n + 1", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "bad": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "annotated": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}
{"fix": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "bad": "let fixpoint (f,b) =\nlet g x = (f b, (b = f b)) in\nwwhile(g, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nlet g x = (f b, (b = f b)) in\nwwhile(g, b)"}
{"fix": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "bad": "let fixpoint (f,b) =\nlet g x = (f b, (b != f b)) in\nwwhile(g, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nlet g x = (f b, (b != f b)) in\nwwhile(g, b)"}
{"fix": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"fix": "let fixpoint (f,b) =\nlet y = f b in (y, (b = f b)) in\nwwhile(y, b)", "bad": "let fixpoint (f,b) =\nlet y x= (f b, (b = f b)) in\nwwhile(y b, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nlet y x= (f b, (b = f b)) in\nwwhile(y b, b)"}
{"fix": "let fixpoint (f,b) =\nlet y = f b in (y, (b = f b)) in\nwwhile(y, b)", "bad": "let fixpoint (f,b) =\nlet y x= (f b, (b = f b)) in\nwwhile(y, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nlet y x= (f b, (b = f b)) in\nwwhile(y, b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) =\nlet y = f b in (y, (b = f b)) in\nwwhile(f, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nlet y = f b in (y, (b = f b)) in\nwwhile(f, b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) =\nlet y = f b in (y, (b = f b)) in\nwwhile(y, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nlet y = f b in (y, (b = f b)) in\nwwhile(y, b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = let y = f b in (y, (b = f b)) in\nwwhile(y, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let y = f b in (y, (b  ->  f b)) in\nwwhile(y, b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = let y = f b in (y, (b = f b)) in\nwwhile(f b, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let y = f b in (y, (b  ->  f b)) in\nwwhile(f b, b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) = let y x = f b in (y, (b = f b)) in\nwwhile(y, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b) = let y x = f b in (y, (b  ->  f b)) in\nwwhile(y, b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) =\nlet y x = (f b, (b = f b)) in\nwwhile(y, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nlet y x = (f b, (b = f b)) in\nwwhile(y, b)"}
{"fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) =\nlet f x = (f b, (b = f b)) in\nwwhile(f, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nlet f x = (f b, (b = f b)) in\nwwhile(f, b)"}
{"fix": "let fixpoint (f,b) =\nlet f x = (f b, (f b = b)) in\nwwhile(f, b)", "bad": "let fixpoint (f,b) =\nlet f x = (f, (f b = b)) in\nwwhile(f, f b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nlet f x = (f, (f b = b)) in\nwwhile(f, f b)"}
{"fix": "let fixpoint (f,b) =\nlet f x = (f b, (f b = b)) in\nwwhile(f, b)", "bad": "let fixpoint (f,b) =\nlet f x = (f, (f b = b)) in\nwwhile(f, x)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nlet f x = (f, (f b = b)) in\nwwhile(f, x)"}
{"fix": "let fixpoint (f,b) =\nlet f x = (f b, (f b = b)) in\nwwhile(f, b)", "bad": "let fixpoint (f,b) =\nlet f x = (f, (f b = b)) in\nwwhile(f b, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nlet f x = (f, (f b = b)) in\nwwhile(f b, b)"}
{"fix": "let fixpoint (f,b) =\nlet f x = (f b, (f b = b)) in\nwwhile(f, b)", "bad": "let fixpoint (f,b) =\nlet f x = (f x, (f b = b)) in\nwwhile(f, b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nlet f x = (f x, (f b = b)) in\nwwhile(f, b)"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi* eval e)\n| Cosine e-> cos(pi* eval e)\n| Average (e1,e2) -> (eval e1 + eval e2) / 2\n| Times (e1,e2) -> eval e1 * eval e2\n| Thresh (e1,e2,e3,e4) -> eval e1 < eval e2 ? eval e3 : eval e4", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi* eval e)\n| Cosine e-> cos(pi* eval e)\n| Average (e1,e2) -> (eval e1 + eval e2) / 2\n| Times (e1,e2) -> eval e1 * eval e2\n| Thresh (e1,e2,e3,e4) -> eval e1 < eval e2 ? eval e3 : eval e4"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*. eval e)\n| Cosine e-> cos(pi*. eval e)\n| Average (e1,e2) -> (eval e1 +. eval e2) /. 2\n| Times (e1,e2) -> eval e1 *. eval e2\n| Thresh (e1,e2,e3,e4) -> if eval e1 < eval e2 then eval e3 else eval e4", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*. eval e)\n| Cosine e-> cos(pi*. eval e)\n| Average (e1,e2) -> (eval e1 +. eval e2) /. 2\n| Times (e1,e2) -> eval e1 *. eval e2\n| Thresh (e1,e2,e3,e4) -> if eval e1 < eval e2 then eval e3 else eval e4"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*. eval(e,x,y))\n| Cosine e-> cos(pi*. eval(e,x,y))\n| Average (e1,e2) -> (eval(e,x,y) +. eval(e,x,y)) /. 2\n| Times (e1,e2) -> eval(e,x,y) *. eval(e,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e,x,y) < eval(e,x,y) then eval(e,x,y) else eval(e,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*. eval(e,x,y))\n| Cosine e-> cos(pi*. eval(e,x,y))\n| Average (e1,e2) -> (eval(e,x,y) +. eval(e,x,y)) /. 2\n| Times (e1,e2) -> eval(e,x,y) *. eval(e,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e,x,y) < eval(e,x,y) then eval(e,x,y) else eval(e,x,y)"}
{"fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*. eval(e,x,y))\n| Cosine e-> cos(pi*. eval(e,x,y))\n| Average (e1,e2) -> (eval(e,x,y) +. eval(e,x,y)) /. 2.\n| Times (e1,e2) -> eval(e,x,y) *. eval(e,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e,x,y) < eval(e,x,y) then eval(e,x,y) else eval(e,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*. eval(e,x,y))\n| Cosine e-> cos(pi*. eval(e,x,y))\n| Average (e1,e2) -> (eval(e,x,y) +. eval(e,x,y)) /. 2.\n| Times (e1,e2) -> eval(e,x,y) *. eval(e,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e,x,y) < eval(e,x,y) then eval(e,x,y) else eval(e,x,y)"}
{"fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*. eval(e,x,y))\n| Cosine e-> cos(pi*. eval(e,x,y))\n| Average (e1,e2) -> (eval(e,x,y) +. eval(e,x,y)) /. 2.\n| Times (e1,e2) -> eval(e,x,y) *. eval(e,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e,x,y) < eval(e,x,y) then eval(e,x,y) else eval(e,x,y)", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*. eval(e,x,y))\n| Cosine e-> cos(pi*. eval(e,x,y))\n| Average (e1,e2) -> (eval(e,x,y) +. eval(e,x,y)) /. 2.\n| Times (e1,e2) -> eval(e,x,y) *. eval(e,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e,x,y) < eval(e,x,y) then eval(e,x,y) else eval(e,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*. eval(e,x,y))\n| Cosine e-> cos(pi*. eval(e,x,y))\n| Average (e1,e2) -> (eval(e,x,y) +. eval(e,x,y)) /. 2.\n| Times (e1,e2) -> eval(e,x,y) *. eval(e,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e,x,y) < eval(e,x,y) then eval(e,x,y) else eval(e,x,y)"}
{"fix": "let rec build (rand, depth) = \nif depth = 0 || depth = 1 then\nlet r = rand(0,1) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,7) in\nmatch r with\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "bad": "let build (rand, depth) = \nlet rec helper (e, rand, depth) =\nif depth = 0 || depth = 1 then\nlet r = rand(0,1) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,7) in\nmatch r with\n| 2 -> buildSine( helper (e, rand, depth-1))\n| 3 -> buildCosine( helper (e, rand, depth-1 ))\n| 4 -> buildAverage(helper (e, rand, depth-1),helper (e, rand, depth-1))", "annotated": "let build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet rec helper (e, rand, depth) =\nif depth = 0 || depth = 1 then\nlet r = rand(0,1) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,7) in\nmatch r with\n| 2 -> buildSine( helper (e, rand, depth-1))\n| 3 -> buildCosine( helper (e, rand, depth-1 ))\n| 4 -> buildAverage(helper (e, rand, depth-1),helper (e, rand, depth-1))"}
{"fix": "let rec build (rand, depth) = \nif depth = 0 || depth = 1 then\nlet r = rand(0,1) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,7) in\nmatch r with\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "bad": "let build (rand, depth) = \nlet rec helper (e, rand, depth) =\nif depth = 0 || depth = 1 then\nlet r = rand(0,1) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,7) in\nmatch r with\n| 2 -> buildSine( helper (e, rand, depth-1))\n| 3 -> buildCosine( helper (e, rand, depth-1 ))", "annotated": "let build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet rec helper (e, rand, depth) =\nif depth = 0 || depth = 1 then\nlet r = rand(0,1) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,7) in\nmatch r with\n| 2 -> buildSine( helper (e, rand, depth-1))\n| 3 -> buildCosine( helper (e, rand, depth-1 ))"}
{"fix": "let rec build (rand, depth) = \nif depth = 0 || depth = 1 then\nlet r = rand(0,1) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,7) in\nmatch r with\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "bad": "let build (rand, depth) = \nlet rec helper (e, rand, depth) =\nif depth = 0 || depth = 1 then\nlet r = rand(0,1) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,7) in\nmatch r with\n| 2 -> buildSine( helper (e, rand, depth-1))\n| 3 -> buildCosine( helper (e, rand, depth-1 ))", "annotated": "let build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet rec helper (e, rand, depth) =\nif depth = 0 || depth = 1 then\nlet r = rand(0,1) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,7) in\nmatch r with\n| 2 -> buildSine( helper (e, rand, depth-1))\n| 3 -> buildCosine( helper (e, rand, depth-1 ))"}
{"fix": "let rec build (rand, depth) = \nif depth = 0 || depth = 1 then\nlet r = rand(0,1) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,7) in\nmatch r with\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "bad": "let rec build (rand, depth) = \nif depth = 0 || depth = 1 then\nlet r = rand(0,1) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,7) in\nmatch r with\n| 2 -> buildSine(build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0 || depth = 1 then\nlet r = rand(0,1) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,7) in\nmatch r with\n| 2 -> buildSine(build(rand,depth-1))"}
{"fix": "let rec build (rand, depth) = \nif depth = 0 || depth = 1 then\nlet r = rand(0,1) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,9) in\nmatch r with\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 -> buildSquared(build(rand,depth-1))\n| 8 -> buildRoot(build(rand,depth-1))", "bad": "let rec build (rand, depth) = \nif depth = 0 || depth = 1 then\nlet r = rand(0,1) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,9) in\nmatch r with\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 -> buildSquared(build(rand,depth-1))\n| 8 -> buildRoot(build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0 || depth = 1 then\nlet r = rand(0,1) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,9) in\nmatch r with\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 -> buildSquared(build(rand,depth-1))\n| 8 -> buildRoot(build(rand,depth-1))"}
{"fix": "let _ = eval (Sine(VarX),pi,0.)", "bad": "let _ = eval (Sine(VarX)),pi,0", "annotated": "let _ = eval (Sine(VarX)),pi,0"}
{"fix": "let _ = eval (Sine(VarX),pi,0.)", "bad": ")", "annotated": ")"}
{"fix": "let _ = eval (Sine(VarX),pi,0.)", "bad": "let _ = eval ((Sine(VarX)),pi,0)", "annotated": "let _ = eval ((Sine(VarX)),pi,0)"}
{"fix": "let _ = eval (Sine(VarX),pi,0.)", "bad": "let _ = eval ((Sine(VarX)),pi,0.)", "annotated": "let _ = eval ((Sine(VarX)),pi,0.)"}
{"fix": "let sqsum xs = \nlet f a x = (a*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = (fun f _ -> a*a) in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = (fun f _ -> a*a) in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let sqsum xs = \nlet f a x = (a*a) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = () in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = () in\nlet base = 0 in\nList.fold_left f base xs"}
{"fix": "let _ = sqsum [(-1); (-2); (-3); (-4)]", "bad": "let _ = sqsum [(-1); (-2); (-3); (-4)]\nlet_ = sqsum [1;2;3]", "annotated": "let _ = sqsum [(-1); (-2); (-3); (-4)]\nlet_ = sqsum [1;2;3]"}
{"fix": "let sqsum xs = \nlet f a x = (a+x*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = (a+x*x) in\nlet base = x in\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = (a+x*x) in\nlet base = x in\nList.fold_left f base xs"}
{"fix": "let pipe fs = \nlet f a x = (a+x) in\nlet base = 0 in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (a+x) in\nlet base = base in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (a+x) in\nlet base = base in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (a+x) in\nlet base = fs in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (a+x) in\nlet base = fs in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (a+x) in\nlet base = fs in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (a+x) in\nlet base = fs in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (a+x) in\nlet base = f in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (a+x) in\nlet base = f in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (a+x) in\nlet base = [] in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (a+x) in\nlet base = [] in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (a+x) in\nlet base = (fun a->a) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (a+x) in\nlet base = (fun a->a) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = () in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = () in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (a+x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (a+x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun f -> (a x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (fun x y) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (fun x y) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = fun f -> (a x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (fun x -> f (a x)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (fun x -> f (a x)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (fun f -> f (a x)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (fun f -> f (a x)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (fun f -> f (x)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (fun f -> f (x)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (fun f -> a(f x)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (fun f -> a(f x)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (a (f x)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (a (f x)) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (a x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (a x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (x a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (a x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (a x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (x)a in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (a x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (a x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (a x) in\nlet base = _ in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let pipe fs = \nlet f a x = (a x) in\nlet base = _ in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (a x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (a x) in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (a x) in\nlet base = _ in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (a x) in\nlet base = (x) in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (a x) in\nlet base = (x) in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (a x) in\nlet base = _ in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (a x) in\nlet base = () in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (a x) in\nlet base = () in\nList.fold_left f base fs"}
{"fix": "let _ = sqsum [(-1); (-2); (-3); (-4)]", "bad": "let _ = sqsum [(-1); (-2); (-3); (-4)]\n\nList.fold_left", "annotated": "let _ = sqsum [(-1); (-2); (-3); (-4)]\n\nList.fold_left"}
{"fix": "let pipe fs = \nlet f a x = (x a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = (x x) in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = (x x) in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"fix": "let pipe fs = \nlet f a x = (fun y -> x (a y)) in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3", "annotated": "let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h in\nlet base = \"\" in\nlet l = l in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h in\nlet base = \"\" in\nlet l = l in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = sepConcat sep t in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = sepConcat sep t in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep::sepConcat(sep t) in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep::sepConcat(sep t) in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep^sepConcat(sep t) in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep^sepConcat(sep t) in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep^t in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep^t in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = sepConcat(sep t) in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = sepConcat(sep t) in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = sepConcat sep t in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = sepConcat sep t in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sepConcat(h^sep t) in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sepConcat(h^sep t) in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"}
{"fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^sep in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sepConcat h^sep t in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = sepConcat h^sep t in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"}
{"fix": "let stringOfList f l = List.map sepConcat", "bad": "let stringOfList f l = List.map sepConcat \"\"", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map sepConcat \"\""}
{"fix": "let stringOfList f l = List.map (sepConcat) (f l)", "bad": "let stringOfList f l = List.map (sepConcat l \"\") f", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map (sepConcat l \"\") f"}
{"fix": "let stringOfList f l = List.map (sepConcat) (f l)", "bad": "let stringOfList f l = List.map (sepConcat \"\" l) f", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map (sepConcat \"\" l) f"}
{"fix": "let stringOfList f l = List.map (sepConcat) (f l)", "bad": "let stringOfList f l = List.map (sepConcat \"\" l)", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map (sepConcat \"\" l)"}
{"fix": "let stringOfList f l = List.map (sepConcat) (f l)", "bad": "let stringOfList f l = List.map (sepConcat \"\" (f l))", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map (sepConcat \"\" (f l))"}
{"fix": "let stringOfList f l = List.map (sepConcat) (f l)", "bad": "let stringOfList f l = List.map (sepConcat \"\" (f l))", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map (sepConcat \"\" (f l))"}
{"fix": "let stringOfList f l = List.map (sepConcat) (f l)", "bad": "let stringOfList f l = List.map (sepConcat) f l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map (sepConcat) f l"}
{"fix": "let stringOfList f l = List.map (sepConcat) (f l)", "bad": "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "annotated": "let _ = stringOfList string_of_int [1;2;3;4;5;6]"}
{"fix": "let stringOfList f l = List.map (sepConcat) (f l)", "bad": "let stringOfList f l = List.map (sepConcat \"\" (f l)) (f l)", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map (sepConcat \"\" (f l)) (f l)"}
{"fix": "let stringOfList f l = List.map (sepConcat) (f l)", "bad": "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "annotated": "let _ = stringOfList string_of_int [1;2;3;4;5;6]"}
{"fix": "let _ = sepConcat \"\" [\"foo\"]", "bad": "let _ = sepConcat [\"foo\"]", "annotated": "let _ = sepConcat [\"foo\"]"}
{"fix": "let stringOfList f l = List.map (sepConcat) (l)", "bad": "let stringOfList f l = List.map (sepConcat \"\" (f l)) (l)", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map (sepConcat \"\" (f l)) (l)"}
{"fix": "let stringOfList f l = List.map (sepConcat) (f l)", "bad": "let _ = stringOfList string_of_int [1;2;3;4;5;6]", "annotated": "let _ = stringOfList string_of_int [1;2;3;4;5;6]"}
{"fix": "let stringOfList f l = List.map (sepConcat) (l)", "bad": "let stringOfList f l = List.map (sepConcat \"\" (f l)) (l)", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map (sepConcat \"\" (f l)) (l)"}
{"fix": "let stringOfList f l = List.map (sepConcat) (f l)", "bad": "let stringOfList f l = List.map (sepConcat) f(l)", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map (sepConcat) f(l)"}
{"fix": "let clone x n = \nlet rec helper x n acc =\nif n <= 0 then acc\nelse helper x (n-1) (x::acc)\nin helper x n []", "bad": "let rec clone x n = \nif n <= 0 then []\nelse x :: clone x n-1", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif n <= 0 then []\nelse x :: clone x n-1"}
{"fix": "let clone x n = \nlet rec helper x n acc =\nif n <= 0 then acc\nelse helper x (n-1) (x::acc)\nin helper x n []", "bad": "let rec clone x n = \nif n <= 0 then []\nelse x :: clone x n-1", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif n <= 0 then []\nelse x :: clone x n-1"}
{"fix": "let clone x n = \nlet rec helper x n acc =\nif n <= 0 then acc\nelse helper x (n-1) (x::acc)\nin helper x n []", "bad": "let rec clone x n = \nif n <= 0 then []\nelse x :: clone (x n-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif n <= 0 then []\nelse x :: clone (x n-1)"}
{"fix": "let clone x n = \nlet rec helper x n acc =\nif n <= 0 then acc\nelse helper x (n-1) (x::acc)\nin helper x n []", "bad": "let rec clone x n = \nif n <= 0 then []\nelse x :: clone x n-1", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif n <= 0 then []\nelse x :: clone x n-1"}
{"fix": "let clone x n = \nlet rec helper x n acc =\nif n <= 0 then acc\nelse helper x (n-1) (x::acc)\nin helper x n []", "bad": "let rec clone x n = \nif n <= 0 then []\nelse clone x n-1", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif n <= 0 then []\nelse clone x n-1"}
{"fix": "let clone x n = \nlet rec helper x n acc =\nif n <= 0 then acc\nelse helper x (n-1) (x::acc)\nin helper x n []", "bad": "let rec clone x n = \nif n <= 0 then []\nelse then x :: clone x n-1", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif n <= 0 then []\nelse then x :: clone x n-1"}
{"fix": "let clone x n = \nlet rec helper x n acc =\nif n <= 0 then acc\nelse helper x (n-1) (x::acc)\nin helper x n []", "bad": "let rec clone x n = \nif n <= 0 then []\nelse x :: clone x n-1", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif n <= 0 then []\nelse x :: clone x n-1"}
{"fix": "let clone x n = \nlet rec helper x n acc =\nif n <= 0 then acc\nelse helper x (n-1) (x::acc)\nin helper x n []", "bad": "let clone x n = \nlet rec helper x n acc =\nif n <= 0 then acc\nelse helper x n-1 x:acc\nin helper x n []", "annotated": "let clone : 'a -> int -> 'a list = fun  x n  ->  \nlet rec helper x n acc =\nif n <= 0 then acc\nelse helper x n-1 x:acc\nin helper x n []"}
{"fix": "let clone x n = \nlet rec helper x n acc =\nif n <= 0 then acc\nelse helper x (n-1) (x::acc)\nin helper x n []", "bad": "let clone x n = \nlet rec helper x n acc =\nif n <= 0 then acc\nelse helper x n-1 x::acc\nin helper x n []", "annotated": "let clone : 'a -> int -> 'a list = fun  x n  ->  \nlet rec helper x n acc =\nif n <= 0 then acc\nelse helper x n-1 x::acc\nin helper x n []"}
{"fix": "let padZero l1 l2 =\nif (List.length l1) < (List.length l2) then\nList.append [(clone 0 (List.length l2 - List.length l1)) @ l1] [l2]\nelse\nList.append [l1] [(clone 0 (List.length l1 - List.length l2)) @ l2]", "bad": "let padZero l1 l2 =\nif (List.length l1) < (List.length l2) then\nList.append [(clone 0 (List.length l2 - List.length l1)) @ l1] [l2]\nelse (List.length l1) > (List.length l2)\nList.append [l1] [(clone 0 (List.length l1 - List.length l2)) @ l2]", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \nif (List.length l1) < (List.length l2) then\nList.append [(clone 0 (List.length l2 - List.length l1)) @ l1] [l2]\nelse (List.length l1) > (List.length l2)\nList.append [l1] [(clone 0 (List.length l1 - List.length l2)) @ l2]"}
{"fix": "let padZero l1 l2 =\nif (List.length l1) < (List.length l2) then\n((clone 0 (List.length l2 - List.length l1)) @ l1, l2)\nelse\n(l1, (clone 0 (List.length l1 - List.length l2)) @ l2)", "bad": "let padZero l1 l2 =\nif (List.length l1) < (List.length l2) then\n([(clone 0 (List.length l2 - List.length l1)) @ l1], [l2])\nelse\n([l1], [(clone 0 (List.length l1 - List.length l2)) @ [l2])", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \nif (List.length l1) < (List.length l2) then\n([(clone 0 (List.length l2 - List.length l1)) @ l1], [l2])\nelse\n([l1], [(clone 0 (List.length l1 - List.length l2)) @ [l2])"}
{"fix": "let padZero l1 l2 =\nif (List.length l1) < (List.length l2) then\n((clone 0 (List.length l2 - List.length l1)) @ l1, l2)\nelse\n(l1, (clone 0 (List.length l1 - List.length l2)) @ l2)", "bad": "let padZero l1 l2 =\nif (List.length l1) < (List.length l2) then\n([(clone 0 (List.length l2 - List.length l1)) @ l1], l2)\nelse\n([l1], [(clone 0 (List.length l1 - List.length l2)) @ l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \nif (List.length l1) < (List.length l2) then\n([(clone 0 (List.length l2 - List.length l1)) @ l1], l2)\nelse\n([l1], [(clone 0 (List.length l1 - List.length l2)) @ l2)"}
{"fix": "let padZero l1 l2 =\nif (List.length l1) < (List.length l2) then\n((clone 0 (List.length l2 - List.length l1)) @ l1, l2)\nelse\n(l1, (clone 0 (List.length l1 - List.length l2)) @ l2)", "bad": "let padZero l1 l2 =\nif (List.length l1) < (List.length l2) then\n((clone 0 (List.length l2 - List.length l1)) @ l1, l2)\nelse\n([l1], (clone 0 (List.length l1 - List.length l2)) @ l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \nif (List.length l1) < (List.length l2) then\n((clone 0 (List.length l2 - List.length l1)) @ l1, l2)\nelse\n([l1], (clone 0 (List.length l1 - List.length l2)) @ l2)"}
{"fix": "let padZero l1 l2 =\nif (List.length l1) < (List.length l2) then\n(List.append (clone 0 (List.length l2 - List.length l1)) l1, l2)\nelse\n(l1, List.append (clone 0 (List.length l1 - List.length l2)) l2)", "bad": "let padZero l1 l2 =\nif (List.length l1) < (List.length l2) then\n((List.append clone 0 (List.length l2 - List.length l1)) l1, l2)\nelse\n(l1, List.append (clone 0 (List.length l1 - List.length l2)) l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \nif (List.length l1) < (List.length l2) then\n((List.append clone 0 (List.length l2 - List.length l1)) l1, l2)\nelse\n(l1, List.append (clone 0 (List.length l1 - List.length l2)) l2)"}
{"fix": "let _ = stringOfList string_of_int [9;9]", "bad": "let _ = stringOfList [9;9]", "annotated": "let _ = stringOfList [9;9]"}
{"fix": "let _ = padZero [9;9] [1;0;0;2]", "bad": "let _ = List.rev List.combine( padZero([9;9] [1;0;0;2]))", "annotated": "let _ = List.rev List.combine( padZero([9;9] [1;0;0;2]))"}
{"fix": "let _ = padZero [9;9] [1;0;0;2]", "bad": "let _ = List.rev (List.combine( padZero([9;9] [1;0;0;2])))", "annotated": "let _ = List.rev (List.combine( padZero([9;9] [1;0;0;2])))"}
{"fix": "let _ = padZero [9;9] [1;0;0;2]", "bad": "let _ = List.rev (List.combine( padZero [9;9] [1;0;0;2]))", "annotated": "let _ = List.rev (List.combine( padZero [9;9] [1;0;0;2]))"}
{"fix": "let _ = padZero [9;9] [1;0;0;2]", "bad": "let _ = List.combine(padZero [9;9] [1;0;0;2])", "annotated": "let _ = List.combine(padZero [9;9] [1;0;0;2])"}
{"fix": "let _ = padZero [9;9] [1;0;0;2]", "bad": "let _ = List.rev(padZero [9;9] [1;0;0;2])", "annotated": "let _ = List.rev(padZero [9;9] [1;0;0;2])"}
{"fix": "let _ = removeZero [0;0;0;0]", "bad": "let _ = removeZero [0;0;0;0]\n\nint_of_list [9;9]", "annotated": "let _ = removeZero [0;0;0;0]\n\nint_of_list [9;9]"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [(0, [])] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = xin", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = xin"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [(0, [])] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (a,b) in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (a,b) in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [(0, [])] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [(0, [])] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = (0,List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = (0,List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [(0, [])] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = (0, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = (0, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [(0, [])] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = (0, l1) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = (0, l1) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [(0, [])] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = (0, []) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = (0, []) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [(0, [])] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [(0, [l1,l2])] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [(0, [l1,l2])] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [ (3, [] ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [ (l1+l2, [] ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [ (l1+l2, [] ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| x'::xs -> x' in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [[ (h, l2 ) ]] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| x::xs -> x in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| x::xs -> x in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| x'::xs -> x' in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [[ (h, l2 ) ]] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| x'::xs -> x' in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| x'::xs -> x' in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (c,d) -> (c,d) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match a with\n| (c,d) -> c in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match a with\n| (c,d) -> c in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d) -> a in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d) -> (c,a) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d) -> (c,a) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d) -> a in\nlet base = (0, [1]) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d) -> a in\nlet base = (0, [1,1]) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d) -> a in\nlet base = (0, [1,1]) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> a in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d) -> c+d::a in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d) -> c+d::a in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> a in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> c+d::a in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> c+d::a in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> a in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c+d::a,l2) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c+d::a,l2) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> a in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> c+d::a in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> c+d::a in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,d::t) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> c+d in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> c+d in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,d::t) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c+d)::a in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c+d)::a in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,d::t) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> c in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> c in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,d::t) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> c,d in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> c,d in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,d::t) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,d) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,d) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,t) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,a) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,a) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,t) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,[a]) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,[a]) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,t) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, List.rev l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,d) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, List.rev l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,d) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, List.rev l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,t) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, List.rev l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,c+t) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, List.rev l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,c+t) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, List.rev l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2) -> (d1+d2, d1+d2::\nmatch a with \n| (a1,a2)->a2) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2) -> (d1+d2, d1+d2::) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2) -> (d1+d2, d1+d2::) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2) -> (d1+d2, d1+d2::\nmatch a with \n| (a1,a2)->a2) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2) -> (d1+d2, d1+d2::a) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2) -> (d1+d2, d1+d2::a) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2) -> (d1+d2, d1+d2::\nmatch a with \n| (a1,a2)->a2) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2) -> (d1+d2, d1+d2::(match a with | (a1,a2)->a2) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2) -> (d1+d2, d1+d2::(match a with | (a1,a2)->a2) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (o,p) = a in\nmatch x with \n| (d1,d2) -> (((d1+d2) mod 10 -(d1+d2))/10, (d1+d2) mod 10+o::p) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2) -> (((d1+d2) mod 10 -(d1+d2))/10, (d1+d2) mod 10+\nmatch a with \n| (a1,a2)->a1)::a2 in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2) -> (((d1+d2) mod 10 -(d1+d2))/10, (d1+d2) mod 10+\nmatch a with \n| (a1,a2)->a1)::a2 in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (o,p) = a in\nmatch x with \n| (d1,d2) -> (((d1+d2) mod 10 -(d1+d2))/10, (d1+d2) mod 10+o::p) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2) -> (((d1+d2) mod 10 -(d1+d2))/10, (d1+d2) mod 10+\nmatch a with \n| (a1,a2)-> a1::a2 in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2) -> (((d1+d2) mod 10 -(d1+d2))/10, (d1+d2) mod 10+\nmatch a with \n| (a1,a2)-> a1::a2 in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (o,p) = a in\nmatch x with \n| (d1,d2) -> ((d1+d2) mod 10 /10, ((d1+d2) mod 10)+o ::p) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (o,p) = a in\nmatch x with \n| (d1,d2) -> ((d1+d2) mod 10 /10, ((d1+d2) mod 10)+o)::p", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (o,p) = a in\nmatch x with \n| (d1,d2) -> ((d1+d2) mod 10 /10, ((d1+d2) mod 10)+o)::p"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (o,p) = a in\nmatch x with \n| (d1,d2) -> ( (d1+d2+o)/10, ((d1+d2+o) mod 10) ::p) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (o,p) = a in\nmatch x with \n| (d1,d2) -> ( (d1+d2+a)/10, ((d1+d2+o) mod 10) ::p) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (o,p) = a in\nmatch x with \n| (d1,d2) -> ( (d1+d2+a)/10, ((d1+d2+o) mod 10) ::p) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (o,p) = a in\nlet (d1,d2) = x in ( (d1+d2+o)/10, ((d1+d2+o) mod 10) ::p) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (o,p) = a in\nlet (d1,d2) = x in ( (d1+d2+o)/10, ((d1+d2+o) mod 10) ::p) in\nlet base = (0, []) in\nlet args = List.rev (List.combine 0::l1 0::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (o,p) = a in\nlet (d1,d2) = x in ( (d1+d2+o)/10, ((d1+d2+o) mod 10) ::p) in\nlet base = (0, []) in\nlet args = List.rev (List.combine 0::l1 0::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"fix": "let mulByDigit i l = \nlet rec helper i l acc =\nmatch l with\n| [] -> acc\n| h::t -> (h*i) :: acc \nin helper i l []", "bad": "let rec mulByDigit i l = let h::t = List.rev l in\nmulByDigit (h*i)", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l = let h::t  ->  List.rev l in\nmulByDigit (h*i)"}
{"fix": "let mulByDigit i l = \nlet rec helper i l acc =\nmatch l with\n| [] -> acc\n| h::t -> h*i :: acc \nin helper i l []", "bad": "let mulByDigit i l = \nlet rec helper i l acc =\nmatch l with\n| [] -> acc\n| h::t -> helper(t*i) :: acc \nin helper i l []", "annotated": "let mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet rec helper i l acc =\nmatch l with\n| [] -> acc\n| h::t -> helper(t*i) :: acc \nin helper i l []"}
{"fix": "let mulByDigit i l = \nlet rec helper i l acc =\nmatch l with\n| [] -> acc\n| h::t -> h*i :: acc \nin helper i l []", "bad": "let mulByDigit i l = \nlet rec helper i l acc =\nmatch l with\n| [] -> acc\n| h::t -> helper(h*i) :: acc \nin helper i l []", "annotated": "let mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet rec helper i l acc =\nmatch l with\n| [] -> acc\n| h::t -> helper(h*i) :: acc \nin helper i l []"}
{"fix": "let rec mulByDigit i l = mulByDigit (i-1) (bigAdd l l)", "bad": "let rec mulByDigit i l = mulByDigit i-1 (bigAdd l l)", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  mulByDigit i-1 (bigAdd l l)"}
{"fix": "let sqsum xs = \nlet f a x = (a+x*x) in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let a1::a2::t = l1 in\n(mulByDigit a2 (mulByDigit a1 l2))", "annotated": "let a1::a2::t = l1 in\n(mulByDigit a2 (mulByDigit a1 l2))"}
{"fix": "let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet h::t = x in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o) )in\nlet base = (0,[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet h::t = x in (o+1, bigAdd (mulByDigit h l2) p @ clone 0 o )in\nlet base = (0,[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (o,p) = a in \nlet h::t = x in (o+1, bigAdd (mulByDigit h l2) p @ clone 0 o )in\nlet base = (0,[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet (h::t,y) = x in (o+1, bigAdd (mulByDigit h y) (p @ clone 0 o) ) in\nlet base = (0,[]) in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres", "bad": "let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet h::t = x in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o) ) in\nlet base = (0,[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (o,p) = a in \nlet h::t = x in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o) ) in\nlet base = (0,[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "bad": "let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet (h::t,y) = x in (o+1, bigAdd (mulByDigit h y) (p @ clone 0 o) ) in\nlet base = (0,[]) in\nlet args = [(l1, l2)] in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (o,p) = a in \nlet (h::t,y) = x in (o+1, bigAdd (mulByDigit h y) (p @ clone 0 o) ) in\nlet base = (0,[]) in\nlet args = [(l1, l2)] in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "bad": "let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet (h::t) = x in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o)) in\nlet base = (0,[]) in\nlet args = [l1] in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (o,p) = a in \nlet (h::t) = x in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o)) in\nlet base = (0,[]) in\nlet args = [l1] in\nlet (_, res) = List.fold_left f base args in\nres"}
{"fix": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "bad": "let _ = bigMul [[9;9;9;9]] [9;9;9;9]", "annotated": "let _ = bigMul [[9;9;9;9]] [9;9;9;9]"}
{"fix": "let _ = bigMul [9;9;9;9] [9;9;9;9]", "bad": "let bigMul l1 l2 = \nlet f a x = let (o,p) = a in \nlet h::t = [x] in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o)) in\nlet base = (0,[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (o,p) = a in \nlet h::t = [x] in (o+1, bigAdd (mulByDigit h l2) (p @ clone 0 o)) in\nlet base = (0,[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres"}
