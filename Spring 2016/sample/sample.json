{"annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif (n<=0) \nthen []\nelse\n(digitsOfInt (n/10) ):: (n mod 10)", "fix": "let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)", "annotated_fix": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)", "bad": "let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\n(digitsOfInt (n/10) ):: (n mod 10)"}
{"annotated": "et _ = removeDuplicates [1;6;2;4;12;2;13;6;9]", "fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen)\nthen \nseen\nelse \nh :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated_fix": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen)\nthen \nseen\nelse \nh :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "et _ = removeDuplicates [1;6;2;4;12;2;13;6;9]"}
{"annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map f (sepConcat l)", "fix": "let stringOfList f l = \"[\" ^ ( sepConcat \";\" (List.map f l) ) ^ \"]\"", "annotated_fix": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\" ^ ( sepConcat \";\" (List.map f l) ) ^ \"]\"", "bad": "let stringOfList f l = List.map f (sepConcat l)"}
{"annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match (List.rev l) with\n| []   -> []\n| h::t -> (mulByDigit i (List.rev t) ) :: 0 @  h*i :: []", "fix": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> (mulByDigit i (List.rev t) @ [0])  @  h*i :: []", "annotated_fix": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match (List.rev l) with\n| []   -> []\n| h::t -> (mulByDigit i (List.rev t) @ [0])  @  h*i :: []", "bad": "let rec mulByDigit i l = match (List.rev l) with\n| []   -> []\n| h::t -> (mulByDigit i (List.rev t) ) :: 0 @  h*i :: []"}
{"annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match x with\n(k,v) -> (k,v) in \nlet base = ([], [0]) in\nlet args = let rec helper acc l1 l2 = \nmatch l1 with \n| [] -> acc\n| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2\nin helper [] (List.rev l1) l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "fix": "", "annotated_fix": "", "bad": "let bigMul l1 l2 = \nlet f a x = match x with\n(k,v) -> (k,v) in \nlet base = ([], [0]) in\nlet args = let rec helper acc l1 l2 = \nmatch l1 with \n| [] -> acc\n| h::t -> helper ((h, l2) :: acc) (List.map (fun x->x*10) t) l2\nin helper [] (List.rev l1) l2\nin\nlet (_, res) = List.fold_left f base args in\nres"}
{"annotated": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "fix": "", "annotated_fix": "", "bad": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}
{"annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t-> sqrt (eval(e',x,y))\n| FunckyRoot (e1,e2,e3) -> (sqrt (eval(e1,x,x))) *.  (sqrt (eval(e2,x,y))) *. (sqrt (eval(e3,y,y)))", "fix": "", "annotated_fix": "", "bad": "let rec eval (e,x,y) = match e with\n| VarX\t\t\t-> x\n| VarY\t\t\t-> y\n| Sine     e'\t\t-> sin (pi *. eval(e', x, y))\n| Cosine   e'\t\t-> cos (pi *. eval(e', x, y))\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\n| Times   (e1, e2)\t-> eval (e1,x,y) *. eval (e2,x,y)\n| Thresh  (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| SquareRoot e'\t\t-> sqrt (eval(e',x,y))\n| FunckyRoot (e1,e2,e3) -> (sqrt (eval(e1,x,x))) *.  (sqrt (eval(e2,x,y))) *. (sqrt (eval(e3,y,y)))"}
{"annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  (*failwith \"to be implemented\" *) if depth > (-1)\nthen \nlet randNum = rand(1,2) in\nlet randNum2 = rand(3,4) in\nmatch (randNum, randNum2) with\n| (1,3) -> failwith \"bahh\"\n| (1,4) -> buildSine(buildOp2(  build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )\n| (2,3) -> buildCosine(buildOp1(buildX()))\n| (2,4) -> buildCosine(buildOp2(build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )\n| _ -> failwith \"didnt work\"", "fix": "let rec build (rand, depth) = \nif depth = 0\nthen \nbuildSine(buildX())\nelse\nbuildX()", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0\nthen \nbuildSine(buildX())\nelse\nbuildX()", "bad": "let rec build (rand, depth) = (*failwith \"to be implemented\" *) if depth > (-1)\nthen \nlet randNum = rand(1,2) in\nlet randNum2 = rand(3,4) in\nmatch (randNum, randNum2) with\n| (1,3) -> failwith \"bahh\"\n| (1,4) -> buildSine(buildOp2(  build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )\n| (2,3) -> buildCosine(buildOp1(buildX()))\n| (2,4) -> buildCosine(buildOp2(build(rand, depth - 1), \nbuild(rand, depth - 1),\nbuild(rand, depth - 1))  )\n| _ -> failwith \"didnt work\""}
{"annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "fix": "", "annotated_fix": "", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n <= 0 then []\nelse (digitsOfInt div(n, 10)) @ [n]", "fix": "let rec digitsOfInt n = \nif n <= 0 then []\nelse (digitsOfInt (n / 10)) @ [n mod 10]", "annotated_fix": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n <= 0 then []\nelse (digitsOfInt (n / 10)) @ [n mod 10]", "bad": "let rec digitsOfInt n = \nif n <= 0 then []\nelse (digitsOfInt div(n, 10)) @ [n]"}
{"annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet (l, r) = additivePersAndRoot(abs(n)) in\nl", "fix": "", "annotated_fix": "", "bad": "let rec additivePersistence n = \nlet (l, r) = additivePersAndRoot(abs(n)) in\nl"}
{"annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n <= 0 then []\nelse digitsOfInt(n/10) :: []", "fix": "", "annotated_fix": "", "bad": "let rec digitsOfInt n = \nif n <= 0 then []\nelse digitsOfInt(n/10) :: []"}
{"annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = (a + x) mod 10 in\nlet base = [] in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "fix": "", "annotated_fix": "", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (a + x) mod 10 in\nlet base = [] in\nlet args = [] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated_fix": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"TBD\" in\nlet base = failwith \"TBD\" in\nlet args =  failwith \"TBD\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (w,y)::t -> ((w+y)/10)::((w+y) mod 10)::a\n| _ -> a  in\nlet base = [] in\nlet args =  List.rev ((List.combine l1 l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"annotated": "let digits n = digitsOfInt (abs n)", "fix": "", "annotated_fix": "", "bad": "let digits n = digitsOfInt (abs n)"}
{"annotated": "let rec additivePersistence : int -> int = fun  n  -> \nlet rec aPHelper n i =\nif (n < 10) then i\nelse aPHelper (sumList (digits n)) (i+1)", "fix": "", "annotated_fix": "", "bad": "let rec additivePersistence n =\nlet rec aPHelper n i =\nif (n < 10) then i\nelse aPHelper (sumList (digits n)) (i+1)"}
{"annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem tl hd = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem hd seen = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated_fix": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem hd seen = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem tl hd = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "fix": "let fixpoint (f,b) = wwhile((let g b = let xx = f x in (xx, xx!=b) in g), b)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile((let g b = let xx = f x in (xx, xx!=b) in g), b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = (f x, (f x)=(f b)) in helper b), b)", "fix": "let fixpoint (f,b) = \nwwhile((let helper x = (f b, (f x)=(f b)) in helper), b)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = (f b, (f x)=(f b)) in helper), b)", "bad": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, (f x)=(f b)) in helper b), b)"}
{"annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a + x*x in\nlet base = \nmatch xs with\n| [] -> f 0 []\n| hd::tl -> f 0 hd\nin\nList.fold_left f base xs", "fix": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = \nmatch xs with\n| [] -> f 0 0\n| hd::tl -> f 0 hd\nin\nList.fold_left f base xs", "annotated_fix": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a + x*x in\nlet base = \nmatch xs with\n| [] -> f 0 0\n| hd::tl -> f 0 hd\nin\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = \nmatch xs with\n| [] -> f 0 []\n| hd::tl -> f 0 hd\nin\nList.fold_left f base xs"}
{"annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = a::x in\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| hd::tl -> \nif (tl=[]) then [(x,hd)]\nelse (x,hd)::(argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "fix": "", "annotated_fix": "", "bad": "let bigMul l1 l2 = \nlet f a x = a::x in\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| hd::tl -> \nif (tl=[]) then [(x,hd)]\nelse (x,hd)::(argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres"}
{"annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x =\nmatch x with\n| (l2digit,templ1) ->\nlet multres = \nmulByDigit l2digit templ1\nin\n(0,bigAdd (a@[0]) multres) in\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> []\n| hd::tl -> \nif (tl=[]) then [hd,x]\nelse (hd,x)::(argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres", "fix": "", "annotated_fix": "", "bad": "let bigMul l1 l2 = \nlet f a x =\nmatch x with\n| (l2digit,templ1) ->\nlet multres = \nmulByDigit l2digit templ1\nin\n(0,bigAdd (a@[0]) multres) in\nlet base = (0, []) in\nlet args =\nlet rec argmaker x y =\nmatch y with\n| [] -> []\n| hd::tl -> \nif (tl=[]) then [hd,x]\nelse (hd,x)::(argmaker x tl)\nin\nargmaker l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres"}
{"annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y =clone List.hd l1 (List.length l1 - List.length l2) in\n(y, l2)\nelse let z = clone List.hd l2 (List.length l2 - List.length l1) in\n(z, l1)", "fix": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y = clone (List.hd l1) (List.length l1 - List.length l2) in\n(y, l2)\nelse let z = clone (List.hd l2) (List.length l2 - List.length l1) in\n(z, l1)", "annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y = clone (List.hd l1) (List.length l1 - List.length l2) in\n(y, l2)\nelse let z = clone (List.hd l2) (List.length l2 - List.length l1) in\n(z, l1)", "bad": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if (List.length l1) > (List.length l2)\nthen let y =clone List.hd l1 (List.length l1 - List.length l2) in\n(y, l2)\nelse let z = clone List.hd l2 (List.length l2 - List.length l1) in\n(z, l1)"}
{"annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)\nelse (0,(d1+d2)::result) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev l1, List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)\nelse (0,(d1+d2)::result) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated_fix": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)\nelse (0,(d1+d2)::result) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+1) - 10 :: result)\nelse (0,(d1+d2)::result) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev l1, List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs", "fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun a->a in\nList.fold_left f base fs", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun a->a in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs"}
{"annotated": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n| [] -> []\n| h::t -> h+sumList t", "fix": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n| [] -> 0\n| h::t -> h + sumList t", "bad": "let rec sumList xs = match xs with\n| [] -> []\n| h::t -> h+sumList t"}
{"annotated": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "fix": "let rec build (rand, depth) = \n\nfailwith \"to be implemented\"", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \n\nfailwith \"to be implemented\"", "bad": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}
{"annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \"\" in\nlet base =  sepConcat sep t in\nlet l =  \"\" in\nList.fold_left f base l", "fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^a in\nlet base =  sepConcat sep t in\nlet l =  t in\nList.fold_left f base l", "annotated_fix": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^a in\nlet base =  sepConcat sep t in\nlet l =  t in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \"\" in\nlet base =  sepConcat sep t in\nlet l =  \"\" in\nList.fold_left f base l"}
{"annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  failwith List.map (fun x-> \"\") l", "fix": "let stringOfList f l = List.map (sepConcat \"\") l", "annotated_fix": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map (sepConcat \"\") l", "bad": "let stringOfList f l = failwith List.map (fun x-> \"\") l"}
{"annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map (sepConcat \" \") l.string", "fix": "let stringOfList f l = List.map (sepConcat \"\") l", "annotated_fix": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map (sepConcat \"\") l", "bad": "let stringOfList f l = List.map (sepConcat \" \") l.string"}
{"annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  -> \nlet acc = [] in\nif n=0\nthen acc\nelse clone x::acc n-1", "fix": "", "annotated_fix": "", "bad": "let rec clone x n =\nlet acc = [] in\nif n=0\nthen acc\nelse clone x::acc n-1"}
{"annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nlet rec helper count x =\nif (x < 10) then count\nelse  helper (count + 1) (sumList (digits n))\nin helper 0 n", "fix": "", "annotated_fix": "", "bad": "let rec additivePersistence n = \nlet rec helper count x =\nif (x < 10) then count\nelse  helper (count + 1) (sumList (digits n))\nin helper 0 n"}
{"annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \n2.0 *.exp (\n-(eval (e1, x, y) -. \neval (e2, x, y))** 2.0 \n/. eval (e3, x,y))", "fix": "", "annotated_fix": "", "bad": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi*.eval(e', x, y))\n| Cosine(e') -> cos(pi*.eval(e', x, y))\n| Average(e1, e2) -> (eval(e1, x, y) +. eval(e2, x, y))/.2.0\n| Times (e1, e2) -> (eval(e1, x, y) *. eval(e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif eval(e1, x, y) < eval (e2, x, y)\nthen eval(e3, x, y)\nelse eval(e4, x, y)\n| Sqrt (e) -> sqrt (abs_float (eval (e, x, y)))\n| Gauss (e1, e2, e3) -> \n2.0 *.exp (\n-(eval (e1, x, y) -. \neval (e2, x, y))** 2.0 \n/. eval (e3, x,y))"}
{"annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = (x / 10, 1 ) in\nlet base = (0 , 0) in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "fix": "let bigAdd l1 l2 = failwith \"moo\"", "annotated_fix": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  failwith \"moo\"", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (x / 10, 1 ) in\nlet base = (0 , 0) in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nmatch x with \n| ([], []) ->  (0, if carry > 0 then carry :: num else num)\n| (l1', l2') -> \nlet addit = List.hd l1' + List.hd l2' + carry in\n((if (addit > 10) then (addit mod 10) else 0), \n(addit / 10) :: num)\t  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))", "fix": "", "annotated_fix": "", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nmatch x with \n| ([], []) ->  (0, if carry > 0 then carry :: num else num)\n| (l1', l2') -> \nlet addit = List.hd l1' + List.hd l2' + carry in\n((if (addit > 10) then (addit mod 10) else 0), \n(addit / 10) :: num)\t  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}
{"annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  if (i = 0) then []\nelse if (i = 1) then l \nelse if (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)\nelse bigAdd l (mulByDigit (i - 1) l)", "fix": "", "annotated_fix": "", "bad": "let rec mulByDigit i l = if (i = 0) then []\nelse if (i = 1) then l \nelse if (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)\nelse bigAdd l (mulByDigit (i - 1) l)"}
{"annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  match l with\n[] -> \"\"\n| h::t -> f h ^ stringOfList f t", "fix": "let stringOfList f l = match l with\n[] -> \"\"\n| h::t -> \nlet f' a x = x ^ a in\nlet base = f h in\nlet l = t in\nList.fold_left f' base l", "annotated_fix": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  match l with\n[] -> \"\"\n| h::t -> \nlet f' a x = x ^ a in\nlet base = f h in\nlet l = t in\nList.fold_left f' base l", "bad": "let stringOfList f l = match l with\n[] -> \"\"\n| h::t -> f h ^ stringOfList f t"}
{"annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> removeZero (((h1 + h2) / 10 )::(( h1 + h2) mod 10 ))::a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated_fix": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> ((h1 + h2) / 10 )::(( h1 + h2) mod 10 )::a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n| (h1, h2) -> removeZero (((h1 + h2) / 10 )::(( h1 + h2) mod 10 ))::a\n| _ -> a \nin\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet res = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile(if f b = b then (f b, true) else (f b, false),b)", "fix": "let fixpoint (f,b) = let fx b' = (f b', f b' = b') in\nwwhile(fx,b)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  let fx b' = (f b', f b' = b') in\nwwhile(fx,b)", "bad": "let fixpoint (f,b) = \nwwhile(if f b = b then (f b, true) else (f b, false),b)"}
{"annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero (0:l1) (0:l2)))", "fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero (0::l1) (0::l2)))", "annotated_fix": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero (0::l1) (0::l2)))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let sum = fst a + (fst x + snd x) in\n(sum/10, (sum mod 10)::snd a) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero (0:l1) (0:l2)))"}
{"annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = match x with\n| []     -> a\n| (h::t) -> f (a+(h*h)) t in\nlet base = 0 in\nList.fold_left f base xs", "fix": "let sqsum xs = \nlet rec f a x = match x with\n| []     -> a\n| (h::t) -> f (a+(h*h)) t in\nlet base = 0 in\nList.fold_left f base xs", "annotated_fix": "let sqsum : int list -> int  = fun  xs  ->  \nlet rec f a x = match x with\n| []     -> a\n| (h::t) -> f (a+(h*h)) t in\nlet base = 0 in\nList.fold_left f base xs", "bad": "let sqsum xs = \nlet f a x = match x with\n| []     -> a\n| (h::t) -> f (a+(h*h)) t in\nlet base = 0 in\nList.fold_left f base xs"}
{"annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let add (m,n) = [m + n] in (add x)::a in\nlet base = [] in\nlet args = match (List.rev (List.combine l1 l2)) with \n| [] -> (0,0)\n| (h::t) -> h in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet prevN (n1, n2) = n1 in\nlet prev = prevN a in\nlet sumlist (p1, p2) = p2 in\nlet sum = sumlist a in\nlet add (m,n) = m + n in\nlet digit = (add x) + prev in\nif digit > 10 then (1, (digit-10)::sum) else (0, (digit)::sum) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated_fix": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet prevN (n1, n2) = n1 in\nlet prev = prevN a in\nlet sumlist (p1, p2) = p2 in\nlet sum = sumlist a in\nlet add (m,n) = m + n in\nlet digit = (add x) + prev in\nif digit > 10 then (1, (digit-10)::sum) else (0, (digit)::sum) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let add (m,n) = [m + n] in (add x)::a in\nlet base = [] in\nlet args = match (List.rev (List.combine l1 l2)) with \n| [] -> (0,0)\n| (h::t) -> h in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse digitsOfInt n mod 10", "fix": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n/10)", "annotated_fix": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n < 0 then []\nelse digitsOfInt (n/10)", "bad": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt n mod 10"}
{"annotated": "let rec digitalRoot : int -> int = fun  n  ->  \nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in \nif x > 9 then digitalRoot x\nelse 1 in digitalRoot x", "fix": "let digitalRoot n =\nif n < 10 then 0\nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then 1 + addTimes x\nelse 1 in\naddTimes n", "annotated_fix": "let digitalRoot : int -> int = fun  n  -> \nif n < 10 then 0\nelse \nlet rec addTimes n =\nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in\nif x > 9 then 1 + addTimes x\nelse 1 in\naddTimes n", "bad": "let rec digitalRoot n = \nlet rec digits n = \nif n <= 0 then 0\nelse ((n mod 10) + digits (n/10)) in\nlet x = digits n in \nif x > 9 then digitalRoot x\nelse 1 in digitalRoot x"}
{"annotated": "let listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec reverseHelper acc = function\n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l", "fix": "", "annotated_fix": "", "bad": "let listReverse l = \nlet rec reverseHelper acc = function\n| [] -> acc\n| h::t -> reverseHelper (h::acc) t in\nreverseHelper [] l"}
{"annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval ex x y )\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "fix": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "annotated_fix": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval (ex,x,y) )\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\"", "bad": "let rec eval (e,x,y) = match e with VarX -> x\n| VarY -> y\n| Sine ex -> sin(pi*.eval ex x y )\n| Cosine ex -> \"cos(pi*\"^ exprToString ex ^\")\"\n| Average (ex1,ex2) -> \"((\"^exprToString ex1^\"+\"^exprToString ex2^\")/2)\"\n| Times (ex1,ex2) -> exprToString ex1^\"*\"^exprToString ex2\n| Thresh (ex1,ex2,ex3,ex4) -> \"(\"^exprToString ex1^\"<\"^exprToString ex2^\"?\"^exprToString ex3^\":\"^ exprToString ex4^\")\""}
{"annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "fix": "let fixpoint (f,b) = wwhile ( (f b),b)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( (f b),b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with \n| 0 -> buildX() \n| 1 ->  if(rand > 1) then buildSine( build(rand, depth - 1) )\n| _ -> buildCosine( build(rand, depth - 1) )", "fix": "let rec build (rand, depth) = match depth with \n| 0 -> buildX() \n| 1 ->  buildSine( build(rand, depth - 1) )\n| _ -> buildCosine( build(rand, depth - 1) )", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with \n| 0 -> buildX() \n| 1 ->  buildSine( build(rand, depth - 1) )\n| _ -> buildCosine( build(rand, depth - 1) )", "bad": "let rec build (rand, depth) = match depth with \n| 0 -> buildX() \n| 1 ->  if(rand > 1) then buildSine( build(rand, depth - 1) )\n| _ -> buildCosine( build(rand, depth - 1) )"}
{"annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = 0 in\nlet args = \nlet rec pair list1 list2 = match (list1, list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> []\nin pair l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair list1 list2 = \nmatch (List.rev list1, List.rev list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> []\nin pair l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nargs\nin \nremoveZero (add (padZero l1 l2))", "annotated_fix": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with\n(x1, x2) -> \nmatch a with\n(o , z) -> if o + x1 + x2 > 9 \nthen (1, ((o + x1 + x2) mod 10)::z )\nelse (0, (o + x1 + x2)::z)\nin\nlet base = (0, []) in\nlet args = \nlet rec pair list1 list2 = \nmatch (List.rev list1, List.rev list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> []\nin pair l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nargs\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = 0 in\nlet args = \nlet rec pair list1 list2 = match (list1, list2) with\n| (h1::t1, h2::t2) -> (h1,h2)::pair t1 t2\n| (_ , _) -> []\nin pair l1 l2\nin\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = fun x y -> x y in\nList.fold_left f base fs", "fix": "let pipe fs = \nlet f a x = x in\nlet base = fun x y -> x y in\nList.fold_left f base fs", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x in\nlet base = fun x y -> x y in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = fun x y -> x y in\nList.fold_left f base fs"}
{"annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet ns = [] in \nmatch n with\n| 0 -> 0\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))", "fix": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((digitsOfInt (n / 10))::(n mod 10)::ns)", "annotated_fix": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet ns = [] in \nmatch n with\n| 0 -> 0::ns\n| n -> ((digitsOfInt (n / 10))::(n mod 10)::ns)", "bad": "let rec digitsOfInt n = \nlet ns = [] in \nmatch n with\n| 0 -> 0\n| n -> ((n mod 10)::(digitsOfInt (n / 10)))"}
{"annotated": "eval (Times(VarX,VarY), 1, 2)", "fix": "eval (Times (VarX,VarY), 1, 2)", "annotated_fix": "eval (Times (VarX,VarY), 1, 2)", "bad": "eval (Times(VarX,VarY), 1, 2)"}
{"annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [0, 0] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base =  [0], [0]in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated_fix": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base =  [0], [0]in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [0, 0] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (List.length a = 5)\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated_fix": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (List.length a = 5)\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (s = [])\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated_fix": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (s = [])\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = (List.length x) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = (List.length s) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated_fix": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = (List.length s) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = (List.length x) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((let g x = let d = (f x) in (d, x = d) in g),b)", "fix": "let fixpoint (f,b) = wwhile ((let g x = (f x, x = f x) in g),b)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((let g x = (f x, x = f x) in g),b)", "bad": "let fixpoint (f,b) = wwhile ((let g x = let d = (f x) in (d, x = d) in g),b)"}
{"annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = pipe a x in\nlet base = 3 in\nList.fold_left f base fs", "fix": "let pipe fs = \nlet f a x = fun x -> x  in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x -> x  in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = pipe a x in\nlet base = 3 in\nList.fold_left f base fs"}
{"annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun x -> x a in\nlet base = fun x1->x1 in\nList.fold_left f base fs", "fix": "", "annotated_fix": "", "bad": "let pipe fs = \nlet f a x = fun x -> x a in\nlet base = fun x1->x1 in\nList.fold_left f base fs"}
{"annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif( head mod 2) = 0 \nthen [] \nelse tail", "fix": "", "annotated_fix": "", "bad": "let rec digitsOfInt n = \nif( head mod 2) = 0 \nthen [] \nelse tail"}
{"annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet (b', c') = f b in\nif c' = true\nthen wwhile (f, b')\nelse b'", "fix": "", "annotated_fix": "", "bad": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' = true\nthen wwhile (f, b')\nelse b'"}
{"annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = function g -> g x a in\nlet base = function x -> x in\nList.fold_left f base fs", "fix": "let pipe fs = \nlet f a x = function g -> g in\nlet base = function x -> x in\nList.fold_left f base fs", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = function g -> g in\nlet base = function x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = function g -> g x a in\nlet base = function x -> x in\nList.fold_left f base fs"}
{"annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) = 2\nthen a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) < 2\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "annotated_fix": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) < 2\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) = 2\nthen a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}
{"annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1 * (clone 0 a))\nelse l1 * l2", "fix": "let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1,(clone 0 a))\nelse (l1,l2)", "annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1,(clone 0 a))\nelse (l1,l2)", "bad": "let padZero l1 l2 = \nlet a = List.length(l1) - List.length(l2) in\nif a > 0\nthen (l1 * (clone 0 a))\nelse l1 * l2"}
{"annotated": "let rec removeZero : int list -> int list = fun  l  ->  match l with\n|[] -> []\n|h::t -> \nif h = 0\nthen removeZero t\nelse l", "fix": "", "annotated_fix": "", "bad": "let rec removeZero l = match l with\n|[] -> []\n|h::t -> \nif h = 0\nthen removeZero t\nelse l"}
{"annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  a + x in\nlet base = (0, 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "fix": "", "annotated_fix": "", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a + x in\nlet base = (0, 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (fixpoint(f,f b),b)", "fix": "", "annotated_fix": "", "bad": "let fixpoint (f,b) =\nwwhile (fixpoint(f,f b),b)"}
{"annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> \nlet f a x = let y z = fun xn -> xn a in y in\nlet base = fun b -> b in\nList.fold_left f base fs", "fix": "let pipe fs =\nlet f a x = let y = a in x y in\nlet base = fun b -> b in\nList.fold_left f base fs", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  -> \nlet f a x = let y = a in x y in\nlet base = fun b -> b in\nList.fold_left f base fs", "bad": "let pipe fs =\nlet f a x = let y z = fun xn -> xn a in y in\nlet base = fun b -> b in\nList.fold_left f base fs"}
{"annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin(pi *. eval(a,x,y))\n| Cosine a -> cos(pi *. eval(a,x,y))\n| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "fix": "", "annotated_fix": "", "bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin(pi *. eval(a,x,y))\n| Cosine a -> cos(pi *. eval(a,x,y))\n| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)"}
{"annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif (n <= 0) \nthen []\nelse \n(n mod 10) :: digitsOfInt n :: []", "fix": "", "annotated_fix": "", "bad": "let rec digitsOfInt n = \nif (n <= 0) \nthen []\nelse \n(n mod 10) :: digitsOfInt n :: []"}
{"annotated": "let rec additivePersistence : int -> int = fun  n  ->  \nmatch (digitsOfInt n) with\n| [] -> 0\n| _ -> sumList digitsOfInt n", "fix": "let rec additivePersistence n = \nmatch (digitsOfInt n) with\n| [] -> 0\n| _ -> sumList (digitsOfInt n)", "annotated_fix": "let rec additivePersistence : int -> int = fun  n  ->  \nmatch (digitsOfInt n) with\n| [] -> 0\n| _ -> sumList (digitsOfInt n)", "bad": "let rec additivePersistence n = \nmatch (digitsOfInt n) with\n| [] -> 0\n| _ -> sumList digitsOfInt n"}
{"annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (b,b)", "fix": "let fixpoint (f,b) = b", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  b", "bad": "let fixpoint (f,b) = wwhile (b,b)"}
{"annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "fix": "let fixpoint (f,b) = \nlet h b = (b, b != f b)  in\nwwhile (h, b)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet h b = (b, b != f b)  in\nwwhile (h, b)", "bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}
{"annotated": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = h in\nif List.mem h l then h::seen' \nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "fix": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = seen in\nif List.mem h seen' then h::seen \nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated_fix": "let removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = seen in\nif List.mem h seen' then h::seen \nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "bad": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = h in\nif List.mem h l then h::seen' \nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}
{"annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \nList.append(l1, clone(0  l1G) l2 )\nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l1 in \nList.append (clone (0 l2G) l1) l2\nelse (l1, l2)", "fix": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \n(* L1 is greater, so append 0's to l2 *)\n(l1, List.append (clone 0 l1G) l2) \nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l1 in \n(List.append (clone 0 l2G) l1, l2)\nelse (l1, l2)", "annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \n(* L1 is greater, so append 0's to l2 *)\n(l1, List.append (clone 0 l1G) l2) \nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l1 in \n(List.append (clone 0 l2G) l1, l2)\nelse (l1, l2)", "bad": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \nList.append(l1, clone(0  l1G) l2 )\nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l1 in \nList.append (clone (0 l2G) l1) l2\nelse (l1, l2)"}
{"annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nn mod 10 :: if n <> [] then digitsOfInt (n / 10)", "fix": "", "annotated_fix": "", "bad": "let rec digitsOfInt n = \nn mod 10 :: if n <> [] then digitsOfInt (n / 10)"}
{"annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(expr) -> \"sin(pi*\"^exprToString(expr)^\")\"\n| Cosine(expr) -> \"cos(pi\"^ exprToString(expr)^\")\"\n| Average(expr, expr2) -> \"((\"^exprToString(expr)^\"+\"^exprToString(expr2)^\"/2)\"\n| Times(expr, expr2) -> exprToString(expr)^\"*\"^exprToString(expr2)\n| Thresh(expr, expr2, expr3, expr4) -> \"(\"^exprToString(expr)^\"<\"^exprToString(expr2)^\"?\"^exprToString(expr3)^\":\"^exprToString(expr4)\")\"", "fix": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(expr) -> \"sin(pi*\"^exprToString(expr)^\")\"\n| Cosine(expr) -> \"cos(pi\"^ exprToString(expr)^\")\"\n| Average(expr, expr2) -> \"((\"^exprToString(expr)^\"+\"^exprToString(expr2)^\"/2)\"\n| Times(expr, expr2) -> exprToString(expr)^\"*\"^exprToString(expr2)\n| Thresh(expr, expr2, expr3, expr4) -> \"(\"^exprToString(expr)^\"<\"^exprToString(expr2)^\"?\"^exprToString(expr3)^\":\"^exprToString(expr4)^\")\"", "annotated_fix": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(expr) -> \"sin(pi*\"^exprToString(expr)^\")\"\n| Cosine(expr) -> \"cos(pi\"^ exprToString(expr)^\")\"\n| Average(expr, expr2) -> \"((\"^exprToString(expr)^\"+\"^exprToString(expr2)^\"/2)\"\n| Times(expr, expr2) -> exprToString(expr)^\"*\"^exprToString(expr2)\n| Thresh(expr, expr2, expr3, expr4) -> \"(\"^exprToString(expr)^\"<\"^exprToString(expr2)^\"?\"^exprToString(expr3)^\":\"^exprToString(expr4)^\")\"", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(expr) -> \"sin(pi*\"^exprToString(expr)^\")\"\n| Cosine(expr) -> \"cos(pi\"^ exprToString(expr)^\")\"\n| Average(expr, expr2) -> \"((\"^exprToString(expr)^\"+\"^exprToString(expr2)^\"/2)\"\n| Times(expr, expr2) -> exprToString(expr)^\"*\"^exprToString(expr2)\n| Thresh(expr, expr2, expr3, expr4) -> \"(\"^exprToString(expr)^\"<\"^exprToString(expr2)^\"?\"^exprToString(expr3)^\":\"^exprToString(expr4)\")\""}
{"annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(expr) -> \"sin(pi*\"^exprToString(expr)^\")\"\n| Cosine(expr) -> \"cos(pi\"^ exprToString(expr)^\")\"\n| Average(expr, expr2) -> \"((\"^exprToString(expr)^\"+\"^exprToString(expr2)^\")/2)\"\n| Times(expr, expr2) -> exprToString(expr)^\"*\"^exprToString(expr2)\n| Thresh(expr, expr2, expr3, expr4) -> \"(\"^exprToString(expr)^\"<\"^exprToString(expr2)^\"?\"^exprToString(expr3)^\":\"^exprToString(expr4)^\")\"\n| Chunky(expr, expr2, expr3) -> \"((\"^exprToString(expr)^\"^\"^exprToString(expr2)^\")^\"^exprToString(expr3)^\")\"\n| Monkey(expr, expr2) -> \"(\"^exprToString(expr)^\"<\"^exprToString(expr2)^\"?-1.0:1.0)\"", "fix": "", "annotated_fix": "", "bad": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(expr) -> \"sin(pi*\"^exprToString(expr)^\")\"\n| Cosine(expr) -> \"cos(pi\"^ exprToString(expr)^\")\"\n| Average(expr, expr2) -> \"((\"^exprToString(expr)^\"+\"^exprToString(expr2)^\")/2)\"\n| Times(expr, expr2) -> exprToString(expr)^\"*\"^exprToString(expr2)\n| Thresh(expr, expr2, expr3, expr4) -> \"(\"^exprToString(expr)^\"<\"^exprToString(expr2)^\"?\"^exprToString(expr3)^\":\"^exprToString(expr4)^\")\"\n| Chunky(expr, expr2, expr3) -> \"((\"^exprToString(expr)^\"^\"^exprToString(expr2)^\")^\"^exprToString(expr3)^\")\"\n| Monkey(expr, expr2) -> \"(\"^exprToString(expr)^\"<\"^exprToString(expr2)^\"?-1.0:1.0)\""}
{"annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = f g in\nList.fold_left f base fs", "fix": "let pipe fs = \nlet f a x = x a in\nlet base = (+) in\nList.fold_left f base fs", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = (+) in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = x a in\nlet base = f g in\nList.fold_left f base fs"}
{"annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs", "fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "bad": "let pipe fs = \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs"}
{"annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n(tens, ones) :: a \nin\nlet base = [(0 , 0)] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (a1, a2) = a in\nlet h :: _ = a1 in\nlet tens = x1 + x2 + h / 10 in\nlet ones = x1 + x2 + h mod 10 in\n(tens :: a1, ones :: a2)\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated_fix": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet (a1, a2) = a in\nlet h :: _ = a1 in\nlet tens = x1 + x2 + h / 10 in\nlet ones = x1 + x2 + h mod 10 in\n(tens :: a1, ones :: a2)\nin\nlet base = ([], []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (x1, x2) = x in\nlet ha :: _ = a in\nlet (a1, a2) = ha in\nlet tens = x1 + x2 + a1 / 10 in\nlet ones = x1 + x2 + a1 mod 10 in\n(tens, ones) :: a \nin\nlet base = [(0 , 0)] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"annotated": "let digitalRoot : int -> int = fun  n  ->  \nlet x = sumList (digits n) in\nif x > 9\nthen digitalRoot x\nelse sumList x", "fix": "let rec digitalRoot n = \nif sumList (digits n) > 9\nthen digitalRoot (sumList (digits n))\nelse sumList (digits n)", "annotated_fix": "let rec digitalRoot : int -> int = fun  n  ->  \nif sumList (digits n) > 9\nthen digitalRoot (sumList (digits n))\nelse sumList (digits n)", "bad": "let digitalRoot n = \nlet x = sumList (digits n) in\nif x > 9\nthen digitalRoot x\nelse sumList x"}
{"annotated": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> 0\n| x :: xs' -> x + sum xs'", "fix": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x :: xs' -> x + sumList xs'", "annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> 0\n| x :: xs' -> x + sumList xs'", "bad": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x :: xs' -> x + sum xs'"}
{"annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse l' @ [x]", "fix": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse l'", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse l'", "bad": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse l' @ [x]"}
{"annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (b,b)", "fix": "let fixpoint (f,b) = wwhile ((f b),b)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((f b),b)", "bad": "let fixpoint (f,b) = wwhile (b,b)"}
{"annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>0 then\ndigitOfInt n/10 @ ( n mod 10 ::[])\nelse\n[]", "fix": "let rec digitsOfInt n = \nif n>0 then\n[2]\nelse\n[1]", "annotated_fix": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>0 then\n[2]\nelse\n[1]", "bad": "let rec digitsOfInt n = \nif n>0 then\ndigitOfInt n/10 @ ( n mod 10 ::[])\nelse\n[]"}
{"annotated": "let build: ((int * int -> int) * int) -> expr = fun Nom(e,e1,e2)\t\t    ->  Nom(e,e1,e2)", "fix": "let buildNom(e,e1,e2)\t\t   = Nom(e,e1,e2)", "annotated_fix": "let build: ((int * int -> int) * int) -> expr = fun Nom(e,e1,e2)\t\t    ->  Nom(e,e1,e2)", "bad": "let buildNom(e,e1,e2)\t\t   = Nom(e,e1,e2)"}
{"annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = List.combine (List.rev l1) (List.rev l2) in\nlet args = \nList.split base in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "fix": "", "annotated_fix": "", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = List.combine (List.rev l1) (List.rev l2) in\nlet args = \nList.split base in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> sin (pi *. (eval u))\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v", "fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)", "annotated_fix": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> pi *. eval (u,x,y) \n| Cosine u ->  cos (pi *. eval (u,x,y))\n| Average (u,v) -> ((eval (u,x,y)) +. (eval (v,x,y))) /. 2.0\n| Times (u,v) -> ((eval (u,x,y)) *. (eval (v,x,y)))\n| Thresh (s,t,u,v) -> if (eval (s,x,y)) < (eval (t,x,y)) then eval (u,x,y) else eval (v,x,y)", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine u -> sin (pi *. (eval u))\n| Cosine u ->  cos (pi *. (eval u))\n| Average (u,v) -> ((eval u) +. (eval v)) /. 2\n| Times (u,v) -> ((eval u) *. (eval v))\n| Thresh (s,t,u,v) -> if (eval s) < (eval t) then eval u else eval v"}
{"annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x =  a in\nlet base = ([], []) in\nlet args = 0 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "fix": "", "annotated_fix": "", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =  a in\nlet base = ([], []) in\nlet args = 0 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}
{"annotated": "let rec digitalRoot : int -> int = fun  n  ->  \nif n < 10 then n\nelse digitalRoot (sumList (digitalOfInt n))", "fix": "let rec digitalRoot n = \nif n < 10 then n\nelse digitalRoot (sumList (digitsOfInt n))", "annotated_fix": "let rec digitalRoot : int -> int = fun  n  ->  \nif n < 10 then n\nelse digitalRoot (sumList (digitsOfInt n))", "bad": "let rec digitalRoot n = \nif n < 10 then n\nelse digitalRoot (sumList (digitalOfInt n))"}
{"annotated": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine e-> build(pi*e)", "fix": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY", "annotated_fix": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> buildX\n| VarY -> buildY\n| Sine e-> build(pi*e)"}
{"annotated": "let rec eval (e,x,y) = match e with \n| VarX -> buildX * 1.0\n| VarY -> buildY * 1.0", "fix": "", "annotated_fix": "", "bad": "let rec eval (e,x,y) = match e with \n| VarX -> buildX * 1.0\n| VarY -> buildY * 1.0"}
{"annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  -> \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*.eval(e,x,y))\n| Cosine e-> sin(pi*.eval(e,x,y))\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)", "fix": "", "annotated_fix": "", "bad": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*.eval(e,x,y))\n| Cosine e-> sin(pi*.eval(e,x,y))\n| Average (e1,e2) -> (eval(e1,x,y)+.eval(e2,x,y))/.2.0\n| Times (e1,e2) ->eval(e1,x,y)*.eval(e2,x,y)\n| Thresh (e1, e2, e3, e4) -> if eval(e1, x, y) < eval(e2, x, y) then eval(e3, x, y) else eval(e4, x, y)"}
{"annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match build with\n| buildX()\n| buildY()", "fix": "", "annotated_fix": "", "bad": "let rec build (rand, depth) = match build with\n| buildX()\n| buildY()"}
{"annotated": "let digitsOfInt : int -> int list = fun  n  ->  \nlet rec lastDigit n accu = \nif n <= 0 then accu\nelse lastDigit (n/10) (n mod 10::accu) in\nmatch n with\n| _ -> lastDigit n []", "fix": "let digits n = digitsOfInt (abs n)", "annotated_fix": "let digits n = digitsOfInt (abs n)", "bad": "let digitsOfInt n = \nlet rec lastDigit n accu = \nif n <= 0 then accu\nelse lastDigit (n/10) (n mod 10::accu) in\nmatch n with\n| _ -> lastDigit n []"}
{"annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nif b != f b then\nwwhile(f, f b)\nelse\nb", "fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated_fix": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "bad": "let fixpoint (f,b) =\nif b != f b then\nwwhile(f, f b)\nelse\nb"}
{"annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map (sepConcat \"\" l)", "fix": "let stringOfList f l = List.map (sepConcat) (f l)", "annotated_fix": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  List.map (sepConcat) (f l)", "bad": "let stringOfList f l = List.map (sepConcat \"\" l)"}
{"annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,a::t) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, List.rev l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "fix": "", "annotated_fix": "", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (c,d::t) -> (c,a::t) in\nlet base = (0, []) in\nlet args =  match l1 with\n| h::t -> [ (h, List.rev l2 ) ] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
{"annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2)::ds -> d1+d2 in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2) -> (d1+d2, d1+d2::\nmatch a with \n| (a1,a2)->a2) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated_fix": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2) -> (d1+d2, d1+d2::\nmatch a with \n| (a1,a2)->a2) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1,d2)::ds -> d1+d2 in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}
