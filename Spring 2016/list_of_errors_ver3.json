{"fix": ["\nlet rec digitsOfInt n =\n  let x = if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse x;;\n\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"error\";;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (removeLast tl) | [] -> [];;\n\nlet rec listReverse l =\n  let x = last l in\n  let y = removeLast l in if y = [] then x :: y else x :: (listReverse y);;\n\nlet rec reversed n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec digitsOfInt n = listReverse (reversed n);;\n"], "hw": "hw1", "problem": "listReverse", "bad": ["\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> tl :: (listReverse hd);;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) :: hd;;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) :: hd;;\n", "\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd != [] then (listReverse tl) :: hd else hd;;\n", "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"NO ELEMENT\";;\n\nlet rec listReverse l = match l with | [] -> [] | hd::tl -> (last tl) :: hd;;\n", "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"NO ELEMENT\";;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | hd::tl -> let x = last l in if x > 0 then x else x;;\n", "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"NO ELEMENT\";;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | hd::tl -> let x = last l in if x > 0 then x :: x else x :: x;;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> listReverse (hd :: l) tl;;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> listReverse (hd :: l) tl;;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> [listReverse tl; hd];;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> [listReverse tl; hd];;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) :: hd;;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> join (listReverse tl) hd;;\n", "\nlet join x l = x :: l;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> join (listReverse tl) hd;;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | x::[] -> x | hd::tl -> (listReverse tl) :: hd;;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | x::[] -> x | hd::tl -> (listReverse tl) :: hd;;\n", "\nlet rec listReverse l =\n  match l with | x::[] -> x | hd::tl -> (listReverse tl) :: hd;;\n"]}
{"fix": ["\nlet count x = x + 1;;\n\nlet counter = 0;;\n\nlet rec digitalRoot n =\n  let temp = sum n in if temp >= 10 then digitalRoot temp else temp;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence n =\n  let temp = sum n in\n  let counter = count counter in\n  if temp >= 10 then digitalRoot temp else counter;;\n"], "hw": "hw1", "problem": "digitalRoot", "bad": ["\nlet rec digitalRoot n =\n  let temp = sum n in if temp > 10 then digitalRoot temp;;\n", "\nlet rec digitalRoot n = failwith \"TBD\";;\n\nlet rec sum n =\n  if n < 0 then failwith \"TBD\" else (n % 10) + ((digitalRoot n) / 10);;\n", "\nlet count x = x + 1;;\n\nlet rec digitalRoot n =\n  let temp = sum n in if temp >= 10 then digitalRoot temp else temp;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence n =\n  let temp = sum n in\n  let counter = count 0 in\n  if temp >= 10 then (digitalRoot temp) && (count counter) else counter;;\n"]}
{"fix": ["\nlet count x = x + 1;;\n\nlet counter = 0;;\n\nlet rec digitalRoot n =\n  let temp = sum n in if temp >= 10 then digitalRoot temp else temp;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence n =\n  let temp = sum n in\n  let counter = count counter in\n  if temp >= 10 then digitalRoot temp else counter;;\n"], "hw": "hw1", "problem": "additivePersistence", "bad": ["\nlet count x = x + 1;;\n\nlet rec digitalRoot n =\n  let temp = sum n in if temp >= 10 then digitalRoot temp else temp;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence n =\n  let temp = sum n in\n  let counter = count 0 in\n  if temp >= 10 then (digitalRoot temp) && (count counter) else counter;;\n"]}
{"fix": ["\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum n in\n  if temp >= 10 then additivePersistence_helper (temp, (i + 1)) else i;;\n"], "hw": "hw1", "problem": "additivePersistence", "bad": ["\nlet count x = x + 1;;\n\nlet counter = 0;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence n =\n  let temp = sum n in\n  let counter = count counter in\n  if temp >= 10 then additivePersitence temp else counter;;\n"]}
{"fix": ["\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum n in\n  if temp >= 10 then additivePersistence_helper (temp, (i + 1)) else i;;\n\nlet rec additivePersistence n = additivePersistence_helper (n, 0);;\n"], "hw": "hw1", "problem": "additivePersistence", "bad": ["\nlet rec additivePersistence n = additivePersistence (n, 0);;\n"]}
{"fix": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (1 + 1));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum (n, i) in\n  let (num,is) = temp in\n  if num >= 10 then additivePersistence_helper (num, (is + 1)) else is;;\n"], "hw": "hw1", "problem": "additivePersistence", "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (1 + 1));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum (n, i) in\n  if temp >= 10 then additivePersistence_helper (temp, (i + 1)) else i;;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (1 + 1));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum (n, i) in\n  if temp >= (10, 0) then additivePersistence_helper (temp, (i + 1)) else i;;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (1 + 1));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum (n, i) in\n  if (List.hd temp) >= 10\n  then additivePersistence_helper (temp, (i + 1))\n  else i;;\n"]}
{"fix": ["\nlet rec digitsOfInt n =\n  let x = if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse x;;\n\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"error\";;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (removeLast tl) | [] -> [];;\n\nlet rec listReverse l =\n  let x = last l in\n  let y = removeLast l in if y = [] then x :: y else x :: (listReverse y);;\n\nlet rec reversed n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec digitsOfInt n = listReverse (reversed n);;\n"], "hw": "hw1", "problem": "digitsOfInt", "bad": ["\nlet rec digitsOfInt n = match n with | _ -> (n % (10 digitsOfInt n)) / 10;;\n", "\nlet rec digitsOfInt n = match n with | _ -> (n mod (10 digitsOfInt n)) / 10;;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then sumList (digitsOfInt n) i\n  else (sumList (digitsOfInt n) 1) + 1;;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n::i::[]) =\n  if (n < 10) || []\n  then [sumList (digitsOfInt n); i]\n  else [sumList (digitsOfInt n); 1 + 1];;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ =\n  let rec digitalRoot n = temp = (sumList (digitsOfInt n)) in\n  if temp >= 10 then digitalRoot temp else temp;;\n", "\nlet rec digitsOfInt n =\n  let x = if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  reverseList x;;\n", "\nlet rec digitsOfInt n =\n  let x = if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  reverseList x;;\n"]}
{"fix": ["\nlet rec digitsOfInt_helper n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt_helper (n / 10));;\n"], "hw": "hw1", "problem": "digitsOfInt", "bad": ["\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"error\";;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (removeLast tl) | [] -> [];;\n\nlet rec listReverse l =\n  let x = last l in\n  let y = removeLast l in if y = [] then x :: y else x :: (listReverse y);;\n\nlet rec reversed n = if n <= 0 then [] else (n mod 10) :: (reversed (n / 10));;\n\nlet rec digitsOfInt n = listReverse reversed n;;\n"]}
{"fix": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"], "hw": "hw2", "problem": "build", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (x1, x2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (x1, x2) in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"]}
{"fix": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n"], "hw": "hw2", "problem": "build", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num (a,b) = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num (a,b) = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let nums (a,b) = rand in\n    let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let nums (a,b) = rand in\n     let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> BuildSine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n"]}
{"fix": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n"], "hw": "hw2", "problem": "build", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 ->\n         buildAverage\n           ((build (rand, (depth - 1))),\n             (buildAverage (build (rand, (depth - 1)))))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n"]}
{"fix": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"], "hw": "hw2", "problem": "eval", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | Sine m -> sin (pi *. (eval m));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | Sine m -> sin (pi *. (eval m)) | _ -> x;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) / 2.;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) / 2.;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) / 2.;;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"]}
{"fix": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"], "hw": "hw2", "problem": "eval", "bad": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let nums (a,b) = rand in\n    let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let nums (a,b) = rand in\n     let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"]}
{"fix": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 -> buildSquare (build (rand, (depth - 1)))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"], "hw": "hw2", "problem": "eval", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n"]}
{"fix": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | MyExpr (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then sqrt (abs_float (eval (o, x, y)))\n      else (eval (p, x, y)) /. 2.\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMyExpr (a,b,a_less,b_less) = MyExpr (a, b, a_less, b_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 6) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildMyExpr\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString p) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"], "hw": "hw2", "problem": "eval", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | MyExpr (m,n,o) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then sqrt (abs_float (eval (o, x, y)))\n      else (eval (o, x, y)) /. 2\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n"]}
{"fix": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"], "hw": "hw2", "problem": "exprToString", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> \"x\" | VarY  -> \"y\" | Sine m -> \"sin\" ^ exprToString;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin\" ^ (exprToString m);;\n\nlet b = exprToString Sine VarX;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | (Average m,n) ->\n      \"((\" ^ ((exprToStirng m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToStirng m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Tresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ (exprToString p)))))));;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"]}
{"fix": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"], "hw": "hw2", "problem": "exprToString", "bad": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let nums (a,b) = rand in\n    let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let nums (a,b) = rand in\n     let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"]}
{"fix": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | MyExpr (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then sqrt (abs_float (eval (o, x, y)))\n      else (eval (p, x, y)) /. 2.\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMyExpr (a,b,a_less,b_less) = MyExpr (a, b, a_less, b_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 6) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildMyExpr\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString p) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"], "hw": "hw2", "problem": "exprToString", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              (expToString ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString o) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              (exprToString ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString o) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n"]}
{"fix": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin\" ^ (exprToString m);;\n"], "hw": "hw2", "problem": "expr", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> \"x\" | VarY  -> \"y\" | Sine m -> \"sin\" ^ exprToString;;\n"]}
{"fix": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin\" ^ (exprToString m);;\n\nlet b = exprToString (Sine VarX);;\n"], "hw": "hw2", "problem": "expr", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin\" ^ (exprToString m);;\n\nlet b = exprToString Sine VarX;;\n"]}
{"fix": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")));;\n"], "hw": "hw2", "problem": "expr", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | (Average m,n) ->\n      \"((\" ^ ((exprToStirng m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToStirng m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")));;\n"]}
{"fix": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ (exprToString p)))))));;\n"], "hw": "hw2", "problem": "expr", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Tresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ (exprToString p)))))));;\n"]}
{"fix": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"], "hw": "hw2", "problem": "expr", "bad": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"]}
{"fix": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"], "hw": "hw2", "problem": "expr", "bad": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let nums (a,b) = rand in\n    let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let nums (a,b) = rand in\n     let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"]}
{"fix": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString o) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n"], "hw": "hw2", "problem": "expr", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              (expToString ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString o) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              (exprToString ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString o) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n"]}
{"fix": ["\nlet rec digitsOfInt n =\n  let x = if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse x;;\n\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"error\";;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (removeLast tl) | [] -> [];;\n\nlet rec listReverse l =\n  let x = last l in\n  let y = removeLast l in if y = [] then x :: y else x :: (listReverse y);;\n\nlet rec reversed n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec digitsOfInt n = listReverse (reversed n);;\n"], "hw": "hw1", "bad": ["\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> tl :: (listReverse hd);;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) :: hd;;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) :: hd;;\n", "\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd != [] then (listReverse tl) :: hd else hd;;\n", "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"NO ELEMENT\";;\n\nlet rec listReverse l = match l with | [] -> [] | hd::tl -> (last tl) :: hd;;\n", "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"NO ELEMENT\";;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | hd::tl -> let x = last l in if x > 0 then x else x;;\n", "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"NO ELEMENT\";;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | hd::tl -> let x = last l in if x > 0 then x :: x else x :: x;;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> listReverse (hd :: l) tl;;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> listReverse (hd :: l) tl;;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> [listReverse tl; hd];;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> [listReverse tl; hd];;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) :: hd;;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> join (listReverse tl) hd;;\n", "\nlet join x l = x :: l;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> join (listReverse tl) hd;;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | x::[] -> x | hd::tl -> (listReverse tl) :: hd;;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | x::[] -> x | hd::tl -> (listReverse tl) :: hd;;\n", "\nlet rec listReverse l =\n  match l with | x::[] -> x | hd::tl -> (listReverse tl) :: hd;;\n"], "problem": "listReverse"}
{"fix": ["\nlet count x = x + 1;;\n\nlet counter = 0;;\n\nlet rec digitalRoot n =\n  let temp = sum n in if temp >= 10 then digitalRoot temp else temp;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence n =\n  let temp = sum n in\n  let counter = count counter in\n  if temp >= 10 then digitalRoot temp else counter;;\n"], "hw": "hw1", "bad": ["\nlet rec digitalRoot n =\n  let temp = sum n in if temp > 10 then digitalRoot temp;;\n", "\nlet rec digitalRoot n = failwith \"TBD\";;\n\nlet rec sum n =\n  if n < 0 then failwith \"TBD\" else (n % 10) + ((digitalRoot n) / 10);;\n", "\nlet count x = x + 1;;\n\nlet rec digitalRoot n =\n  let temp = sum n in if temp >= 10 then digitalRoot temp else temp;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence n =\n  let temp = sum n in\n  let counter = count 0 in\n  if temp >= 10 then (digitalRoot temp) && (count counter) else counter;;\n"], "problem": "digitalRoot"}
{"fix": ["\nlet count x = x + 1;;\n\nlet counter = 0;;\n\nlet rec digitalRoot n =\n  let temp = sum n in if temp >= 10 then digitalRoot temp else temp;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence n =\n  let temp = sum n in\n  let counter = count counter in\n  if temp >= 10 then digitalRoot temp else counter;;\n"], "hw": "hw1", "bad": ["\nlet count x = x + 1;;\n\nlet rec digitalRoot n =\n  let temp = sum n in if temp >= 10 then digitalRoot temp else temp;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence n =\n  let temp = sum n in\n  let counter = count 0 in\n  if temp >= 10 then (digitalRoot temp) && (count counter) else counter;;\n"], "problem": "additivePersistence"}
{"fix": ["\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum n in\n  if temp >= 10 then additivePersistence_helper (temp, (i + 1)) else i;;\n"], "hw": "hw1", "bad": ["\nlet count x = x + 1;;\n\nlet counter = 0;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence n =\n  let temp = sum n in\n  let counter = count counter in\n  if temp >= 10 then additivePersitence temp else counter;;\n"], "problem": "additivePersistence"}
{"fix": ["\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum n in\n  if temp >= 10 then additivePersistence_helper (temp, (i + 1)) else i;;\n\nlet rec additivePersistence n = additivePersistence_helper (n, 0);;\n"], "hw": "hw1", "bad": ["\nlet rec additivePersistence n = additivePersistence (n, 0);;\n"], "problem": "additivePersistence"}
{"fix": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (1 + 1));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum (n, i) in\n  let (num,is) = temp in\n  if num >= 10 then additivePersistence_helper (num, (is + 1)) else is;;\n"], "hw": "hw1", "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (1 + 1));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum (n, i) in\n  if temp >= 10 then additivePersistence_helper (temp, (i + 1)) else i;;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (1 + 1));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum (n, i) in\n  if temp >= (10, 0) then additivePersistence_helper (temp, (i + 1)) else i;;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (1 + 1));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum (n, i) in\n  if (List.hd temp) >= 10\n  then additivePersistence_helper (temp, (i + 1))\n  else i;;\n"], "problem": "additivePersistence"}
{"fix": ["\nlet rec digitsOfInt n =\n  let x = if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse x;;\n\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"error\";;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (removeLast tl) | [] -> [];;\n\nlet rec listReverse l =\n  let x = last l in\n  let y = removeLast l in if y = [] then x :: y else x :: (listReverse y);;\n\nlet rec reversed n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec digitsOfInt n = listReverse (reversed n);;\n"], "hw": "hw1", "bad": ["\nlet rec digitsOfInt n = match n with | _ -> (n % (10 digitsOfInt n)) / 10;;\n", "\nlet rec digitsOfInt n = match n with | _ -> (n mod (10 digitsOfInt n)) / 10;;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then sumList (digitsOfInt n) i\n  else (sumList (digitsOfInt n) 1) + 1;;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n::i::[]) =\n  if (n < 10) || []\n  then [sumList (digitsOfInt n); i]\n  else [sumList (digitsOfInt n); 1 + 1];;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ =\n  let rec digitalRoot n = temp = (sumList (digitsOfInt n)) in\n  if temp >= 10 then digitalRoot temp else temp;;\n", "\nlet rec digitsOfInt n =\n  let x = if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  reverseList x;;\n", "\nlet rec digitsOfInt n =\n  let x = if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  reverseList x;;\n"], "problem": "digitsOfInt"}
{"fix": ["\nlet rec digitsOfInt_helper n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt_helper (n / 10));;\n"], "hw": "hw1", "bad": ["\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"error\";;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (removeLast tl) | [] -> [];;\n\nlet rec listReverse l =\n  let x = last l in\n  let y = removeLast l in if y = [] then x :: y else x :: (listReverse y);;\n\nlet rec reversed n = if n <= 0 then [] else (n mod 10) :: (reversed (n / 10));;\n\nlet rec digitsOfInt n = listReverse reversed n;;\n"], "problem": "digitsOfInt"}
{"fix": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"], "hw": "hw2", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (x1, x2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (x1, x2) in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"], "problem": "build"}
{"fix": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n"], "hw": "hw2", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num (a,b) = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num (a,b) = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let nums (a,b) = rand in\n    let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let nums (a,b) = rand in\n     let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> BuildSine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n"], "problem": "build"}
{"fix": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n"], "hw": "hw2", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 ->\n         buildAverage\n           ((build (rand, (depth - 1))),\n             (buildAverage (build (rand, (depth - 1)))))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n"], "problem": "build"}
{"fix": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"], "hw": "hw2", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | Sine m -> sin (pi *. (eval m));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | Sine m -> sin (pi *. (eval m)) | _ -> x;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) / 2.;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) / 2.;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) / 2.;;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"], "problem": "eval"}
{"fix": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"], "hw": "hw2", "bad": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let nums (a,b) = rand in\n    let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let nums (a,b) = rand in\n     let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"], "problem": "eval"}
{"fix": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 -> buildSquare (build (rand, (depth - 1)))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"], "hw": "hw2", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n"], "problem": "eval"}
{"fix": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | MyExpr (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then sqrt (abs_float (eval (o, x, y)))\n      else (eval (p, x, y)) /. 2.\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMyExpr (a,b,a_less,b_less) = MyExpr (a, b, a_less, b_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 6) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildMyExpr\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString p) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"], "hw": "hw2", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | MyExpr (m,n,o) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then sqrt (abs_float (eval (o, x, y)))\n      else (eval (o, x, y)) /. 2\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n"], "problem": "eval"}
{"fix": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"], "hw": "hw2", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> \"x\" | VarY  -> \"y\" | Sine m -> \"sin\" ^ exprToString;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin\" ^ (exprToString m);;\n\nlet b = exprToString Sine VarX;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | (Average m,n) ->\n      \"((\" ^ ((exprToStirng m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToStirng m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Tresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ (exprToString p)))))));;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"], "problem": "exprToString"}
{"fix": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"], "hw": "hw2", "bad": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let nums (a,b) = rand in\n    let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let nums (a,b) = rand in\n     let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"], "problem": "exprToString"}
{"fix": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | MyExpr (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then sqrt (abs_float (eval (o, x, y)))\n      else (eval (p, x, y)) /. 2.\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMyExpr (a,b,a_less,b_less) = MyExpr (a, b, a_less, b_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 6) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildMyExpr\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString p) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"], "hw": "hw2", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              (expToString ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString o) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              (exprToString ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString o) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n"], "problem": "exprToString"}
{"fix": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin\" ^ (exprToString m);;\n"], "hw": "hw2", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> \"x\" | VarY  -> \"y\" | Sine m -> \"sin\" ^ exprToString;;\n"], "problem": "expr"}
{"fix": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin\" ^ (exprToString m);;\n\nlet b = exprToString (Sine VarX);;\n"], "hw": "hw2", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin\" ^ (exprToString m);;\n\nlet b = exprToString Sine VarX;;\n"], "problem": "expr"}
{"fix": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")));;\n"], "hw": "hw2", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | (Average m,n) ->\n      \"((\" ^ ((exprToStirng m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToStirng m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")));;\n"], "problem": "expr"}
{"fix": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ (exprToString p)))))));;\n"], "hw": "hw2", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Tresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ (exprToString p)))))));;\n"], "problem": "expr"}
{"fix": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"], "hw": "hw2", "bad": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"], "problem": "expr"}
{"fix": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"], "hw": "hw2", "bad": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let nums (a,b) = rand in\n    let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let nums (a,b) = rand in\n     let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"{"problem": "listReverse", "bad": ["\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> tl :: (listReverse hd);;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) :: hd;;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) :: hd;;\n", "\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd != [] then (listReverse tl) :: hd else hd;;\n", "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"NO ELEMENT\";;\n\nlet rec listReverse l = match l with | [] -> [] | hd::tl -> (last tl) :: hd;;\n", "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"NO ELEMENT\";;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | hd::tl -> let x = last l in if x > 0 then x else x;;\n", "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"NO ELEMENT\";;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | hd::tl -> let x = last l in if x > 0 then x :: x else x :: x;;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> listReverse (hd :: l) tl;;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> listReverse (hd :: l) tl;;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> [listReverse tl; hd];;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> [listReverse tl; hd];;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) :: hd;;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> join (listReverse tl) hd;;\n", "\nlet join x l = x :: l;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> join (listReverse tl) hd;;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | x::[] -> x | hd::tl -> (listReverse tl) :: hd;;\n", "\nlet rec listReverse l =\n  match l with | [] -> [] | x::[] -> x | hd::tl -> (listReverse tl) :: hd;;\n", "\nlet rec listReverse l =\n  match l with | x::[] -> x | hd::tl -> (listReverse tl) :: hd;;\n"], "hw": "hw1", "fix": ["\nlet rec digitsOfInt n =\n  let x = if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse x;;\n\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"error\";;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (removeLast tl) | [] -> [];;\n\nlet rec listReverse l =\n  let x = last l in\n  let y = removeLast l in if y = [] then x :: y else x :: (listReverse y);;\n\nlet rec reversed n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec digitsOfInt n = listReverse (reversed n);;\n"]}
{"problem": "digitalRoot", "bad": ["\nlet rec digitalRoot n =\n  let temp = sum n in if temp > 10 then digitalRoot temp;;\n", "\nlet rec digitalRoot n = failwith \"TBD\";;\n\nlet rec sum n =\n  if n < 0 then failwith \"TBD\" else (n % 10) + ((digitalRoot n) / 10);;\n", "\nlet count x = x + 1;;\n\nlet rec digitalRoot n =\n  let temp = sum n in if temp >= 10 then digitalRoot temp else temp;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence n =\n  let temp = sum n in\n  let counter = count 0 in\n  if temp >= 10 then (digitalRoot temp) && (count counter) else counter;;\n"], "hw": "hw1", "fix": ["\nlet count x = x + 1;;\n\nlet counter = 0;;\n\nlet rec digitalRoot n =\n  let temp = sum n in if temp >= 10 then digitalRoot temp else temp;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence n =\n  let temp = sum n in\n  let counter = count counter in\n  if temp >= 10 then digitalRoot temp else counter;;\n"]}
{"problem": "additivePersistence", "bad": ["\nlet count x = x + 1;;\n\nlet rec digitalRoot n =\n  let temp = sum n in if temp >= 10 then digitalRoot temp else temp;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence n =\n  let temp = sum n in\n  let counter = count 0 in\n  if temp >= 10 then (digitalRoot temp) && (count counter) else counter;;\n"], "hw": "hw1", "fix": ["\nlet count x = x + 1;;\n\nlet counter = 0;;\n\nlet rec digitalRoot n =\n  let temp = sum n in if temp >= 10 then digitalRoot temp else temp;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence n =\n  let temp = sum n in\n  let counter = count counter in\n  if temp >= 10 then digitalRoot temp else counter;;\n"]}
{"problem": "additivePersistence", "bad": ["\nlet count x = x + 1;;\n\nlet counter = 0;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence n =\n  let temp = sum n in\n  let counter = count counter in\n  if temp >= 10 then additivePersitence temp else counter;;\n"], "hw": "hw1", "fix": ["\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum n in\n  if temp >= 10 then additivePersistence_helper (temp, (i + 1)) else i;;\n"]}
{"problem": "additivePersistence", "bad": ["\nlet rec additivePersistence n = additivePersistence (n, 0);;\n"], "hw": "hw1", "fix": ["\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum n in\n  if temp >= 10 then additivePersistence_helper (temp, (i + 1)) else i;;\n\nlet rec additivePersistence n = additivePersistence_helper (n, 0);;\n"]}
{"problem": "additivePersistence", "bad": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (1 + 1));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum (n, i) in\n  if temp >= 10 then additivePersistence_helper (temp, (i + 1)) else i;;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (1 + 1));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum (n, i) in\n  if temp >= (10, 0) then additivePersistence_helper (temp, (i + 1)) else i;;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (1 + 1));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum (n, i) in\n  if (List.hd temp) >= 10\n  then additivePersistence_helper (temp, (i + 1))\n  else i;;\n"], "hw": "hw1", "fix": ["\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (1 + 1));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum (n, i) in\n  let (num,is) = temp in\n  if num >= 10 then additivePersistence_helper (num, (is + 1)) else is;;\n"]}
{"problem": "digitsOfInt", "bad": ["\nlet rec digitsOfInt n = match n with | _ -> (n % (10 digitsOfInt n)) / 10;;\n", "\nlet rec digitsOfInt n = match n with | _ -> (n mod (10 digitsOfInt n)) / 10;;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then sumList (digitsOfInt n) i\n  else (sumList (digitsOfInt n) 1) + 1;;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n::i::[]) =\n  if (n < 10) || []\n  then [sumList (digitsOfInt n); i]\n  else [sumList (digitsOfInt n); 1 + 1];;\n", "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ =\n  let rec digitalRoot n = temp = (sumList (digitsOfInt n)) in\n  if temp >= 10 then digitalRoot temp else temp;;\n", "\nlet rec digitsOfInt n =\n  let x = if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  reverseList x;;\n", "\nlet rec digitsOfInt n =\n  let x = if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  reverseList x;;\n"], "hw": "hw1", "fix": ["\nlet rec digitsOfInt n =\n  let x = if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse x;;\n\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"error\";;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (removeLast tl) | [] -> [];;\n\nlet rec listReverse l =\n  let x = last l in\n  let y = removeLast l in if y = [] then x :: y else x :: (listReverse y);;\n\nlet rec reversed n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec digitsOfInt n = listReverse (reversed n);;\n"]}
{"problem": "digitsOfInt", "bad": ["\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"error\";;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (removeLast tl) | [] -> [];;\n\nlet rec listReverse l =\n  let x = last l in\n  let y = removeLast l in if y = [] then x :: y else x :: (listReverse y);;\n\nlet rec reversed n = if n <= 0 then [] else (n mod 10) :: (reversed (n / 10));;\n\nlet rec digitsOfInt n = listReverse reversed n;;\n"], "hw": "hw1", "fix": ["\nlet rec digitsOfInt_helper n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt_helper (n / 10));;\n"]}
{"problem": "build", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (x1, x2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (x1, x2) in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"], "hw": "hw2", "fix": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"]}
{"problem": "build", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num (a,b) = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num (a,b) = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let nums (a,b) = rand in\n    let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let nums (a,b) = rand in\n     let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> BuildSine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n"], "hw": "hw2", "fix": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n"]}
{"problem": "build", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 ->\n         buildAverage\n           ((build (rand, (depth - 1))),\n             (buildAverage (build (rand, (depth - 1)))))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n"], "hw": "hw2", "fix": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n"]}
{"problem": "eval", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | Sine m -> sin (pi *. (eval m));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with | VarX  -> x | Sine m -> sin (pi *. (eval m)) | _ -> x;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) / 2.;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) / 2.;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) / 2.;;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"], "hw": "hw2", "fix": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"]}
{"problem": "eval", "bad": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let nums (a,b) = rand in\n    let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let nums (a,b) = rand in\n     let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"], "hw": "hw2", "fix": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"]}
{"problem": "eval", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n"], "hw": "hw2", "fix": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 -> buildSquare (build (rand, (depth - 1)))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"]}
{"problem": "eval", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | MyExpr (m,n,o) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then sqrt (abs_float (eval (o, x, y)))\n      else (eval (o, x, y)) /. 2\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n"], "hw": "hw2", "fix": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | MyExpr (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then sqrt (abs_float (eval (o, x, y)))\n      else (eval (p, x, y)) /. 2.\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMyExpr (a,b,a_less,b_less) = MyExpr (a, b, a_less, b_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 6) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildMyExpr\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString p) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"]}
{"problem": "exprToString", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> \"x\" | VarY  -> \"y\" | Sine m -> \"sin\" ^ exprToString;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin\" ^ (exprToString m);;\n\nlet b = exprToString Sine VarX;;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | (Average m,n) ->\n      \"((\" ^ ((exprToStirng m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToStirng m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Tresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ (exprToString p)))))));;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"], "hw": "hw2", "fix": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"]}
{"problem": "exprToString", "bad": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let nums (a,b) = rand in\n    let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let nums (a,b) = rand in\n     let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"], "hw": "hw2", "fix": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"]}
{"problem": "exprToString", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              (expToString ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString o) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              (exprToString ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString o) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n"], "hw": "hw2", "fix": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Square m -> (eval (m, x, y)) ** 2.0\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | MyExpr (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then sqrt (abs_float (eval (o, x, y)))\n      else (eval (p, x, y)) /. 2.\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Square of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | MyExpr of expr* expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMyExpr (a,b,a_less,b_less) = MyExpr (a, b, a_less, b_less);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare e = Square e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 6) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildMyExpr\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildSquare (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Square m -> \"(\" ^ ((exprToString m) ^ \"^2)\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | MyExpr (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?sqrt(|\" ^\n                    ((exprToString o) ^\n                       (\"|)\" ^ (\":\" ^ (\"(\" ^ ((exprToString p) ^ \"/2)\")))))))))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"]}
{"problem": "expr", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> \"x\" | VarY  -> \"y\" | Sine m -> \"sin\" ^ exprToString;;\n"], "hw": "hw2", "fix": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin\" ^ (exprToString m);;\n"]}
{"problem": "expr", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin\" ^ (exprToString m);;\n\nlet b = exprToString Sine VarX;;\n"], "hw": "hw2", "fix": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin\" ^ (exprToString m);;\n\nlet b = exprToString (Sine VarX);;\n"]}
{"problem": "expr", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | (Average m,n) ->\n      \"((\" ^ ((exprToStirng m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")));;\n", "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToStirng m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")));;\n"], "hw": "hw2", "fix": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")));;\n"]}
{"problem": "expr", "bad": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Tresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ (exprToString p)))))));;\n"], "hw": "hw2", "fix": ["\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ (exprToString p)))))));;\n"]}
{"problem": "expr", "bad": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand 0 2 in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand 0 5 in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"], "hw": "hw2", "fix": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"]}
{"problem": "expr", "bad": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let nums (a,b) = rand in\n    let num = rand in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let nums (a,b) = rand in\n     let num = rand in\n     match num with\n     | 0 -> Sine (build (rand, (depth - 1)))\n     | _ -> Cosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"], "hw": "hw2", "fix": ["\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let num = rand (0, 2) in match num with | 0 -> VarX | _ -> VarY\n  else\n    (let num = rand (0, 5) in\n     match num with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine m -> \"sin(pi*\" ^ ((exprToString m) ^ \")\")\n  | Cosine m -> \"cos(pi*\" ^ ((exprToString m) ^ \")\")\n  | Average (m,n) ->\n      \"((\" ^ ((exprToString m) ^ (\"+\" ^ ((exprToString n) ^ \")/2)\")))\n  | Times (m,n) -> (exprToString m) ^ (\"*\" ^ (exprToString n))\n  | Thresh (m,n,o,p) ->\n      \"(\" ^\n        ((exprToString m) ^\n           (\"<\" ^\n              ((exprToString n) ^\n                 (\"?\" ^ ((exprToString o) ^ (\":\" ^ ((exprToString p) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n"