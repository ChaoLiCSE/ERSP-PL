{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (fun j y->y) in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 77-78:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs = let f a x = a x in let base j y = y in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base = (fun j y->y) in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (fun j y->y) in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (fun y->y) in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (fun y->y) in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (fun y->y) in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = 3 in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (fun y->y) in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (fun y->y) in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (fun y->y) in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 45-46:\n  let base = y in \n             ^\nError: Unbound value y\n", "min": "\nlet pipe fs = let f a x = x a in let base = y in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base = y in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (fun z->z) in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (fun z->z) in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun z->z in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x  in\nlet base = fun z->z in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = a in\nlet base = fun z->z in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = fun z->z in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun z->z in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (fun a->a) in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (fun x->x) in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 46-47:\n  let base =  a in \n              ^\nError: Unbound value a\n", "min": "\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  a in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 46-47:\n  let base =  x in \n              ^\nError: Unbound value x\n", "min": "\nlet pipe fs = let f a x = x a in let base = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  x in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 75-77:\n  List.fold_left f base fs;;\n                        ^^\nError: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n", "min": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  fs in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  (fun y->y) in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  (fun y->y) in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  id in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base =   id in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base =   id in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  (fun x->x) in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 76-77:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base =  (fun x->x) in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 76-77:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base =  (fun x->x) in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  (fun x _->x) in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  (fun x y->x) in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  (fun x ->x) in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 77-78:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base =  (fun x ->x) in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x in\nlet base =  (fun x ->x) in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x  a in\nlet base =  (fun x ->x) in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = fun j->x a in\nlet base =  (fun x ->x) in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 90-91:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> 'c -> 'd -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'd -> 'a\n", "min": "\nlet pipe fs = let f a x j x = a in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fun j->fun x-> a in\nlet base =  (fun x ->x) in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = fun j->fun y-> x a in\nlet base =  (fun x ->x) in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = fun j->fun a-> x  in\nlet base =  (fun x ->x) in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = fun j->a x  in\nlet base =  (fun x ->x) in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = fun j->a x  in\nlet base =  (fun x ->x) in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = fun j-> (a x)  in\nlet base =  (fun x ->x) in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = fun j-> (x (a j))  in\nlet base =  (fun x ->x) in \nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 154-155:\n  List.fold_left f base l;;\n                        ^\nError: This expression has type string but an expression was expected of type\n         string list\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = sepConcat sep t in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = sepConcat sep t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 23-26:\n  let stringOfList f l = map f l;;\n                         ^^^\nError: Unbound value map\nHint: Did you mean max?\n", "min": "\nlet stringOfList f l = map f l;;\n", "in": "let stringOfList f l = map f l"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 23-26:\n  let stringOfList f l = map f l;;\n                         ^^^\nError: Unbound value map\nHint: Did you mean max?\n", "min": "\nlet stringOfList f l = map f l;;\n", "in": "let stringOfList f l = map f l"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 23-26:\n  let stringOfList f l = map f l;;\n                         ^^^\nError: Unbound value map\nHint: Did you mean max?\n", "min": "\nlet stringOfList f l = map f l;;\n", "in": "let stringOfList f l = map f l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = List.map f l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 28-37:\n  let stringOfList f l =\"[\"^ (sepConcat \"; \" sepList.map f l) ^\"]\";;\n                              ^^^^^^^^^\nError: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" sepList.map f l) ^ \"]\");;\n", "in": "let stringOfList f l =\"[\"^ (sepConcat \"; \" sepList.map f l) ^\"]\""}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 44-51:\n  let stringOfList f l =\"[\"^ (sepConcat \"; \" (sepList.map f l) )^\"]\";;\n                                              ^^^^^^^\nError: Unbound value sepList\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (sepList.map f l)) ^ \"]\");;\n", "in": "let stringOfList f l =\"[\"^ (sepConcat \"; \" (sepList.map f l) )^\"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l =\"[\"^ (sepConcat \"; \" (List.map f l) )^\"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l =\"[\"^ (sepConcat \"; \" (List.map f l) )^\"]\""}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 71-77:\n  |_->helper (sub::xs) sub (depth-1)\n      ^^^^^^\nError: Unbound value helper\n", "min": "\nlet rec clone x n =\n  let helper xs sub depth =\n    match depth with | 0 -> xs | _ -> helper (sub :: xs) sub (depth - 1) in\n  helper [] x n;;\n", "in": "let rec clone x n = let helper xs sub depth=match depth with\n0->xs\n|_->helper (sub::xs) sub (depth-1)\nin helper [] x n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = let rec  helper xs sub depth=match depth with\n0->xs\n|_->helper (sub::xs) sub (depth-1)\nin helper [] x n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = let rec  helper xs sub depth=match depth with\n0->xs\n|_->helper (sub::xs) sub (depth-1)\nin helper [] x n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec padZero l1 l2 = failwith \"to be implemented\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec padZero l1 l2 = let sizeDif= (List.length l1)-(List.length l2) in\nlet appendS=(clone ( abs  sizeDif ) 0) in\nif sizeDif<0 then ( appendS@l1,l2)\nelse (l1,appendS@l2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec padZero l1 l2 = let sizeDif= (List.length l1)-(List.length l2) in\nlet appendS=(clone 0 ( abs  sizeDif )) in\nif sizeDif<0 then ( appendS@l1,l2)\nelse (l1,appendS@l2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec removeZero l = match l with \n[]->[]\n|h::t-> if h=0 then\nremoveZero t\nelse\nl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 123-124:\n  let car,res=(res/10),(res%10) in\n                           ^\nError: Unbound value %\n", "min": "\nlet rec clone x n =\n  let rec helper xs sub depth =\n    match depth > 0 with\n    | false  -> xs\n    | true  -> helper (sub :: xs) sub (depth - 1) in\n  helper [] x n;;\n\nlet rec padZero l1 l2 =\n  let sizeDif = (List.length l1) - (List.length l2) in\n  let appendS = clone 0 (abs sizeDif) in\n  if sizeDif < 0 then ((appendS @ l1), l2) else (l1, (appendS @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (op1,op2) ->\n          let res = op1 + op2 in\n          let (car,res) = ((res / 10), (res % 10)) in\n          let (c1,c2) = a in\n          (match c1 with\n           | [] -> ([car], (res :: c2))\n           | y::s -> ((car :: s), ((res + y) :: c2))) in\n    let base = ([], []) in\n    let args = List.combine List.rev l1 List.rev l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in \nlet car,res=(res/10),(res%10) in\nlet c1,c2=a in\nmatch c1 with\n[]->([car],res::c2)\n|y::s->(car::s,(res+y)::c2) in\nlet base = ([],[]) in\nlet args = List.combine List.rev l1 List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 248-260:\n  let args = List.combine List.rev l1 List.rev l2 in\n             ^^^^^^^^^^^^\nError: This function has type 'a list -> 'b list -> ('a * 'b) list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec clone x n =\n  let rec helper xs sub depth =\n    match depth > 0 with\n    | false  -> xs\n    | true  -> helper (sub :: xs) sub (depth - 1) in\n  helper [] x n;;\n\nlet rec padZero l1 l2 =\n  let sizeDif = (List.length l1) - (List.length l2) in\n  let appendS = clone 0 (abs sizeDif) in\n  if sizeDif < 0 then ((appendS @ l1), l2) else (l1, (appendS @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (op1,op2) ->\n          let res = op1 + op2 in\n          let (car,res) = ((res / 10), (res mod 10)) in\n          let (c1,c2) = a in\n          (match c1 with\n           | [] -> ([car], (res :: c2))\n           | y::s -> ((car :: s), ((res + y) :: c2))) in\n    let base = ([], []) in\n    let args = List.combine List.rev l1 List.rev l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in \nlet car,res=(res/10),(res mod 10) in\nlet c1,c2=a in\nmatch c1 with\n[]->([car],res::c2)\n|y::s->(car::s,(res+y)::c2) in\nlet base = ([],[]) in\nlet args = List.combine List.rev l1 List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in \nlet car,res=(res/10),(res mod 10) in\nlet c1,c2=a in\nmatch c1 with\n[]->([car],res::c2)\n|y::s->(car::s,(res+y)::c2) in\nlet base = ([],[]) in\nlet args = List.combine (List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in \nlet car,re=(res/10),(res mod 10) in\nlet c1,c2=a in\nmatch c1 with\n[]->([car],re::c2)\n|y::s->(car::s,(re+y)::c2) in\nlet base = ([],[]) in\nlet args = List.combine (List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in \nlet car,re=(res/10),(res mod 10) in\nlet c1,c2=a in\nmatch c1 with\n[]->([car],re::c2)\n|y::s->((car::s),((re+y)mod 10)::c2) in\nlet base = ([],[]) in\nlet args = List.combine (List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in \nlet car,re=(res/10),(res mod 10) in\nlet c1,c2=a in\nmatch c1 with\n[]->([car],re::c2)\n|y::s->let sub=re+y in( ((sub /10) +car)::s),\n((sub mod 10)::c2) in\nlet base = ([],[]) in\nlet args = List.combine (List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 325-326:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type 'a * int list -> int * int -> int list\n       but an expression was expected of type\n         'a * int list -> int * int -> 'a * int list\n       Type int list is not compatible with type 'a * int list \n", "min": "\nlet rec clone x n =\n  let rec helper xs sub depth =\n    match depth > 0 with\n    | false  -> xs\n    | true  -> helper (sub :: xs) sub (depth - 1) in\n  helper [] x n;;\n\nlet rec padZero l1 l2 =\n  let sizeDif = (List.length l1) - (List.length l2) in\n  let appendS = clone 0 (abs sizeDif) in\n  if sizeDif < 0 then ((appendS @ l1), l2) else (l1, (appendS @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (op1,op2) ->\n          let res = op1 + op2 in\n          let (p1,p2) = a in\n          (match p2 with\n           | [] -> [res / 10; res mod 10]\n           | a::b ->\n               let re = a + (res mod 10) in (re / 10) :: (re mod 10) :: b) in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in\nlet p1,p2=a in\nmatch p2 with \n[]->(res/10)::(res mod 10)::[]\n|a::b->let re=a+(res mod 10)  in\n(re/10)::(re mod 10)::b in\n\nlet base = ([],[]) in\nlet args = List.combine (List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in\nlet p1,p2=a in\nmatch p2 with \n[]->(p1,(res/10)::(res mod 10)::[])\n|a::b->let re=a+(res mod 10)  in\n(p1,(re/10)::(re mod 10)::b )in\nlet base = ([],[]) in\nlet args = List.combine (List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n(op1,op2)->let res =op1+op2 in\nlet p1,p2=a in\nmatch p2 with \n[]->(p1,(res/10)::(res mod 10)::[])\n|a::b->let re=a+(res)  in\n(p1,(re/10)::(re mod 10)::b )in\nlet base = ([],[]) in\nlet args = List.combine (List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = let rec helper i l acc=match i with\n0->acc\n|_->helper (i-1) l (bigAdd l  acc)\nin\nhelper i l [0]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = let rec helper i l acc=match i with\n0->acc\n|_->helper (i-1) l (bigAdd l  acc)\nin\nhelper i l [0]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 32-33:\n  let f a x = s in\n              ^\nError: Unbound value s\n", "min": "\nlet bigMul l1 l2 =\n  let f a x = s in\n  let base = ([0], [0]) in\n  let args = (l1, l2) in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = s in\nlet base =([0],[0]) in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 84-104:\n  d::t-> ((d*10)::t,bigAdd((mulByDigit (d*x) t) c))\n                           ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec clone x n =\n  let rec helper xs sub depth =\n    match depth > 0 with\n    | false  -> xs\n    | true  -> helper (sub :: xs) sub (depth - 1) in\n  helper [] x n;;\n\nlet rec padZero l1 l2 =\n  let sizeDif = (List.length l1) - (List.length l2) in\n  let appendS = clone 0 (abs sizeDif) in\n  if sizeDif < 0 then ((appendS @ l1), l2) else (l1, (appendS @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (op1,op2) ->\n          let res = op1 + op2 in\n          let (p1,p2) = a in\n          (match p2 with\n           | [] -> (p1, [res / 10; res mod 10])\n           | a::b ->\n               let re = a + res in (p1, ((re / 10) :: (re mod 10) :: b))) in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i l acc =\n    match i with | 0 -> acc | _ -> helper (i - 1) l (bigAdd l acc) in\n  helper i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (b,c) = a in\n    match b with\n    | d::t -> (((d * 10) :: t), (bigAdd ((mulByDigit (d * x) t) c)))\n    | _ -> a in\n  let base = ((1 :: l2), [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = let b,c=a in match b with \nd::t-> ((d*10)::t,bigAdd((mulByDigit (d*x) t) c))\n|_    ->a\nin\n\nlet base =(1::l2,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = let b,c=a in match b with \nd::t-> ((d*10)::t, t)\n|_    ->a\nin\n\nlet base =(1::l2,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = let b,c=a in match b with \nd::t-> ((d*10)::t,bigAdd t t)\n|_    ->a\nin\n\nlet base =(1::l2,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = let b,c=a in match b with \nd::t-> ((d*10)::t, mulByDigit x t)\n|_    ->a\nin\n\nlet base =(1::l2,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = let b,c=a in match b with \nd::t-> ((d*10)::t, mulByDigit (d*x) t)\n|_    ->a\nin\n\nlet base =(1::l2,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = let b,c=a in match b with \nd::t-> ((d*10)::t, bigAdd (mulByDigit (d*x) t) t)\n|_    ->a\nin\n\nlet base =(1::l2,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = let b,c=a in match b with \nd::t-> ((d*10)::t, bigAdd (mulByDigit (d*x) t) t)\n|_    ->a\nin\n\nlet base =(1::l2,[0]) in\nlet args = List.rev l1 in\nlet (res, _) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = let b,c=a in match b with \nd::t-> ((d*10)::t,  (mulByDigit (d*x) t) )\n|_    ->a\nin\n\nlet base =(1::l2,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = let b,c=a in match b with \nd::t-> ((d*10)::t,  (mulByDigit (d*x) t) )\n|_    ->a\nin\n\nlet base =(1::l2,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = let b,c=a in match b with \nd::t-> ((d*10)::t,  bigAdd (mulByDigit (d*x) t) [0] )\n|_    ->a\nin\n\nlet base =(1::l2,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = let b,c=a in match b with \nd::t-> ((d*10)::t,  bigAdd (mulByDigit (d*x) t) c )\n|_    ->a\nin\n\nlet base =(1::l2,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = let b,c=a in match b with \nd::t-> ((d*10)::t,  bigAdd (mulByDigit (d*x) t) c )\n|_    ->a\nin\n\nlet base =(1::l2,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = let b,c=a in match b with \nd::t-> ((d*10)::t,  bigAdd (mulByDigit (d*x) t) c )\n|_    ->a in\nlet base =(1::l2,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = let b,c=a in match b with \nd::t-> ((d*10)::t,  bigAdd (mulByDigit (d*x) t) c )\n|_    ->a in\nlet base =(1::l2,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = let b,c=a in match b with \nd::t-> ((d*10)::t,  bigAdd (mulByDigit (d*x) t) c )\n|_    ->a in\nlet base =(1::l2,[0]) in\nlet args = List.rev l1 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
