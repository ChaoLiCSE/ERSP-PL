{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n|[] -> -1\n|(ki,vi)::l -> if k = ki then vi\nelse d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n|[] -> -1\n|(ki,vi)::l -> if k = ki then vi\nelse d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n|[] -> -1\n|(ki,vi)::l -> if k = ki then vi\nelse assoc (d,k,l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n|[] -> -1\n|(ki,vi)::l -> if k = ki then vi\nelse assoc (d,k,l)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 151-156:\n  helper (seen',rest')\n          ^^^^^\nError: Unbound value seen'\nHint: Did you mean seen?\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let rest' = t in\n        if List.mem h seen\n        then helper (seen', rest')\n        else h :: (seen' helper (seen', rest')) in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(*let seen' = failwith \"to be written\" in*)\n\n(*in list of seen elts*)\nlet rest' = (*failwith \"to be written\" in *)\nt\nin (*orig list*)\nif List.mem h seen then\nhelper (seen',rest')\nelse \nh::seen'\nhelper (seen', rest')\n\nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = (*failwith \"to be written\" in*)\nif List.mem h seen then\nseen\nelse \nh::seen\nin (*list of seen elts*)\nlet rest' = (*failwith \"to be written\" in *)\nt\nin (*orig list*)\nhelper (seen',rest')\n\nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n|[] -> d\n|(ki,vi)::l -> if k = ki then vi\nelse assoc (d,k,l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n|[] -> d\n|(ki,vi)::l -> if k = ki then vi\nelse assoc (d,k,l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n|[] -> d\n|(ki,vi)::l -> if k = ki then vi\nelse assoc (d,k,l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet c' = f b in\nif c' = b \nthen c'\nelse wwhile (f, c')"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet c' = f b in\nif c' = b \nthen c'\nelse wwhile (f, c')"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 54-55:\n  wwhile (f, 2);;\n          ^\nError: This expression has type int -> int * bool\n       but an expression was expected of type int -> int\n       Type int * bool is not compatible with type int \n", "min": "\nlet rec wwhile (f,b) = let c' = f b in if c' = b then c' else wwhile (f, c');;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n|[] -> d\n|(ki,vi)::l -> if k = ki then vi\nelse assoc (d,k,l)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 86-88:\n  else wwhile (c', b');;\n               ^^\nError: This expression has type 'a but an expression was expected of type\n         'a -> 'a\n       The type variable 'a occurs inside 'a -> 'a\n", "min": "\nlet rec wwhile (f,b) =\n  let c' = f b in let b' = b in if c' = b then c' else wwhile (c', b');;\n", "in": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet c' = f b in\nlet b' = b in\nif c' = b \nthen c'\nelse wwhile (c', b')"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet c' = f b in\n(*let b' = in*)\nif c' = b \nthen c'\nelse wwhile (f, c')"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet c' = f b in\nlet b' = false in\nif c' = b \nthen b'\nelse wwhile (f, c')"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet b' = f b in\nlet c' =\nif f b' then true\nelse false in\n\nif c' = false\nthen b'\nelse wwhile (f, c')"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 43-45:\n  (b', bool c') in\n   ^^\nError: Unbound value b'\n", "min": "\nlet rec wwhile (f,b) =\n  let helper f b = (b', (bool c')) in\n  match c' with | false  -> b' | true  -> wwhile (f, b');;\n", "in": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet helper f b = \n(b', bool c') in\nmatch c' with\n| false -> b'\n| true -> wwhile (f, b')"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 43-45:\n  (b', bool c') in\n   ^^\nError: Unbound value b'\n", "min": "\nlet rec wwhile (f,b) =\n  let helper f b = (b', (bool c')) in\n  match helper with | (int,bool) -> if c' = false then b' else wwhile (f, b');;\n", "in": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet helper f b = \n(b', bool c') in\nmatch helper with\n| (int, bool) -> if c' = false then b'\nelse wwhile (f, b')"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 43-46:\n  (int b', bool c') in\n   ^^^\nError: Unbound value int\n", "min": "\nlet rec wwhile (f,b) =\n  let helper f b = ((int b'), (bool c')) in\n  match helper with\n  | false  -> if c' = false then b'\n  | true  -> wwhile (f, b');;\n", "in": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet helper f b = \n(int b', bool c') in\nmatch helper with\n| false -> if c' = false then b'\n| true -> wwhile (f, b')"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 39-41:\n  (b', bool c') in\n   ^^\nError: Unbound value b'\n", "min": "\nlet rec wwhile (f,b) =\n  let b' f b = (b', (bool c')) in\n  match helper with\n  | false  -> if c' = false then b'\n  | true  -> wwhile (f, b');;\n", "in": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet b' f b = \n(b', bool c') in\nmatch helper with\n| false -> if c' = false then b'\n| true -> wwhile (f, b')"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 53-57:\n  let p = (b', bool c') in\n               ^^^^\nError: Unbound value bool\n", "min": "\nlet rec wwhile (f,b) =\n  let b' = f b in\n  let p = (b', (bool c')) in\n  match c' with | false  -> b' | true  -> wwhile (f, b');;\n", "in": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet b' = f b in\nlet p = (b', bool c') in\nmatch c' with\n| false -> b'\n| true  -> wwhile (f, b')"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 35-37:\n  let f b = (b', c') in\n             ^^\nError: Unbound value b'\n", "min": "\nlet rec wwhile (f,b) =\n  let f b = (b', c') in\n  match c' with | false  -> b' | true  -> wwhile (f, b');;\n", "in": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet f b = (b', c') in\nmatch c' with\n| false -> b'\n| true  -> wwhile (f, b')"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 33-36:\n  let b' = int in\n           ^^^\nError: Unbound value int\n", "min": "\nlet rec wwhile (f,b) =\n  let b' = int in\n  let c' = bool in\n  let f b = (b', c') in\n  match c' with | false  -> b' | true  -> wwhile (f, b');;\n", "in": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet b' = int in\nlet c' = bool in\nlet f b = (b', c') in\nmatch c' with\n| false -> b'\n| true  -> wwhile (f, b')"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet helper = f b in\nmatch helper with\n| (x, y) -> if y \nthen wwhile (f, x)\nelse x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet helper = f b in\nmatch helper with\n| (x, y) -> if y = true\nthen wwhile (f, x)\nelse x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet helper = f b in\nmatch helper with\n| (x, y) -> if y = false\nthen x\nelse wwhile (f, x)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \"to be written\")*)\nlet g b =\nlet self = f b in\nmatch self with\n| b -> (self, true)\n| _ -> (self, false)\nin g\n,b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 116-117:\n  in g\n     ^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let helper = f b in\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let g =\n       let self = f b in\n       match self with | b -> (self, true) | _ -> (self, false) in\n     (g, b));;\n", "in": "let fixpoint (f,b) = wwhile ((*(failwith \"to be written\")*)\nlet g =\nlet self = f b in\nmatch self with\n| b -> (self, true)\n| _ -> (self, false)\nin g\n,b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \"to be written\")*)\nlet g b =\nlet self = f b in\nmatch b with\n| self -> (self, false)\n| _ -> (self, true)\nin g\n,b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile (\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) =\n  wwhile\n    (let g b =\n       let self = f b in\n       match b with | self -> (self, false) | _ -> (self, true) in\n     (g, b));;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-16:\n  let _ = fixpoint (collatz, 3);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 3);;\n", "in": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet helper = f b in\nmatch helper with\n| (x, y) -> if y = false\nthen x\nelse wwhile (f, x)"}, {"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \"to be written\")*)\nlet g b = \nf b\nin g\n,b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \"to be written\")*)\nlet g b = \nlet helper = f b in\nmatch helper with\n| (x, y) -> if x = b\nthen (f, false)\nelse (f, true)\nin g\n,b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 134-135:\n  in g\n     ^\nError: This expression has type 'a -> ('a -> 'a * 'b) * bool\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a -> 'a * 'b\n", "min": "\nlet rec wwhile (f,b) =\n  let helper = f b in\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let g b =\n       let helper = f b in\n       match helper with | (x,y) -> if x = b then (f, false) else (f, true) in\n     (g, b));;\n", "in": "let fixpoint (f,b) = wwhile ((*(failwith \"to be written\")*)\nlet g b = \nlet helper = f b in\nmatch helper with\n| b -> if f = b\nthen (f, false)\nelse (f, true)\nin g\n,b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 93-94:\n  | b -> if f = b\n                ^\nError: This expression has type 'a but an expression was expected of type\n         'b -> 'a\n       The type variable 'a occurs inside 'b -> 'a\n", "min": "\nlet rec wwhile (f,b) =\n  let helper = f b in\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let g b =\n       let helper = f b in\n       match helper with | b -> if f = b then (f, false) else (f, true) in\n     (g, b));;\n", "in": "let fixpoint (f,b) = wwhile ((*(failwith \"to be written\")*)\nlet g b = \nlet helper = f b in\nmatch helper with\n| f-> if f = b\nthen (f, false)\nelse (f, true)\nin g\n,b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \"to be written\")*)\nlet g b = \nlet helper = f b in\nmatch helper with\n| f-> if f = b\nthen (f, false)\nelse (f, true)\nin g\n,b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = (*failwith \"to be written\"*)\nmatch e with\nVarX           -> \"x\"\n| VarY           -> \"y\"\n| Sine e         -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e       -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average e1 e2  -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")\" ^ \"/\" ^ \")\"\n| Times e1 e2    -> \"(\" ^ exprToString e1 ^ \"*\" ^ exprToString e2 ^ \")\"\n(*Thresh = e1<e2?e3:e4*)\n| Thresh e1 e2 e3 e4 -> \"(\" ^exprToString e1^ \"<\" ^exprToString e2^ \"?\" ^exprToString e3^ \":\" ^exprToString e4^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 39-43:\n  VarX           -> \"x\"\n  ^^^^\nError: Unbound constructor VarX\n", "min": "\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\")\" ^ (\"/\" ^ \")\")))))\n  | Times (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"*\" ^ ((exprToString e2) ^ \")\")))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "in": "et rec exprToString e = (*failwith \"to be written\"*)\nmatch e with\n| VarX           -> \"x\"\n| VarY           -> \"y\"\n| Sine e         -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e       -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1,e2)-> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")\" ^ \"/\" ^ \")\"\n| Times (e1,e2)  -> \"(\" ^ exprToString e1 ^ \"*\" ^ exprToString e2 ^ \")\"\n(*Thresh = e1<e2?e3:e4*)\n| Thresh (e1,e2,e3,e4)-> \"(\" ^exprToString e1^ \"<\" ^exprToString e2^ \"?\" ^exprToString e3^ \":\" ^exprToString e4^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 41-45:\n  | VarX           -> \"x\"\n    ^^^^\nError: Unbound constructor VarX\n", "min": "\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^\n        ((exprToString e1) ^\n           (\"+\" ^ ((exprToString e2) ^ (\")\" ^ (\"/\" ^ \")\")))))\n  | Times (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"*\" ^ ((exprToString e2) ^ \")\")))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "in": "let rec exprToString e = (*failwith \"to be written\"*)\nlet helper = exprToString in\nmatch e with\n| VarX           -> \"x\"\n| VarY           -> \"y\"\n| Sine e         -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e       -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1,e2)-> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")\" ^ \"/\" ^ \")\"\n| Times (e1,e2)  -> \"(\" ^ exprToString e1 ^ \"*\" ^ exprToString e2 ^ \")\"\n(*Thresh = e1<e2?e3:e4*)\n| Thresh (e1,e2,e3,e4)-> \"(\" ^exprToString e1^ \"<\" ^exprToString e2^ \"?\" ^exprToString e3^ \":\" ^exprToString e4^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = (*failwith \"to be written\"*)\nlet helper = exprToString in\nmatch e with\nVarX           -> \"x\"\n| VarY           -> \"y\"\n| Sine e         -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e       -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1,e2)-> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")\" ^ \"/\" ^ \")\"\n| Times (e1,e2)  -> \"(\" ^ exprToString e1 ^ \"*\" ^ exprToString e2 ^ \")\"\n(*Thresh = e1<e2?e3:e4*)\n| Thresh (e1,e2,e3,e4)-> \"(\" ^exprToString e1^ \"<\" ^exprToString e2^ \"?\" ^exprToString e3^ \":\" ^exprToString e4^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = (*failwith \"to be written\"*)\nmatch e with\nVarX           -> \"x\"\n| VarY           -> \"y\"\n| Sine e         -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e       -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1,e2)-> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")\" ^ \"/\" ^ \")\"\n| Times (e1,e2)  -> \"(\" ^ exprToString e1 ^ \"*\" ^ exprToString e2 ^ \")\"\n(*Thresh = e1<e2?e3:e4*)\n| Thresh (e1,e2,e3,e4)-> \"(\" ^exprToString e1^ \"<\" ^exprToString e2^ \"?\" ^exprToString e3^ \":\" ^exprToString e4^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = (*failwith \"to be written\"*)\nmatch e with\nVarX           -> \"x\"\n| VarY           -> \"y\"\n| Sine e         -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e       -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1,e2)-> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")\" ^ \"/\" ^ \"2\" ^\")\"\n| Times (e1,e2)  -> \"(\" ^ exprToString e1 ^ \"*\" ^ exprToString e2 ^ \")\"\n(*Thresh = e1<e2?e3:e4*)\n| Thresh (e1,e2,e3,e4)-> \"(\" ^exprToString e1^ \"<\" ^exprToString e2^ \"?\" ^exprToString e3^ \":\" ^exprToString e4^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = (*failwith \"to be written\"*)\nmatch e with\nVarX           -> \"x\"\n| VarY           -> \"y\"\n| Sine e         -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e       -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1,e2)-> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")\" ^ \"/\" ^ \"2\" ^\")\"\n| Times (e1,e2)  -> exprToString e1 ^ \"*\" ^ exprToString e2\n(*Thresh = e1<e2?e3:e4*)\n| Thresh (e1,e2,e3,e4)-> \"(\" ^exprToString e1^ \"<\" ^exprToString e2^ \"?\" ^exprToString e3^ \":\" ^exprToString e4^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = (*failwith \"to be written\"*)\nmatch e with\nVarX           -> x\n| VarY           -> y\n| Sine e         -> sin(pi*. eval (e,x,y))\n| Cosine e       -> cos(pi*. eval (e,x,y))\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\n(*Thresh = e1<e2?e3:e4*)\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = (*failwith \"to be written\"*)\nmatch e with\nVarX           -> x\n| VarY           -> y\n| Sine e         -> sin(pi*. eval (e,x,y))\n| Cosine e       -> cos(pi*. eval (e,x,y))\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\n(*Thresh = e1<e2?e3:e4*)\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = (*failwith \"to be written\"*)\nmatch e with\nVarX           -> x\n| VarY           -> y\n| Sine e         -> sin(pi*. eval (e,x,y))\n| Cosine e       -> cos(pi*. eval (e,x,y))\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\n(*Thresh = e1<e2?e3:e4*)\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = (*failwith \"to be written\"*)\nmatch e with\nVarX           -> x\n| VarY           -> y\n| Sine e         -> sin(pi*. eval (e,x,y))\n| Cosine e       -> cos(pi*. eval (e,x,y))\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\n(*Thresh = e1<e2?e3:e4*)\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-21:\n  let _ = emitGrayscale (eval_fn sampleExpr, 150, \"sample\");;\n          ^^^^^^^^^^^^^\nError: Unbound value emitGrayscale\n", "min": "\nlet _ = emitGrayscale ((eval_fn sampleExpr), 150, \"sample\");;\n", "in": "let rec build (rand, depth) = (*failwith \"to be implemented\"*)\nlet rng = rand(0,9) in\nif depth >= 0 then \nmatch rand 0 2 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \nmatch rng with\n| 0 -> build(rand,depth-1)\n| 1 -> build(rand,depth-1)\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\n| 7 -> buildExpwn(build(rand, depth-1))\n| 8 -> buildLogTen(build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 85-86:\n  match rand 0 2 with\n             ^\nError: This expression has type int but an expression was expected of type\n         int * int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rng = rand (0, 9) in\n  if depth >= 0\n  then match rand 0 2 with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rng with\n     | 0 -> build (rand, (depth - 1))\n     | 1 -> build (rand, (depth - 1))\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) = (*failwith \"to be implemented\"*)\nlet rng = rand(0,9) in\nif depth >= 0 then \nmatch rand (0,2) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \nmatch rng with\n| 0 -> build(rand,depth-1)\n| 1 -> build(rand,depth-1)\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\n| 7 -> buildExpwn(build(rand, depth-1))\n| 8 -> buildLogTen(build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 518-528:\n  | 7 -> buildExpwn(build(rand, depth-1))\n         ^^^^^^^^^^\nError: Unbound value buildExpwn\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rng = rand (0, 9) in\n  if depth >= 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rng with\n     | 0 -> build (rand, (depth - 1))\n     | 1 -> build (rand, (depth - 1))\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\n", "in": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n|[] -> d\n|(ki,vi)::l -> if k = ki then vi\nelse assoc (d,k,l)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 518-528:\n  | 7 -> buildExpwn(build(rand, depth-1))\n         ^^^^^^^^^^\nError: Unbound value buildExpwn\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rng = rand (0, 9) in\n  if depth >= 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rng with\n     | 0 -> build (rand, (depth - 1))\n     | 1 -> build (rand, (depth - 1))\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\n", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}, {"type": "", "out": "", "min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage(buildTimes (buildY(),buildY()),buildCosine (buildX())))),buildCosine (buildTimes (buildSine (buildCosine(buildY())),buildAverage (buildSine (buildX()), buildTimes(buildX(),buildX()))))))),buildY())))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 518-528:\n  | 7 -> buildExpwn(build(rand, depth-1))\n         ^^^^^^^^^^\nError: Unbound value buildExpwn\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rng = rand (0, 9) in\n  if depth >= 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rng with\n     | 0 -> build (rand, (depth - 1))\n     | 1 -> build (rand, (depth - 1))\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\n", "in": "let rec eval (e,x,y) = (*failwith \"to be written\"*)\nmatch e with\nVarX           -> x\n| VarY           -> y\n| Sine e         -> sin(pi*. eval (e,x,y))\n| Cosine e       -> cos(pi*. eval (e,x,y))\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\n(*Thresh = e1<e2?e3:e4*)\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| Expwn e        -> phi ** eval (e, x, y)\n| Logten e       ->"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 518-528:\n  | 7 -> buildExpwn(build(rand, depth-1))\n         ^^^^^^^^^^\nError: Unbound value buildExpwn\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rng = rand (0, 9) in\n  if depth >= 0\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match rng with\n     | 0 -> build (rand, (depth - 1))\n     | 1 -> build (rand, (depth - 1))\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\n     | 8 -> buildTan (build (rand, (depth - 1))));;\n", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Expwn    of expr\n| Tan      of expr"}, {"type": "", "out": "", "min": "", "in": "let rec exprToString e = (*failwith \"to be written\"*)\nmatch e with\nVarX           -> \"x\"\n| VarY           -> \"y\"\n| Sine e         -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e       -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1,e2)-> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")\" ^ \"/\" ^ \"2\" ^\")\"\n| Times (e1,e2)  -> exprToString e1 ^ \"*\" ^ exprToString e2\n(*Thresh = e1<e2?e3:e4*)\n| Thresh (e1,e2,e3,e4)-> \"(\" ^exprToString e1^ \"<\" ^exprToString e2^ \"?\" ^exprToString e3^ \":\" ^exprToString e4^ \")\"\n| Expwn e        -> \"phi^\" ^ exprToString e \n| Tan e          -> \"tan(pi*\" ^ exprToString e ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = (*failwith \"to be written\"*)\nmatch e with\nVarX           -> x\n| VarY           -> y\n| Sine e         -> sin(pi*. eval (e,x,y))\n| Cosine e       -> cos(pi*. eval (e,x,y))\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\n(*Thresh = e1<e2?e3:e4*)\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\nthen eval (e3,x,y)\nelse eval (e4,x,y)\n| Expwn e        -> phi ** eval (e, x, y)\n| Tan e          -> sin(pi*. eval(e,x,y))/. cos(pi*. eval(e,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = (*failwith \"to be implemented\"*)\nlet rng = rand(0,9) in\nif depth >= 0 then \nmatch rand (0,2) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \nmatch rng with\n| 0 -> build(rand,depth-1)\n| 1 -> build(rand,depth-1)\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\n| 7 -> buildExpwn(build(rand, depth-1))\n| _ -> buildTan(build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = (*failwith \"to be implemented\"*)\nlet rng = rand(0,9) in\nif depth >= 0 then \nmatch rand (0,2) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> build(rand, depth-1)\nelse \nmatch rng with\n| 0 -> build(rand,depth-1)\n| 1 -> build(rand,depth-1)\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\n| 7 -> buildExpwn(build(rand, depth-1))\n| _ -> buildTan(build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = (*failwith \"to be implemented\"*)\nlet rng = rand(0,9) in\nif depth >= 0 then \nmatch rand (0,2) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> build(rand, depth-1)\nelse \nmatch rng with\n| 0 -> build(rand,depth-1)\n| 1 -> build(rand,depth-1)\n| 2 -> buildSine(build(rand, depth-1))\n| 3 -> buildCosine(build(rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\n| 7 -> buildExpwn(build(rand, depth-1))\n| _ -> buildTan(build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
