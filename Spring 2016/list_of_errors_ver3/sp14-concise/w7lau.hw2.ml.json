{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = failwith \"to be written\"", "out": "", "min": "\nlet rec assoc (d,k,l) = failwith \"to be written\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = failwith \"to be written\"", "out": "", "min": "\nlet rec assoc (d,k,l) = failwith \"to be written\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = failwith \"to be written\"", "out": "", "min": "\nlet rec assoc (d,k,l) = failwith \"to be written\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif not List.mem h seen then\nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 98-101:\n  if not List.mem h seen then\n     ^^^\nError: This function has type bool -> bool\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if not List.mem h seen\n        then let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif not (List.mem h seen) then\nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 166-186:\n  helper (seen',rest') \n  ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if not (List.mem h seen)\n        then let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif List.mem h seen then\nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 160-180:\n  helper (seen',rest') \n  ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if List.mem h seen\n        then let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif List.mem h seen then\nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 160-180:\n  helper (seen',rest') \n  ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if List.mem h seen\n        then let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif List.mem h seen then\nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 160-180:\n  helper (seen',rest') \n  ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if List.mem h seen\n        then let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 132-134:\n  let seen' = if List.mem h seen then h::seen in\n                                       ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif List.mem h seen then\nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 160-180:\n  helper (seen',rest') \n  ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if List.mem h seen\n        then let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nif List.mem h seen then\nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 68-69:\n  if List.mem h seen then\n              ^\nError: Unbound value h\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    if List.mem h seen\n    then\n      match rest with\n      | [] -> seen\n      | h::t ->\n          let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nhelper ([],l)", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  helper ([], l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif not List.mem seen h then\nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 98-101:\n  if not List.mem seen h then\n     ^^^\nError: This function has type bool -> bool\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if not List.mem seen h\n        then let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif not (List.mem seen h) then\nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 140-144:\n  let seen' = h::seen in\n                 ^^^^\nError: This expression has type 'a but an expression was expected of type\n         'a list list\n       The type variable 'a occurs inside 'a list list\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if not (List.mem seen h)\n        then let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif not (List.mem seen h) then\nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 140-144:\n  let seen' = h::seen in\n                 ^^^^\nError: This expression has type 'a but an expression was expected of type\n         'a list list\n       The type variable 'a occurs inside 'a list list\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if not (List.mem seen h)\n        then let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif not (List.mem seen h) then\nlet seen' = h::rest in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 174-179:\n  helper (seen',rest') \n          ^^^^^\nError: This expression has type 'a list list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list list\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if not (List.mem seen h)\n        then let seen' = h :: rest in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = h :: seen in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif List.mem h seen then\nlet seen' = seen' in\nlet rest' = t in\nhelper (seen', rest')\nelse\nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "Characters 131-136:\n  let seen' = seen' in\n              ^^^^^\nError: Unbound value seen'\nHint: Did you mean seen?\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if List.mem h seen\n        then let seen' = seen' in let rest' = t in helper (seen', rest')\n        else\n          (let seen' = h :: seen in let rest' = t in helper (seen', rest')) in\n  List.rev (helper ([], l));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif List.mem h seen then\nlet seen' = seen in\nlet rest' = t in\nhelper (seen', rest')\nelse\nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if List.mem h seen\n        then let seen' = seen in let rest' = t in helper (seen', rest')\n        else\n          (let seen' = h :: seen in let rest' = t in helper (seen', rest')) in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | (s,i)::t -> if s = k then i else assoc (d, k, t) | [] -> d;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | (s,i)::t -> if s = k then i else assoc (d, k, t) | [] -> d;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | (s,i)::t -> if s = k then i else assoc (d, k, t) | [] -> d;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif List.mem h seen then\nlet seen' = seen in\nlet rest' = t in\nhelper (seen', rest')\nelse\nlet seen' = h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "out": "", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if List.mem h seen\n        then let seen' = seen in let rest' = t in helper (seen', rest')\n        else\n          (let seen' = h :: seen in let rest' = t in helper (seen', rest')) in\n  List.rev (helper ([], l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | (s,i)::t -> if s = k then i else assoc (d, k, t) | [] -> d;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let wwhile (f,b) =\nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f, x)\n| false -> x\nin (f,b) (b, true)", "out": "Characters 71-84:\n  | true -> helper (f, x)\n            ^^^^^^^^^^^^^\nError: This expression has type 'a * bool -> 'b\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside 'a * bool -> 'b\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) | false  -> x in\n  (f, b) (b, true);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let wwhile (f,b) =\nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f,x) (x,y)\n| false -> x\nin (f,b) (b, true)", "out": "Characters 106-111:\n  in (f,b) (b, true);;\n     ^^^^^\nError: This expression has type 'a * 'b\n       This is not a function; it cannot be applied.\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (x, y) | false  -> x in\n  (f, b) (b, true);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let wwhile (f,b) =\nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f,x) (x,y)\n| false -> x\nin helper (f,b) (b, true)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (x, y) | false  -> x in\n  helper (f, b) (b, true);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (x, y) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let wwhile (f,b) =\nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f,x) f b\n| false -> x\nin helper (f,b) (b, true)", "out": "Characters 71-87:\n  | true -> helper (f,x) f b\n            ^^^^^^^^^^^^^^^^\nError: This expression has type 'a but an expression was expected of type\n         'b -> 'a\n       The type variable 'a occurs inside 'b -> 'a\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) f b | false  -> x in\n  helper (f, b) (b, true);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let wwhile (f,b) =\nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f,x) f(b)\n| false -> x\nin helper (f,b) (b, true)", "out": "Characters 71-88:\n  | true -> helper (f,x) f(b)\n            ^^^^^^^^^^^^^^^^^\nError: This expression has type 'a but an expression was expected of type\n         'b -> 'a\n       The type variable 'a occurs inside 'b -> 'a\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) f b | false  -> x in\n  helper (f, b) (b, true);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let wwhile (f,b) =\nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f,x) f b\n| false -> x\nin helper (f,b) (b, true)", "out": "Characters 71-87:\n  | true -> helper (f,x) f b\n            ^^^^^^^^^^^^^^^^\nError: This expression has type 'a but an expression was expected of type\n         'b -> 'a\n       The type variable 'a occurs inside 'b -> 'a\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) f b | false  -> x in\n  helper (f, b) (b, true);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let wwhile (f,b) =\nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f,x) f b\n| false -> x\nin helper (f,b) (b, true)", "out": "Characters 71-87:\n  | true -> helper (f,x) f b\n            ^^^^^^^^^^^^^^^^\nError: This expression has type 'a but an expression was expected of type\n         'b -> 'a\n       The type variable 'a occurs inside 'b -> 'a\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) f b | false  -> x in\n  helper (f, b) (b, true);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let wwhile (f,b) =\nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f,x) (f b)\n| false -> x\nin helper (f,b) (b, true)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 3)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 3);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 1)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 1);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let wwhile (f,b) =\nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f,x) (f b)\n| false -> x\nin helper (f,b) (b, true)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "out": "Characters 46-52:\n  wwhile (f, 2);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "out": "Characters 46-52:\n  wwhile (f, 2);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "out": "Characters 46-52:\n  wwhile (f, 2);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (f,b)", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile (f,b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile (f, b);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (f,b)", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile (f,b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile (f, b);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (f,b)", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile (f,b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile (f, b);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (f,b)", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile (f,b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile (f, b);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let wwhile (f,b) =\nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f,x) (f b)\n| false -> x\nin helper (f,b) (b, true)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((f b),b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((f),b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((f b),b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((b),b)", "out": "Characters 33-34:\n  let fixpoint (f,b) = wwhile ((b),b);;\n                                   ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (b, b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((f b),b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((f f b),b)", "out": "Characters 32-33:\n  let fixpoint (f,b) = wwhile ((f f b),b);;\n                                  ^\nError: This expression has type 'a -> 'b -> 'c\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b -> 'c\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f f b), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((f (f b)),b)", "out": "Characters 39-40:\n  let fixpoint (f,b) = wwhile ((f (f b)),b);;\n                                         ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f (f b)), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((f b),b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((f b),b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((f b),b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let wwhile (f,b) =\nlet rec helper (f,b) (x,y) =\nmatch y with\n| true -> helper (f,x) (f b)\n| false -> x\nin helper (f,b) (b, true)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((b),b)", "out": "Characters 33-34:\n  let fixpoint (f,b) = wwhile ((b),b);;\n                                   ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (b, b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((f b),b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((f (f b)),b)", "out": "Characters 39-40:\n  let fixpoint (f,b) = wwhile ((f (f b)),b);;\n                                         ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f (f b)), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((f b),b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((f b),b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (f,b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile( wwhile (f,b), b)", "out": "Characters 43-44:\n  let fixpoint (f,b) = wwhile( wwhile (f,b), b);;\n                                             ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((wwhile (f, b)), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (f,b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((f b),b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "\nlet _ = fixpoint (collatz, 1) ", "out": "Characters 19-26:\n  let _ = fixpoint (collatz, 1) ;;\n                    ^^^^^^^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ = fixpoint (collatz, 1);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((wwhile (f b)),b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((wwhile (f b)), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (f,f b)", "out": "Characters 31-34:\n  let fixpoint (f,b) = wwhile (f,f b);;\n                                 ^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, (f b));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (f,(f b))", "out": "Characters 31-36:\n  let fixpoint (f,b) = wwhile (f,(f b));;\n                                 ^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, (f b));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (f,b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (f,b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (f b,b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | (s,i)::t -> if s = k then i else assoc (d, k, t) | [] -> d;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (f,b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (f,b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = f b", "out": "", "min": "\nlet fixpoint (f,b) = f b;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | (s,i)::t -> if s = k then i else assoc (d, k, t) | [] -> d;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = (f b, wwhile(f,b))", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = ((f b), (wwhile (f, b)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nlet f x = x in\nwwhile (f,b)", "out": "Characters 45-46:\n  wwhile (f,b);;\n          ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let f x = x in wwhile (f, b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nlet f x = xx = (f x) in (xx, xx != b) in f\nwwhile (f,b)", "out": "Characters 32-34:\n  let f x = xx = (f x) in (xx, xx != b) in f\n            ^^\nError: Unbound value xx\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ =\n  let fixpoint (f,b) = let f x = xx = (f x) in (xx, (xx != b)) in\n  f wwhile (f, b);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nlet f x = let xx = (f x) in (xx, xx != b) in f\nwwhile (f,b)", "out": "Characters 67-68:\n  let f x = let xx = (f x) in (xx, xx != b) in f\n                                               ^\nError: This function has type 'a -> 'b * bool\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) =\n  let f x = let xx = f x in (xx, (xx != b)) in f wwhile (f, b);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nlet f x = let xx = (f x) in (xx, xx != b) in f", "out": "", "min": "\nlet fixpoint (f,b) = let f x = let xx = f x in (xx, (xx != b)) in f;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nwwhile (f, if b = (f b) then b else b)", "out": "Characters 40-45:\n  wwhile (f, if b = (f b) then b else b);;\n                    ^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, (if b = (f b) then b else b));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nwwhile (f, if b = (f(b)) then b else b)", "out": "Characters 40-46:\n  wwhile (f, if b = (f(b)) then b else b);;\n                    ^^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, (if b = (f b) then b else b));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (f, b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nwwhile ((let f b = b in b), b)", "out": "Characters 50-51:\n  wwhile ((let f b = b in b), b);;\n                              ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((let f b = b in b), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nwwhile ((let f b = b in b), b)", "out": "Characters 50-51:\n  wwhile ((let f b = b in b), b);;\n                              ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = wwhile ((let f b = b in b), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nlet g b = b in \nwwhile ((g), b)", "out": "Characters 46-49:\n  wwhile ((g), b);;\n          ^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let g b = b in wwhile (g, b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nlet g b = b in \nwwhile (g, b)", "out": "Characters 46-47:\n  wwhile (g, b);;\n          ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let g b = b in wwhile (g, b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nlet g b = b in \nwwhile ((g,true), b)", "out": "Characters 46-54:\n  wwhile ((g,true), b);;\n          ^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let g b = b in wwhile ((g, true), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nlet g b = b, (f b) in \nwwhile (g, b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let g b = (b, (f b)) in wwhile (g, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nlet g b = (b, (f b)) in \nwwhile (g, b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let g b = (b, (f b)) in wwhile (g, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nlet g b = b, (f b) in \nwwhile (g, b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let g b = (b, (f b)) in wwhile (g, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nlet f x = b, (f b) in \nwwhile (f, b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let f x = (b, (f b)) in wwhile (f, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nlet f x = b, (f b) in (b = (f b)) in \nwwhile (f, b)", "out": "Characters 49-54:\n  let f x = b, (f b) in (b = (f b)) in \n                             ^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * 'b\n", "min": "\nlet f b = b;;\n\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ =\n  let fixpoint (f,b) = let f x = (b, (f b)) in b = (f b) in wwhile (f, b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nlet g x = b, (f b) in (b = (f b)) in \nwwhile (g, b)", "out": "Characters 68-69:\n  wwhile (g, b);;\n          ^\nError: Unbound value g\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ =\n  let fixpoint (f,b) = let g x = (b, (f b)) in b = (f b) in wwhile (g, b);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nif b != f b then\nlet f x = b, (f b) in\nwwhile(f, b)\nelse b", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) =\n  if b != (f b) then let f x = (b, (f b)) in wwhile (f, b) else b;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nif b != f b then\nlet f b = b, (f b) in\nwwhile(f, b)\nelse b", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) =\n  if b != (f b) then let f b = (b, (f b)) in wwhile (f, b) else b;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type bool -> bool\n       Type int is not compatible with type bool \n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) =\n  if b != (f b) then let f b = (b, (f b)) in wwhile (f, b) else b;;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nif b != f b then\nlet b = f b in\nwwhile(f, b)\nelse b", "out": "Characters 61-62:\n  wwhile(f, b)\n         ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = if b != (f b) then let b = f b in wwhile (f, b) else b;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | (s,i)::t -> if s = k then i else assoc (d, k, t) | [] -> d;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nif b != f b then\nwwhile(f, f b)\nelse\nb", "out": "Characters 45-46:\n  wwhile(f, f b)\n         ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = if b != (f b) then wwhile (f, (f b)) else b;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nif b != (f b) then\nwwhile(f, f b)\nelse\nb", "out": "Characters 47-48:\n  wwhile(f, f b)\n         ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = if b != (f b) then wwhile (f, (f b)) else b;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nif b != (f b) then\nlet f = (f, true) in\nwwhile(f, f b)\nelse\nb", "out": "Characters 68-69:\n  wwhile(f, f b)\n         ^\nError: This expression has type ('a -> 'a) * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) =\n  if b != (f b) then let f = (f, true) in wwhile (f, (f b)) else b;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nif b != (f b) then\nlet f = (f b, true) in\nwwhile(f, f b)\nelse\nb", "out": "Characters 70-71:\n  wwhile(f, f b)\n         ^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) =\n  if b != (f b) then let f = ((f b), true) in wwhile (f, (f b)) else b;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nif b != (f b) then\nlet f b = (b, true) in\nwwhile(f, f b)\nelse\nb", "out": "Characters 83-84:\n  b;;\n  ^\nError: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) =\n  if b != (f b) then let f b = (b, true) in wwhile (f, (f b)) else b;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nif b != (f b) then\nlet f b = (b, true) in\nwwhile(f, f b)\nelse\nwwhile(f b)", "out": "Characters 83-94:\n  wwhile(f b);;\n  ^^^^^^^^^^^\nError: This expression has type 'a but an expression was expected of type\n         (('a -> 'a * bool) * 'a) * bool\n       The type variable 'a occurs inside (('a -> 'a * bool) * 'a) * bool\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) =\n  if b != (f b)\n  then let f b = (b, true) in wwhile (f, (f b))\n  else wwhile (f b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nif b = f b then\nf b\nelse\nlet g b = (f b, true) in\nwwhile(g, f b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) =\n  if b = (f b) then f b else (let g b = ((f b), true) in wwhile (g, (f b)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) =\n  if b = (f b) then f b else (let g b = ((f b), true) in wwhile (g, (f b)));;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nif b = f b then\nb\nelse\nlet g b = (f b, true) in\nwwhile(g, f b)", "out": "Characters 69-75:\n  wwhile(g, f b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) =\n  if b = (f b) then b else (let g b = ((f b), true) in wwhile (g, (f b)));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet g b = (f b, (b = f b)) in\nwwhile(g, f b)", "out": "Characters 51-57:\n  wwhile(g, f b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = let g b = ((f b), (b = (f b))) in wwhile (g, (f b));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet g x = (f b, (b = f b)) in\nwwhile(g, f b)", "out": "Characters 51-57:\n  wwhile(g, f b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = let g x = ((f b), (b = (f b))) in wwhile (g, (f b));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet f x = (f b, (b = f b)) in\nwwhile(f, f b)", "out": "Characters 51-57:\n  wwhile(f, f b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = let f x = ((f b), (b = (f b))) in wwhile (f, (f b));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet g x = (f b, (b = f b)) in\nwwhile(g, f b)", "out": "Characters 51-57:\n  wwhile(g, f b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = let g x = ((f b), (b = (f b))) in wwhile (g, (f b));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet g x = (f, (b = f b)) in\nwwhile(g, f b)", "out": "Characters 49-55:\n  wwhile(g, f b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = let g x = (f, (b = (f b))) in wwhile (g, (f b));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet g x = (f b, (b = f b)) in\nwwhile(g, b)", "out": "Characters 51-57:\n  wwhile(g, b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = let g x = ((f b), (b = (f b))) in wwhile (g, b);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "out": "Characters 46-52:\n  wwhile (f, 2);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet g x = (f b, (b = f b)) in\nwwhile(g, b)", "out": "Characters 51-57:\n  wwhile(g, b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = let g x = ((f b), (b = (f b))) in wwhile (g, b);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 4)", "out": "Characters 46-52:\n  wwhile (f, 4);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 4);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "out": "Characters 46-52:\n  wwhile (f, 2);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": "scope"}, {"in": "let fixpoint (f,b) =\nlet g x = (f b, (b = f b)) in\nwwhile(g, b)", "out": "Characters 51-57:\n  wwhile(g, b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = let g x = ((f b), (b = (f b))) in wwhile (g, b);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet g x = (f b, (b != f b)) in\nwwhile(g, b)", "out": "Characters 52-58:\n  wwhile(g, b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = let g x = ((f b), (b != (f b))) in wwhile (g, b);;\n", "type": "scope"}, {"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | (s,i)::t -> if s = k then i else assoc (d, k, t) | [] -> d;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet y = (f b, (b = f b)) in\nwwhile(y, b)", "out": "Characters 56-57:\n  wwhile(y, b);;\n         ^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let y = ((f b), (b = (f b))) in wwhile (y, b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet y x= (f b, (b = f b)) in\nwwhile(y b, b)", "out": "Characters 57-60:\n  wwhile(y b, b);;\n         ^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let y x = ((f b), (b = (f b))) in wwhile ((y b), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet y x= (f b, (b = f b)) in\nwwhile(y, b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let y x = ((f b), (b = (f b))) in wwhile (y, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet y = f b in (y, (b = f b)) in\nwwhile(y, b)", "out": "Characters 61-62:\n  wwhile(y, b);;\n         ^\nError: Unbound value y\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ = let fixpoint (f,b) = let y = f b in (y, (b = (f b))) in wwhile (y, b);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet y = f b in (y, (b = f b)) in\nwwhile(f, b)", "out": "Characters 61-62:\n  wwhile(f, b);;\n         ^\nError: Unbound value f\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ = let fixpoint (f,b) = let y = f b in (y, (b = (f b))) in wwhile (f, b);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet y = f b in (y, (b = f b)) in\nwwhile(y, b)", "out": "Characters 61-62:\n  wwhile(y, b);;\n         ^\nError: Unbound value y\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ = let fixpoint (f,b) = let y = f b in (y, (b = (f b))) in wwhile (y, b);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = let y = f b in (y, (b = f b)) in\nwwhile(y, b)", "out": "Characters 61-62:\n  wwhile(y, b);;\n         ^\nError: Unbound value y\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ = let fixpoint (f,b) = let y = f b in (y, (b = (f b))) in wwhile (y, b);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = let y = f b in (y, (b = f b)) in\nwwhile(f b, b)", "out": "Characters 61-62:\n  wwhile(f b, b);;\n         ^\nError: Unbound value f\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ =\n  let fixpoint (f,b) = let y = f b in (y, (b = (f b))) in wwhile ((f b), b);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = let y x = f b in (y, (b = f b)) in\nwwhile(y, b)", "out": "Characters 63-64:\n  wwhile(y, b);;\n         ^\nError: Unbound value y\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ =\n  let fixpoint (f,b) = let y x = f b in (y, (b = (f b))) in wwhile (y, b);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet y x = (f b, (b = f b)) in\nwwhile(y, b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let y x = ((f b), (b = (f b))) in wwhile (y, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let y x = ((f b), (b = (f b))) in wwhile (y, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet y x = (f b, (b = f b)) in\nwwhile(f, b)", "out": "Characters 58-59:\n  wwhile(f, b);;\n         ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let y x = ((f b), (b = (f b))) in wwhile (f, b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet f x = (f b, (b = f b)) in\nwwhile(f, b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let f x = ((f b), (b = (f b))) in wwhile (f, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let f x = ((f b), (b = (f b))) in wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet f x = let y = f b in (f b, (b = f b)) in\nwwhile(f, b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) =\n  let f x = let y = f b in ((f b), (b = (f b))) in wwhile (f, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) =\n  let f x = let y = f b in ((f b), (b = (f b))) in wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet f x = (f b, (b = f b)) in\nwwhile(f, b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let f x = ((f b), (b = (f b))) in wwhile (f, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet f x = (f b, (f b = b)) in\nwwhile(f, b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let f x = ((f b), ((f b) = b)) in wwhile (f, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let f x = ((f b), ((f b) = b)) in wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet f x = (f b, (f b = b)) in\nwwhile(f, b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let f x = ((f b), ((f b) = b)) in wwhile (f, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet f x = (f x, (f b = b)) in\nwwhile(f, b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let f x = ((f x), ((f b) = b)) in wwhile (f, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet f x = (f, (f b = b)) in\nwwhile(f, b)", "out": "Characters 59-60:\n  wwhile(f, b);;\n            ^\nError: This expression has type 'a but an expression was expected of type\n         'a -> 'a\n       The type variable 'a occurs inside 'a -> 'a\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let f x = (f, ((f b) = b)) in wwhile (f, b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet f x = (f, (f b = b)) in\nwwhile(f, f b)", "out": "Characters 59-62:\n  wwhile(f, f b);;\n            ^^^\nError: This expression has type ('a -> 'a) * bool\n       but an expression was expected of type 'a -> 'a\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let f x = (f, ((f b) = b)) in wwhile (f, (f b));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet f x = (f, (f b = b)) in\nwwhile(f, x)", "out": "Characters 59-60:\n  wwhile(f, x);;\n            ^\nError: Unbound value x\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let f x = (f, ((f b) = b)) in wwhile (f, x);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet f x = (f, (f b = b)) in\nwwhile(f b, b)", "out": "Characters 56-59:\n  wwhile(f b, b);;\n         ^^^\nError: This expression has type ('a -> 'a) * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let f x = (f, ((f b) = b)) in wwhile ((f b), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet f x = (f x, (f b = b)) in\nwwhile(f, b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let f x = ((f x), ((f b) = b)) in wwhile (f, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet f x = (f b, (f b = b)) in\nwwhile(f, b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let f x = ((f b), ((f b) = b)) in wwhile (f, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet g x = (f b, (f b = b)) in\nwwhile(g, b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let g x = ((f b), ((f b) = b)) in wwhile (g, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet g x = (f b, (f(b)= b)) in\nwwhile(g, b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let g x = ((f b), ((f b) = b)) in wwhile (g, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet g x = (f(b), (f(b)= b)) in\nwwhile(g, b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let g x = ((f b), ((f b) = b)) in wwhile (g, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let g x = ((f b), ((f b) = b)) in wwhile (g, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet g x = (f(x), (f(b)= b)) in\nwwhile(g, b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let g x = ((f x), ((f b) = b)) in wwhile (g, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet g x = (f(x), (f(x)= b)) in\nwwhile(g, b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let g x = ((f x), ((f x) = b)) in wwhile (g, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet g x = (f(x), (f(x)= x)) in\nwwhile(g, b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let g x = ((f x), ((f x) = x)) in wwhile (g, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet g x = (f(x), (f(x)= b)) in\nwwhile(g, b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let g x = ((f x), ((f x) = b)) in wwhile (g, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet g x = (f(x), (f(x)!= x)) in\nwwhile(g, b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let g x = ((f x), ((f x) != x)) in wwhile (g, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) =\nlet g x = (f x, (f x != x)) in\nwwhile(g, b)", "out": "", "min": "\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet fixpoint (f,b) = let g x = ((f x), ((f x) != x)) in wwhile (g, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = failwith \"to be written\"", "out": "", "min": "\nlet rec exprToString e = failwith \"to be written\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX e -> printf \"%s\" e\n| VarY e -> printf \"%s\" e\n| Sine e -> printf \"sin(%s)\" e\n| Cosine e -> printf \"cos(%s)\" e\n| Average e1, e2 -> printf \"%s+%s/2\" e1 e2\n| Times e1, e2 -> printf \"%s*%s\" e1 e2\n| Thresh e1, e2, e3, e4 -> printf \"(%s<%s?%s:%s)\" e1 e2 e3 e4", "out": "Characters 40-46:\n  | VarX e -> printf \"%s\" e\n    ^^^^^^\nError: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX e -> printf \"%s\" e\n  | VarY e -> printf \"%s\" e\n  | Sine e -> printf \"sin(%s)\" e\n  | Cosine e -> printf \"cos(%s)\" e\n  | (Average e1,e2) -> printf \"%s+%s/2\" e1 e2\n  | (Times e1,e2) -> printf \"%s*%s\" e1 e2\n  | (Thresh e1,e2,e3,e4) -> printf \"(%s<%s?%s:%s)\" e1 e2 e3 e4;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> printf \"x\"\n| VarY -> printf \"y\"\n| Sine e -> printf \"sin(%s)\" e\n| Cosine e -> printf \"cos(%s)\" e\n| Average e1, e2 -> printf \"%s+%s/2\" e1 e2\n| Times e1, e2 -> printf \"%s*%s\" e1 e2\n| Thresh e1, e2, e3, e4 -> printf \"(%s<%s?%s:%s)\" e1 e2 e3 e4", "out": "Characters 146-160:\n  | Average e1, e2 -> printf \"%s+%s/2\" e1 e2\n    ^^^^^^^^^^^^^^\nError: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> printf \"x\"\n  | VarY  -> printf \"y\"\n  | Sine e -> printf \"sin(%s)\" e\n  | Cosine e -> printf \"cos(%s)\" e\n  | (Average e1,e2) -> printf \"%s+%s/2\" e1 e2\n  | (Times e1,e2) -> printf \"%s*%s\" e1 e2\n  | (Thresh e1,e2,e3,e4) -> printf \"(%s<%s?%s:%s)\" e1 e2 e3 e4;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> printf \"x\"\n| VarY -> printf \"y\"\n| Sine e -> printf \"sin(%s)\" e\n| Cosine e -> printf \"cos(%s)\" e\n| Average (e1,e2) -> printf \"%s+%s/2\" e1 e2\n| Times (e1,e2) -> printf \"%s*%s\" e1 e2\n| Thresh (e1,e2,e3,e4) -> printf \"(%s<%s?%s:%s)\" e1 e2 e3 e4", "out": "Characters 48-54:\n  | VarX -> printf \"x\"\n            ^^^^^^\nError: Unbound value printf\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> printf \"x\"\n  | VarY  -> printf \"y\"\n  | Sine e -> printf \"sin(%s)\" e\n  | Cosine e -> printf \"cos(%s)\" e\n  | Average (e1,e2) -> printf \"%s+%s/2\" e1 e2\n  | Times (e1,e2) -> printf \"%s*%s\" e1 e2\n  | Thresh (e1,e2,e3,e4) -> printf \"(%s<%s?%s:%s)\" e1 e2 e3 e4;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> Format.printf \"x\"\n| VarY -> printf \"y\"\n| Sine e -> printf \"sin(%s)\" e\n| Cosine e -> printf \"cos(%s)\" e\n| Average (e1,e2) -> printf \"%s+%s/2\" e1 e2\n| Times (e1,e2) -> printf \"%s*%s\" e1 e2\n| Thresh (e1,e2,e3,e4) -> printf \"(%s<%s?%s:%s)\" e1 e2 e3 e4", "out": "Characters 76-82:\n  | VarY -> printf \"y\"\n            ^^^^^^\nError: Unbound value printf\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.printf \"x\"\n  | VarY  -> printf \"y\"\n  | Sine e -> printf \"sin(%s)\" e\n  | Cosine e -> printf \"cos(%s)\" e\n  | Average (e1,e2) -> printf \"%s+%s/2\" e1 e2\n  | Times (e1,e2) -> printf \"%s*%s\" e1 e2\n  | Thresh (e1,e2,e3,e4) -> printf \"(%s<%s?%s:%s)\" e1 e2 e3 e4;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> Format.printf \"x\"\n| VarY -> Format.printf \"y\"\n| Sine e -> Format.printf \"sin(%s)\" e\n| Cosine e -> Format.printf \"cos(%s)\" e\n| Average (e1,e2) -> Format.printf \"%s+%s/2\" e1 e2\n| Times (e1,e2) -> Format.printf \"%s*%s\" e1 e2\n| Thresh (e1,e2,e3,e4) -> Format.printf \"(%s<%s?%s:%s)\" e1 e2 e3 e4", "out": "Characters 130-131:\n  | Sine e -> Format.printf \"sin(%s)\" e\n                                      ^\nError: This expression has type expr but an expression was expected of type\n         string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.printf \"x\"\n  | VarY  -> Format.printf \"y\"\n  | Sine e -> Format.printf \"sin(%s)\" e\n  | Cosine e -> Format.printf \"cos(%s)\" e\n  | Average (e1,e2) -> Format.printf \"%s+%s/2\" e1 e2\n  | Times (e1,e2) -> Format.printf \"%s*%s\" e1 e2\n  | Thresh (e1,e2,e3,e4) -> Format.printf \"(%s<%s?%s:%s)\" e1 e2 e3 e4;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> Format.printf \"x\"\n| VarY -> Format.printf \"y\"\n| Sine e -> Format.printf \"sin(%s)\" to_string e\n| Cosine e -> Format.printf \"cos(%s)\" e\n| Average (e1,e2) -> Format.printf \"%s+%s/2\" e1 e2\n| Times (e1,e2) -> Format.printf \"%s*%s\" e1 e2\n| Thresh (e1,e2,e3,e4) -> Format.printf \"(%s<%s?%s:%s)\" e1 e2 e3 e4", "out": "Characters 120-129:\n  | Sine e -> Format.printf \"sin(%s)\" to_string e\n                            ^^^^^^^^^\nError: This expression has type\n         ('a -> 'b, Format.formatter, unit, unit, unit, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, Format.formatter, unit, unit, unit, unit)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type unit \n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Format.printf \"x\"\n  | VarY  -> Format.printf \"y\"\n  | Sine e -> Format.printf \"sin(%s)\" to_string e\n  | Cosine e -> Format.printf \"cos(%s)\" e\n  | Average (e1,e2) -> Format.printf \"%s+%s/2\" e1 e2\n  | Times (e1,e2) -> Format.printf \"%s*%s\" e1 e2\n  | Thresh (e1,e2,e3,e4) -> Format.printf \"(%s<%s?%s:%s)\" e1 e2 e3 e4;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin(\" ^ e ^ \")\"\n| Cosine e -> \"cos(\" ^ e ^ \")\"\n| Average (e1,e2) -> e1 ^ \"+\" ^ e2 ^ \"/2\"\n| Times (e1,e2) -> e1 ^ \"*\" ^ e2\n| Thresh (e1,e2,e3,e4) -> e1^\"<\" ^e2^ \"?\" ^ e3 ^\":\" ^ e4", "out": "Characters 87-88:\n  | Sine e -> \"sin(\" ^ e ^ \")\"\n                       ^\nError: This expression has type expr but an expression was expected of type\n         string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(\" ^ (e ^ \")\")\n  | Cosine e -> \"cos(\" ^ (e ^ \")\")\n  | Average (e1,e2) -> e1 ^ (\"+\" ^ (e2 ^ \"/2\"))\n  | Times (e1,e2) -> e1 ^ (\"*\" ^ e2)\n  | Thresh (e1,e2,e3,e4) -> e1 ^ (\"<\" ^ (e2 ^ (\"?\" ^ (e3 ^ (\":\" ^ e4)))));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin(\" ^ exprToString e ^ \")\"\n| Cosine e -> \"cos(\" ^ e ^ \")\"\n| Average (e1,e2) -> e1 ^ \"+\" ^ e2 ^ \"/2\"\n| Times (e1,e2) -> e1 ^ \"*\" ^ e2\n| Thresh (e1,e2,e3,e4) -> e1^\"<\" ^e2^ \"?\" ^ e3 ^\":\" ^ e4", "out": "Characters 131-132:\n  | Cosine e -> \"cos(\" ^ e ^ \")\"\n                         ^\nError: This expression has type expr but an expression was expected of type\n         string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(\" ^ (e ^ \")\")\n  | Average (e1,e2) -> e1 ^ (\"+\" ^ (e2 ^ \"/2\"))\n  | Times (e1,e2) -> e1 ^ (\"*\" ^ e2)\n  | Thresh (e1,e2,e3,e4) -> e1 ^ (\"<\" ^ (e2 ^ (\"?\" ^ (e3 ^ (\":\" ^ e4)))));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin(\" ^ exprToString e ^ \")\"\n| Cosine e -> \"cos(\" ^ exprToString e ^ \")\"\n| Average (e1,e2) -> exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"/2\"\n| Times (e1,e2) -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1,e2,e3,e4) -> e1^\"<\" ^e2^ \"?\" ^ e3 ^\":\" ^ e4", "out": "Characters 305-307:\n  | Thresh (e1,e2,e3,e4) -> e1^\"<\" ^e2^ \"?\" ^ e3 ^\":\" ^ e4;;\n                            ^^\nError: This expression has type expr but an expression was expected of type\n         string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) -> (exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2\"))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) -> e1 ^ (\"<\" ^ (e2 ^ (\"?\" ^ (e3 ^ (\":\" ^ e4)))));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin(\" ^ exprToString e ^ \")\"\n| Cosine e -> \"cos(\" ^ exprToString e ^ \")\"\n| Average (e1,e2) -> exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"/2\"\n| Times (e1,e2) -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1,e2,e3,e4) -> exprToString e1^\"<\" ^exprToString e2^ \"?\" ^ exprToString e3 ^\":\" ^ exprToString e4", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) -> (exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2\"))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        (\"<\" ^\n           ((exprToString e2) ^\n              (\"?\" ^ ((exprToString e3) ^ (\":\" ^ (exprToString e4))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin(pi\" ^ exprToString e ^ \")\"\n| Cosine e -> \"cos(pi\" ^ exprToString e ^ \")\"\n| Average (e1,e2) -> exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"/2\"\n| Times (e1,e2) -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1,e2,e3,e4) -> exprToString e1^\"<\" ^exprToString e2^ \"?\" ^ exprToString e3 ^\":\" ^ exprToString e4", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) -> (exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2\"))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        (\"<\" ^\n           ((exprToString e2) ^\n              (\"?\" ^ ((exprToString e3) ^ (\":\" ^ (exprToString e4))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1,e2) -> exprToString e1 ^ \"+\" ^ exprToString e2 ^ \"/2\"\n| Times (e1,e2) -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1,e2,e3,e4) -> exprToString e1^\"<\" ^exprToString e2^ \"?\" ^ exprToString e3 ^\":\" ^ exprToString e4", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) -> (exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2\"))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        (\"<\" ^\n           ((exprToString e2) ^\n              (\"?\" ^ ((exprToString e3) ^ (\":\" ^ (exprToString e4))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1,e2) -> \"((\"^exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1,e2) -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1,e2,e3,e4) -> exprToString e1^\"<\" ^exprToString e2^ \"?\" ^ exprToString e3 ^\":\" ^ exprToString e4", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      (exprToString e1) ^\n        (\"<\" ^\n           ((exprToString e2) ^\n              (\"?\" ^ ((exprToString e3) ^ (\":\" ^ (exprToString e4))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1,e2) -> \"((\"^exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1,e2) -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\" ^ exprToString e1^\"<\" ^exprToString e2^ \"?\" ^ exprToString e3 ^\":\" ^ exprToString e4 ^ \")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildX()                       = VarX", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*. eval e)\n| Cosine e-> cos(pi*. eval e)\n| Average (e1,e2) -> (eval e1 +. eval e2) /. 2\n| Times (e1,e2) -> eval e1 *. eval e2\n| Thresh (e1,e2,e3,e4) -> if eval e1 < eval e2 then eval e3 else eval e4", "out": "Characters 86-87:\n  | Sine e -> sin(pi*. eval e)\n                            ^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'a\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval e))\n  | Cosine e -> cos (pi *. (eval e))\n  | Average (e1,e2) -> ((eval e1) +. (eval e2)) /. 2\n  | Times (e1,e2) -> (eval e1) *. (eval e2)\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval e1) < (eval e2) then eval e3 else eval e4;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*. eval(e,x,y))\n| Cosine e-> cos(pi*. eval(e,x,y))\n| Average (e1,e2) -> (eval(e,x,y) +. eval(e,x,y)) /. 2\n| Times (e1,e2) -> eval(e,x,y) *. eval(e,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e,x,y) < eval(e,x,y) then eval(e,x,y) else eval(e,x,y)", "out": "Characters 182-183:\n  | Average (e1,e2) -> (eval(e,x,y) +. eval(e,x,y)) /. 2\n                                                       ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e, x, y)) +. (eval (e, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e, x, y)) *. (eval (e, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e, x, y)) < (eval (e, x, y))\n      then eval (e, x, y)\n      else eval (e, x, y);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*. eval(e,x,y))\n| Cosine e-> cos(pi*. eval(e,x,y))\n| Average (e1,e2) -> (eval(e,x,y) +. eval(e,x,y)) /. 2.\n| Times (e1,e2) -> eval(e,x,y) *. eval(e,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e,x,y) < eval(e,x,y) then eval(e,x,y) else eval(e,x,y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e, x, y)) +. (eval (e, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e, x, y)) *. (eval (e, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e, x, y)) < (eval (e, x, y))\n      then eval (e, x, y)\n      else eval (e, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*. e)\n| Cosine e-> cos(pi*. e)\n| Average (e1,e2) -> (eval(e,x,y) +. eval(e,x,y)) /. 2.\n| Times (e1,e2) -> eval(e,x,y) *. eval(e,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e,x,y) < eval(e,x,y) then eval(e,x,y) else eval(e,x,y)", "out": "Characters 81-82:\n  | Sine e -> sin(pi*. e)\n                       ^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. e)\n  | Cosine e -> cos (pi *. e)\n  | Average (e1,e2) -> ((eval (e, x, y)) +. (eval (e, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e, x, y)) *. (eval (e, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e, x, y)) < (eval (e, x, y))\n      then eval (e, x, y)\n      else eval (e, x, y);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*. eval(e,x,y))\n| Cosine e-> cos(pi*. eval(e,x,y))\n| Average (e1,e2) -> (eval(e,x,y) +. eval(e,x,y)) /. 2.\n| Times (e1,e2) -> eval(e,x,y) *. eval(e,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e,x,y) < eval(e,x,y) then eval(e,x,y) else eval(e,x,y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e, x, y)) +. (eval (e, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e, x, y)) *. (eval (e, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e, x, y)) < (eval (e, x, y))\n      then eval (e, x, y)\n      else eval (e, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*. eval(e,x,y))\n| Cosine e-> cos(pi*. eval(e,x,y))\n| Average (e1,e2) -> (eval(e,x,y) +. eval(e,x,y)) /. 2.\n| Times (e1,e2) -> eval(e,x,y) *. eval(e,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e,x,y) < eval(e,x,y) then eval(e,x,y) else eval(e,x,y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e, x, y)) +. (eval (e, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e, x, y)) *. (eval (e, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e, x, y)) < (eval (e, x, y))\n      then eval (e, x, y)\n      else eval (e, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*. eval(e,x,y))\n| Cosine e-> cos(pi*. eval(e,x,y))\n| Average (e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.\n| Times (e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | (s,i)::t -> if s = k then i else assoc (d, k, t) | [] -> d;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth = 0 || depth = 1 then\nlet r = rand(0,1) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,7) in\nmatch r with\n| 2 -> buildSine(build(rand,depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if (depth = 0) || (depth = 1)\n  then let r = rand (0, 1) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 7) in\n     match r with | 2 -> buildSine (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth = 0 || depth = 1 then\nlet r = rand(0,1) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,7) in\nmatch r with\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if (depth = 0) || (depth = 1)\n  then let r = rand (0, 1) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 7) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if (depth = 0) || (depth = 1)\n  then let r = rand (0, 1) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 7) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth = 0 || depth = 1 then\nlet r = rand(0,1) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,7) in\nmatch r with\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if (depth = 0) || (depth = 1)\n  then let r = rand (0, 1) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 7) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if (depth = 0) || (depth = 1)\n  then let r = rand (0, 1) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 7) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if (depth = 0) || (depth = 1)\n  then let r = rand (0, 1) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 7) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if (depth = 0) || (depth = 1)\n  then let r = rand (0, 1) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 7) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | (s,i)::t -> if s = k then i else assoc (d, k, t) | [] -> d;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if (depth = 0) || (depth = 1)\n  then let r = rand (0, 1) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 7) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Squared  of expr\n| Root     of expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*. eval(e,x,y))\n| Cosine e-> cos(pi*. eval(e,x,y))\n| Average (e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.\n| Times (e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Squared e -> eval(e ** 2)\n| Root e -> eval(e ** (1/2))", "out": "Characters 348-349:\n  | Squared e -> eval(e ** 2)\n                      ^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> eval (e ** 2)\n  | Root e -> eval (e ** (1 / 2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*. eval(e,x,y))\n| Cosine e-> cos(pi*. eval(e,x,y))\n| Average (e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.\n| Times (e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Squared e -> (eval(e) ** 2)\n| Root e -> (eval(e) ** (1/2))", "out": "Characters 348-351:\n  | Squared e -> (eval(e) ** 2)\n                      ^^^\nError: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval e) ** 2\n  | Root e -> (eval e) ** (1 / 2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*. eval(e,x,y))\n| Cosine e-> cos(pi*. eval(e,x,y))\n| Average (e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.\n| Times (e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Squared e -> (eval(e,x,y) ** 2)\n| Root e -> (eval(e,x,y) ** (1/2))", "out": "Characters 359-360:\n  | Squared e -> (eval(e,x,y) ** 2)\n                                 ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2\n  | Root e -> (eval (e, x, y)) ** (1 / 2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*. eval(e,x,y))\n| Cosine e-> cos(pi*. eval(e,x,y))\n| Average (e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.\n| Times (e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Squared e -> (eval(e,x,y) ** 2.)\n| Root e -> (eval(e,x,y) ** (1/2))", "out": "Characters 391-396:\n  | Root e -> (eval(e,x,y) ** (1/2));;\n                              ^^^^^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** (1 / 2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*. eval(e,x,y))\n| Cosine e-> cos(pi*. eval(e,x,y))\n| Average (e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.\n| Times (e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Squared e -> (eval(e,x,y) ** 2.)\n| Root e -> (eval(e,x,y) ** 0.5)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildSquared(e)                = Squared(e)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet buildSquared e = Squared e;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth = 0 || depth = 1 then\nlet r = rand(0,1) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,9) in\nmatch r with\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 -> buildSquared(build(rand,depth-1))\n| 8 -> buildRoot(build(rand,depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildRoot e = Root e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquared e = Squared e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if (depth = 0) || (depth = 1)\n  then let r = rand (0, 1) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 9) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildSquared (build (rand, (depth - 1)))\n     | 8 -> buildRoot (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth = 0 || depth = 1 then\nlet r = rand(0,1) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,9) in\nmatch r with\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 -> buildSquared(build(rand,depth-1))\n| 8 -> buildRoot(build(rand,depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildRoot e = Root e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquared e = Squared e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if (depth = 0) || (depth = 1)\n  then let r = rand (0, 1) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 9) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildSquared (build (rand, (depth - 1)))\n     | 8 -> buildRoot (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | (s,i)::t -> if s = k then i else assoc (d, k, t) | [] -> d;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildRoot e = Root e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquared e = Squared e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if (depth = 0) || (depth = 1)\n  then let r = rand (0, 1) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 9) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildSquared (build (rand, (depth - 1)))\n     | 8 -> buildRoot (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Squared e -> \"(\" ^ ((exprToString e) ^ \")^(2)\")\n  | Root e -> \"(\" ^ ((exprToString e) ^ \")^(1/2)\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildRoot e = Root e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquared e = Squared e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if (depth = 0) || (depth = 1)\n  then let r = rand (0, 1) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 9) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildSquared (build (rand, (depth - 1)))\n     | 8 -> buildRoot (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Squared e -> \"(\" ^ ((exprToString e) ^ \")^(2)\")\n  | Root e -> \"(\" ^ ((exprToString e) ^ \")^(1/2)\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth = 0 || depth = 1 then\nlet r = rand(0,1) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,7) in\nmatch r with\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 -> buildSquared(build(rand,depth-1))\n| 8 -> buildRoot(build(rand,depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildRoot e = Root e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquared e = Squared e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if (depth = 0) || (depth = 1)\n  then let r = rand (0, 1) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 7) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildSquared (build (rand, (depth - 1)))\n     | 8 -> buildRoot (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | (s,i)::t -> if s = k then i else assoc (d, k, t) | [] -> d;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | (s,i)::t -> if s = k then i else assoc (d, k, t) | [] -> d;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*. eval(e,x,y))\n| Cosine e-> cos(pi*. eval(e,x,y))\n| Average (e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.\n| Times (e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Squared e -> (eval(e,x,y) ** 2.)\n| Root e -> (eval(e,x,y) ** 0.5)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi*. eval(e,x,y))\n| Cosine e-> cos(pi*. eval(e,x,y))\n| Average (e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.\n| Times (e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Squared e -> (eval(e,x,y) ** 2.)\n| Root e -> (eval(e,x,y) ** 0.5)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth = 0 || depth = 1 then\nlet r = rand(0,1) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,15) in\nmatch r with\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 -> buildSquared(build(rand,depth-1))\n| 8 -> buildRoot(build(rand,depth-1))\n| 9 -> buildSine(build(rand,depth-1))\n| 10 -> buildCosine(build(rand,depth-1))\n| 11 -> buildSine(build(rand,depth-1))\n| 12 -> buildCosine(build(rand,depth-1))\n| 13 -> buildSine(build(rand,depth-1))\n| 14 -> buildCosine(build(rand,depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildRoot e = Root e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquared e = Squared e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if (depth = 0) || (depth = 1)\n  then let r = rand (0, 1) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 15) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildSquared (build (rand, (depth - 1)))\n     | 8 -> buildRoot (build (rand, (depth - 1)))\n     | 9 -> buildSine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildSine (build (rand, (depth - 1)))\n     | 12 -> buildCosine (build (rand, (depth - 1)))\n     | 13 -> buildSine (build (rand, (depth - 1)))\n     | 14 -> buildCosine (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth = 0 || depth = 1 || depth = 4 || depth = 5 then\nlet r = rand(0,1) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,15) in\nmatch r with\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 -> buildSquared(build(rand,depth-1))\n| 8 -> buildRoot(build(rand,depth-1))\n| 9 -> buildSine(build(rand,depth-1))\n| 10 -> buildCosine(build(rand,depth-1))\n| 11 -> buildSine(build(rand,depth-1))\n| 12 -> buildCosine(build(rand,depth-1))\n| 13 -> buildSine(build(rand,depth-1))\n| 14 -> buildCosine(build(rand,depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildRoot e = Root e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquared e = Squared e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if (depth = 0) || ((depth = 1) || ((depth = 4) || (depth = 5)))\n  then let r = rand (0, 1) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 15) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildSquared (build (rand, (depth - 1)))\n     | 8 -> buildRoot (build (rand, (depth - 1)))\n     | 9 -> buildSine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildSine (build (rand, (depth - 1)))\n     | 12 -> buildCosine (build (rand, (depth - 1)))\n     | 13 -> buildSine (build (rand, (depth - 1)))\n     | 14 -> buildCosine (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth = 0 || depth = 1 || depth = 4 || depth = 5 then\nlet r = rand(0,1) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,15) in\nmatch r with\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 -> buildSquared(build(rand,depth-1))\n| 8 -> buildRoot(build(rand,depth-1))\n| 9 -> buildSine(build(rand,depth-1))\n| 10 -> buildCosine(build(rand,depth-1))\n| 11 -> buildSine(build(rand,depth-1))\n| 12 -> buildCosine(build(rand,depth-1))\n| 13 -> buildSine(build(rand,depth-1))\n| 14 -> buildCosine(build(rand,depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildRoot e = Root e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquared e = Squared e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if (depth = 0) || ((depth = 1) || ((depth = 4) || (depth = 5)))\n  then let r = rand (0, 1) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 15) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildSquared (build (rand, (depth - 1)))\n     | 8 -> buildRoot (build (rand, (depth - 1)))\n     | 9 -> buildSine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildSine (build (rand, (depth - 1)))\n     | 12 -> buildCosine (build (rand, (depth - 1)))\n     | 13 -> buildSine (build (rand, (depth - 1)))\n     | 14 -> buildCosine (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildRoot e = Root e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquared e = Squared e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if (depth = 0) || ((depth = 1) || ((depth = 4) || (depth = 5)))\n  then let r = rand (0, 1) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 15) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildSquared (build (rand, (depth - 1)))\n     | 8 -> buildRoot (build (rand, (depth - 1)))\n     | 9 -> buildSine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildSine (build (rand, (depth - 1)))\n     | 12 -> buildCosine (build (rand, (depth - 1)))\n     | 13 -> buildSine (build (rand, (depth - 1)))\n     | 14 -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Squared e -> \"(\" ^ ((exprToString e) ^ \")^(2)\")\n  | Root e -> \"(\" ^ ((exprToString e) ^ \")^(1/2)\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | (s,i)::t -> if s = k then i else assoc (d, k, t) | [] -> d;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | (s,i)::t -> if s = k then i else assoc (d, k, t) | [] -> d;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | (s,i)::t -> if s = k then i else assoc (d, k, t) | [] -> d;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | (s,i)::t -> if s = k then i else assoc (d, k, t) | [] -> d;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth = 0 || depth = 1 || depth = 3 then\nlet r = rand(0,2) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,15) in\nmatch r with\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 -> buildSquared(build(rand,depth-1))\n| 8 -> buildRoot(build(rand,depth-1))\n| 9 -> buildSine(build(rand,depth-1))\n| 10 -> buildCosine(build(rand,depth-1))\n| 11 -> buildSine(build(rand,depth-1))\n| 12 -> buildCosine(build(rand,depth-1))\n| 13 -> buildSine(build(rand,depth-1))\n| 14 -> buildCosine(build(rand,depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildRoot e = Root e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquared e = Squared e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if (depth = 0) || ((depth = 1) || (depth = 3))\n  then let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 15) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildSquared (build (rand, (depth - 1)))\n     | 8 -> buildRoot (build (rand, (depth - 1)))\n     | 9 -> buildSine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildSine (build (rand, (depth - 1)))\n     | 12 -> buildCosine (build (rand, (depth - 1)))\n     | 13 -> buildSine (build (rand, (depth - 1)))\n     | 14 -> buildCosine (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth = 0 || depth = 1 then\nlet r = rand(0,2) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,15) in\nmatch r with\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 -> buildSquared(build(rand,depth-1))\n| 8 -> buildRoot(build(rand,depth-1))\n| 9 -> buildSine(build(rand,depth-1))\n| 10 -> buildCosine(build(rand,depth-1))\n| 11 -> buildSine(build(rand,depth-1))\n| 12 -> buildCosine(build(rand,depth-1))\n| 13 -> buildSine(build(rand,depth-1))\n| 14 -> buildCosine(build(rand,depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildRoot e = Root e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquared e = Squared e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if (depth = 0) || (depth = 1)\n  then let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 15) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildSquared (build (rand, (depth - 1)))\n     | 8 -> buildRoot (build (rand, (depth - 1)))\n     | 9 -> buildSine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildSine (build (rand, (depth - 1)))\n     | 12 -> buildCosine (build (rand, (depth - 1)))\n     | 13 -> buildSine (build (rand, (depth - 1)))\n     | 14 -> buildCosine (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildRoot e = Root e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquared e = Squared e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if (depth = 0) || (depth = 1)\n  then let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 15) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildSquared (build (rand, (depth - 1)))\n     | 8 -> buildRoot (build (rand, (depth - 1)))\n     | 9 -> buildSine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildSine (build (rand, (depth - 1)))\n     | 12 -> buildCosine (build (rand, (depth - 1)))\n     | 13 -> buildSine (build (rand, (depth - 1)))\n     | 14 -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Squared e -> \"(\" ^ ((exprToString e) ^ \")^(2)\")\n  | Root e -> \"(\" ^ ((exprToString e) ^ \")^(1/2)\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | (s,i)::t -> if s = k then i else assoc (d, k, t) | [] -> d;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildRoot e = Root e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquared e = Squared e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if (depth = 0) || (depth = 1)\n  then let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 15) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildSquared (build (rand, (depth - 1)))\n     | 8 -> buildRoot (build (rand, (depth - 1)))\n     | 9 -> buildSine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildSine (build (rand, (depth - 1)))\n     | 12 -> buildCosine (build (rand, (depth - 1)))\n     | 13 -> buildSine (build (rand, (depth - 1)))\n     | 14 -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Squared e -> \"(\" ^ ((exprToString e) ^ \")^(2)\")\n  | Root e -> \"(\" ^ ((exprToString e) ^ \")^(1/2)\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | (s,i)::t -> if s = k then i else assoc (d, k, t) | [] -> d;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | (s,i)::t -> if s = k then i else assoc (d, k, t) | [] -> d;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nFormat.printf \"heere\";\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildRoot e = Root e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquared e = Squared e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if (depth = 0) || (depth = 1)\n  then let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 15) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildSquared (build (rand, (depth - 1)))\n     | 8 -> buildRoot (build (rand, (depth - 1)))\n     | 9 -> buildSine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildSine (build (rand, (depth - 1)))\n     | 12 -> buildCosine (build (rand, (depth - 1)))\n     | 13 -> buildSine (build (rand, (depth - 1)))\n     | 14 -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Squared e -> \"(\" ^ ((exprToString e) ^ \")^(2)\")\n  | Root e -> \"(\" ^ ((exprToString e) ^ \")^(1/2)\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  Format.printf \"heere\";\n  (let _ = print_string (exprToString e) in\n   let f = eval_fn e in\n   let n = 150 in\n   let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n   emitGrayscale (f, n, name));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nFormat.printf \"heere\";\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildRoot e = Root e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquared e = Squared e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if (depth = 0) || (depth = 1)\n  then let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 15) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildSquared (build (rand, (depth - 1)))\n     | 8 -> buildRoot (build (rand, (depth - 1)))\n     | 9 -> buildSine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildSine (build (rand, (depth - 1)))\n     | 12 -> buildCosine (build (rand, (depth - 1)))\n     | 13 -> buildSine (build (rand, (depth - 1)))\n     | 14 -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Squared e -> \"(\" ^ ((exprToString e) ^ \")^(2)\")\n  | Root e -> \"(\" ^ ((exprToString e) ^ \")^(1/2)\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  Format.printf \"heere\";\n  (let _ = print_string (exprToString e) in\n   let f = eval_fn e in\n   let n = 150 in\n   let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n   emitGrayscale (f, n, name));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | (s,i)::t -> if s = k then i else assoc (d, k, t) | [] -> d;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nFormat.printf \"heere\";\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildRoot e = Root e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquared e = Squared e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if (depth = 0) || (depth = 1)\n  then let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 15) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildSquared (build (rand, (depth - 1)))\n     | 8 -> buildRoot (build (rand, (depth - 1)))\n     | 9 -> buildSine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildSine (build (rand, (depth - 1)))\n     | 12 -> buildCosine (build (rand, (depth - 1)))\n     | 13 -> buildSine (build (rand, (depth - 1)))\n     | 14 -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Squared e -> \"(\" ^ ((exprToString e) ^ \")^(2)\")\n  | Root e -> \"(\" ^ ((exprToString e) ^ \")^(1/2)\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  Format.printf \"heere\";\n  (let _ = print_string (exprToString e) in\n   let f = eval_fn e in\n   let n = 150 in\n   let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n   emitGrayscale (f, n, name));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildRoot e = Root e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquared e = Squared e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if (depth = 0) || (depth = 1)\n  then let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 15) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildSquared (build (rand, (depth - 1)))\n     | 8 -> buildRoot (build (rand, (depth - 1)))\n     | 9 -> buildSine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildSine (build (rand, (depth - 1)))\n     | 12 -> buildCosine (build (rand, (depth - 1)))\n     | 13 -> buildSine (build (rand, (depth - 1)))\n     | 14 -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Squared e -> \"(\" ^ ((exprToString e) ^ \")^(2)\")\n  | Root e -> \"(\" ^ ((exprToString e) ^ \")^(1/2)\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\nFormat.printf(\"here\");\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildRoot e = Root e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquared e = Squared e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if (depth = 0) || (depth = 1)\n  then let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 15) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildSquared (build (rand, (depth - 1)))\n     | 8 -> buildRoot (build (rand, (depth - 1)))\n     | 9 -> buildSine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildSine (build (rand, (depth - 1)))\n     | 12 -> buildCosine (build (rand, (depth - 1)))\n     | 13 -> buildSine (build (rand, (depth - 1)))\n     | 14 -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Squared e -> \"(\" ^ ((exprToString e) ^ \")^(2)\")\n  | Root e -> \"(\" ^ ((exprToString e) ^ \")^(1/2)\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  Format.printf \"here\";\n  (let n = 150 in\n   let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n   emitGrayscale (f, n, name));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildRoot e = Root e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquared e = Squared e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if (depth = 0) || (depth = 1)\n  then let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 15) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildSquared (build (rand, (depth - 1)))\n     | 8 -> buildRoot (build (rand, (depth - 1)))\n     | 9 -> buildSine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildSine (build (rand, (depth - 1)))\n     | 12 -> buildCosine (build (rand, (depth - 1)))\n     | 13 -> buildSine (build (rand, (depth - 1)))\n     | 14 -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Squared e -> \"(\" ^ ((exprToString e) ^ \")^(2)\")\n  | Root e -> \"(\" ^ ((exprToString e) ^ \")^(1/2)\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildRoot e = Root e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquared e = Squared e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if (depth = 0) || (depth = 1)\n  then let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 15) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildSquared (build (rand, (depth - 1)))\n     | 8 -> buildRoot (build (rand, (depth - 1)))\n     | 9 -> buildSine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildSine (build (rand, (depth - 1)))\n     | 12 -> buildCosine (build (rand, (depth - 1)))\n     | 13 -> buildSine (build (rand, (depth - 1)))\n     | 14 -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Squared e -> \"(\" ^ ((exprToString e) ^ \")^(2)\")\n  | Root e -> \"(\" ^ ((exprToString e) ^ \")^(1/2)\");;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi *. eval(e,x,y))\n| Cosine e-> cos(pi *. eval(e,x,y))\n| Average (e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.\n| Times (e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y) \nelse eval(e4,x,y)\n| Squared e -> (eval(e,x,y) ** 2.)\n| Root e -> (eval(e,x,y) ** 0.5)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi *. eval(e,x,y))\n| Cosine e-> cos(pi *. eval(e,x,y))\n| Average (e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y)) / 2\n| Times (e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y) \nelse eval(e4,x,y)\n| Squared e -> (eval(e,x,y) ** 2.)\n| Root e -> (eval(e,x,y) ** 0.5)", "out": "Characters 152-182:\n  | Average (e1,e2) -> (eval(e1,x,y) +. eval(e2,x,y)) / 2\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi *. eval(e,x,y))\n| Cosine e-> cos(pi *. eval(e,x,y))\n| Average (e1,e2) -> (eval(e1,x,y) + eval(e2,x,y)) / 2\n| Times (e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y) \nelse eval(e4,x,y)\n| Squared e -> (eval(e,x,y) ** 2.)\n| Root e -> (eval(e,x,y) ** 0.5)", "out": "Characters 153-165:\n  | Average (e1,e2) -> (eval(e1,x,y) + eval(e2,x,y)) / 2\n                        ^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) + (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi *. eval(e,x,y))\n| Cosine e-> cos(pi *. eval(e,x,y))\n| Average (e1,e2) -> ((eval(e1,x,y) +. eval(e2,x,y)) /. 2)\n| Times (e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y) \nelse eval(e4,x,y)\n| Squared e -> (eval(e,x,y) ** 2.)\n| Root e -> (eval(e,x,y) ** 0.5)", "out": "Characters 187-188:\n  | Average (e1,e2) -> ((eval(e1,x,y) +. eval(e2,x,y)) /. 2)\n                                                          ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi *. eval(e,x,y))\n| Cosine e-> cos(pi *. eval(e,x,y))\n| Average (e1,e2) -> ((eval(e1,x,y) +. eval(e2,x,y)) /. 2.)\n| Times (e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y) \nelse eval(e4,x,y)\n| Squared e -> (eval(e,x,y) ** 2.)\n| Root e -> (eval(e,x,y) ** 0.5)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi *. eval(e,x,y))\n| Cosine e-> cos(pi *. eval(e,x,y))\n| Average (e1,e2) -> 1.\n| Times (e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y) \nelse eval(e4,x,y)\n| Squared e -> (eval(e,x,y) ** 2.)\n| Root e -> (eval(e,x,y) ** 0.5)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> 1.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi *. eval(e,x,y))\n| Cosine e-> cos(pi *. eval(e,x,y))\n| Average (e1,e2) -> ( (eval(e1,x,y) +. eval(e2,x,y) ) /. 2.)\n| Times (e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> 1.\n| Squared e -> (eval(e,x,y) ** 2.)\n| Root e -> (eval(e,x,y) ** 0.5)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) -> 1.\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi *. eval(e,x,y))\n| Cosine e-> cos(pi *. eval(e,x,y))\n| Average (e1,e2) -> 1.\n| Times (e1,e2) -> 1.\n| Thresh (e1,e2,e3,e4) -> 1.\n| Squared e -> (eval(e,x,y) ** 2.)\n| Root e -> (eval(e,x,y) ** 0.5)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> 1.\n  | Times (e1,e2) -> 1.\n  | Thresh (e1,e2,e3,e4) -> 1.\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> 1.\n| Cosine e-> 1.\n| Average (e1,e2) -> 1.\n| Times (e1,e2) -> 1.\n| Thresh (e1,e2,e3,e4) -> 1.\n| Squared e -> (eval(e,x,y) ** 2.)\n| Root e -> (eval(e,x,y) ** 0.5)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> 1.\n  | Cosine e -> 1.\n  | Average (e1,e2) -> 1.\n  | Times (e1,e2) -> 1.\n  | Thresh (e1,e2,e3,e4) -> 1.\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi *. eval(e,x,y))\n| Cosine e-> cos(pi *. eval(e,x,y))\n| Average (e1,e2) -> ( (eval(e1,x,y) +. eval(e2,x,y) ) /. 2.)\n| Times (e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y) \nelse eval(e4,x,y)\n| Squared e -> (eval(e,x,y) ** 2.)\n| Root e -> (eval(e,x,y) ** 0.5)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> 1.\n| Cosine e-> 1.\n| Average (e1,e2) -> ( (eval(e1,x,y) +. eval(e2,x,y) ) /. 2.)\n| Times (e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y) \nelse eval(e4,x,y)\n| Squared e -> (eval(e,x,y) ** 2.)\n| Root e -> (eval(e,x,y) ** 0.5)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> 1.\n  | Cosine e -> 1.\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi *. eval(e,x,y))\n| Cosine e-> cos(pi *. eval(e,x,y))\n| Average (e1,e2) -> ( (eval(e1,x,y) +. eval(e2,x,y) ) /. 2.)\n| Times (e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y) \nelse eval(e4,x,y)\n| Squared e -> (eval(e,x,y) ** 2.)\n| Root e -> (eval(e,x,y) ** 0.5)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (true);\nrv", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n\nlet eval_fn e (x,y) = let rv = eval (e, x, y) in assert true; rv;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Root e -> (eval (e, x, y)) ** 0.5;;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth = 0 then\nlet r = rand(0,2) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,15) in\nmatch r with\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 -> buildSquared(build(rand,depth-1))\n| 8 -> buildRoot(build(rand,depth-1))\n| 9 -> buildSine(build(rand,depth-1))\n| 10 -> buildCosine(build(rand,depth-1))\n| 11 -> buildSine(build(rand,depth-1))\n| 12 -> buildCosine(build(rand,depth-1))\n| 13 -> buildSine(build(rand,depth-1))\n| 14 -> buildCosine(build(rand,depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildRoot e = Root e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquared e = Squared e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 15) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildSquared (build (rand, (depth - 1)))\n     | 8 -> buildRoot (build (rand, (depth - 1)))\n     | 9 -> buildSine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildSine (build (rand, (depth - 1)))\n     | 12 -> buildCosine (build (rand, (depth - 1)))\n     | 13 -> buildSine (build (rand, (depth - 1)))\n     | 14 -> buildCosine (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth = 0 || depth = 1 || depth = 3 then\nlet r = rand(0,2) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,15) in\nmatch r with\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 -> buildSquared(build(rand,depth-1))\n| 8 -> buildRoot(build(rand,depth-1))\n| 9 -> buildSine(build(rand,depth-1))\n| 10 -> buildCosine(build(rand,depth-1))\n| 11 -> buildSine(build(rand,depth-1))\n| 12 -> buildCosine(build(rand,depth-1))\n| 13 -> buildSine(build(rand,depth-1))\n| 14 -> buildCosine(build(rand,depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildRoot e = Root e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquared e = Squared e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if (depth = 0) || ((depth = 1) || (depth = 3))\n  then let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 15) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildSquared (build (rand, (depth - 1)))\n     | 8 -> buildRoot (build (rand, (depth - 1)))\n     | 9 -> buildSine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildSine (build (rand, (depth - 1)))\n     | 12 -> buildCosine (build (rand, (depth - 1)))\n     | 13 -> buildSine (build (rand, (depth - 1)))\n     | 14 -> buildCosine (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth = 0 || depth = 1 || depth = 3 || depth = 5 then\nlet r = rand(0,2) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,15) in\nmatch r with\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 -> buildSquared(build(rand,depth-1))\n| 8 -> buildRoot(build(rand,depth-1))\n| 9 -> buildSine(build(rand,depth-1))\n| 10 -> buildCosine(build(rand,depth-1))\n| 11 -> buildSine(build(rand,depth-1))\n| 12 -> buildCosine(build(rand,depth-1))\n| 13 -> buildSine(build(rand,depth-1))\n| 14 -> buildCosine(build(rand,depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildRoot e = Root e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquared e = Squared e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if (depth = 0) || ((depth = 1) || ((depth = 3) || (depth = 5)))\n  then let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 15) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildSquared (build (rand, (depth - 1)))\n     | 8 -> buildRoot (build (rand, (depth - 1)))\n     | 9 -> buildSine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildSine (build (rand, (depth - 1)))\n     | 12 -> buildCosine (build (rand, (depth - 1)))\n     | 13 -> buildSine (build (rand, (depth - 1)))\n     | 14 -> buildCosine (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth = 0 then\nlet r = rand(0,2) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,15) in\nmatch r with\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 -> buildSquared(build(rand,depth-1))\n| 8 -> buildRoot(build(rand,depth-1))\n| 9 -> buildSine(build(rand,depth-1))\n| 10 -> buildCosine(build(rand,depth-1))\n| 11 -> buildSine(build(rand,depth-1))\n| 12 -> buildCosine(build(rand,depth-1))\n| 13 -> buildSine(build(rand,depth-1))\n| 14 -> buildCosine(build(rand,depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildRoot e = Root e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSquared e = Squared e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 15) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildSquared (build (rand, (depth - 1)))\n     | 8 -> buildRoot (build (rand, (depth - 1)))\n     | 9 -> buildSine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildSine (build (rand, (depth - 1)))\n     | 12 -> buildCosine (build (rand, (depth - 1)))\n     | 13 -> buildSine (build (rand, (depth - 1)))\n     | 14 -> buildCosine (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth = 0 then\nlet r = rand(0,2) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,13) in\nmatch r with\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 -> buildSine(build(rand,depth-1))\n| 8 -> buildCosine(build(rand,depth-1))\n| 9 -> buildSine(build(rand,depth-1))\n| 10 -> buildCosine(build(rand,depth-1))\n| 11 -> buildSine(build(rand,depth-1))\n| 12 -> buildCosine(build(rand,depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Root of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 13) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildSine (build (rand, (depth - 1)))\n     | 8 -> buildCosine (build (rand, (depth - 1)))\n     | 9 -> buildSine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildSine (build (rand, (depth - 1)))\n     | 12 -> buildCosine (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | (s,i)::t -> if s = k then i else assoc (d, k, t) | [] -> d;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | (s,i)::t -> if s = k then i else assoc (d, k, t) | [] -> d;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | (s,i)::t -> if s = k then i else assoc (d, k, t) | [] -> d;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | (s,i)::t -> if s = k then i else assoc (d, k, t) | [] -> d;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin(pi*\" ^ exprToString e ^ \")\"\n| Cosine e -> \"cos(pi*\" ^ exprToString e ^ \")\"\n| Average (e1,e2) -> \"((\"^exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1,e2) -> exprToString e1 ^ \"*\" ^ exprToString e2\n| Thresh (e1,e2,e3,e4) -> \"(\" ^ exprToString e1^\"<\" ^exprToString e2^ \"?\" ^ exprToString e3 ^\":\" ^ exprToString e4 ^ \")\"\n| Squared e -> \"(\" ^ exprToString e ^ \")^(2)\"\n| Flatten (e1,e2,e3) -> \"(\" ^ exprToString e1 ^ \"/\" ^ exprToString e2 ^ \"/\" ^ exprToString e3 ^ \")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Flatten of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Squared e -> \"(\" ^ ((exprToString e) ^ \")^(2)\")\n  | Flatten (e1,e2,e3) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"/\" ^ ((exprToString e2) ^ (\"/\" ^ ((exprToString e3) ^ \")\")))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildFlatten(e)                = Flatten(e1,e2,e3)", "out": "Characters 45-47:\n  let buildFlatten(e)                = Flatten(e1,e2,e3);;\n                                               ^^\nError: Unbound value e1\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Flatten of expr* expr* expr;;\n\nlet buildFlatten e = Flatten (e1, e2, e3);;\n", "type": "scope"}, {"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi *. eval(e,x,y))\n| Cosine e-> cos(pi *. eval(e,x,y))\n| Average (e1,e2) -> ( (eval(e1,x,y) +. eval(e2,x,y) ) /. 2.)\n| Times (e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y) \nelse eval(e4,x,y)\n| Squared e -> (eval(e,x,y) ** 2.)\n| Flatten (e1,e2,e3) -> (eval(e1,x,y) / eval(e2,x,y)/ eval(e3,x,y))", "out": "Characters 396-408:\n  | Flatten (e1,e2,e3) -> (eval(e1,x,y) / eval(e2,x,y)/ eval(e3,x,y));;\n                           ^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Flatten of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Flatten (e1,e2,e3) ->\n      ((eval (e1, x, y)) / (eval (e2, x, y))) / (eval (e3, x, y));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let buildFlatten(e1,e2,e3)         = Flatten(e1,e2,e3)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Flatten of expr* expr* expr;;\n\nlet buildFlatten (e1,e2,e3) = Flatten (e1, e2, e3);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi *. eval(e,x,y))\n| Cosine e-> cos(pi *. eval(e,x,y))\n| Average (e1,e2) -> ( (eval(e1,x,y) +. eval(e2,x,y) ) /. 2.)\n| Times (e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y) \nelse eval(e4,x,y)\n| Squared e -> (eval(e,x,y) ** 2.)\n| Flatten (e1,e2,e3) -> (eval(e1,x,y) /. eval(e2,x,y)/. eval(e3,x,y))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Flatten of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Flatten (e1,e2,e3) ->\n      ((eval (e1, x, y)) /. (eval (e2, x, y))) /. (eval (e3, x, y));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e -> sin(pi *. eval(e,x,y))\n| Cosine e-> cos(pi *. eval(e,x,y))\n| Average (e1,e2) -> ( (eval(e1,x,y) +. eval(e2,x,y) ) /. 2.)\n| Times (e1,e2) -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> if eval(e1,x,y) < eval(e2,x,y) \nthen eval(e3,x,y) \nelse eval(e4,x,y)\n| Squared e -> (eval(e,x,y) ** 2.)\n| Flatten (e1,e2,e3) -> (eval(e1,x,y) /. eval(e2,x,y)/. eval(e3,x,y))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Flatten of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Squared e -> (eval (e, x, y)) ** 2.\n  | Flatten (e1,e2,e3) ->\n      ((eval (e1, x, y)) /. (eval (e2, x, y))) /. (eval (e3, x, y));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth = 0 then\nlet r = rand(0,2) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,14) in\nmatch r with\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 -> buildSine(build(rand,depth-1))\n| 8 -> buildCosine(build(rand,depth-1))\n| 9 -> buildSine(build(rand,depth-1))\n| 10 -> buildCosine(build(rand,depth-1))\n| 11 -> buildSine(build(rand,depth-1))\n| 12 -> buildCosine(build(rand,depth-1))\n| 13 -> buildFlatten(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Flatten of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildFlatten (e1,e2,e3) = Flatten (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 14) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildSine (build (rand, (depth - 1)))\n     | 8 -> buildCosine (build (rand, (depth - 1)))\n     | 9 -> buildSine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildSine (build (rand, (depth - 1)))\n     | 12 -> buildCosine (build (rand, (depth - 1)))\n     | 13 ->\n         buildFlatten\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Squared  of expr\n| Negative of expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Negative of expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nif depth = 0 then\nlet r = rand(0,2) in\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet r = rand(2,13) in\nmatch r with\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 7 -> buildSine(build(rand,depth-1))\n| 8 -> buildCosine(build(rand,depth-1))\n| 9 -> buildSine(build(rand,depth-1))\n| 10 -> buildCosine(build(rand,depth-1))\n| 11 -> buildSine(build(rand,depth-1))\n| 12 -> buildCosine(build(rand,depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Squared of expr\n  | Negative of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let r = rand (2, 13) in\n     match r with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 -> buildSine (build (rand, (depth - 1)))\n     | 8 -> buildCosine (build (rand, (depth - 1)))\n     | 9 -> buildSine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildSine (build (rand, (depth - 1)))\n     | 12 -> buildCosine (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | (s,i)::t -> if s = k then i else assoc (d, k, t) | [] -> d;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| (s,i)::t -> if s = k then i\nelse assoc (d,k,t)\n| [] -> d", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | (s,i)::t -> if s = k then i else assoc (d, k, t) | [] -> d;;\n", "type": ""}]}
