{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = 0 in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = 0 in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x(fs) in\nlet base = a in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x fs in let base = a in List.fold_left f base fs;;\n", "out": "Characters 47-48:\n  let base = a in\n             ^\nError: Unbound value a\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = x(fs) in\nlet base = 0 in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x fs in let base = 0 in List.fold_left f base fs;;\n", "out": "Characters 74-76:\n  List.fold_left f base fs;;\n                        ^^\nError: This expression has type 'a but an expression was expected of type\n         ('a -> int) list\n       The type variable 'a occurs inside ('a -> int) list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = x(fs) in\nlet base = fs in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x fs in let base = fs in List.fold_left f base fs;;\n", "out": "Characters 75-77:\n  List.fold_left f base fs;;\n                        ^^\nError: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x(fs) in\nlet base = a in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x fs in let base = a in List.fold_left f base fs;;\n", "out": "Characters 47-48:\n  let base = a in\n             ^\nError: Unbound value a\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = a+x(fs) in\nlet base = a in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = a + (x fs) in let base = a in List.fold_left f base fs;;\n", "out": "Characters 49-50:\n  let base = a in\n             ^\nError: Unbound value a\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = fs in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "out": "Characters 74-76:\n  List.fold_left f base fs;;\n                        ^^\nError: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = fs(fs) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = fs fs in List.fold_left f base fs;;\n", "out": "Characters 48-52:\n  let base = fs(fs) in\n               ^^^^\nError: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =  x in\nlet base = fun q->q in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base q = q in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =  x in\nlet base = (fun q->q) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base q = q in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =  x(a) in\nlet base = (fun q->q) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base q = q in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x =  a(x) in\nlet base = (fun q->q) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a x in let base q = q in List.fold_left f base fs;;\n", "out": "Characters 76-77:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =  x(a) in\nlet base = (fun q->q) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base q = q in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x =  a(x) in\nlet base = (fun q->q) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a x in let base q = q in List.fold_left f base fs;;\n", "out": "Characters 76-77:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =  x(a) in\nlet base = (fun q->q) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base q = q in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x =  f x(a) in\nlet base = (fun q->q) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = f x a in let base q = q in List.fold_left f base fs;;\n", "out": "Characters 28-29:\n  let f a x =  f x(a) in\n               ^\nError: Unbound value f\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = (fun q->q) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base q = q in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = fun x -> a in\nlet base = (fun q->q) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x x = a in let base q = q in List.fold_left f base fs;;\n", "out": "Characters 81-82:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun w -> x(a) in\nlet base = (fun q->q) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x w = x a in let base q = q in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = fun w -> x(a) in\nlet base = (fun a->q) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x w = x a in let base a = q in List.fold_left f base fs;;\n", "out": "Characters 63-64:\n  let base = (fun a->q) in\n                     ^\nError: Unbound value q\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun w -> x(a) in\nlet base = (fun a->a) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x w = x a in let base a = a in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = (fun a->a) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base a = a in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = (fun a->a) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base a = a in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (fun a->a) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base a = a in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = a x in\nlet base = (fun a->a) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a x in let base a = a in List.fold_left f base fs;;\n", "out": "Characters 74-75:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = fun a -> a x in\nlet base = (fun a->a) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x a = a x in let base a = a in List.fold_left f base fs;;\n", "out": "Characters 85-89:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x a  in\nlet base = a in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n", "out": "Characters 46-47:\n  let base = a in\n             ^\nError: Unbound value a\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x a  in\nlet base = fun s -> a s in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base s = a s in List.fold_left f base fs;;\n", "out": "Characters 55-56:\n  let base = fun s -> a s in\n                      ^\nError: Unbound value a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a  in\nlet base = fun a -> a in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base a = a in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x   in\nlet base = fun a -> a in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base a = a in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = a(x)   in\nlet base = fun a -> a in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a x in let base a = a in List.fold_left f base fs;;\n", "out": "Characters 77-78:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = a x   in\nlet base = fun a -> a in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a x in let base a = a in List.fold_left f base fs;;\n", "out": "Characters 76-77:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = a x   in\nlet base =  a in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a x in let base = a in List.fold_left f base fs;;\n", "out": "Characters 48-49:\n  let base =  a in\n              ^\nError: Unbound value a\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = a x   in\nlet base =  x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a x in let base = x in List.fold_left f base fs;;\n", "out": "Characters 48-49:\n  let base =  x in\n              ^\nError: Unbound value x\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun w -> x(a(w))   in\nlet base = fun a -> a in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x w = x (a w) in let base a = a in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let stringOfList f l = \"[\"^(sepConcat \"; \"(List.map f \"\" l))^\"]\"", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f \"\" l)) ^ \"]\");;\n", "out": "Characters 43-51:\n  let stringOfList f l = \"[\"^(sepConcat \"; \"(List.map f \"\" l))^\"]\";;\n                                             ^^^^^^^^\nError: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let stringOfList f l = \"[\"^(sepConcat \"; \" (List.map f \"\" l))^\"]\"", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f \"\" l)) ^ \"]\");;\n", "out": "Characters 44-52:\n  let stringOfList f l = \"[\"^(sepConcat \"; \" (List.map f \"\" l))^\"]\";;\n                                              ^^^^^^^^\nError: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l = \"[\"^(sepConcat \"; \" (List.map f l))^\"]\"", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec clone x n = if n<1 then return [] \nelse \nlet rec helper acc f x = match x with \n| 0 -> acc\n| _ -> helper (f::acc) f x-1\nin helper [] x n", "min": "\nlet rec clone x n =\n  if n < 1\n  then return []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> (helper (f :: acc) f x) - 1 in\n     helper [] x n);;\n", "out": "Characters 32-38:\n  let rec clone x n = if n<1 then return [] \n                                  ^^^^^^\nError: Unbound value return\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec clone x n = if n<1 then [] \nelse \nlet rec helper acc f x = match x with \n| 0 -> acc\n| _ -> helper (f::acc) f x-1\nin helper [] x n", "min": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> (helper (f :: acc) f x) - 1 in\n     helper [] x n);;\n", "out": "Characters 99-118:\n  | _ -> helper (f::acc) f x-1\n         ^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec clone x n = if n<1 then [] \nelse \nlet rec helper acc f x = match x with \n| 0 -> acc\n| _ -> helper (f::acc) f (x-1)\nin helper [] x n", "min": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let padZero l1 l2 = let x = (List.length l1 - List.length l2) in \nif x then\nif x<0 then\n(((clone 0 (abs x))@l1),l2)\nelse \n(l1,((clone 0 (abs x))@l2))\nelse \n(l1,l2)", "min": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n", "out": "Characters 69-70:\n  if x then\n     ^\nError: This expression has type int but an expression was expected of type\n         bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = let x = (List.length l1 - List.length l2) in \nif x!=0 then\nif x<0 then\n(((clone 0 (abs x))@l1),l2)\nelse \n(l1,((clone 0 (abs x))@l2))\nelse \n(l1,l2)", "min": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l with\n| x::xs -> if x=0 then removeZero xs\nelse xs\n| _ -> l", "min": "\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else xs | _ -> l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l with\n| x::xs -> if x=0 then removeZero xs\nelse l\n| _ -> l", "min": "\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec clone x n = if n<1 then [] \nelse \nlet rec helper acc f x = match x with \n| 0 -> acc\n| _ -> helper (f::acc) f (x-1)\nin helper [] x n", "min": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let args = List.combine (clone List.length l1 List.length l1) (List.combine (List.rev l1) (List.rev l2))", "min": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet args =\n  List.combine (clone List.length l1 List.length l1)\n    (List.combine (List.rev l1) (List.rev l2));;\n", "out": "Characters 25-30:\n  let args = List.combine (clone List.length l1 List.length l1) (List.combine (List.rev l1) (List.rev l2));;\n                           ^^^^^\nError: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (b,c) -> let sum= b+c in \nif sum<10 then \nmatch a with \n| [] -> sum::a\n| x'::xs' -> \nif (x'=-1) then\nif (sum=9) then\n-1::0::xs'\nelse\n(sum+1)::xs'\nelse \nsum::a\nelse\nmatch a with \n| [] -> -1::(sum mod 10)::a\n| x'::xs' -> \nif (x'=-1) then\n-1::(sum mod 10)::a\nelse \n-1::(sum mod 10)::a\n\nin\nlet base = [] in\nlet args = List.combine (clone (List.length l1) (List.length l1)) (List.combine (List.rev l1) (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | [] -> sum :: a\n             | x'::xs' ->\n                 if x' =- 1\n                 then\n                   (if sum = 9 then (-1) :: 0 :: xs' else (sum + 1) :: xs')\n                 else sum :: a)\n          else\n            (match a with\n             | [] -> (-1) :: (sum mod 10) :: a\n             | x'::xs' ->\n                 if x' =- 1\n                 then (-1) :: (sum mod 10) :: a\n                 else (-1) :: (sum mod 10) :: a) in\n    let base = [] in\n    let args =\n      List.combine (clone (List.length l1) (List.length l1))\n        (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 159-161:\n  if (x'=-1) then\n        ^^\nError: Unbound value =-\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (b,c) -> let sum= b+c in \nif sum<10 then \nmatch a with \n| [] -> sum::a\n| x'::xs' -> \nif (x'=(-1)) then\nif (sum=9) then\n-1::0::xs'\nelse\n(sum+1)::xs'\nelse \nsum::a\nelse\nmatch a with \n| [] -> -1::(sum mod 10)::a\n| x'::xs' -> \nif (x'=-1) then\n-1::(sum mod 10)::a\nelse \n-1::(sum mod 10)::a\n\nin\nlet base = [] in\nlet args = List.combine (clone (List.length l1) (List.length l1)) (List.combine (List.rev l1) (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | [] -> sum :: a\n             | x'::xs' ->\n                 if x' = (-1)\n                 then\n                   (if sum = 9 then (-1) :: 0 :: xs' else (sum + 1) :: xs')\n                 else sum :: a)\n          else\n            (match a with\n             | [] -> (-1) :: (sum mod 10) :: a\n             | x'::xs' ->\n                 if x' =- 1\n                 then (-1) :: (sum mod 10) :: a\n                 else (-1) :: (sum mod 10) :: a) in\n    let base = [] in\n    let args =\n      List.combine (clone (List.length l1) (List.length l1))\n        (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 296-298:\n  if (x'=-1) then\n        ^^\nError: Unbound value =-\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (b,c) -> let sum= b+c in \nif sum<10 then \nmatch a with \n| [] -> sum::a\n| x'::xs' -> \nif (x'=(-1)) then\nif (sum=9) then\n-1::0::xs'\nelse\n(sum+1)::xs'\nelse \nsum::a\nelse\nmatch a with \n| [] -> -1::(sum mod 10)::a\n| x'::xs' -> \nif (x'=(-1)) then\n-1::(sum mod 10)::a\nelse \n-1::(sum mod 10)::a\n\nin\nlet base = [] in\nlet args = List.combine (clone (List.length l1) (List.length l1)) (List.combine (List.rev l1) (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | [] -> sum :: a\n             | x'::xs' ->\n                 if x' = (-1)\n                 then\n                   (if sum = 9 then (-1) :: 0 :: xs' else (sum + 1) :: xs')\n                 else sum :: a)\n          else\n            (match a with\n             | [] -> (-1) :: (sum mod 10) :: a\n             | x'::xs' ->\n                 if x' = (-1)\n                 then (-1) :: (sum mod 10) :: a\n                 else (-1) :: (sum mod 10) :: a) in\n    let base = [] in\n    let args =\n      List.combine (clone (List.length l1) (List.length l1))\n        (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 524-528:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type (int * ('a * 'b)) list\n       but an expression was expected of type (int * int) list\n       Type 'a * 'b is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d,(b,c)) -> let sum= b+c in \nif sum<10 then \nmatch a with \n| [] -> sum::a\n| x'::xs' -> \nif (x'=(-1)) then\nif (sum=9) then\n-1::0::xs'\nelse\n(sum+1)::xs'\nelse \nsum::a\nelse\nmatch a with \n| [] -> -1::(sum mod 10)::a\n| x'::xs' -> \nif (x'=(-1)) then\n-1::(sum mod 10)::a\nelse \n-1::(sum mod 10)::a\n\nin\nlet base = [] in\nlet args = List.combine (clone (List.length l1) (List.length l1)) (List.combine (List.rev l1) (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d,(b,c)) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | [] -> sum :: a\n             | x'::xs' ->\n                 if x' = (-1)\n                 then\n                   (if sum = 9 then (-1) :: 0 :: xs' else (sum + 1) :: xs')\n                 else sum :: a)\n          else\n            (match a with\n             | [] -> (-1) :: (sum mod 10) :: a\n             | x'::xs' ->\n                 if x' = (-1)\n                 then (-1) :: (sum mod 10) :: a\n                 else (-1) :: (sum mod 10) :: a) in\n    let base = [] in\n    let args =\n      List.combine (clone (List.length l1) (List.length l1))\n        (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 506-532:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d,(b,c)) -> let sum= b+c in \nif sum<10 then \nmatch a with \n| [] -> sum::a\n| x'::xs' -> \nif (x'=(-1)) then\nif (sum=9) then\n-1::0::xs'\nelse\n(sum+1)::xs'\nelse \nsum::a\nelse\nmatch a with \n| [] -> -1::(sum mod 10)::a\n| x'::xs' -> \nif (x'=(-1)) then\n-1::(sum mod 10)::a\nelse \n-1::(sum mod 10)::a\n\nin\nlet base = [] in\nlet args = List.combine (clone (List.length l1) (List.length l1)) (List.combine (List.rev l1) (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d,(b,c)) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | [] -> sum :: a\n             | x'::xs' ->\n                 if x' = (-1)\n                 then\n                   (if sum = 9 then (-1) :: 0 :: xs' else (sum + 1) :: xs')\n                 else sum :: a)\n          else\n            (match a with\n             | [] -> (-1) :: (sum mod 10) :: a\n             | x'::xs' ->\n                 if x' = (-1)\n                 then (-1) :: (sum mod 10) :: a\n                 else (-1) :: (sum mod 10) :: a) in\n    let base = [] in\n    let args =\n      List.combine (clone (List.length l1) (List.length l1))\n        (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 506-532:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d,(b,c)) -> let sum= b+c in \nif sum<10 then \nmatch a with \n| [] -> sum::a\n| x'::xs' -> \nif (x'=(-1)) then\nif (sum=9) then\n-1::0::xs'\nelse\n(sum+1)::xs'\nelse \nsum::a\nelse\nmatch a with \n| [] -> -1::(sum mod 10)::a\n| x'::xs' -> \nif (x'=(-1)) then\n-1::(sum mod 10)::a\nelse \n-1::(sum mod 10)::a\n\nin\nlet base = (List.length l1,[]) in\nlet args = List.combine (clone (List.length l1) (List.length l1)) (List.combine (List.rev l1) (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d,(b,c)) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | [] -> sum :: a\n             | x'::xs' ->\n                 if x' = (-1)\n                 then\n                   (if sum = 9 then (-1) :: 0 :: xs' else (sum + 1) :: xs')\n                 else sum :: a)\n          else\n            (match a with\n             | [] -> (-1) :: (sum mod 10) :: a\n             | x'::xs' ->\n                 if x' = (-1)\n                 then (-1) :: (sum mod 10) :: a\n                 else (-1) :: (sum mod 10) :: a) in\n    let base = ((List.length l1), []) in\n    let args =\n      List.combine (clone (List.length l1) (List.length l1))\n        (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 540-544:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type int * 'a list\n       but an expression was expected of type int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (b,c) -> let sum= b+c in \nif sum<10 then \nmatch a with \n| (len,[]) -> (len,[sum])\n| (len,x'::xs') -> \nif (x'=(-1)) then\nif (sum=9) then\n(len,-1::0::xs')\nelse\n(len,(sum+1)::xs')\nelse \n(len,sum::a)\nelse\nmatch a with \n| (len,[]) -> (len,-1::[(sum mod 10)])\n| (len,x'::xs') -> \nif (x'=(-1)) then\n-1::((sum mod 10)+1)::a\nelse \n(len,-1::(sum mod 10)::x'::xs')\n\nin\nlet base = (List.length l1,[]) in\nlet args = (List.combine (List.rev l1) (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | (len,[]) -> (len, [sum])\n             | (len,x'::xs') ->\n                 if x' = (-1)\n                 then\n                   (if sum = 9\n                    then (len, ((-1) :: 0 :: xs'))\n                    else (len, ((sum + 1) :: xs')))\n                 else (len, (sum :: a)))\n          else\n            (match a with\n             | (len,[]) -> (len, [(-1); sum mod 10])\n             | (len,x'::xs') ->\n                 if x' = (-1)\n                 then (-1) :: ((sum mod 10) + 1) :: a\n                 else (len, ((-1) :: (sum mod 10) :: x' :: xs'))) in\n    let base = ((List.length l1), []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 261-262:\n  (len,sum::a)\n            ^\nError: This expression has type 'a * int list\n       but an expression was expected of type int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (b,c) -> let sum= b+c in \nif sum<10 then \nmatch a with \n| (len,[]) -> (len,[sum])\n| (len,x'::xs') -> \nif (x'=(-1)) then\nif (sum=9) then\n(len,-1::0::xs')\nelse\n(len,(sum+1)::xs')\nelse \n(len,sum::x'::xs')\nelse\nmatch a with \n| (len,[]) -> (len,-1::[(sum mod 10)])\n| (len,x'::xs') -> \nif (x'=(-1)) then\n-1::((sum mod 10)+1)::a\nelse \n(len,-1::(sum mod 10)::x'::xs')\n\nin\nlet base = (List.length l1,[]) in\nlet args = (List.combine (List.rev l1) (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | (len,[]) -> (len, [sum])\n             | (len,x'::xs') ->\n                 if x' = (-1)\n                 then\n                   (if sum = 9\n                    then (len, ((-1) :: 0 :: xs'))\n                    else (len, ((sum + 1) :: xs')))\n                 else (len, (sum :: x' :: xs')))\n          else\n            (match a with\n             | (len,[]) -> (len, [(-1); sum mod 10])\n             | (len,x'::xs') ->\n                 if x' = (-1)\n                 then (-1) :: ((sum mod 10) + 1) :: a\n                 else (len, ((-1) :: (sum mod 10) :: x' :: xs'))) in\n    let base = ((List.length l1), []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 366-389:\n  -1::((sum mod 10)+1)::a\n  ^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b * int list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (b,c) -> let sum= b+c in \nif sum<10 then \nmatch a with \n| (len,[]) -> (len,[sum])\n| (len,x'::xs') -> \nif (x'=(-1)) then\nif (sum=9) then\n(len,-1::0::xs')\nelse\n(len,(sum+1)::xs')\nelse \n(len,sum::x'::xs')\nelse\nmatch a with \n| (len,[]) -> (len,-1::[(sum mod 10)])\n| (len,x'::xs') -> \nif (x'=(-1)) then\n(len,-1::((sum mod 10)+1)::xs')\nelse \n(len,-1::(sum mod 10)::x'::xs')\n\nin\nlet base = (List.length l1,[]) in\nlet args = (List.combine (List.rev l1) (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | (len,[]) -> (len, [sum])\n             | (len,x'::xs') ->\n                 if x' = (-1)\n                 then\n                   (if sum = 9\n                    then (len, ((-1) :: 0 :: xs'))\n                    else (len, ((sum + 1) :: xs')))\n                 else (len, (sum :: x' :: xs')))\n          else\n            (match a with\n             | (len,[]) -> (len, [(-1); sum mod 10])\n             | (len,x'::xs') ->\n                 if x' = (-1)\n                 then (len, ((-1) :: ((sum mod 10) + 1) :: xs'))\n                 else (len, ((-1) :: (sum mod 10) :: x' :: xs'))) in\n    let base = ((List.length l1), []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (b,c) -> let sum= b+c in \nif sum<10 then \nmatch a with \n| (len,[]) -> (len,[sum])\n| (len,x'::xs') -> \nif (x'=(-1)) then\nif (sum=9) then\n(len,-1::0::xs')\nelse\n(len,(sum+1)::xs')\nelse \n(len,sum::x'::xs')\nelse\nmatch a with \n| (len,[]) -> (len,-1::[(sum mod 10)])\n| (len,x'::xs') -> \nif (x'=(-1)) then\n(len,-1::((sum mod 10)+1)::xs')\nelse \n(len,-1::(sum mod 10)::x'::xs')\n\nin\nlet base = (List.length l1,[]) in\nlet args = (List.combine (List.rev l1) (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | (len,[]) -> (len, [sum])\n             | (len,x'::xs') ->\n                 if x' = (-1)\n                 then\n                   (if sum = 9\n                    then (len, ((-1) :: 0 :: xs'))\n                    else (len, ((sum + 1) :: xs')))\n                 else (len, (sum :: x' :: xs')))\n          else\n            (match a with\n             | (len,[]) -> (len, [(-1); sum mod 10])\n             | (len,x'::xs') ->\n                 if x' = (-1)\n                 then (len, ((-1) :: ((sum mod 10) + 1) :: xs'))\n                 else (len, ((-1) :: (sum mod 10) :: x' :: xs'))) in\n    let base = ((List.length l1), []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (b,c) -> let sum= b+c in \nif sum<10 then \nmatch a with \n| (len,[]) -> (len,[sum])\n| (len,x'::xs') -> \nif (len<0) then\nif (sum=9) then\n(-1,1::0::xs')\nelse\n(1,(sum+1)::xs')\nelse \n(1,sum::x'::xs')\nelse\nmatch a with \n| (len,[]) -> (-1,1::[(sum mod 10)])\n| (len,x'::xs') -> \nif (len<0) then\n(-1,1::((sum mod 10)+1)::xs')\nelse \n(-1,1::(sum mod 10)::x'::xs')\n\nin\nlet base = (List.length l1,[]) in\nlet args = (List.combine (List.rev l1) (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | (len,[]) -> (len, [sum])\n             | (len,x'::xs') ->\n                 if len < 0\n                 then\n                   (if sum = 9\n                    then ((-1), (1 :: 0 :: xs'))\n                    else (1, ((sum + 1) :: xs')))\n                 else (1, (sum :: x' :: xs')))\n          else\n            (match a with\n             | (len,[]) -> ((-1), [1; sum mod 10])\n             | (len,x'::xs') ->\n                 if len < 0\n                 then ((-1), (1 :: ((sum mod 10) + 1) :: xs'))\n                 else ((-1), (1 :: (sum mod 10) :: x' :: xs'))) in\n    let base = ((List.length l1), []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec mulByDigit i l = let lre = List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 num::xs' xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::xs' xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 num::accum xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::accum xs\nin helper 0 [] lre", "min": "\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet rec mulByDigit i l =\n  let lre = List.rev l in\n  let rec helper carry accum lrev =\n    match lrev with\n    | [] -> removeZero accum\n    | x::xs ->\n        if carry = 1\n        then\n          (match accum with\n           | x1'::xs' ->\n               let num = (x * i) + x1' in\n               if num < 10\n               then (helper 0 num) :: (xs' xs)\n               else (helper 1 ((num / 10) mod 10)) :: (num mod 10) ::\n                 (xs' xs))\n        else\n          (let num = x * i in\n           if num < 10\n           then (helper 0 num) :: (accum xs)\n           else (helper 1 ((num / 10) mod 10)) :: (num mod 10) :: (accum xs)) in\n  helper 0 [] lre;;\n", "out": "Characters 234-237:\n  helper 0 num::xs' xs\n           ^^^\nError: This expression has type int but an expression was expected of type\n         int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec mulByDigit i l = let lre = List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 num::xs' xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::xs' xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 num::accum xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::accum xs\nin helper 0 [] lre", "min": "\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet rec mulByDigit i l =\n  let lre = List.rev l in\n  let rec helper carry accum lrev =\n    match lrev with\n    | [] -> removeZero accum\n    | x::xs ->\n        if carry = 1\n        then\n          (match accum with\n           | x1'::xs' ->\n               let num = (x * i) + x1' in\n               if num < 10\n               then (helper 0 num) :: (xs' xs)\n               else (helper 1 ((num / 10) mod 10)) :: (num mod 10) ::\n                 (xs' xs))\n        else\n          (let num = x * i in\n           if num < 10\n           then (helper 0 num) :: (accum xs)\n           else (helper 1 ((num / 10) mod 10)) :: (num mod 10) :: (accum xs)) in\n  helper 0 [] lre;;\n", "out": "Characters 234-237:\n  helper 0 num::xs' xs\n           ^^^\nError: This expression has type int but an expression was expected of type\n         int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec mulByDigit i l = let lre = List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 (num::xs') xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::xs' xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 num::accum xs\nelse\nhelper 1 ((num/10) mod 10)::(num mod 10)::accum xs\nin helper 0 [] lre", "min": "\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet rec mulByDigit i l =\n  let lre = List.rev l in\n  let rec helper carry accum lrev =\n    match lrev with\n    | [] -> removeZero accum\n    | x::xs ->\n        if carry = 1\n        then\n          (match accum with\n           | x1'::xs' ->\n               let num = (x * i) + x1' in\n               if num < 10\n               then helper 0 (num :: xs') xs\n               else (helper 1 ((num / 10) mod 10)) :: (num mod 10) ::\n                 (xs' xs))\n        else\n          (let num = x * i in\n           if num < 10\n           then (helper 0 num) :: (accum xs)\n           else (helper 1 ((num / 10) mod 10)) :: (num mod 10) :: (accum xs)) in\n  helper 0 [] lre;;\n", "out": "Characters 262-279:\n  helper 1 ((num/10) mod 10)::(num mod 10)::xs' xs\n           ^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = let lre = List.rev l in\nlet rec helper carry accum lrev =  \nmatch lrev with\n| [] -> removeZero accum\n| x::xs -> \nif(carry=1) then\nmatch accum with x1'::xs' -> \nlet num = (x*i)+ x1' in\nif(num<10) then\nhelper 0 (num::xs') xs\nelse\nhelper 1 (((num/10) mod 10)::(num mod 10)::xs') xs\nelse\nlet num = (x*i) in\nif(num<10) then\nhelper 0 (num::accum) xs\nelse\nhelper 1 (((num/10) mod 10)::(num mod 10)::accum) xs\nin helper 0 [] lre", "min": "\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet rec mulByDigit i l =\n  let lre = List.rev l in\n  let rec helper carry accum lrev =\n    match lrev with\n    | [] -> removeZero accum\n    | x::xs ->\n        if carry = 1\n        then\n          (match accum with\n           | x1'::xs' ->\n               let num = (x * i) + x1' in\n               if num < 10\n               then helper 0 (num :: xs') xs\n               else helper 1 (((num / 10) mod 10) :: (num mod 10) :: xs') xs)\n        else\n          (let num = x * i in\n           if num < 10\n           then helper 0 (num :: accum) xs\n           else helper 1 (((num / 10) mod 10) :: (num mod 10) :: accum) xs) in\n  helper 0 [] lre;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with \n|((num,count),accum)-> ((num,count+1),(bigAdd accum (List.rev((clone 0 count)@(List.rev (mulByDigit x num))))))\nin\nlet base = ((l1,0),[]) in\nlet args =  (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | (len,[]) -> (len, [sum])\n             | (len,x'::xs') ->\n                 if len < 0\n                 then\n                   (if sum = 9\n                    then ((-1), (1 :: 0 :: xs'))\n                    else (1, ((sum + 1) :: xs')))\n                 else (1, (sum :: x' :: xs')))\n          else\n            (match a with\n             | (len,[]) -> ((-1), [1; sum mod 10])\n             | (len,x'::xs') ->\n                 if len < 0\n                 then ((-1), (1 :: ((sum mod 10) + 1) :: xs'))\n                 else ((-1), (1 :: (sum mod 10) :: x' :: xs'))) in\n    let base = ((List.length l1), []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet rec mulByDigit i l =\n  let lre = List.rev l in\n  let rec helper carry accum lrev =\n    match lrev with\n    | [] -> removeZero accum\n    | x::xs ->\n        if carry = 1\n        then\n          (match accum with\n           | x1'::xs' ->\n               let num = (x * i) + x1' in\n               if num < 10\n               then helper 0 (num :: xs') xs\n               else helper 1 (((num / 10) mod 10) :: (num mod 10) :: xs') xs)\n        else\n          (let num = x * i in\n           if num < 10\n           then helper 0 (num :: accum) xs\n           else helper 1 (((num / 10) mod 10) :: (num mod 10) :: accum) xs) in\n  helper 0 [] lre;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | ((num,count),accum) ->\n        ((num, (count + 1)),\n          (bigAdd accum\n             (List.rev ((clone 0 count) @ (List.rev (mulByDigit x num)))))) in\n  let base = ((l1, 0), []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
