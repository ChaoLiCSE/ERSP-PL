{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec sumList xs = \nmatch x with\n| [] -> 0\n| h :: tail -> sumList tail + h", "min": "\nlet rec sumList xs = match x with | [] -> 0 | h::tail -> (sumList tail) + h;;\n", "out": "Characters 28-29:\n  match x with\n        ^\nError: Unbound value x\n"}, {"type": "", "in": "let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"", "min": "\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h :: tail -> sumList tail + h", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::tail -> (sumList tail) + h;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h :: tail -> sumList tail + h", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::tail -> (sumList tail) + h;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h :: tail -> sumList tail + h", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::tail -> (sumList tail) + h;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h :: tail -> sumList tail + h", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::tail -> (sumList tail) + h;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h :: tail -> sumList tail + h", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::tail -> (sumList tail) + h;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \n[digitsOfInt n/10] @ [n mod 10]", "min": "\nlet rec digitsOfInt n = [(digitsOfInt n) / 10] @ [n mod 10];;\n", "out": "Characters 25-56:\n  [digitsOfInt n/10] @ [n mod 10];;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}, {"type": "", "in": "let digits n = digitsOfInt (abs n)", "min": "\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n\nlet digits n = digitsOfInt (abs n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \ndigitsOfInt n/10 @ [n mod 10]", "min": "\nlet rec digitsOfInt n = ((digitsOfInt n) / 10) @ [n mod 10];;\n", "out": "Characters 25-41:\n  digitsOfInt n/10 @ [n mod 10];;\n  ^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}, {"type": "", "in": "let digits n = digitsOfInt (abs n)", "min": "\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n\nlet digits n = digitsOfInt (abs n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \n(digitsOfInt n/10) @ [n mod 10]", "min": "\nlet rec digitsOfInt n = ((digitsOfInt n) / 10) @ [n mod 10];;\n", "out": "Characters 25-43:\n  (digitsOfInt n/10) @ [n mod 10];;\n  ^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}, {"type": "", "in": "let digits n = digitsOfInt (abs n)", "min": "\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n\nlet digits n = digitsOfInt (abs n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \n(n mod 10) :: digitsOfInt n/10", "min": "\nlet rec digitsOfInt n = (n mod 10) :: ((digitsOfInt n) / 10);;\n", "out": "Characters 39-52:\n  (n mod 10) :: digitsOfInt n/10;;\n                ^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}, {"type": "", "in": "let digits n = digitsOfInt (abs n)", "min": "\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n\nlet digits n = digitsOfInt (abs n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \n(n mod 10) :: digitsOfInt (n/10)", "min": "\nlet rec digitsOfInt n = (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \n(digitsOfInt (n/10)) @ [n mod 10]", "min": "\nlet rec digitsOfInt n = (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \n(digitsOfInt (n/10)) @ [n mod 10]", "min": "\nlet rec digitsOfInt n = (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \n(digitsOfInt (n/10)) @ [n mod 10]", "min": "\nlet rec digitsOfInt n = (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \n(digitsOfInt (n/10)) @ [n mod 10]", "min": "\nlet rec digitsOfInt n = (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \n\nif n<=0 then [] \nelse\n(digitsOfInt (n/10)) @ [n mod 10]", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n = \nx = sumList(digits (n))", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::tail -> (sumList tail) + h;;\n\nlet rec additivePersistence n = x = (sumList (digits n));;\n", "out": "Characters 33-34:\n  x = sumList(digits (n));;\n  ^\nError: Unbound value x\n"}, {"type": "scope", "in": "if x<10 then 0  \nelse\n1 + additivePersistence (x)", "min": "\nlet rec additivePersistence n = failwith \"TBD\";;\n\nlet _ = if x < 10 then 0 else 1 + (additivePersistence x);;\n", "out": "Characters 3-4:\n  if x<10 then 0  \n     ^\nError: Unbound value x\n"}, {"type": "", "in": "let rec digitalRoot n = failwith \"TBD\"", "min": "\nlet rec digitalRoot n = failwith \"TBD\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = failwith \"TBD\"", "min": "\nlet rec digitalRoot n = failwith \"TBD\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digits n = digitsOfInt (abs n)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nlet x = sumList(digits (n)) in\nif x<10 then 0  \nelse\n1 + additivePersistence (x)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::tail -> (sumList tail) + h;;\n\nlet rec additivePersistence n =\n  let x = sumList (digits n) in\n  if x < 10 then 0 else 1 + (additivePersistence x);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nlet x = sumList(digits (n)) in\nif x<10 then 0  \nelse\n1 + additivePersistence (x)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::tail -> (sumList tail) + h;;\n\nlet rec additivePersistence n =\n  let x = sumList (digits n) in\n  if x < 10 then 0 else 1 + (additivePersistence x);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n < 10 then 0 \nelse\nlet x = sumList(digits (n)) in\nif x<10 then 1  \nelse\n1 + additivePersistence (x)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::tail -> (sumList tail) + h;;\n\nlet rec additivePersistence n =\n  if n < 10\n  then 0\n  else\n    (let x = sumList (digits n) in\n     if x < 10 then 1 else 1 + (additivePersistence x));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h :: tail -> sumList tail + h", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::tail -> (sumList tail) + h;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n<10 then n\nelse\nlet x= sumList(digits (n)) in\nif x<10 then x\nelse \ndigitalRoot x", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::tail -> (sumList tail) + h;;\n\nlet rec digitalRoot n =\n  if n < 10\n  then n\n  else (let x = sumList (digits n) in if x < 10 then x else digitalRoot x);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nmatch l with\n| [] -> []\n| h :: t -> (listReverse t) @ [h]", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let palindrome w = \nlistReverse explode w == w", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w = (listReverse explode w) == w;;\n", "out": "Characters 20-31:\n  listReverse explode w == w;;\n  ^^^^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let palindrome w = \nlistReverse (explode w) == w", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w = (listReverse (explode w)) == w;;\n", "out": "Characters 47-48:\n  listReverse (explode w) == w;;\n                             ^\nError: This expression has type string but an expression was expected of type\n         char list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \nlistReverse (explode w) == explode w", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w = (listReverse (explode w)) == (explode w);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \nlistReverse (explode w) == explode w", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w = (listReverse (explode w)) == (explode w);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \nlistReverse (explode w) == explode w", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w = (listReverse (explode w)) == (explode w);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \nlistReverse (explode w) == explode w", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w = (listReverse (explode w)) == (explode w);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \nlistReverse (explode w) == explode w", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w = (listReverse (explode w)) == (explode w);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h :: tail -> sumList tail + h", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::tail -> (sumList tail) + h;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h :: tail -> sumList tail + h", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::tail -> (sumList tail) + h;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = failwith \"TBD\"", "min": "\nlet palindrome w = failwith \"TBD\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = failwith \"TBD\"", "min": "\nlet palindrome w = failwith \"TBD\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nmatch l with \n| [] -> []\n| h :: t -> listReverse t @ [h]", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h :: tail -> sumList tail + h", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::tail -> (sumList tail) + h;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h :: tail -> sumList tail + h", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::tail -> (sumList tail) + h;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \nlistReverse ( explode w) == explode w", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w = (listReverse (explode w)) == (explode w);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \nlistReverse ( explode w) == explode w", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w = (listReverse (explode w)) == (explode w);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \nlistReverse ( explode w) = explode w", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w = (listReverse (explode w)) = (explode w);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \nlistReverse ( explode w) = explode w", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w = (listReverse (explode w)) = (explode w);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h :: tail -> sumList tail + h", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::tail -> (sumList tail) + h;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverseA l r =\nmatch l with\n| [] -> []\n| h :: t -> let x= h::r in listReverseA t x", "min": "\nlet rec listReverseA l r =\n  match l with | [] -> [] | h::t -> let x = h :: r in listReverseA t x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nlistReverseA l []", "min": "\nlet rec listReverseA l r =\n  match l with | [] -> [] | h::t -> let x = h :: r in listReverseA t x;;\n\nlet rec listReverse l = listReverseA l [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverseA l r =\nmatch l with\n| [] -> r\n| h :: t -> let x= h::r in listReverseA t x", "min": "\nlet rec listReverseA l r =\n  match l with | [] -> r | h::t -> let x = h :: r in listReverseA t x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nlet rec listReverseA l2 r =\nmatch l2 with\n| [] -> r\n| h :: t -> let x= h::r in listReverseA t x in\nlistReverseA l []", "min": "\nlet rec listReverse l =\n  let rec listReverseA l2 r =\n    match l2 with | [] -> r | h::t -> let x = h :: r in listReverseA t x in\n  listReverseA l [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet rec dOI m l = \nif m<=0 then l \nelse\nlet x = (m mod 10)::l in dOI (m/10) x in\ndOI n []", "min": "\nlet rec digitsOfInt n =\n  let rec dOI m l =\n    if m <= 0 then l else (let x = (m mod 10) :: l in dOI (m / 10) x) in\n  dOI n [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h :: tail -> sumList tail + h", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::tail -> (sumList tail) + h;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nif n < 10 then 0 \nelse\nlet x = sumList(digits (n)) in\n1 + additivePersistence (x)", "min": "\nlet rec digitsOfInt n =\n  let rec dOI m l =\n    if m <= 0 then l else (let x = (m mod 10) :: l in dOI (m / 10) x) in\n  dOI n [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::tail -> (sumList tail) + h;;\n\nlet rec additivePersistence n =\n  if n < 10\n  then 0\n  else (let x = sumList (digits n) in 1 + (additivePersistence x));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nlet rec listReverseA l2 r =\nmatch l2 with\n| [] -> r\n| h :: t -> let x= h::r in listReverseA t x\nin listReverseA l []", "min": "\nlet rec listReverse l =\n  let rec listReverseA l2 r =\n    match l2 with | [] -> r | h::t -> let x = h :: r in listReverseA t x in\n  listReverseA l [];;\n", "out": ""}]}
