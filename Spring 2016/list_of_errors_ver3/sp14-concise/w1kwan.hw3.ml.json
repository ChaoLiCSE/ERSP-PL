{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =  fun x' -> x (a x') in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x x' = x (a x') in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec clone x n = if (n<=0) then [] else [x]@(clone x (n-1))", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let padZero l1 l2 = \nif (List.length l1 > List.length l2) then (padZero l1 ([0]@l2))\nelse if (List.length l1 < List.length l2) then (padZero ([0]@l1) l2)\nelse (l1, l2)", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then padZero l1 ([0] @ l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero ([0] @ l1) l2\n    else (l1, l2);;\n", "out": "Characters 64-71:\n  if (List.length l1 > List.length l2) then (padZero l1 ([0]@l2))\n                                             ^^^^^^^\nError: Unbound value padZero\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let padZero l1 l2 = \nif (List.length l1 > List.length l2) then (padZero l1 ([0]@l2))\nelse if (List.length l1 < List.length l2) then (padZero ([0]@l1) l2)\nelse (l1, l2)", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then padZero l1 ([0] @ l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero ([0] @ l1) l2\n    else (l1, l2);;\n", "out": "Characters 64-71:\n  if (List.length l1 > List.length l2) then (padZero l1 ([0]@l2))\n                                             ^^^^^^^\nError: Unbound value padZero\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec padZero l1 l2 = \nif (List.length l1 > List.length l2) then (padZero l1 ([0]@l2))\nelse if (List.length l1 < List.length l2) then (padZero ([0]@l1) l2)\nelse (l1, l2)", "min": "\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then padZero l1 ([0] @ l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero ([0] @ l1) l2\n    else (l1, l2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = \nmatch l with \n[] -> l\n| head::tail -> if (head = 0) then removeZero tail\nelse head::tail", "min": "\nlet rec removeZero l =\n  match l with\n  | [] -> l\n  | head::tail -> if head = 0 then removeZero tail else head :: tail;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet onesD = (fst x + snd x) mod 10 in \nlet tensD = (fst x + snd x)/10 in\nlet sum = (fst x + snd x) in \nmatch (snd a) with\nhead::tail -> (sum, ((head + fst x + snd x)/10)\n::((head + fst x + snd x) mod 10)::tail)\n| [] -> (sum, [tensD]@[onesD]) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then padZero l1 ([0] @ l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero ([0] @ l1) l2\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> l\n  | head::tail -> if head = 0 then removeZero tail else head :: tail;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let onesD = ((fst x) + (snd x)) mod 10 in\n      let tensD = ((fst x) + (snd x)) / 10 in\n      let sum = (fst x) + (snd x) in\n      match snd a with\n      | head::tail ->\n          (sum, ((((head + (fst x)) + (snd x)) / 10) ::\n            (((head + (fst x)) + (snd x)) mod 10) :: tail))\n      | [] -> (sum, ([tensD] @ [onesD])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nif (i<=0) then []\nelse if i = 1 then l\nelse if i = 2 then bigAdd l l\nelse bigAdd (mulByDigit (i-2) l) (mulByDigit 2 l)", "min": "\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then padZero l1 ([0] @ l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero ([0] @ l1) l2\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> l\n  | head::tail -> if head = 0 then removeZero tail else head :: tail;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let onesD = ((fst x) + (snd x)) mod 10 in\n      let tensD = ((fst x) + (snd x)) / 10 in\n      let sum = (fst x) + (snd x) in\n      match snd a with\n      | head::tail ->\n          (sum, ((((head + (fst x)) + (snd x)) / 10) ::\n            (((head + (fst x)) + (snd x)) mod 10) :: tail))\n      | [] -> (sum, ([tensD] @ [onesD])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0\n  then []\n  else\n    if i = 1\n    then l\n    else\n      if i = 2\n      then bigAdd l l\n      else bigAdd (mulByDigit (i - 2) l) (mulByDigit 2 l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = \nlet index = fst a in\nlet newIn = index + 1 in\n(newIn, bigAdd (snd a) (mulByDigit x (l1@(clone 0 index)))) in\nlet base = (0, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then padZero l1 ([0] @ l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero ([0] @ l1) l2\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> l\n  | head::tail -> if head = 0 then removeZero tail else head :: tail;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let onesD = ((fst x) + (snd x)) mod 10 in\n      let tensD = ((fst x) + (snd x)) / 10 in\n      let sum = (fst x) + (snd x) in\n      match snd a with\n      | head::tail ->\n          (sum, ((((head + (fst x)) + (snd x)) / 10) ::\n            (((head + (fst x)) + (snd x)) mod 10) :: tail))\n      | [] -> (sum, ([tensD] @ [onesD])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i <= 0\n  then []\n  else\n    if i = 1\n    then l\n    else\n      if i = 2\n      then bigAdd l l\n      else bigAdd (mulByDigit (i - 2) l) (mulByDigit 2 l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let index = fst a in\n    let newIn = index + 1 in\n    (newIn, (bigAdd (snd a) (mulByDigit x (l1 @ (clone 0 index))))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| head::tail -> \nlet f a x = a ^ sep ^ x in\nlet base = head in\nlet l = tail in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | head::tail ->\n      let f a x = a ^ (sep ^ x) in\n      let base = head in let l = tail in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let padZero l1 l2 = \nlet lenl1 = List.length l1 in \nlet lenl2 = List.length l2 in \n(List.append(clone 0 (lenl1 - lenl2) l1, (List.append (clone 0 (lenl1 - lenl2)) l2)))", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  List.append\n    ((clone 0 (lenl1 - lenl2) l1),\n      (List.append (clone 0 (lenl1 - lenl2)) l2));;\n", "out": "Characters 95-167:\n  (List.append(clone 0 (lenl1 - lenl2) l1, (List.append (clone 0 (lenl1 - lenl2)) l2)));;\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = \nlet lenl1 = List.length l1 in \nlet lenl2 = List.length l2 in \n((List.append(clone 0 (lenl1 - lenl2)) l1), (List.append (clone 0 (lenl1 - lenl2)) l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  ((List.append (clone 0 (lenl1 - lenl2)) l1),\n    (List.append (clone 0 (lenl1 - lenl2)) l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = \nlet lenl1 = List.length l1 in \nlet lenl2 = List.length l2 in \n((List.append(clone 0 (lenl1 - lenl2)) l1), (List.append (clone 0 (lenl1 - lenl2)) l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  ((List.append (clone 0 (lenl1 - lenl2)) l1),\n    (List.append (clone 0 (lenl1 - lenl2)) l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = \nlet lenl1 = List.length l1 in \nlet lenl2 = List.length l2 in \n((List.append(clone 0 (lenl1 - lenl2)) l1), (List.append (clone 0 (lenl1 - lenl2)) l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  ((List.append (clone 0 (lenl1 - lenl2)) l1),\n    (List.append (clone 0 (lenl1 - lenl2)) l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = \nlet lenl1 = List.length l1 in \nlet lenl2 = List.length l2 in \n((List.append(clone 0 (lenl1 - lenl2)) l1), (List.append (clone 0 (lenl1 - lenl2)) l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  ((List.append (clone 0 (lenl1 - lenl2)) l1),\n    (List.append (clone 0 (lenl1 - lenl2)) l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = \nlet lenl1 = List.length l1 in \nlet lenl2 = List.length l2 in \nif (lenl1 > lenl2) then (List.append(clone 0 (lenl1 - lenl2)) l1)\nelse (List.append (clone 0 (lenl1 - lenl2)) l2)", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then List.append (clone 0 (lenl1 - lenl2)) l1\n  else List.append (clone 0 (lenl1 - lenl2)) l2;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = \nlet lenl1 = List.length l1 in \nlet lenl2 = List.length l2 in \nif (lenl1 < lenl2) then (List.append(clone 0 (lenl1 - lenl2)) l1)\nelse (List.append (clone 0 (lenl1 - lenl2)) l2)", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 < lenl2\n  then List.append (clone 0 (lenl1 - lenl2)) l1\n  else List.append (clone 0 (lenl1 - lenl2)) l2;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = \nlet lenl1 = List.length l1 in \nlet lenl2 = List.length l2 in \n((List.append(clone 0 (lenl1 - lenl2)) l1), (List.append (clone 0 (lenl1 - lenl2)) l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  ((List.append (clone 0 (lenl1 - lenl2)) l1),\n    (List.append (clone 0 (lenl1 - lenl2)) l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let padZero l1 l2 = \nlet lenl1 = List.length l1 in \nlet lenl2 = List.length l2 in \nif (lenl1 < lenl2) then ((List.append(clone 0 (lenl1 - lenl2)) l1), (List.append (clone 0 (lenl1 - lenl2)) l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 < lenl2\n  then\n    ((List.append (clone 0 (lenl1 - lenl2)) l1),\n      (List.append (clone 0 (lenl1 - lenl2)) l2));;\n", "out": "Characters 107-194:\n  if (lenl1 < lenl2) then ((List.append(clone 0 (lenl1 - lenl2)) l1), (List.append (clone 0 (lenl1 - lenl2)) l2));;\n                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type unit\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = \nlet lenl1 = List.length l1 in \nlet lenl2 = List.length l2 in \n((List.append(clone 0 (lenl1 - lenl2)) l1), (List.append (clone 0 (lenl1 - lenl2)) l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  ((List.append (clone 0 (lenl1 - lenl2)) l1),\n    (List.append (clone 0 (lenl1 - lenl2)) l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = \nlet lenl1 = List.length l1 in \nlet lenl2 = List.length l2 in \nif (lenl1 < lenl2) then ((List.append(clone 0 (lenl1 - lenl2)) l1), l2) \nelse (l1, List.append (clone 0 (lenl1 - lenl2)) l2)", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 < lenl2\n  then ((List.append (clone 0 (lenl1 - lenl2)) l1), l2)\n  else (l1, (List.append (clone 0 (lenl1 - lenl2)) l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = \nlet lenl1 = List.length l1 in \nlet lenl2 = List.length l2 in \nif (lenl1 < lenl2) then ((List.append(clone 0 (lenl1 - lenl2)) l1), l2) \nelse (l1, List.append (clone 0 (lenl1 - lenl2)) l2)", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 < lenl2\n  then ((List.append (clone 0 (lenl1 - lenl2)) l1), l2)\n  else (l1, (List.append (clone 0 (lenl1 - lenl2)) l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = \nlet lenl1 = List.length l1 in \nlet lenl2 = List.length l2 in \nif (lenl1 > lenl2) then ((List.append (clone 0 (lenl1 - lenl2)) l1), l2) \nelse (l1, List.append (clone 0 (lenl1 - lenl2)) l2)", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then ((List.append (clone 0 (lenl1 - lenl2)) l1), l2)\n  else (l1, (List.append (clone 0 (lenl1 - lenl2)) l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = \nlet lenl1 = List.length l1 in \nlet lenl2 = List.length l2 in \nif (lenl1 < lenl2) then ((List.append (clone 0 (lenl1 - lenl2)) l1), l2) \nelse (l1, List.append (clone 0 (lenl1 - lenl2)) l2)", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 < lenl2\n  then ((List.append (clone 0 (lenl1 - lenl2)) l1), l2)\n  else (l1, (List.append (clone 0 (lenl1 - lenl2)) l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = \nlet lenl1 = List.length l1 in \nlet lenl2 = List.length l2 in \nif (lenl1 < lenl2) then ((List.append (clone 0 (lenl2 - lenl1)) l1), l2) \nelse (l1, List.append (clone 0 (lenl1 - lenl2)) l2)", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 < lenl2\n  then ((List.append (clone 0 (lenl2 - lenl1)) l1), l2)\n  else (l1, (List.append (clone 0 (lenl1 - lenl2)) l2));;\n", "out": ""}]}
