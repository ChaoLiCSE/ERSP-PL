{"event": "eval", "ocaml": [{"in": "let rec sumList xs = failwith \"TBD:sumList\"", "out": "", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = failwith \"TBD:sumList\"", "out": "", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = failwith \"TBD:sumList\"", "out": "", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs =\nmatch xs with\n[] -> []\n| head::tail -> head + (sumList tail)", "out": "Characters 67-81:\n  | head::tail -> head + (sumList tail);;\n                         ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec sumList xs =\n  match xs with | [] -> [] | head::tail -> head + (sumList tail);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs =\nmatch xs with\n[] -> 0\n| head::tail -> head  (sumList tail)", "out": "", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head (sumList tail);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs =\nmatch xs with\n[] -> 0\n| head::tail -> head  (sumList tail)", "out": "", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head (sumList tail);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs =\nmatch xs with\n[] -> 0\n| head::tail -> head + (sumList tail)", "out": "", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [0]\nelse (digitsOfInt (n/10)) @ [n mod 10]", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [0] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse (digitsOfInt (n/10)) @ [n mod 10]", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nif n < 10 then 1\nelse 1 + additivePersistence (sumList (digitsOfInt n))", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n\nlet rec additivePersistence n =\n  if n < 10 then 1 else 1 + (additivePersistence (sumList (digitsOfInt n)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nif n < 10 then n\nelse digitalRoot (sumList (digitalOfInt n))", "out": "Error: Unbound value digitalOfInt\nHint: Did you mean digitsOfInt?\nError: Unbound value digitalOfInt\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 69-81:\n  else digitalRoot (sumList (digitalOfInt n));;\n                             ^^^^^^^^^^^^\nError: Unbound value digitalOfInt\nHint: Did you mean digitsOfInt?\n", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitalOfInt n));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nif n < 10 then n\nelse digitalRoot (sumList (digitsOfInt n))", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nif n < 10 then 0\nelse 1 + additivePersistence (sumList (digitsOfInt n))", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digitsOfInt n)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = \nmatch l with \n[] -> []\n| head::tail -> listReverse tail @ head", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | head::tail -> (listReverse tail) @ head;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = \nmatch l with \n[] -> []\n| head::tail -> listReverse tail @ [head]", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | head::tail -> (listReverse tail) @ [head];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = \nif ((explode w) = (explode (listReverse w))) then true\nelse false", "out": "Characters 60-61:\n  if ((explode w) = (explode (listReverse w))) then true\n                                          ^\nError: This expression has type string but an expression was expected of type\n         'a list\n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | head::tail -> (listReverse tail) @ [head];;\n\nlet palindrome w =\n  if (explode w) = (explode (listReverse w)) then true else false;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = \nif ((explode w) = (listReverse (explode w))) then true\nelse false", "out": "", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | head::tail -> (listReverse tail) @ [head];;\n\nlet palindrome w =\n  if (explode w) = (listReverse (explode w)) then true else false;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs =\nmatch xs with\n[] -> 0\n| head::tail -> head + (sumList tail)", "out": "", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs =\nmatch xs with\n[] -> 0\n| head::tail -> head + (sumList tail)", "out": "", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs =\nmatch xs with\n[] -> 0\n| head::tail -> head + (sumList tail)", "out": "", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs =\nmatch xs with\n[] -> 0\n| head::tail -> head + (sumList tail)", "out": "", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse (digitsOfInt (n/10)) @ [n mod 10]", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs =\nmatch xs with\n[] -> 0\n| head::tail -> head + (sumList tail)", "out": "", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n = 0 && n < 10 then [0]\nelse if n <= 0 then []\nelse (digitsOfInt (n/10)) @ [n mod 10]", "out": "", "min": "\nlet rec digitsOfInt n =\n  if (n = 0) && (n < 10)\n  then [0]\n  else if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n = 0 && n < 10 then [0]\nelse if n <= 0 then []\nelse (digitsOfInt (n/10)) @ [n mod 10]", "out": "", "min": "\nlet rec digitsOfInt n =\n  if (n = 0) && (n < 10)\n  then [0]\n  else if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif (n > 0 && (n/10 = 0)) then [n] \nelse if n > 0 then (digitsOfInt (n/10)) @ [n mod 10]\nelse []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if (n > 0) && ((n / 10) = 0)\n  then [n]\n  else if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif (n > 0 && (n/10 = 0)) then [n] \nelse if (n > 0) then (digitsOfInt (n/10)) @ [n mod 10]\nelse []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if (n > 0) && ((n / 10) = 0)\n  then [n]\n  else if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif (n > 0) then \nif (n/10 = 0) then [n] \nelse (digitsOfInt (n/10)) @ [n mod 10]\nelse []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n > 0\n  then (if (n / 10) = 0 then [n] else (digitsOfInt (n / 10)) @ [n mod 10])\n  else [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs =\nmatch xs with\n[] -> 0\n| head::tail -> head + (sumList tail)", "out": "", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs =\nmatch xs with\n[] -> 0\n| head::tail -> head + (sumList tail)", "out": "", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs =\nmatch xs with\n[] -> 0\n| head::tail -> head + (sumList tail)", "out": "", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digits n = digitsOfInt (abs n)", "out": "", "min": "\nlet rec append_new xs1 xs2 =\n  match xs1 with | [] -> xs2 | head::tail -> head :: (append_new tail xs2);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append_new (digitsOfInt (n / 10)) [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs =\nmatch xs with\n[] -> 0\n| head::tail -> head + (sumList tail)", "out": "", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = \nmatch l with \n[] -> []\n| head::tail -> append_new (listReverse tail) [head]", "out": "", "min": "\nlet rec append_new xs1 xs2 =\n  match xs1 with | [] -> xs2 | head::tail -> head :: (append_new tail xs2);;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | head::tail -> append_new (listReverse tail) [head];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nlet rec digs acc n=\nif n < 10 then n::acc\nelse digs ((n mod 10)::acc) (n/10) in digs [] n", "out": "", "min": "\nlet rec digitsOfInt n =\n  let rec digs acc n =\n    if n < 10 then n :: acc else digs ((n mod 10) :: acc) (n / 10) in\n  digs [] n;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n <= 0 then []\nelse append_new (digitsOfInt (n/10)) [n mod 10]", "out": "", "min": "\nlet rec append_new xs1 xs2 =\n  match xs1 with | [] -> xs2 | head::tail -> head :: (append_new tail xs2);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append_new (digitsOfInt (n / 10)) [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 10 then [n]\nelse append_new (digitsOfInt (n/10)) [n mod 10]", "out": "", "min": "\nlet rec append_new xs1 xs2 =\n  match xs1 with | [] -> xs2 | head::tail -> head :: (append_new tail xs2);;\n\nlet rec digitsOfInt n =\n  if n < 10 then [n] else append_new (digitsOfInt (n / 10)) [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 10 then [n]\nelse append_new (digitsOfInt (n/10)) [n mod 10]", "out": "", "min": "\nlet rec append_new xs1 xs2 =\n  match xs1 with | [] -> xs2 | head::tail -> head :: (append_new tail xs2);;\n\nlet rec digitsOfInt n =\n  if n < 10 then [n] else append_new (digitsOfInt (n / 10)) [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digits n = digitsOfInt (abs n)", "out": "", "min": "\nlet rec append_new xs1 xs2 =\n  match xs1 with | [] -> xs2 | head::tail -> head :: (append_new tail xs2);;\n\nlet rec digitsOfInt n =\n  if n < 10 then [n] else append_new (digitsOfInt (n / 10)) [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n", "type": ""}]}
