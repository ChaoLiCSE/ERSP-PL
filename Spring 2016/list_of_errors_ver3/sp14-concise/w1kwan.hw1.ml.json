{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 67-81:\n  | head::tail -> head + (sumList tail);;\n                         ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec sumList xs =\n  match xs with | [] -> [] | head::tail -> head + (sumList tail);;\n", "in": "let rec sumList xs =\nmatch xs with\n[] -> []\n| head::tail -> head + (sumList tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs =\nmatch xs with\n[] -> 0\n| head::tail -> head  (sumList tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs =\nmatch xs with\n[] -> 0\n| head::tail -> head  (sumList tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs =\nmatch xs with\n[] -> 0\n| head::tail -> head + (sumList tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [0]\nelse (digitsOfInt (n/10)) @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse (digitsOfInt (n/10)) @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif n < 10 then 1\nelse 1 + additivePersistence (sumList (digitsOfInt n))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value digitalOfInt\nHint: Did you mean digitsOfInt?\nError: Unbound value digitalOfInt\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 69-81:\n  else digitalRoot (sumList (digitalOfInt n));;\n                             ^^^^^^^^^^^^\nError: Unbound value digitalOfInt\nHint: Did you mean digitsOfInt?\n", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | head::tail -> head + (sumList tail);;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitalOfInt n));;\n", "in": "let rec digitalRoot n = \nif n < 10 then n\nelse digitalRoot (sumList (digitalOfInt n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n < 10 then n\nelse digitalRoot (sumList (digitsOfInt n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif n < 10 then 0\nelse 1 + additivePersistence (sumList (digitsOfInt n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nmatch l with \n[] -> []\n| head::tail -> listReverse tail @ head"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nmatch l with \n[] -> []\n| head::tail -> listReverse tail @ [head]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 60-61:\n  if ((explode w) = (explode (listReverse w))) then true\n                                          ^\nError: This expression has type string but an expression was expected of type\n         'a list\n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | head::tail -> (listReverse tail) @ [head];;\n\nlet palindrome w =\n  if (explode w) = (explode (listReverse w)) then true else false;;\n", "in": "let palindrome w = \nif ((explode w) = (explode (listReverse w))) then true\nelse false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = \nif ((explode w) = (listReverse (explode w))) then true\nelse false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs =\nmatch xs with\n[] -> 0\n| head::tail -> head + (sumList tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs =\nmatch xs with\n[] -> 0\n| head::tail -> head + (sumList tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs =\nmatch xs with\n[] -> 0\n| head::tail -> head + (sumList tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs =\nmatch xs with\n[] -> 0\n| head::tail -> head + (sumList tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse (digitsOfInt (n/10)) @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs =\nmatch xs with\n[] -> 0\n| head::tail -> head + (sumList tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n = 0 && n < 10 then [0]\nelse if n <= 0 then []\nelse (digitsOfInt (n/10)) @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n = 0 && n < 10 then [0]\nelse if n <= 0 then []\nelse (digitsOfInt (n/10)) @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif (n > 0 && (n/10 = 0)) then [n] \nelse if n > 0 then (digitsOfInt (n/10)) @ [n mod 10]\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif (n > 0 && (n/10 = 0)) then [n] \nelse if (n > 0) then (digitsOfInt (n/10)) @ [n mod 10]\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif (n > 0) then \nif (n/10 = 0) then [n] \nelse (digitsOfInt (n/10)) @ [n mod 10]\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs =\nmatch xs with\n[] -> 0\n| head::tail -> head + (sumList tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs =\nmatch xs with\n[] -> 0\n| head::tail -> head + (sumList tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs =\nmatch xs with\n[] -> 0\n| head::tail -> head + (sumList tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs =\nmatch xs with\n[] -> 0\n| head::tail -> head + (sumList tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nmatch l with \n[] -> []\n| head::tail -> append_new (listReverse tail) [head]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nlet rec digs acc n=\nif n < 10 then n::acc\nelse digs ((n mod 10)::acc) (n/10) in digs [] n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n <= 0 then []\nelse append_new (digitsOfInt (n/10)) [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 10 then [n]\nelse append_new (digitsOfInt (n/10)) [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 10 then [n]\nelse append_new (digitsOfInt (n/10)) [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
