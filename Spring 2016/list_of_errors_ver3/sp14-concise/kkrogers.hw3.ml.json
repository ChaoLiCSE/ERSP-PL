{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + (x*x) in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun x -> x a in\nlet base = fun x1->x1 in\nList.fold_left f base fs", "out": "Characters 83-84:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n", "min": "\nlet pipe fs =\n  let f a x x = x a in let base x1 = x1 in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun y ->  x (a y) in\nlet base = fun x1->x1 in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x y = x (a y) in let base x1 = x1 in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = List.map (f (sepconcat \" \" l))", "out": "Error: Unbound value sepconcat\nHint: Did you mean sepConcat?\nError: Unbound value sepconcat\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 36-45:\n  let stringOfList f l = List.map (f (sepconcat \" \" l));;\n                                      ^^^^^^^^^\nError: Unbound value sepconcat\nHint: Did you mean sepConcat?\n", "min": "\nlet stringOfList f l = List.map (f (sepconcat \" \" l));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = List.map (f (sepConcat \" \" l))", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (f (sepConcat \" \" l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = sepConcat (\" \" List.map(f l))", "out": "Characters 34-37:\n  let stringOfList f l = sepConcat (\" \" List.map(f l));;\n                                    ^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (\" \" List.map (f l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = sepConcat (\" \" List.map(f l))", "out": "Characters 34-37:\n  let stringOfList f l = sepConcat (\" \" List.map(f l));;\n                                    ^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (\" \" List.map (f l));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = sepConcat (\" \" (List.map(f l)))", "out": "Characters 34-37:\n  let stringOfList f l = sepConcat (\" \" (List.map(f l)));;\n                                    ^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (\" \" (List.map (f l)));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = sepConcat \" \" l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \" \" l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = sepConcat \" \" (List.map f l)", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \" \" (List.map f l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = sepConcat \"; \" (List.map f l)", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \"[\"^sepConcat \"; \" (List.map f l)^\"]\"", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n = \nif (n <= 0) then []\nelse x::(clone x n-1)", "out": "Characters 50-59:\n  else x::(clone x n-1);;\n           ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: ((clone x n) - 1);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n = \nif (n <= 0) then []\nelse x::(clone x (n-1))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n = \nif (n <= 0) then []\nelse x::(clone x (n-1))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 < List.length l2\nthen (clone 0 (List.length l2 - List.length l1))@l1\nelse (clone 0 (List.length l1 - List.length l2))@l2", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 < List.length l2\nthen (clone 0 (List.length l2 - List.length l1))@l1\nelse (clone 0 (List.length l1 - List.length l2))@l2", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 < List.length l2\nthen ((clone 0 (List.length l2 - List.length l1))@l1,l2)\nelse (l1,(clone 0 (List.length l1 - List.length l2))@l2)", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec removeZero l = match l with\n| [] -> []\n| h::t -> if (h=0) then removeZero t else l", "out": "", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (x,y) -> a::[(x+y) mod 10] in\nlet base = [] in\nlet args = failwith List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 135-147:\n  let args = failwith List.combine l1 l2 in\n                      ^^^^^^^^^^^^\nError: This expression has type 'a list -> 'b list -> ('a * 'b) list\n       but an expression was expected of type string\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (x,y) -> [a; (x + y) mod 10] in\n    let base = [] in\n    let args = failwith List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (y,z) -> let sum = y+z in\nmatch a with \n| h::t -> ((sum+h)/10)::((sum+h)mod 10)::t\n| [] -> (sum/10)::[(sum mod 10)] in\nlet base = [] in\nlet args = failwith List.combine(l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 224-236:\n  let args = failwith List.combine(l1 l2) in\n                      ^^^^^^^^^^^^\nError: This expression has type 'a list -> 'b list -> ('a * 'b) list\n       but an expression was expected of type string\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (y,z) ->\n          let sum = y + z in\n          (match a with\n           | h::t -> ((sum + h) / 10) :: ((sum + h) mod 10) :: t\n           | [] -> [sum / 10; sum mod 10]) in\n    let base = [] in\n    let args = failwith List.combine (l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (y,z) -> let sum = y+z in\nmatch a with \n| h::t -> ((sum+h)/10)::((sum+h)mod 10)::t\n| [] -> (sum/10)::[(sum mod 10)] in\nlet base = [] in\nlet args = List.combine(l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 275-279:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type 'a list -> ('b * 'a) list\n       but an expression was expected of type (int * int) list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (y,z) ->\n          let sum = y + z in\n          (match a with\n           | h::t -> ((sum + h) / 10) :: ((sum + h) mod 10) :: t\n           | [] -> [sum / 10; sum mod 10]) in\n    let base = [] in\n    let args = List.combine (l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (y,z) -> let sum = y+z in\nmatch a with \n| h::t -> ((sum+h)/10)::((sum+h)mod 10)::t\n| _ -> (sum/10)::[(sum mod 10)] in\nlet base = [] in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 261-287:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (y,z) ->\n          let sum = y + z in\n          (match a with\n           | h::t -> ((sum + h) / 10) :: ((sum + h) mod 10) :: t\n           | _ -> [sum / 10; sum mod 10]) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (y,z) -> let sum = y+z in\nmatch a with \n| h::t -> ((sum+h)/10)::((sum+h)mod 10)::t\n| _ -> (sum/10)::[(sum mod 10)] in\nlet base = [] in\nlet args = List.rev(List.combine l1 l2) in\n(*let (_, res) =*) List.fold_left f base args (*in\nres*)\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (y,z) ->\n          let sum = y + z in\n          (match a with\n           | h::t -> ((sum + h) / 10) :: ((sum + h) mod 10) :: t\n           | _ -> [sum / 10; sum mod 10]) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (y,z) -> let sum = y+z in\nmatch a with \n| h::t -> ((sum+h)/10)::((sum+h)mod 10)::t\n| _ -> (sum/10)::[(sum mod 10)] in\nlet base = [] in\nlet args = List.rev(List.combine l1 l2) in List.fold_left f base args \nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (y,z) ->\n          let sum = y + z in\n          (match a with\n           | h::t -> ((sum + h) / 10) :: ((sum + h) mod 10) :: t\n           | _ -> [sum / 10; sum mod 10]) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l =  \nlet f a x = let mult = i*x in\nmatch a with \n|h::t -> ((h+mult)/10)::(h+mult) mod 10::t\n| _ -> mult/10::[mult mod 10] in\nlet base = [] in\nremoveZero (List.fold_left f base (List.rev l))", "out": "", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let mult = i * x in\n    match a with\n    | h::t -> ((h + mult) / 10) :: ((h + mult) mod 10) :: t\n    | _ -> [mult / 10; mult mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = List.append((mulByDigit x l1) (clone 0 (List.length b)))::b in\nlet base = [] in\nlet args = List.rev l2 in List.fold_left f base args", "out": "Characters 44-61:\n  let f a x = List.append((mulByDigit x l1) (clone 0 (List.length b)))::b in\n                          ^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let mult = i * x in\n    match a with\n    | h::t -> ((h + mult) / 10) :: ((h + mult) mod 10) :: t\n    | _ -> [mult / 10; mult mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x = (List.append ((mulByDigit x l1) (clone 0 (List.length b)))) ::\n    b in\n  let base = [] in let args = List.rev l2 in List.fold_left f base args;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet g =\nlet f a x = List.append((mulByDigit x l1) (clone 0 (List.length b)))::b in\nlet base = [] in\nlet args = List.rev l2 in List.fold_left f base args in\nList.fold_left bigAdd [] g", "out": "Error: This expression has type int list\n       This is not a function; it cannot be applied.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 52-69:\n  let f a x = List.append((mulByDigit x l1) (clone 0 (List.length b)))::b in\n                          ^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (y,z) ->\n          let sum = y + z in\n          (match a with\n           | h::t -> ((sum + h) / 10) :: ((sum + h) mod 10) :: t\n           | _ -> [sum / 10; sum mod 10]) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let mult = i * x in\n    match a with\n    | h::t -> ((h + mult) / 10) :: ((h + mult) mod 10) :: t\n    | _ -> [mult / 10; mult mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let g =\n    let f a x = (List.append ((mulByDigit x l1) (clone 0 (List.length b))))\n      :: b in\n    let base = [] in let args = List.rev l2 in List.fold_left f base args in\n  List.fold_left bigAdd [] g;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet g =\nlet f a x = ((mulByDigit x l1)@(clone 0 (List.length b)))::b in\nlet base = [] in\nlet args = List.rev l2 in List.fold_left f base args in\nList.fold_left bigAdd [] g", "out": "Error: Unbound value b\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 81-82:\n  let f a x = ((mulByDigit x l1)@(clone 0 (List.length b)))::b in\n                                                       ^\nError: Unbound value b\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (y,z) ->\n          let sum = y + z in\n          (match a with\n           | h::t -> ((sum + h) / 10) :: ((sum + h) mod 10) :: t\n           | _ -> [sum / 10; sum mod 10]) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let mult = i * x in\n    match a with\n    | h::t -> ((h + mult) / 10) :: ((h + mult) mod 10) :: t\n    | _ -> [mult / 10; mult mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let g =\n    let f a x = ((mulByDigit x l1) @ (clone 0 (List.length b))) :: b in\n    let base = [] in let args = List.rev l2 in List.fold_left f base args in\n  List.fold_left bigAdd [] g;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet g =\nlet f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in\nlet base = [] in\nlet args = List.rev l2 in List.fold_left f base args in\nList.fold_left bigAdd [] g", "out": "", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (y,z) ->\n          let sum = y + z in\n          (match a with\n           | h::t -> ((sum + h) / 10) :: ((sum + h) mod 10) :: t\n           | _ -> [sum / 10; sum mod 10]) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let mult = i * x in\n    match a with\n    | h::t -> ((h + mult) / 10) :: ((h + mult) mod 10) :: t\n    | _ -> [mult / 10; mult mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let g =\n    let f a x = ((mulByDigit x l1) @ (clone 0 (List.length a))) :: a in\n    let base = [] in let args = List.rev l2 in List.fold_left f base args in\n  List.fold_left bigAdd [] g;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l =  \nif i = 1 then l\nelse if i = 0 then [0]\nelse bigAdd (bigAdd l l) (mulByDigit (i-2) l)", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (input,result) ->\n          (match x with\n           | (y,z) ->\n               let sum = (y + z) + input in\n               ((sum / 10), ((sum mod 10) :: result))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 1\n  then l\n  else if i = 0 then [0] else bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l =  \nif i = 1 then l\nelse if i = 0 then [0]\nelse if i<0 then []\nelse bigAdd (bigAdd l l) (mulByDigit (i-2) l)", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (input,result) ->\n          (match x with\n           | (y,z) ->\n               let sum = (y + z) + input in\n               ((sum / 10), ((sum mod 10) :: result))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 1\n  then l\n  else\n    if i = 0\n    then [0]\n    else if i < 0 then [] else bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = match a with\n|(move,result) -> match x with\n|(fac,dig) -> let prod = mulByDigit dig (fac @ (clone 0 move)) in\n(move +1, bigAdd result prod) in \nlet base = (0,[]) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev 12) in \nlet (_,res) = List.fold_left f base args in\nres", "out": "Error: This expression has type int but an expression was expected of type\n         'a list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 259-261:\n  let args = List.combine (clone l1 (List.length l2)) (List.rev 12) in \n                                                                ^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (input,result) ->\n          (match x with\n           | (y,z) ->\n               let sum = (y + z) + input in\n               ((sum / 10), ((sum mod 10) :: result))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i = 1\n  then l\n  else\n    if i = 0\n    then [0]\n    else if i < 0 then [] else bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (move,result) ->\n        (match x with\n         | (fac,dig) ->\n             let prod = mulByDigit dig (fac @ (clone 0 move)) in\n             ((move + 1), (bigAdd result prod))) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) (List.rev 12) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = match a with\n|(move,result) -> match x with\n|(fac,dig) -> let prod = mulByDigit dig (fac @ (clone 0 move)) in\n(move +1, bigAdd result prod) in \nlet base = (0,[]) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2) in \nlet (_,res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (input,result) ->\n          (match x with\n           | (y,z) ->\n               let sum = (y + z) + input in\n               ((sum / 10), ((sum mod 10) :: result))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  if i = 1\n  then l\n  else\n    if i = 0\n    then [0]\n    else if i < 0 then [] else bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (move,result) ->\n        (match x with\n         | (fac,dig) ->\n             let prod = mulByDigit dig (fac @ (clone 0 move)) in\n             ((move + 1), (bigAdd result prod))) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
