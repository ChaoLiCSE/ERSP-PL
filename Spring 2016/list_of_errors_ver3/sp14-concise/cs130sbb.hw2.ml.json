{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =   \nmatch l with\n| [] -> d\n| x :: xs -> match x with\n| (s,i) -> if s = k then i\nelse assoc(d,k,xs)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | x::xs -> (match x with | (s,i) -> if s = k then i else assoc (d, k, xs));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =   \nmatch l with\n| [] -> d\n| x :: xs -> match x with\n| (s,i) -> if s = k then i else assoc(d,k,xs)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | x::xs -> (match x with | (s,i) -> if s = k then i else assoc (d, k, xs));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h = seen) = false then seen' @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ =\n  (et removeDuplicates l) =\n    (let rec helper (seen,rest) =\n       match rest with\n       | [] -> seen\n       | h::t ->\n           let seen' =\n             if ((List.mem h) = seen) = false then seen' @ [h] else seen in\n           let rest' = t in helper (seen', rest') in\n     List.rev (helper ([], l)));;\n", "out": "Characters 0-2:\n  et removeDuplicates l = \n  ^^\nError: Unbound value et\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h = seen) = false then seen@ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ =\n  (et removeDuplicates l) =\n    (let rec helper (seen,rest) =\n       match rest with\n       | [] -> seen\n       | h::t ->\n           let seen' =\n             if ((List.mem h) = seen) = false then seen @ [h] else seen in\n           let rest' = t in helper (seen', rest') in\n     List.rev (helper ([], l)));;\n", "out": "Characters 0-2:\n  et removeDuplicates l = \n  ^^\nError: Unbound value et\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h = seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ =\n  (et removeDuplicates l) =\n    (let rec helper (seen,rest) =\n       match rest with\n       | [] -> seen\n       | h::t ->\n           let seen' =\n             if ((List.mem h) = seen) = false then seen @ [h] else seen in\n           let rest' = t in helper (seen', rest') in\n     List.rev (helper ([], l)));;\n", "out": "Characters 0-2:\n  et removeDuplicates l = \n  ^^\nError: Unbound value et\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ =\n  (et removeDuplicates l) =\n    (let rec helper (seen,rest) =\n       match rest with\n       | [] -> seen\n       | h::t ->\n           let seen' = if (List.mem h seen) = false then seen @ [h] else seen in\n           let rest' = t in helper (seen', rest') in\n     List.rev (helper ([], l)));;\n", "out": "Characters 0-2:\n  et removeDuplicates l = \n  ^^\nError: Unbound value et\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ =\n  (et removeDuplicates l) =\n    (let rec helper (seen,rest) =\n       match rest with\n       | [] -> seen\n       | h::t ->\n           let seen' = if (List.mem h seen) = false then seen @ [h] else seen in\n           let rest' = t in helper (seen', rest') in\n     List.rev (helper ([], l)));;\n", "out": "Characters 0-2:\n  et removeDuplicates l = \n  ^^\nError: Unbound value et\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": " removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ =\n  (removeDuplicates l) =\n    (let rec helper (seen,rest) =\n       match rest with\n       | [] -> seen\n       | h::t ->\n           let seen' = if (List.mem h seen) = false then seen @ [h] else seen in\n           let rest' = t in helper (seen', rest') in\n     List.rev (helper ([], l)));;\n", "out": "Characters 18-19:\n   removeDuplicates l = \n                    ^\nError: Unbound value l\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nhelper ([],l)", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ =\n  (et removeDuplicates l) =\n    (let rec helper (seen,rest) =\n       match rest with\n       | [] -> seen\n       | h::t ->\n           let seen' = if (List.mem h seen) = false then seen @ [h] else seen in\n           let rest' = t in helper (seen', rest') in\n     helper ([], l));;\n", "out": "Characters 0-2:\n  et removeDuplicates l = \n  ^^\nError: Unbound value et\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then h::seen\nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ =\n  (et removeDuplicates l) =\n    (let rec helper (seen,rest) =\n       match rest with\n       | [] -> seen\n       | h::t ->\n           let seen' = if (List.mem h seen) = false then h :: seen else seen in\n           let rest' = t in helper (seen', rest') in\n     List.rev (helper ([], l)));;\n", "out": "Characters 0-2:\n  et removeDuplicates l = \n  ^^\nError: Unbound value et\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then h::seen\nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet helper = (f,b) in\nmatch helper with\n| (x',n) ->\nif n = true then wwhile(f,x')\nelse x'", "min": "\nlet rec wwhile (f,b) =\n  let helper = (f, b) in\n  match helper with | (x',n) -> if n = true then wwhile (f, x') else x';;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet helper = (f,b) in\nmatch helper with\n| (x',n) ->\nif n = true then wwhile(f,x')\nelse x'", "min": "\nlet rec wwhile (f,b) =\n  let helper = (f, b) in\n  match helper with | (x',n) -> if n = true then wwhile (f, x') else x';;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet helper = (f,b) in\nmatch helper with\n| (x',n) ->\nif n = false then x'\nelse wwhile(f,x')", "min": "\nlet rec wwhile (f,b) =\n  let helper = (f, b) in\n  match helper with | (x',n) -> if n = false then x' else wwhile (f, x');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet helper = (f b) in\nmatch helper with\n| (x',n) ->\nif n = false then x'\nelse wwhile(f,x')", "min": "\nlet rec wwhile (f,b) =\n  let helper = f b in\n  match helper with | (x',n) -> if n = false then x' else wwhile (f, x');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  let helper = f b in\n  match helper with | (x',n) -> if n = false then x' else wwhile (f, x');;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet helper = (f b) in\nmatch helper with\n| (x',n) ->\nif n = true then wwhile(f,x')\nelse x'", "min": "\nlet rec wwhile (f,b) =\n  let helper = f b in\n  match helper with | (x',n) -> if n = true then wwhile (f, x') else x';;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \n(*let helper = (f b) in\nmatch helper with*)\nmatch (f b) with \n| (x',n) ->\nif n = true then wwhile(f,x')\nelse x'", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x',n) -> if n = true then wwhile (f, x') else x';;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x',n) -> if n = true then wwhile (f, x') else x';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x',n) -> if n = true then wwhile (f, x') else x';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x',n) -> if n = true then wwhile (f, x') else x';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nmatch (f b) with \n| (x',n) ->\nif n = true then wwhile(f,x')\nelse x'", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x',n) -> if n = true then wwhile (f, x') else x';;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile(f,b) =\nmatch (f b) with \n| (v,false) -> v\n| (v,true)  -> wwhile(f,v)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (v,false ) -> v | (v,true ) -> wwhile (f, v);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((fun v -> let b = (f v) in (b, b != v)),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (v,false ) -> v | (v,true ) -> wwhile (f, v);;\n\nlet fixpoint (f,b) = wwhile ((fun v  -> let b = f v in (b, (b != v))), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =   \nmatch l with\n| [] -> d\n| x :: xs -> match x with\n| (s,i) -> if s = k then i else assoc(d,k,xs)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | x::xs -> (match x with | (s,i) -> if s = k then i else assoc (d, k, xs));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((fun v -> let x = (f v) in (x, x != v)),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (v,false ) -> v | (v,true ) -> wwhile (f, v);;\n\nlet fixpoint (f,b) = wwhile ((fun v  -> let x = f v in (x, (x != v))), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with \n| VarX ->            \"x\"\n| VarY ->            \"y\"\n| Sine(v) ->         \"sin(pi*\"^exprToString(v)^\")\"\n| Cosine(v) ->       \"cos(pi*\"^exprToString(v)^\")\"\n| Average(v,w) ->    \"((\"^exprToString(v)^\"+\"^exprToString(w)^\")/2)\"\n| Times(v,w) ->      exprToString(v)^\"*\"^exprToString(w)\n| Thresh(v,w,x,y) -> exprToString(v)^\"<\"^exprToString(w)^\n\"?\"^exprToString(x)^\":\"^exprToString(y)^\")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Cosine v -> \"cos(pi*\" ^ ((exprToString v) ^ \")\")\n  | Average (v,w) ->\n      \"((\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")/2)\")))\n  | Times (v,w) -> (exprToString v) ^ (\"*\" ^ (exprToString w))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ ((exprToString y) ^ \")\"))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) + eval(w,x,y))/2.0)\n| Times(v,w) -> eval(v,x,y) * eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (eval (v, x, y))\n  | Cosine v -> cos (eval (v, x, y))\n  | Average (v,w) -> ((eval (v, x, y)) + (eval (w, x, y))) / 2.0\n  | Times (v,w) -> (eval (v, x, y)) * (eval (v, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": "Characters 119-130:\n  | Average(v,w) -> ((eval(v,x,y) + eval(w,x,y))/2.0)\n                      ^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/2.0)\n| Times(v,w) -> eval(v,x,y) * eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (eval (v, x, y))\n  | Cosine v -> cos (eval (v, x, y))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) / 2.0\n  | Times (v,w) -> (eval (v, x, y)) * (eval (v, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": "Characters 118-146:\n  | Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/2.0)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) * eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (eval (v, x, y))\n  | Cosine v -> cos (eval (v, x, y))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) * (eval (v, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": "Characters 169-180:\n  | Times(v,w) -> eval(v,x,y) * eval(v,x,y)\n                  ^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (eval (v, x, y))\n  | Cosine v -> cos (eval (v, x, y))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (v, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> ((eval(v,x,y) +. eval(w,x,y))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if ((eval(a,x,y)) < (eval(b,x,y))) then (eval(c,x,y)) else (eval(d,x,y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (eval (v, x, y))\n  | Cosine v -> cos (eval (v, x, y))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (v, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| Sine(v) -> sin(eval(v,x,y))\n| Cosine(v) -> cos(eval(v,x,y))\n| Average(v,w) -> (((eval(v,x,y) +. eval(w,x,y)))/.2.0)\n| Times(v,w) -> eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if ((eval(a,x,y)) < (eval(b,x,y))) then (eval(c,x,y)) else (eval(d,x,y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (eval (v, x, y))\n  | Cosine v -> cos (eval (v, x, y))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (v, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = match e with \n| Var(x) ->          x\n| Var(y) ->\t     y\n| Sine(v) ->         sin(eval(v,x,y))\n| Cosine(v) ->       cos(eval(v,x,y))\n| Average(v,w) ->    (((eval(v,x,y) +. eval(w,x,y)))/.2.0)\n| Times(v,w) ->      eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if ((eval(a,x,y)) < (eval(b,x,y))) then (eval(c,x,y)) else (eval(d,x,y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Var x -> x\n  | Var y -> y\n  | Sine v -> sin (eval (v, x, y))\n  | Cosine v -> cos (eval (v, x, y))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (v, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": "Characters 39-42:\n  | Var(x) ->          x\n    ^^^\nError: Unbound constructor Var\nHint: Did you mean VarX or VarY?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| VarX ->            x\n| VarY ->\t     y\n| Sine(v) ->         sin(eval(v,x,y))\n| Cosine(v) ->       cos(eval(v,x,y))\n| Average(v,w) ->    (((eval(v,x,y) +. eval(w,x,y)))/.2.0)\n| Times(v,w) ->      eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if ((eval(a,x,y)) < (eval(b,x,y))) then (eval(c,x,y)) else (eval(d,x,y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine v -> sin (eval (v, x, y))\n  | Cosine v -> cos (eval (v, x, y))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (v, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| Sine(v) ->         sin(eval(v,x,y))\n| Cosine(v) ->       cos(eval(v,x,y))\n| Average(v,w) ->    (((eval(v,x,y) +. eval(w,x,y)))/.2.0)\n| Times(v,w) ->      eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if ((eval(a,x,y)) < (eval(b,x,y))) then (eval(c,x,y)) else (eval(d,x,y))\n| VarX ->            x\n| VarY ->\t     y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (eval (v, x, y))\n  | Cosine v -> cos (eval (v, x, y))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (v, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | VarX  -> x\n  | VarY  -> y;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (eval (v, x, y))\n  | Cosine v -> cos (eval (v, x, y))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (v, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | VarX  -> x\n  | VarY  -> y;;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with \n| VarX ->  \t     \"X\"\n| VarY ->            \"Y\"\n| Sine(v) ->         \"sin(pi*\"^exprToString(v)^\")\"\n| Cosine(v) ->       \"cos(pi*\"^exprToString(v)^\")\"\n| Average(v,w) ->    \"((\"^exprToString(v)^\"+\"^exprToString(w)^\")/2)\"\n| Times(v,w) ->      exprToString(v)^\"*\"^exprToString(w)\n| Thresh(v,w,x,y) -> exprToString(v)^\"<\"^exprToString(w)^\"?\"^exprToString(x)^\":\"^exprToString(y)^\")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"X\"\n  | VarY  -> \"Y\"\n  | Sine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Cosine v -> \"cos(pi*\" ^ ((exprToString v) ^ \")\")\n  | Average (v,w) ->\n      \"((\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")/2)\")))\n  | Times (v,w) -> (exprToString v) ^ (\"*\" ^ (exprToString w))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ ((exprToString y) ^ \")\"))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with \n| VarX ->  \t     \"x\"\n| VarY ->            \"y\"\n| Sine(v) ->         \"sin(pi*\"^exprToString(v)^\")\"\n| Cosine(v) ->       \"cos(pi*\"^exprToString(v)^\")\"\n| Average(v,w) ->    \"((\"^exprToString(v)^\"+\"^exprToString(w)^\")/2)\"\n| Times(v,w) ->      exprToString(v)^\"*\"^exprToString(w)\n| Thresh(v,w,x,y) -> exprToString(v)^\"<\"^exprToString(w)^\"?\"^exprToString(x)^\":\"^exprToString(y)^\")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Cosine v -> \"cos(pi*\" ^ ((exprToString v) ^ \")\")\n  | Average (v,w) ->\n      \"((\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")/2)\")))\n  | Times (v,w) -> (exprToString v) ^ (\"*\" ^ (exprToString w))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ ((exprToString y) ^ \")\"))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| Sine(v) ->         sin(eval(v,x,y))\n| Cosine(v) ->       cos(eval(v,x,y))\n| Average(v,w) ->    (((eval(v,x,y) +. eval(w,x,y)))/.2.0)\n| Times(v,w) ->      eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if ((eval(a,x,y)) < (eval(b,x,y))) then (eval(c,x,y)) else (eval(d,x,y))\n| VarX ->\t     x\n| VarY ->\t     y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (eval (v, x, y))\n  | Cosine v -> cos (eval (v, x, y))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (v, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | VarX  -> x\n  | VarY  -> y;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with \n| Sine(v) ->         sin(pi*eval(v,x,y))\n| Cosine(v) ->       cos(pi*eval(v,x,y))\n| Average(v,w) ->    (((eval(v,x,y) +. eval(w,x,y)))/.2.0)\n| Times(v,w) ->      eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if ((eval(a,x,y)) < (eval(b,x,y))) then (eval(c,x,y)) else (eval(d,x,y))\n| VarX ->\t     x\n| VarY ->\t     y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (pi * (eval (v, x, y)))\n  | Cosine v -> cos (pi * (eval (v, x, y)))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (v, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | VarX  -> x\n  | VarY  -> y;;\n", "out": "Characters 62-64:\n  | Sine(v) ->         sin(pi*eval(v,x,y))\n                           ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}, {"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| Sine(v) ->         sin(pi*.eval(v,x,y))\n| Cosine(v) ->       cos(pi*.eval(v,x,y))\n| Average(v,w) ->    (((eval(v,x,y) +. eval(w,x,y)))/.2.0)\n| Times(v,w) ->      eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if ((eval(a,x,y)) < (eval(b,x,y))) then (eval(c,x,y)) else (eval(d,x,y))\n| VarX ->\t     x\n| VarY ->\t     y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (pi *. (eval (v, x, y)))\n  | Cosine v -> cos (pi *. (eval (v, x, y)))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (v, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | VarX  -> x\n  | VarY  -> y;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| Sine(v) ->         sin(pi*.eval(v,x,y))\n| Cosine(v) ->       cos(pi*.eval(v,x,y))\n| Average(v,w) ->    (((eval(v,x,y) +. eval(w,x,y)))/.2.0)\n| Times(v,w) ->      eval(v,x,y) *. eval(v,x,y)\n| Thresh(a,b,c,d) -> if ((eval(a,x,y)) < (eval(b,x,y))) then (eval(c,x,y)) else (eval(d,x,y))\n| VarX ->\t     x\n| VarY ->\t     y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (pi *. (eval (v, x, y)))\n  | Cosine v -> cos (pi *. (eval (v, x, y)))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (v, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | VarX  -> x\n  | VarY  -> y;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| Sine(v) ->         sin(pi*.eval(v,x,y))\n| Cosine(v) ->       cos(pi*.eval(v,x,y))\n| Average(v,w) ->    (((eval(v,x,y) +. eval(w,x,y)))/.2.0)\n| Times(v,w) ->      eval(v,x,y) *. eval(w,x,y)\n| Thresh(a,b,c,d) -> if ((eval(a,x,y)) < (eval(b,x,y))) then (eval(c,x,y)) else (eval(d,x,y))\n| VarX ->\t     x\n| VarY ->\t     y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (pi *. (eval (v, x, y)))\n  | Cosine v -> cos (pi *. (eval (v, x, y)))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (w, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | VarX  -> x\n  | VarY  -> y;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (pi *. (eval (v, x, y)))\n  | Cosine v -> cos (pi *. (eval (v, x, y)))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (w, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | VarX  -> x\n  | VarY  -> y;;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth > 0 \nthen d = d -1 in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,d))\n| 1 -> buildCosine(build(rand,d))\n| 2 -> buildAverage(build(rand,d))\n| 3 -> buildTimes(build(rand,d))\n| 4 -> buildThresh(build(rand,d))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet _ =\n  let rec build (rand,depth) = if depth > 0 then d = (d - 1) in\n  match rand (0, 4) with\n  | 0 -> buildSine (build (rand, d))\n  | 1 -> buildCosine (build (rand, d))\n  | 2 -> buildAverage (build (rand, d))\n  | 3 -> buildTimes (build (rand, d))\n  | 4 -> buildThresh (build (rand, d));;\n", "out": "Characters 50-51:\n  then d = d -1 in\n       ^\nError: Unbound value d\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nif depth > 0 \nthen depth = depth -1 in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet _ =\n  let rec build (rand,depth) = if depth > 0 then depth = (depth - 1) in\n  match rand (0, 4) with\n  | 0 -> buildSine (build (rand, depth))\n  | 1 -> buildCosine (build (rand, depth))\n  | 2 -> buildAverage (build (rand, depth))\n  | 3 -> buildTimes (build (rand, depth))\n  | 4 -> buildThresh (build (rand, depth));;\n", "out": "Characters 50-66:\n  then depth = depth -1 in\n       ^^^^^^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = depth -1 in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let depth = depth - 1 in\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, depth))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage (build (rand, depth))\n    | 3 -> buildTimes (build (rand, depth))\n    | 4 -> buildThresh (build (rand, depth));;\n", "out": "Characters 102-130:\n  | 0 -> buildSine(build(rand,depth))\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = depth -1 in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,depth)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let depth = depth - 1 in\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, depth))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage (build (rand, depth))\n    | 3 -> buildTimes (build (rand, depth))\n    | 4 -> buildThresh (build (rand, depth));;\n", "out": "Characters 102-132:\n  | 0 -> buildSine((build(rand,depth)))\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nif depth > 0 \nthen let d = depth -1 in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,d)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let d = depth - 1 in\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, d))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage (build (rand, depth))\n    | 3 -> buildTimes (build (rand, depth))\n    | 4 -> buildThresh (build (rand, depth));;\n", "out": "Characters 98-124:\n  | 0 -> buildSine((build(rand,d)))\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,depth)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let depth = depth - 1 in\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, depth))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage (build (rand, depth))\n    | 3 -> buildTimes (build (rand, depth))\n    | 4 -> buildThresh (build (rand, depth));;\n", "out": "Characters 104-134:\n  | 0 -> buildSine((build(rand,depth)))\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,depth)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let depth = depth - 1 in\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, depth))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage (build (rand, depth))\n    | 3 -> buildTimes (build (rand, depth))\n    | 4 -> buildThresh (build (rand, depth))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "out": "Characters 192-211:\n  | 2 -> buildAverage(build(rand,depth))\n                     ^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * expr\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let depth = depth - 1 in\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, depth))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n    | 3 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n    | 4 ->\n        buildThresh\n          ((build (rand, depth)), (build (rand, depth)),\n            (build (rand, depth)))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "out": "Characters 302-358:\n  | 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth))\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type expr * expr * expr * expr\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let depth = depth - 1 in\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, depth))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n    | 3 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n    | 4 ->\n        buildThresh\n          ((build (rand, depth)), (build (rand, depth)),\n            (build (rand, depth)), (build (rand, depth)))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let depth = depth - 1 in\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, depth))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n    | 3 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n    | 4 ->\n        buildThresh\n          ((build (rand, depth)), (build (rand, depth)),\n            (build (rand, depth)), (build (rand, depth)))\n  else\n    (match rand (0, 1) with\n     | 0 -> buildX ()\n     | 1 -> buildY ()\n     | 2 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,2) with\n| 0 -> buildX()\n| 1 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let depth = depth - 1 in\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, depth))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n    | 3 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n    | 4 ->\n        buildThresh\n          ((build (rand, depth)), (build (rand, depth)),\n            (build (rand, depth)), (build (rand, depth)))\n  else (match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| _ -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,2) with\n| 0 -> buildX()\n| _ -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let depth = depth - 1 in\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, depth))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n    | 3 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n    | _ ->\n        buildThresh\n          ((build (rand, depth)), (build (rand, depth)),\n            (build (rand, depth)), (build (rand, depth)))\n  else (match rand (0, 2) with | 0 -> buildX () | _ -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (pi *. (eval (v, x, y)))\n  | Cosine v -> cos (pi *. (eval (v, x, y)))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (w, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | VarX  -> x\n  | VarY  -> y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let depth = depth - 1 in\n    match rand (0, 4) with\n    | 0 -> buildSine (build (rand, depth))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n    | 3 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n    | _ ->\n        buildThresh\n          ((build (rand, depth)), (build (rand, depth)),\n            (build (rand, depth)), (build (rand, depth)))\n  else (match rand (0, 2) with | 0 -> buildX () | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Cosine v -> \"cos(pi*\" ^ ((exprToString v) ^ \")\")\n  | Average (v,w) ->\n      \"((\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")/2)\")))\n  | Times (v,w) -> (exprToString v) ^ (\"*\" ^ (exprToString w))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ ((exprToString y) ^ \")\"))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =   \nmatch l with\n| [] -> d\n| x :: xs -> match x with\n| (s,i) -> if s = k then i else assoc(d,k,xs)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | x::xs -> (match x with | (s,i) -> if s = k then i else assoc (d, k, xs));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =   \nmatch l with\n| [] -> d\n| x :: xs -> match x with\n| (s,i) -> if s = k then i else assoc(d,k,xs)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | x::xs -> (match x with | (s,i) -> if s = k then i else assoc (d, k, xs));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =   \nmatch l with\n| [] -> d\n| x :: xs -> match x with\n| (s,i) -> if s = k then i else assoc(d,k,xs)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | x::xs -> (match x with | (s,i) -> if s = k then i else assoc (d, k, xs));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec exprToString e = match e with \n| VarX ->  \t     \"x\"\n| VarY ->            \"y\"\n| Sine(v) ->         \"sin(pi*\"^exprToString(v)^\")\"\n| Cosine(v) ->       \"cos(pi*\"^exprToString(v)^\")\"\n| Average(v,w) ->    \"((\"^exprToString(v)^\"+\"^exprToString(w)^\")/2)\"\n| Times(v,w) ->      exprToString(v)^\"*\"^exprToString(w)\n| Thresh(v,w,x,y) -> exprToString(v)^\"<\"^exprToString(w)^\"?\"^exprToString(x)^\":\"^exprToString(y)^\")\"\n| Plus(v,w) ->\t     \"(\"^exprToString(v)^\"+\"exprToString(w)^\")\"\n| Cube(v,w,x) ->     \"(\"^exprToString(v)^\"*\"^exprToString(w)^\"*\"^exprToString(x)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Plus of expr* expr\n  | Cube of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Cosine v -> \"cos(pi*\" ^ ((exprToString v) ^ \")\")\n  | Average (v,w) ->\n      \"((\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")/2)\")))\n  | Times (v,w) -> (exprToString v) ^ (\"*\" ^ (exprToString w))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ ((exprToString y) ^ \")\"))))))\n  | Plus (v,w) -> \"(\" ^ ((exprToString v) ^ ((\"+\" exprToString w) ^ \")\"))\n  | Cube (v,w,x) ->\n      \"(\" ^\n        ((exprToString v) ^\n           (\"*\" ^ ((exprToString w) ^ (\"*\" ^ (exprToString x)))));;\n", "out": "Characters 454-457:\n  | Plus(v,w) ->\t     \"(\"^exprToString(v)^\"+\"exprToString(w)^\")\"\n                                          ^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n"}, {"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Plus of expr* expr\n  | Cube of expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with \n| VarX ->  \t     \"x\"\n| VarY ->            \"y\"\n| Sine(v) ->         \"sin(pi*\"^exprToString(v)^\")\"\n| Cosine(v) ->       \"cos(pi*\"^exprToString(v)^\")\"\n| Average(v,w) ->    \"((\"^exprToString(v)^\"+\"^exprToString(w)^\")/2)\"\n| Times(v,w) ->      exprToString(v)^\"*\"^exprToString(w)\n| Thresh(v,w,x,y) -> exprToString(v)^\"<\"^exprToString(w)^\"?\"^exprToString(x)^\":\"^exprToString(y)^\")\"\n| Plus(v,w) ->\t     \"(\"^exprToString(v)^\"+\"^exprToString(w)^\")\"\n| Cube(v,w,x) ->     \"(\"^exprToString(v)^\"*\"^exprToString(w)^\"*\"^exprToString(x)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Plus of expr* expr\n  | Cube of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Cosine v -> \"cos(pi*\" ^ ((exprToString v) ^ \")\")\n  | Average (v,w) ->\n      \"((\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")/2)\")))\n  | Times (v,w) -> (exprToString v) ^ (\"*\" ^ (exprToString w))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ ((exprToString y) ^ \")\"))))))\n  | Plus (v,w) -> \"(\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")\")))\n  | Cube (v,w,x) ->\n      \"(\" ^\n        ((exprToString v) ^\n           (\"*\" ^ ((exprToString w) ^ (\"*\" ^ (exprToString x)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| Sine(v) ->         sin(pi*.eval(v,x,y))\n| Cosine(v) ->       cos(pi*.eval(v,x,y))\n| Average(v,w) ->    (((eval(v,x,y) +. eval(w,x,y)))/.2.0)\n| Times(v,w) ->      eval(v,x,y) *. eval(w,x,y)\n| Thresh(a,b,c,d) -> if ((eval(a,x,y)) < (eval(b,x,y))) then (eval(c,x,y)) else (eval(d,x,y))\n| Plus(v,w) ->       (eval(v,x,y) +. eval(w,x,y))\n| Cube(a,b,c) ->     (eval(a,x,y) *. eval(b,x,y) *. eval(c,x,y))\n| VarX ->\t     x\n| VarY ->\t     y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Plus of expr* expr\n  | Cube of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (pi *. (eval (v, x, y)))\n  | Cosine v -> cos (pi *. (eval (v, x, y)))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (w, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Plus (v,w) -> (eval (v, x, y)) +. (eval (w, x, y))\n  | Cube (a,b,c) ->\n      ((eval (a, x, y)) *. (eval (b, x, y))) *. (eval (c, x, y))\n  | VarX  -> x\n  | VarY  -> y;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Plus of expr* expr\n  | Cube of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =   \nmatch l with\n| [] -> d\n| x :: xs -> match x with\n| (s,i) -> if s = k then i else assoc(d,k,xs)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | x::xs -> (match x with | (s,i) -> if s = k then i else assoc (d, k, xs));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =   \nmatch l with\n| [] -> d\n| x :: xs -> match x with\n| (s,i) -> if s = k then i else assoc(d,k,xs)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | x::xs -> (match x with | (s,i) -> if s = k then i else assoc (d, k, xs));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine v -> sin (pi *. (eval (v, x, y)))\n  | Cosine v -> cos (pi *. (eval (v, x, y)))\n  | Average (v,w) -> ((eval (v, x, y)) +. (eval (w, x, y))) /. 2.0\n  | Times (v,w) -> (eval (v, x, y)) *. (eval (w, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Square (v,w) -> (eval (v, x, y)) *. (eval (v, x, y))\n  | Cube (a,b,c) ->\n      ((eval (a, x, y)) *. (eval (b, x, y))) *. (eval (c, x, y))\n  | VarX  -> x\n  | VarY  -> y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr* expr\n  | Cube of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCube (a,b,c) = Cube (a, b, c);;\n\nlet buildSine e = Sine e;;\n\nlet buildSquare (e1,e2) = Square (e1, e2);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let depth = depth - 1 in\n    match rand (0, 6) with\n    | 0 -> buildSine (build (rand, depth))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n    | 3 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n    | 4 ->\n        buildThresh\n          ((build (rand, depth)), (build (rand, depth)),\n            (build (rand, depth)), (build (rand, depth)))\n    | 5 -> buildSquare ((build (rand, depth)), (build (rand, depth)))\n    | _ ->\n        buildCube\n          ((build (rand, depth)), (build (rand, depth)),\n            (build (rand, depth)))\n  else (match rand (0, 2) with | 0 -> buildX () | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Cosine v -> \"cos(pi*\" ^ ((exprToString v) ^ \")\")\n  | Average (v,w) ->\n      \"((\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")/2)\")))\n  | Times (v,w) -> (exprToString v) ^ (\"*\" ^ (exprToString w))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ ((exprToString y) ^ \")\"))))))\n  | Square (v,w) ->\n      \"(\" ^ ((exprToString v) ^ (\"*\" ^ ((exprToString v) ^ \")\")))\n  | Cube (v,w,x) ->\n      \"(\" ^\n        ((exprToString v) ^\n           (\"*\" ^ ((exprToString w) ^ (\"*\" ^ (exprToString x)))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =   \nmatch l with\n| [] -> d\n| x :: xs -> match x with\n| (s,i) -> if s = k then i else assoc(d,k,xs)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | x::xs -> (match x with | (s,i) -> if s = k then i else assoc (d, k, xs));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (v,false ) -> v | (v,true ) -> wwhile (f, v);;\n\nlet fixpoint (f,b) = wwhile ((fun v  -> let x = f v in (x, (x != v))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (v,false ) -> v | (v,true ) -> wwhile (f, v);;\n\nlet fixpoint (f,b) = wwhile ((fun v  -> let x = f v in (x, (x != v))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (v,false ) -> v | (v,true ) -> wwhile (f, v);;\n\nlet fixpoint (f,b) = wwhile ((fun v  -> let x = f v in (x, (x != v))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (v,false ) -> v | (v,true ) -> wwhile (f, v);;\n\nlet fixpoint (f,b) = wwhile ((fun v  -> let x = f v in (x, (x != v))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (v,false ) -> v | (v,true ) -> wwhile (f, v);;\n\nlet fixpoint (f,b) = wwhile ((fun v  -> let x = f v in (x, (x != v))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (v,false ) -> v | (v,true ) -> wwhile (f, v);;\n\nlet fixpoint (f,b) = wwhile ((fun v  -> let x = f v in (x, (x != v))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (v,false ) -> v | (v,true ) -> wwhile (f, v);;\n\nlet fixpoint (f,b) = wwhile ((fun v  -> let x = f v in (x, (x != v))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =   \nmatch l with\n| [] -> d\n| x :: xs -> match x with\n| (s,i) -> if s = k then i else assoc(d,k,xs)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | x::xs -> (match x with | (s,i) -> if s = k then i else assoc (d, k, xs));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint(f,b) = wwhile ((let func v =\nlet result = f p in\nif p = result then (p,false)\nelse (p,true) in func),b)", "min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((let func v =\n        let result = f p in if p = result then (p, false) else (p, true) in\n      func), b);;\n", "out": "Characters 20-26:\n  let fixpoint(f,b) = wwhile ((let func v =\n                      ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}, {"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Square     of expr * expr\n| Cube     of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr* expr\n  | Cube of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint(f,b) = wwhile ((let func v =\nlet result = f b in\nif b = result then (result,false)\nelse (result,true) in v),b)", "min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((let func v =\n        let result = f b in\n        if b = result then (result, false) else (result, true) in\n      v), b);;\n", "out": "Characters 20-26:\n  let fixpoint(f,b) = wwhile ((let func v =\n                      ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint(f,b) = wwhile ((let func v =\nlet result = f b in\nif b = result then (result,false)\nelse (result,true) in func),b)", "min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((let func v =\n        let result = f b in\n        if b = result then (result, false) else (result, true) in\n      func), b);;\n", "out": "Characters 20-26:\n  let fixpoint(f,b) = wwhile ((let func v =\n                      ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": "Characters 46-52:\n  wwhile (f, 2);;\n  ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let fixpoint(f,b) = wwhile(( fun x -> let b = (f x) in (b, b !=x)), b)", "min": "\nlet fixpoint (f,b) = wwhile ((fun x  -> let b = f x in (b, (b != x))), b);;\n", "out": "Characters 20-26:\n  let fixpoint(f,b) = wwhile(( fun x -> let b = (f x) in (b, b !=x)), b);;\n                      ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}, {"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Square     of expr * expr\n| Cube     of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr* expr\n  | Cube of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =   \nmatch l with\n| [] -> d\n| x :: xs -> match x with\n| (s,i) -> if s = k then i else assoc(d,k,xs)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | x::xs -> (match x with | (s,i) -> if s = k then i else assoc (d, k, xs));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": "Characters 46-52:\n  wwhile (f, 2);;\n  ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}, {"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Square     of expr * expr\n| Cube     of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr* expr\n  | Cube of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =   \nmatch l with\n| [] -> d\n| x :: xs -> match x with\n| (s,i) -> if s = k then i else assoc(d,k,xs)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | x::xs -> (match x with | (s,i) -> if s = k then i else assoc (d, k, xs));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}, {"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Square     of expr * expr\n| Cube     of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr* expr\n  | Cube of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((fun x -> let x = (f v) in (x, x != v)),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (v,false ) -> v | (v,true ) -> wwhile (f, v);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let x = f v in (x, (x != v))), b);;\n", "out": "Characters 50-51:\n  let fixpoint (f,b) = wwhile ((fun x -> let x = (f v) in (x, x != v)),b);;\n                                                    ^\nError: Unbound value v\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}, {"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Square     of expr * expr\n| Cube     of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr* expr\n  | Cube of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((fun x -> let x = (f x) in (x, x != v)),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (v,false ) -> v | (v,true ) -> wwhile (f, v);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let x = f x in (x, (x != v))), b);;\n", "out": "Characters 65-66:\n  let fixpoint (f,b) = wwhile ((fun x -> let x = (f x) in (x, x != v)),b);;\n                                                                   ^\nError: Unbound value v\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}, {"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Square     of expr * expr\n| Cube     of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr* expr\n  | Cube of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((fun x -> let x = (f x) in (x, x != v)),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (v,false ) -> v | (v,true ) -> wwhile (f, v);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let x = f x in (x, (x != v))), b);;\n", "out": "Characters 65-66:\n  let fixpoint (f,b) = wwhile ((fun x -> let x = (f x) in (x, x != v)),b);;\n                                                                   ^\nError: Unbound value v\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}, {"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Square     of expr * expr\n| Cube     of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr* expr\n  | Cube of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((fun x -> let x = (f x) in (x, x != v)),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (v,false ) -> v | (v,true ) -> wwhile (f, v);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let x = f x in (x, (x != v))), b);;\n", "out": "Characters 65-66:\n  let fixpoint (f,b) = wwhile ((fun x -> let x = (f x) in (x, x != v)),b);;\n                                                                   ^\nError: Unbound value v\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}, {"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Square     of expr * expr\n| Cube     of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr* expr\n  | Cube of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((fun x -> let x = (f x) in (x, x != v)),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (v,false ) -> v | (v,true ) -> wwhile (f, v);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let x = f x in (x, (x != v))), b);;\n", "out": "Characters 65-66:\n  let fixpoint (f,b) = wwhile ((fun x -> let x = (f x) in (x, x != v)),b);;\n                                                                   ^\nError: Unbound value v\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}, {"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Square     of expr * expr\n| Cube     of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr* expr\n  | Cube of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((fun x -> let x = (f x) in (x, x != x)),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (v,false ) -> v | (v,true ) -> wwhile (f, v);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let x = f x in (x, (x != x))), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((fun x -> let a = (f x) in (a, a != x)),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (v,false ) -> v | (v,true ) -> wwhile (f, v);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let a = f x in (a, (a != x))), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,6) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\n| 5 -> buildSquare(build(rand,depth),build(rand,depth))\n| _ -> buildCube(build(rand,depth),build(rand,depth),build(rand,depth))\nelse \nmatch rand(0,2) with\n| 0 -> buildX()\n| _ -> buildY()", "min": "\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let depth = depth - 1 in\n    match rand (0, 6) with\n    | 0 -> buildSine (build (rand, depth))\n    | 1 -> buildCosine (build (rand, depth))\n    | 2 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n    | 3 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n    | 4 ->\n        buildThresh\n          ((build (rand, depth)), (build (rand, depth)),\n            (build (rand, depth)), (build (rand, depth)))\n    | 5 -> buildSquare ((build (rand, depth)), (build (rand, depth)))\n    | _ ->\n        buildCube\n          ((build (rand, depth)), (build (rand, depth)),\n            (build (rand, depth)))\n  else (match rand (0, 2) with | 0 -> buildX () | _ -> buildY ());;\n", "out": "Characters 104-113:\n  | 0 -> buildSine(build(rand,depth))\n         ^^^^^^^^^\nError: Unbound value buildSine\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =   \nmatch l with\n| [] -> d\n| x :: xs -> match x with\n| (s,i) -> if s = k then i else assoc(d,k,xs)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | x::xs -> (match x with | (s,i) -> if s = k then i else assoc (d, k, xs));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}, {"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Square     of expr * expr\n| Cube     of expr * expr * expr\n\n(* exprToString : expr -> string\nComplete this function to convert an expr to a string \n*)\nlet rec exprToString e = match e with \n| VarX ->  \t     \"x\"\n| VarY ->            \"y\"\n| Sine(v) ->         \"sin(pi*\"^exprToString(v)^\")\"\n| Cosine(v) ->       \"cos(pi*\"^exprToString(v)^\")\"\n| Average(v,w) ->    \"((\"^exprToString(v)^\"+\"^exprToString(w)^\")/2)\"\n| Times(v,w) ->      exprToString(v)^\"*\"^exprToString(w)\n| Thresh(v,w,x,y) -> exprToString(v)^\"<\"^exprToString(w)^\"?\"^exprToString(x)^\":\"^exprToString(y)^\")\"\n| Square(v,w) ->     \"(\"^exprToString(v)^\"*\"^exprToString(v)^\")\"\n| Cube(v,w,x) ->     \"(\"^exprToString(v)^\"*\"^exprToString(w)^\"*\"^exprToString(x)\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr* expr\n  | Cube of expr* expr* expr\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Cosine v -> \"cos(pi*\" ^ ((exprToString v) ^ \")\")\n  | Average (v,w) ->\n      \"((\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")/2)\")))\n  | Times (v,w) -> (exprToString v) ^ (\"*\" ^ (exprToString w))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ ((exprToString y) ^ \")\"))))))\n  | Square (v,w) ->\n      \"(\" ^ ((exprToString v) ^ (\"*\" ^ ((exprToString v) ^ \")\")))\n  | Cube (v,w,x) ->\n      \"(\" ^\n        ((exprToString v) ^\n           (\"*\" ^ ((exprToString w) ^ (\"*\" ^ (exprToString x)))))\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}, {"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Square     of expr * expr\n| Cube     of expr * expr * expr\n\n(* exprToString : expr -> string\nComplete this function to convert an expr to a string \n*)\nlet rec exprToString e = match e with \n| VarX ->  \t     \"x\"\n| VarY ->            \"y\"\n| Sine(v) ->         \"sin(pi*\"^exprToString(v)^\")\"\n| Cosine(v) ->       \"cos(pi*\"^exprToString(v)^\")\"\n| Average(v,w) ->    \"((\"^exprToString(v)^\"+\"^exprToString(w)^\")/2)\"\n| Times(v,w) ->      exprToString(v)^\"*\"^exprToString(w)\n| Thresh(v,w,x,y) -> exprToString(v)^\"<\"^exprToString(w)^\"?\"^exprToString(x)^\":\"^exprToString(y)^\")\"\n| Square(v,w) ->     \"(\"^exprToString(v)^\"*\"^exprToString(v)^\")\"\n| Cube(v,w,x) ->     \"(\"^exprToString(v)^\"*\"^exprToString(w)^\"*\"^exprToString(x)\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr* expr\n  | Cube of expr* expr* expr\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Cosine v -> \"cos(pi*\" ^ ((exprToString v) ^ \")\")\n  | Average (v,w) ->\n      \"((\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")/2)\")))\n  | Times (v,w) -> (exprToString v) ^ (\"*\" ^ (exprToString w))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ ((exprToString y) ^ \")\"))))))\n  | Square (v,w) ->\n      \"(\" ^ ((exprToString v) ^ (\"*\" ^ ((exprToString v) ^ \")\")))\n  | Cube (v,w,x) ->\n      \"(\" ^\n        ((exprToString v) ^\n           (\"*\" ^ ((exprToString w) ^ (\"*\" ^ (exprToString x)))))\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr* expr\n  | Cube of expr* expr* expr\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Cosine v -> \"cos(pi*\" ^ ((exprToString v) ^ \")\")\n  | Average (v,w) ->\n      \"((\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")/2)\")))\n  | Times (v,w) -> (exprToString v) ^ (\"*\" ^ (exprToString w))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ ((exprToString y) ^ \")\"))))))\n  | Square (v,w) ->\n      \"(\" ^ ((exprToString v) ^ (\"*\" ^ ((exprToString v) ^ \")\")))\n  | Cube (v,w,x) ->\n      \"(\" ^\n        ((exprToString v) ^\n           (\"*\" ^ ((exprToString w) ^ (\"*\" ^ (exprToString x)))))\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}, {"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Square     of expr * expr\n| Cube     of expr * expr * expr\n\n(* exprToString : expr -> string\nComplete this function to convert an expr to a string \n*)\nlet rec exprToString e = match e with \n| VarX ->  \t     \"x\"\n| VarY ->            \"y\"\n| Sine(v) ->         \"sin(pi*\"^exprToString(v)^\")\"\n| Cosine(v) ->       \"cos(pi*\"^exprToString(v)^\")\"\n| Average(v,w) ->    \"((\"^exprToString(v)^\"+\"^exprToString(w)^\")/2)\"\n| Times(v,w) ->      exprToString(v)^\"*\"^exprToString(w)\n| Thresh(v,w,x,y) -> exprToString(v)^\"<\"^exprToString(w)^\"?\"^exprToString(x)^\":\"^exprToString(y)^\")\"\n| Square(v,w) ->     \"(\"^exprToString(v)^\"*\"^exprToString(v)^\")\"\n| Cube(v,w,x) ->     \"(\"^exprToString(v)^\"*\"^exprToString(w)^\"*\"^exprToString(x)\n\n\nlet sampleExpr1 = Thresh(VarX,VarY,VarX,(Times(Sine(VarX),Cosine(Average(VarX,VarY)))))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr* expr\n  | Cube of expr* expr* expr\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Cosine v -> \"cos(pi*\" ^ ((exprToString v) ^ \")\")\n  | Average (v,w) ->\n      \"((\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")/2)\")))\n  | Times (v,w) -> (exprToString v) ^ (\"*\" ^ (exprToString w))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ ((exprToString y) ^ \")\"))))))\n  | Square (v,w) ->\n      \"(\" ^ ((exprToString v) ^ (\"*\" ^ ((exprToString v) ^ \")\")))\n  | Cube (v,w,x) ->\n      \"(\" ^\n        ((exprToString v) ^\n           (\"*\" ^ ((exprToString w) ^ (\"*\" ^ (exprToString x)))))\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr* expr\n  | Cube of expr* expr* expr\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Cosine v -> \"cos(pi*\" ^ ((exprToString v) ^ \")\")\n  | Average (v,w) ->\n      \"((\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")/2)\")))\n  | Times (v,w) -> (exprToString v) ^ (\"*\" ^ (exprToString w))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ ((exprToString y) ^ \")\"))))))\n  | Square (v,w) ->\n      \"(\" ^ ((exprToString v) ^ (\"*\" ^ ((exprToString v) ^ \")\")))\n  | Cube (v,w,x) ->\n      \"(\" ^\n        ((exprToString v) ^\n           (\"*\" ^ ((exprToString w) ^ (\"*\" ^ (exprToString x)))))\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr* expr\n  | Cube of expr* expr* expr\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine v -> \"sin(pi*\" ^ ((exprToString v) ^ \")\")\n  | Cosine v -> \"cos(pi*\" ^ ((exprToString v) ^ \")\")\n  | Average (v,w) ->\n      \"((\" ^ ((exprToString v) ^ (\"+\" ^ ((exprToString w) ^ \")/2)\")))\n  | Times (v,w) -> (exprToString v) ^ (\"*\" ^ (exprToString w))\n  | Thresh (v,w,x,y) ->\n      (exprToString v) ^\n        (\"<\" ^\n           ((exprToString w) ^\n              (\"?\" ^ ((exprToString x) ^ (\":\" ^ ((exprToString y) ^ \")\"))))))\n  | Square (v,w) ->\n      \"(\" ^ ((exprToString v) ^ (\"*\" ^ ((exprToString v) ^ \")\")))\n  | Cube (v,w,x) ->\n      \"(\" ^\n        ((exprToString v) ^\n           (\"*\" ^ ((exprToString w) ^ (\"*\" ^ (exprToString x)))))\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((fun v-> let x = \n(f v) in \n(x , x != v)),b)", "min": "\nlet fixpoint (f,b) = wwhile ((fun v  -> let x = f v in (x, (x != v))), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((fun v-> let x = \n                       ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}, {"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Square     of expr * expr\n| Cube     of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Square of expr* expr\n  | Cube of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Fifth    of expr * expr * expr * expr * expr\n| Cube     of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Fifth of expr* expr* expr* expr* expr\n  | Cube of expr* expr* expr;;\n", "out": ""}]}
