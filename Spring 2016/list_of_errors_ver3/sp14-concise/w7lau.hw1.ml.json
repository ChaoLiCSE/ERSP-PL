{"event": "eval", "ocaml": [{"in": "let rec sumList xs = failwith \"TBD:sumList\"", "out": "", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = failwith \"TBD:sumList\"", "out": "", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = failwith \"TBD:sumList\"", "out": "", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd::tl ->\nhd + (sumList tl)", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "sumList[1;-2;3;5]", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "sumList[1;3;5;7;9;11]", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| hd::tl ->\nhd :: (digitsOfInt tl)", "out": "Characters 63-69:\n  | hd::tl ->\n    ^^^^^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | hd::tl -> hd :: (digitsOfInt tl));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> [] @ (n mod 10)", "out": "Characters 73-83:\n  | n -> [] @ (n mod 10);;\n              ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [] @ (n mod 10));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> [] :: (n mod 10)", "out": "Characters 74-84:\n  | n -> [] :: (n mod 10);;\n               ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list list\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [] :: (n mod 10));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> [] @ [(n mod 10)]", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [] @ [n mod 10]);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> [] @ [(digitsOfInt(n mod 10))]", "out": "Characters 68-98:\n  | n -> [] @ [(digitsOfInt(n mod 10))];;\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list list\n       but an expression was expected of type 'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [] @ [digitsOfInt (n mod 10)]);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> [] @ [(n mod 10)]", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [] @ [n mod 10]);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> [] @ (n mod 10)", "out": "Characters 73-83:\n  | n -> [] @ (n mod 10);;\n              ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [] @ (n mod 10));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> [] @ [(n mod 10)]", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [] @ [n mod 10]);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> [] @ [(n mod 10)]", "out": "", "min": "\nlet digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [] @ [n mod 10]);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> (n mod 10) :: []", "out": "", "min": "\nlet digitsOfInt n = if n <= 0 then [] else (match n with | n -> [n mod 10]);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> digitsOfInt(n mod 10) :: []", "out": "", "min": "\nlet digitsOfInt n = if n <= 0 then [] else (match n with | n -> [n mod 10]);;\n\nlet digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [digitsOfInt (n mod 10)]);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> digitsOfInt(n) :: []", "out": "", "min": "\nlet digitsOfInt n = if n <= 0 then [] else (match n with | n -> [n mod 10]);;\n\nlet digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [digitsOfInt (n mod 10)]);;\n\nlet digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [digitsOfInt n]);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> digitsOfInt(n) :: []", "out": "Characters 68-82:\n  | n -> digitsOfInt(n) :: [];;\n         ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [digitsOfInt n]);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> digitsOfInt(n % 10) :: []", "out": "Characters 82-83:\n  | n -> digitsOfInt(n % 10) :: [];;\n                       ^\nError: Unbound value %\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [digitsOfInt (n % 10)]);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> digitsOfInt(n mod 10) :: []", "out": "Characters 68-89:\n  | n -> digitsOfInt(n mod 10) :: [];;\n         ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [digitsOfInt (n mod 10)]);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> digitsOfInt(n mod 10) :: []", "out": "Characters 68-89:\n  | n -> digitsOfInt(n mod 10) :: [];;\n         ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [digitsOfInt (n mod 10)]);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> n mod 10 :: []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [n mod 10]);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> reduceADigit(n) mod 10 :: []", "out": "", "min": "\nlet reduceADigit x = x / 10;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [(reduceADigit n) mod 10]);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> reduceADigit(n) mod 10 :: []", "out": "", "min": "\nlet reduceADigit x = x / 10;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (match n with | n -> [(reduceADigit n) mod 10]);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = \nlet rec addDigit next n = \nif n < 0 then []\nelse addDigit ((n mod 10)::next) (n/10) in addDigit [] n", "out": "", "min": "\nlet digitsOfInt n =\n  let rec addDigit next n =\n    if n < 0 then [] else addDigit ((n mod 10) :: next) (n / 10) in\n  addDigit [] n;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n = 0 then []\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> loop n []", "out": "Characters 135-139:\n  | _ -> loop n [];;\n         ^^^^\nError: Unbound value loop\n", "min": "\nlet digitsOfInt n =\n  let rec addDigit n acc =\n    if n = 0 then [] else addDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | 0 -> [0] | _ -> loop n [];;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n = 0 then []\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> addDigit n []", "out": "", "min": "\nlet digitsOfInt n =\n  let rec addDigit n acc =\n    if n = 0 then [] else addDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | 0 -> [0] | _ -> addDigit n [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n <= 0 then []\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> addDigit n []", "out": "", "min": "\nlet digitsOfInt n =\n  let rec addDigit n acc =\n    if n <= 0 then [] else addDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | 0 -> [0] | _ -> addDigit n [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n <= 0 then []\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| n -> addDigit n []", "out": "", "min": "\nlet digitsOfInt n =\n  let rec addDigit n acc =\n    if n <= 0 then [] else addDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | n -> addDigit n [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n <= 0 then []\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| _ -> addDigit n []", "out": "", "min": "\nlet digitsOfInt n =\n  let rec addDigit n acc =\n    if n <= 0 then [] else addDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> addDigit n [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n <= 0 then []\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> addDigit n []", "out": "", "min": "\nlet digitsOfInt n =\n  let rec addDigit n acc =\n    if n <= 0 then [] else addDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | 0 -> [0] | _ -> addDigit n [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n <= 0 then acc\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> addDigit n []", "out": "", "min": "\nlet digitsOfInt n =\n  let rec addDigit n acc =\n    if n <= 0 then acc else addDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | 0 -> [0] | _ -> addDigit n [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = \nif n <= 0 then []\nelse let rec addDigit n acc = \nif n <= 0 then acc\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> addDigit n []", "out": "", "min": "\nlet digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec addDigit n acc =\n       if n <= 0 then acc else addDigit (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> addDigit n []);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n <= 0 then acc\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> addDigit n []", "out": "", "min": "\nlet digitsOfInt n =\n  let rec addDigit n acc =\n    if n <= 0 then acc else addDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | 0 -> [0] | _ -> addDigit n [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n <= 0 then []\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> addDigit n []", "out": "", "min": "\nlet digitsOfInt n =\n  let rec addDigit n acc =\n    if n <= 0 then [] else addDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | 0 -> [0] | _ -> addDigit n [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n <= 0 then acc\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| 0 -> [0]\n| _ -> addDigit n []", "out": "", "min": "\nlet digitsOfInt n =\n  let rec addDigit n acc =\n    if n <= 0 then acc else addDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | 0 -> [0] | _ -> addDigit n [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n <= 0 then acc\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| _ -> addDigit n []", "out": "", "min": "\nlet digitsOfInt n =\n  let rec addDigit n acc =\n    if n <= 0 then acc else addDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> addDigit n [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n <= 0 then acc\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| n -> addDigit n []", "out": "", "min": "\nlet digitsOfInt n =\n  let rec addDigit n acc =\n    if n <= 0 then acc else addDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | n -> addDigit n [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = \nlet rec addDigit n acc = \nif n <= 0 then acc\nelse addDigit (n/10) (n mod 10::acc) in\nmatch n with\n| _ -> addDigit n []", "out": "", "min": "\nlet digitsOfInt n =\n  let rec addDigit n acc =\n    if n <= 0 then acc else addDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> addDigit n [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = \nlet rec lastDigit n acc = \nif n <= 0 then acc\nelse lastDigit (n/10) (n mod 10::acc) in\nmatch n with\n| _ -> lastDigit n []", "out": "", "min": "\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = \nlet rec lastDigit n acc = \nif n <= 0 then acc\nelse lastDigit (n/10) (n mod 10::acc) in\nmatch n with\n| _ -> lastDigit n []", "out": "", "min": "\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digits n = digitsOfInt (abs n)", "out": "", "min": "\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n\nlet digits n = digitsOfInt (abs n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n count= \nmatch n with\n| [] -> count\n| _ -> additivePersistence(sumList(digitsOfInt(n)) (count+1))", "out": "Characters 92-99:\n  | _ -> additivePersistence(sumList(digitsOfInt(n)) (count+1));;\n                             ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec additivePersistence n count =\n  match n with\n  | [] -> count\n  | _ -> additivePersistence (sumList (digitsOfInt n) (count + 1));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n count= \nmatch n with\n| [] -> count\n| _ -> additivePersistence((sumList(digitsOfInt(n))) (count+1))", "out": "Characters 93-100:\n  | _ -> additivePersistence((sumList(digitsOfInt(n))) (count+1));;\n                              ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec additivePersistence n count =\n  match n with\n  | [] -> count\n  | _ -> additivePersistence ((sumList (digitsOfInt n)) (count + 1));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n count= \nmatch n with\n| 0 -> count\n| _ -> additivePersistence((sumList(digitsOfInt(n))) (count+1))", "out": "Characters 92-99:\n  | _ -> additivePersistence((sumList(digitsOfInt(n))) (count+1));;\n                              ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec additivePersistence n count =\n  match n with\n  | 0 -> count\n  | _ -> additivePersistence ((sumList (digitsOfInt n)) (count + 1));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = \nlet rec lastDigit n accu = \nif n <= 0 then accu\nelse lastDigit (n/10) (n mod 10::accu) in\nmatch n with\n| _ -> lastDigit n []", "out": "", "min": "\nlet digitsOfInt n =\n  let rec lastDigit n accu =\n    if n <= 0 then accu else lastDigit (n / 10) ((n mod 10) :: accu) in\n  match n with | _ -> lastDigit n [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digits n = digitsOfInt (abs n)", "out": "", "min": "\nlet digitsOfInt n =\n  let rec lastDigit n accu =\n    if n <= 0 then accu else lastDigit (n / 10) ((n mod 10) :: accu) in\n  match n with | _ -> lastDigit n [];;\n\nlet digits n = digitsOfInt (abs n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nmatch n with\n| 0 -> 0\n| _ -> additivePersistence sumList digitsOfInt n", "out": "Characters 62-81:\n  | _ -> additivePersistence sumList digitsOfInt n;;\n         ^^^^^^^^^^^^^^^^^^^\nError: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet digitsOfInt n =\n  let rec lastDigit n accu =\n    if n <= 0 then accu else lastDigit (n / 10) ((n mod 10) :: accu) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec additivePersistence n =\n  match n with | 0 -> 0 | _ -> additivePersistence sumList digitsOfInt n;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nmatch n with\n| 0 -> 0\n| _ -> additivePersistence sumList (digitsOfInt n)", "out": "Characters 62-81:\n  | _ -> additivePersistence sumList (digitsOfInt n);;\n         ^^^^^^^^^^^^^^^^^^^\nError: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet digitsOfInt n =\n  let rec lastDigit n accu =\n    if n <= 0 then accu else lastDigit (n / 10) ((n mod 10) :: accu) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec additivePersistence n =\n  match n with | 0 -> 0 | _ -> additivePersistence sumList (digitsOfInt n);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nmatch n with\n| 0 -> 0\n| _ -> additivePersistence (sumList (digitsOfInt n))", "out": "Characters 83-90:\n  | _ -> additivePersistence (sumList (digitsOfInt n));;\n                              ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet digitsOfInt n =\n  let rec lastDigit n accu =\n    if n <= 0 then accu else lastDigit (n / 10) ((n mod 10) :: accu) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec additivePersistence n =\n  match n with | 0 -> 0 | _ -> additivePersistence (sumList (digitsOfInt n));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nmatch n with\n| 0 -> 0\n| _ -> (sumList (digitsOfInt n))", "out": "Characters 63-70:\n  | _ -> (sumList (digitsOfInt n));;\n          ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet rec additivePersistence n =\n  match n with | 0 -> 0 | _ -> sumList (digitsOfInt n);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nmatch n with\n| _ -> (sumList (digitsOfInt n))", "out": "Characters 54-61:\n  | _ -> (sumList (digitsOfInt n));;\n          ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet rec additivePersistence n = match n with | _ -> sumList (digitsOfInt n);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nmatch n with\n| _ -> additivePersistence(sumList (digitsOfInt n))", "out": "Characters 73-80:\n  | _ -> additivePersistence(sumList (digitsOfInt n));;\n                             ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet rec additivePersistence n =\n  match n with | _ -> additivePersistence (sumList (digitsOfInt n));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList digitsOfInt n = 1)\nthen additivePersistence(sumList (digitsOfInt n))\nelse 4", "out": "Characters 84-95:\n  if not (lengthOfList digitsOfInt n = 1)\n                       ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet rec additivePersistence n =\n  match n with\n  | 0 -> 0\n  | _ ->\n      if not ((lengthOfList digitsOfInt n) = 1)\n      then additivePersistence (sumList (digitsOfInt n))\n      else 4;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) = 1)\nthen additivePersistence(sumList (digitsOfInt n))\nelse 4", "out": "Characters 85-96:\n  if not (lengthOfList (digitsOfInt n) = 1)\n                        ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet rec additivePersistence n =\n  match n with\n  | 0 -> 0\n  | _ ->\n      if not ((lengthOfList (digitsOfInt n)) = 1)\n      then additivePersistence (sumList (digitsOfInt n))\n      else 4;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additivePersistence(sumList (digitsOfInt n))\nelse 4", "out": "Characters 85-96:\n  if not (lengthOfList (digitsOfInt n) 0 = 1)\n                        ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet rec additivePersistence n =\n  match n with\n  | 0 -> 0\n  | _ ->\n      if not ((lengthOfList (digitsOfInt n) 0) = 1)\n      then additivePersistence (sumList (digitsOfInt n))\n      else 4;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additivePersistence(sumList (digitsOfInt n)) count+1\nelse count\nin count = 0", "out": "Characters 116-127:\n  if not (lengthOfList (digitsOfInt n) 0 = 1)\n                        ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec additiveSequence n count =\n    match n with\n    | 0 -> 0\n    | _ ->\n        if not ((lengthOfList (digitsOfInt n) 0) = 1)\n        then (additivePersistence (sumList (digitsOfInt n)) count) + 1\n        else count in\n  count = 0;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additivePersistence(sumList (digitsOfInt n) count+1)\nelse count\nin count = 0", "out": "Characters 116-127:\n  if not (lengthOfList (digitsOfInt n) 0 = 1)\n                        ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec additiveSequence n count =\n    match n with\n    | 0 -> 0\n    | _ ->\n        if not ((lengthOfList (digitsOfInt n) 0) = 1)\n        then additivePersistence ((sumList (digitsOfInt n) count) + 1)\n        else count in\n  count = 0;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additivePersistence((sumList (digitsOfInt n)) count+1)\nelse count\nin count = 0", "out": "Characters 116-127:\n  if not (lengthOfList (digitsOfInt n) 0 = 1)\n                        ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec additiveSequence n count =\n    match n with\n    | 0 -> 0\n    | _ ->\n        if not ((lengthOfList (digitsOfInt n) 0) = 1)\n        then additivePersistence (((sumList (digitsOfInt n)) count) + 1)\n        else count in\n  count = 0;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additivePersistence sumList (digitsOfInt n) count+1\nelse count\nin count = 0", "out": "Characters 116-127:\n  if not (lengthOfList (digitsOfInt n) 0 = 1)\n                        ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec additiveSequence n count =\n    match n with\n    | 0 -> 0\n    | _ ->\n        if not ((lengthOfList (digitsOfInt n) 0) = 1)\n        then (additivePersistence sumList (digitsOfInt n) count) + 1\n        else count in\n  count = 0;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sumDigits = fun x -> sumList digitsOfInt x", "out": "Characters 25-32:\n  let sumDigits = fun x -> sumList digitsOfInt x;;\n                           ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet sumDigits x = sumList digitsOfInt x;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sumDigits = fun x -> sumList (digitsOfInt x)", "out": "Characters 25-32:\n  let sumDigits = fun x -> sumList (digitsOfInt x);;\n                           ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet sumDigits x = sumList (digitsOfInt x);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additivePersistence sumDigits n count+1\nelse count\nin count = 0", "out": "Characters 116-127:\n  if not (lengthOfList (digitsOfInt n) 0 = 1)\n                        ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec additiveSequence n count =\n    match n with\n    | 0 -> 0\n    | _ ->\n        if not ((lengthOfList (digitsOfInt n) 0) = 1)\n        then (additivePersistence sumDigits n count) + 1\n        else count in\n  count = 0;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additivePersistence sumDigits n (count+1)\nelse count\nin count = 0", "out": "Characters 116-127:\n  if not (lengthOfList (digitsOfInt n) 0 = 1)\n                        ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec additiveSequence n count =\n    match n with\n    | 0 -> 0\n    | _ ->\n        if not ((lengthOfList (digitsOfInt n) 0) = 1)\n        then additivePersistence sumDigits n (count + 1)\n        else count in\n  count = 0;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additivePersistence (sumDigits n) count+1\nelse count\nin count = 0", "out": "Characters 116-127:\n  if not (lengthOfList (digitsOfInt n) 0 = 1)\n                        ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec additiveSequence n count =\n    match n with\n    | 0 -> 0\n    | _ ->\n        if not ((lengthOfList (digitsOfInt n) 0) = 1)\n        then (additivePersistence (sumDigits n) count) + 1\n        else count in\n  count = 0;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additiveSequence sumDigits n count+1\nelse count\nin count = 0", "out": "Characters 116-127:\n  if not (lengthOfList (digitsOfInt n) 0 = 1)\n                        ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec additiveSequence n count =\n    match n with\n    | 0 -> 0\n    | _ ->\n        if not ((lengthOfList (digitsOfInt n) 0) = 1)\n        then (additiveSequence sumDigits n count) + 1\n        else count in\n  count = 0;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \nlet rec additiveSequence n count =\nmatch n with\n| 0 -> 0\n| _ -> \nif not (lengthOfList (digitsOfInt n) 0 = 1)\nthen additiveSequence (sumDigits n) count+1\nelse count\nin count = 0", "out": "Characters 116-127:\n  if not (lengthOfList (digitsOfInt n) 0 = 1)\n                        ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec additiveSequence n count =\n    match n with\n    | 0 -> 0\n    | _ ->\n        if not ((lengthOfList (digitsOfInt n) 0) = 1)\n        then (additiveSequence (sumDigits n) count) + 1\n        else count in\n  count = 0;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = \nlet rec lastDigit n acc = \nif n <= 0 then acc\nelse lastDigit (n/10) (n mod 10::acc) in\nmatch n with\n| _ -> lastDigit n []", "out": "", "min": "\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \nlet rec sequence n i =\nif lengthOfList (digitsOfInt n) 0 = 1 \nthen i\nelse sequence (sumDigits n) i+1 in\nmatch n with\n| _ -> sequence n 0", "out": "Characters 113-122:\n  else sequence (sumDigits n) i+1 in\n                 ^^^^^^^^^\nError: Unbound value sumDigits\n", "min": "\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec sequence n i =\n    if (lengthOfList (digitsOfInt n) 0) = 1\n    then i\n    else (sequence (sumDigits n) i) + 1 in\n  match n with | _ -> sequence n 0;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \nlet rec sequence n i =\nif lengthOfList (digitsOfInt n) 0 = 1 \nthen i\nelse sequence sumList (digitsOfInt x) i+1 in\nmatch n with\n| _ -> sequence n 0", "out": "Characters 112-119:\n  else sequence sumList (digitsOfInt x) i+1 in\n                ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec sequence n i =\n    if (lengthOfList (digitsOfInt n) 0) = 1\n    then i\n    else (sequence sumList (digitsOfInt x) i) + 1 in\n  match n with | _ -> sequence n 0;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \nlet rec sequence n i =\nif lengthOfList (digitsOfInt n) 0 = 1 \nthen i\nelse sequence (sumList (digitsOfInt x)) i+1 in\nmatch n with\n| _ -> sequence n 0", "out": "Characters 113-120:\n  else sequence (sumList (digitsOfInt x)) i+1 in\n                 ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec sequence n i =\n    if (lengthOfList (digitsOfInt n) 0) = 1\n    then i\n    else (sequence (sumList (digitsOfInt x)) i) + 1 in\n  match n with | _ -> sequence n 0;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \nlet rec sequence n i =\nif lengthOfList (digitsOfInt n) 0 = 1 \nthen i\nelse sequence (sumList (digitsOfInt n)) i+1 in\nmatch n with\n| _ -> sequence n 0", "out": "Characters 113-120:\n  else sequence (sumList (digitsOfInt n)) i+1 in\n                 ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec sequence n i =\n    if (lengthOfList (digitsOfInt n) 0) = 1\n    then i\n    else (sequence (sumList (digitsOfInt n)) i) + 1 in\n  match n with | _ -> sequence n 0;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \nlet rec sequence n i =\nif lengthOfList (digitsOfInt n) 0 = 1 \nthen i\nelse sequence (sumList (digitsOfInt n)) i+1 in\nmatch n with\n| _ -> sequence n 0", "out": "Characters 113-120:\n  else sequence (sumList (digitsOfInt n)) i+1 in\n                 ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec sequence n i =\n    if (lengthOfList (digitsOfInt n) 0) = 1\n    then i\n    else (sequence (sumList (digitsOfInt n)) i) + 1 in\n  match n with | _ -> sequence n 0;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nif lengthOfList (digitsOfInt n) 0 = 1\nthen n\nelse digitalRoot (sumList (digitsOfInt n)) in\nmatch n with\n| _ -> digitalRoot n", "out": "Characters 88-95:\n  else digitalRoot (sumList (digitsOfInt n)) in\n                    ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet _ =\n  let rec digitalRoot n =\n    if (lengthOfList (digitsOfInt n) 0) = 1\n    then n\n    else digitalRoot (sumList (digitsOfInt n)) in\n  match n with | _ -> digitalRoot n;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nif lengthOfList (digitsOfInt n) 0 = 1\nthen n\nelse digitalRoot (sumList (digitsOfInt n))", "out": "Characters 88-95:\n  else digitalRoot (sumList (digitsOfInt n));;\n                    ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet rec digitalRoot n =\n  if (lengthOfList (digitsOfInt n) 0) = 1\n  then n\n  else digitalRoot (sumList (digitsOfInt n));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nif lengthOfList (digitsOfInt n) 0 = 1 then n\nelse digitalRoot (sumList (digitsOfInt n))", "out": "Characters 88-95:\n  else digitalRoot (sumList (digitsOfInt n));;\n                    ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet rec digitalRoot n =\n  if (lengthOfList (digitsOfInt n) 0) = 1\n  then n\n  else digitalRoot (sumList (digitsOfInt n));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let digitalRoot n = \nif lengthOfList (digitsOfInt n) 0 = 1 then n\nelse digitalRoot (sumList (digitsOfInt n))", "out": "Characters 71-82:\n  else digitalRoot (sumList (digitsOfInt n));;\n       ^^^^^^^^^^^\nError: Unbound value digitalRoot\n", "min": "\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet digitalRoot n =\n  if (lengthOfList (digitsOfInt n) 0) = 1\n  then n\n  else digitalRoot (sumList (digitsOfInt n));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n =\nmatch n with\n| _ -> \nif lengthOfList (digitsOfInt n) 0 = 1 then n\nelse digitalRoot (sumList (digitsOfInt n))", "out": "Characters 108-115:\n  else digitalRoot (sumList (digitsOfInt n));;\n                    ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet digitsOfInt n =\n  let rec lastDigit n acc =\n    if n <= 0 then acc else lastDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet rec digitalRoot n =\n  match n with\n  | _ ->\n      if (lengthOfList (digitsOfInt n) 0) = 1\n      then n\n      else digitalRoot (sumList (digitsOfInt n));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = \nlet rec reverse l acc = \nreverse l acc in\nmatch l with\n| [] -> []\n| hd::tl -> reverse l []", "out": "", "min": "\nlet listReverse l =\n  let rec reverse l acc = reverse l acc in\n  match l with | [] -> [] | hd::tl -> reverse l [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = \nlet rec reverse l acc = \nreverse l acc in\nmatch l with\n| hd::tl -> reverse l []", "out": "", "min": "\nlet listReverse l =\n  let rec reverse l acc = reverse l acc in\n  match l with | hd::tl -> reverse l [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = \nlet rec reverse l acc = \nreverse l acc in\nmatch l with\n| [] -> []\n| hd::tl -> reverse l []", "out": "", "min": "\nlet listReverse l =\n  let rec reverse l acc = reverse l acc in\n  match l with | [] -> [] | hd::tl -> reverse l [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = \nlet rec reverse l acc = \nreverse l hd::acc in\nmatch l with\n| [] -> []\n| hd::tl -> reverse tl []", "out": "Characters 56-58:\n  reverse l hd::acc in\n            ^^\nError: Unbound value hd\n", "min": "\nlet listReverse l =\n  let rec reverse l acc = (reverse l hd) :: acc in\n  match l with | [] -> [] | hd::tl -> reverse tl [];;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let digits n = digitsOfInt (abs n)", "out": "Characters 15-26:\n  let digits n = digitsOfInt (abs n);;\n                 ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet digits n = digitsOfInt (abs n);;\n", "type": "scope"}, {"in": "let additivePersistence n = \nlet rec sequence n i =\nif lengthOfList (digitsOfInt n) 0 = 1 \nthen i\nelse sequence (sumList (digitsOfInt n)) i+1 in\nmatch n with\n| _ -> sequence n 0", "out": "Characters 69-80:\n  if lengthOfList (digitsOfInt n) 0 = 1 \n                   ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec sequence n i =\n    if (lengthOfList (digitsOfInt n) 0) = 1\n    then i\n    else (sequence (sumList (digitsOfInt n)) i) + 1 in\n  match n with | _ -> sequence n 0;;\n", "type": "scope"}, {"in": "let rec digitalRoot n =\nmatch n with\n| _ -> \nif lengthOfList (digitsOfInt n) 0 = 1 then n\nelse digitalRoot (sumList (digitsOfInt n))", "out": "Characters 62-73:\n  if lengthOfList (digitsOfInt n) 0 = 1 then n\n                   ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet rec digitalRoot n =\n  match n with\n  | _ ->\n      if (lengthOfList (digitsOfInt n) 0) = 1\n      then n\n      else digitalRoot (sumList (digitsOfInt n));;\n", "type": "scope"}, {"in": "let listReverse l = \nlet rec accReverse l acc =\nif l = [] then acc\nelse accReverse tl hd::acc in \nmatch l with\n| [] -> []\n| l -> accReverse l []", "out": "Characters 83-85:\n  else accReverse tl hd::acc in \n                  ^^\nError: Unbound value tl\n", "min": "\nlet listReverse l =\n  let rec accReverse l acc =\n    if l = [] then acc else (accReverse tl hd) :: acc in\n  match l with | [] -> [] | l -> accReverse l [];;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = \nlet rec accReverse l acc =\nif l = [] then acc\nelse accReverse tl hd::acc in \nmatch l with\n| [] -> []\n| hd::tl -> accReverse l []", "out": "Characters 83-85:\n  else accReverse tl hd::acc in \n                  ^^\nError: Unbound value tl\n", "min": "\nlet listReverse l =\n  let rec accReverse l acc =\n    if l = [] then acc else (accReverse tl hd) :: acc in\n  match l with | [] -> [] | hd::tl -> accReverse l [];;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = \nlet rec accReverse l acc =\nif l = [] then acc\nelse accReverse tl hd::acc in \nmatch l with\n| [] -> []\n| hd::tl -> accReverse hd::tl []", "out": "Characters 83-85:\n  else accReverse tl hd::acc in \n                  ^^\nError: Unbound value tl\n", "min": "\nlet listReverse l =\n  let rec accReverse l acc =\n    if l = [] then acc else (accReverse tl hd) :: acc in\n  match l with | [] -> [] | hd::tl -> (accReverse hd) :: (tl []);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \nlet rec sequence n i =\nif lengthOfList (digitsOfInt n) 0 = 1 then i\nelse sequence (sumList (digitsOfInt n)) i+1 in\nmatch n with\n| _ -> sequence n 0", "out": "Characters 69-80:\n  if lengthOfList (digitsOfInt n) 0 = 1 then i\n                   ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet additivePersistence n =\n  let rec sequence n i =\n    if (lengthOfList (digitsOfInt n) 0) = 1\n    then i\n    else (sequence (sumList (digitsOfInt n)) i) + 1 in\n  match n with | _ -> sequence n 0;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n =\nmatch n with\n| _ -> \nif lengthOfList (digitsOfInt n) 0 = 1 then n\nelse digitalRoot (sumList (digitsOfInt n))", "out": "Characters 62-73:\n  if lengthOfList (digitsOfInt n) 0 = 1 then n\n                   ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet rec lengthOfList xs count =\n  match xs with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet rec digitalRoot n =\n  match n with\n  | _ ->\n      if (lengthOfList (digitsOfInt n) 0) = 1\n      then n\n      else digitalRoot (sumList (digitsOfInt n));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = \nlet rec lastDigit n accu = \nif n <= 0 then accu\nelse lastDigit (n/10) (n mod 10::accu) in\nmatch n with\n| _ -> lastDigit n []", "out": "", "min": "\nlet digitsOfInt n =\n  let rec lastDigit n accu =\n    if n <= 0 then accu else lastDigit (n / 10) ((n mod 10) :: accu) in\n  match n with | _ -> lastDigit n [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = \nlet rec accReverse l accu =\nmatch l with\n| [] -> accu\n| hd::tl -> accReverse tl (hd::accu)\nin accReverse l []", "out": "", "min": "\nlet listReverse l =\n  let rec accReverse l accu =\n    match l with | [] -> accu | hd::tl -> accReverse tl (hd :: accu) in\n  accReverse l [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = \nlet rec lastDigit n accu = \nif n <= 0 then accu\nelse lastDigit (n/10) (n mod 10::accu) \nin lastDigit n []", "out": "", "min": "\nlet digitsOfInt n =\n  let rec lastDigit n accu =\n    if n <= 0 then accu else lastDigit (n / 10) ((n mod 10) :: accu) in\n  lastDigit n [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = fun x -> (explode s = listReverse(explode s))", "out": "Characters 37-38:\n  let palindrome w = fun x -> (explode s = listReverse(explode s));;\n                                       ^\nError: Unbound value s\n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec accReverse l accu =\n    match l with | [] -> accu | hd::tl -> accReverse tl (hd :: accu) in\n  accReverse l [];;\n\nlet palindrome w x = (explode s) = (listReverse (explode s));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = fun x -> (explode w = listReverse(explode w))", "out": "", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec accReverse l accu =\n    match l with | [] -> accu | hd::tl -> accReverse tl (hd :: accu) in\n  accReverse l [];;\n\nlet palindrome w x = (explode w) = (listReverse (explode w));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = (explode w = listReverse(explode w))", "out": "", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec accReverse l accu =\n    match l with | [] -> accu | hd::tl -> accReverse tl (hd :: accu) in\n  accReverse l [];;\n\nlet palindrome w = (explode w) = (listReverse (explode w));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n =\nif lengthOfList (digitsOfInt n) 0 = 1 then n\nelse digitalRoot (sumList (digitsOfInt n))", "out": "Characters 87-94:\n  else digitalRoot (sumList (digitsOfInt n));;\n                    ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet digitsOfInt n =\n  let rec lastDigit n accu =\n    if n <= 0 then accu else lastDigit (n / 10) ((n mod 10) :: accu) in\n  lastDigit n [];;\n\nlet rec lengthOfList l count =\n  match l with | [] -> 0 | hd::tl -> (lengthOfList tl count) + 1;;\n\nlet rec digitalRoot n =\n  if (lengthOfList (digitsOfInt n) 0) = 1\n  then n\n  else digitalRoot (sumList (digitsOfInt n));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = \nlet rec accReverse l accu =\nmatch l with\n| [] -> accu\n| hd::tl -> accReverse tl (hd::accu)\nin accReverse l []", "out": "", "min": "\nlet listReverse l =\n  let rec accReverse l accu =\n    match l with | [] -> accu | hd::tl -> accReverse tl (hd :: accu) in\n  accReverse l [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| hd::tl ->\nhd + (sumList tl)", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n", "type": ""}]}
