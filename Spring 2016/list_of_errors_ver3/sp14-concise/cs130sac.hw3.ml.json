{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let sqsum xs = \nlet f a x = (x*x) + b in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + b in let base = 0 in List.fold_left f base xs;;\n", "out": "Characters 36-37:\n  let f a x = (x*x) + b in\n                      ^\nError: Unbound value b\n"}, {"type": "", "in": "let pipe fs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = (x*x) + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a b = a + (b*b) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a b = a + (b * b) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet l = failwith \"to be implemented\" in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet l = failwith \"to be implemented\" in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet l = failwith \"to be implemented\" in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet l = failwith \"to be implemented\" in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet l = failwith \"to be implemented\" in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet l = failwith \"to be implemented\" in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =  fun a x ->  x  in \nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x a x = x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = failwith \"boo!\" in\nlet f a x =  fun a x ->  x  in \nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet _ =\n  let pipe fs = failwith \"boo!\" in\n  let f a x a x = x in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 112-114:\n  List.fold_left f base fs;;\n                        ^^\nError: Unbound value fs\n"}, {"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet l = failwith \"to be implemented\" in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec clone x n = \nif n > 0 then x::clone(x n-1)\nelse x", "min": "\nlet rec clone x n = if n > 0 then x :: (clone ((x n) - 1)) else x;;\n", "out": "Characters 43-50:\n  if n > 0 then x::clone(x n-1)\n                        ^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int -> int\n"}, {"type": "", "in": "let padZero l1 l2 = failwith \"to be implemented\"", "min": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec clone x n = \nif n > 0 then x::clone(x (n-1))\nelse []", "min": "\nlet rec clone x n = if n > 0 then x :: (clone (x (n - 1))) else [];;\n", "out": "Characters 43-52:\n  if n > 0 then x::clone(x (n-1))\n                        ^^^^^^^^^\nError: This expression has type 'a but an expression was expected of type\n         int -> 'a\n       The type variable 'a occurs inside int -> 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec clone x n = \nif n < 1 then []\nelse x::clone(x (n-1))", "min": "\nlet rec clone x n = if n < 1 then [] else x :: (clone (x (n - 1)));;\n", "out": "Characters 51-60:\n  else x::clone(x (n-1));;\n               ^^^^^^^^^\nError: This expression has type 'a but an expression was expected of type\n         int -> 'a\n       The type variable 'a occurs inside int -> 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec clone x n = \nif n < 1 then []\nelse x::(clone x (n-1))", "min": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec clone x n = \nif n > 0 then x::(clone x (n-1))\nelse []", "min": "\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l with\n| []   -> []\n| h::t -> \nif h = 0 then removeZero t\nelse l", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let padZero l1 l2 = \nlet length1 = List.length(l1) in\nlet length2 = List.length(l2) in\nif lenght1 = length2 then (l1, l2)\nelse \nif length1 < length2 then padZero(0::l1)\nelse padZero(0::l2)", "min": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if lenght1 = length2\n  then (l1, l2)\n  else if length1 < length2 then padZero (0 :: l1) else padZero (0 :: l2);;\n", "out": "Characters 90-97:\n  if lenght1 = length2 then (l1, l2)\n     ^^^^^^^\nError: Unbound value lenght1\nHint: Did you mean length1?\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let padZero l1 l2 = \nlet length1 = List.length(l1) in\nlet length2 = List.length(l2) in\nif length1 = length2 then (l1, l2)\nelse \nif length1 < length2 then padZero(0::l1)\nelse padZero(0::l2)", "min": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else if length1 < length2 then padZero (0 :: l1) else padZero (0 :: l2);;\n", "out": "Characters 154-168:\n  if length1 < length2 then padZero(0::l1)\n                            ^^^^^^^^^^^^^^\nError: This expression has type 'a -> 'b\n       but an expression was expected of type int list * 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let padZero l1 l2 = \nlet length1 = List.length(l1) in\nlet length2 = List.length(l2) in\nif length1 = length2 then (l1, l2)\nelse \nif length1 < length2 then padZero(0::l1, l2)\nelse padZero(l1, 0::l2)", "min": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then padZero ((0 :: l1), l2)\n    else padZero (l1, (0 :: l2));;\n", "out": "Characters 154-172:\n  if length1 < length2 then padZero(0::l1, l2)\n                            ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a -> 'b\n       but an expression was expected of type int list * 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let padZero l1 l2 = \nlet length1 = List.length(l1) in\nlet length2 = List.length(l2) in\nif length1 = length2 then (l1, l2)\nelse \nif length1 < length2 then padZero((0::l1), l2)\nelse padZero(l1, (0::l2))", "min": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then padZero ((0 :: l1), l2)\n    else padZero (l1, (0 :: l2));;\n", "out": "Characters 154-174:\n  if length1 < length2 then padZero((0::l1), l2)\n                            ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a -> 'b\n       but an expression was expected of type int list * 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let padZero l1 l2 = \nlet length1 = List.length(l1) in\nlet length2 = List.length(l2) in\nif length1 = length2 then (l1, l2)\nelse \nif length1 < length2 then (padZero(0::l1), l2)\nelse (padZero l1, (0::l2))", "min": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((padZero (0 :: l1)), l2)\n    else ((padZero l1), (0 :: l2));;\n", "out": "Characters 155-169:\n  if length1 < length2 then (padZero(0::l1), l2)\n                             ^^^^^^^^^^^^^^\nError: This expression has type 'a -> 'b\n       but an expression was expected of type int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let padZero l1 l2 = \nlet length1 = List.length(l1) in\nlet length2 = List.length(l2) in\nif length1 = length2 then (l1, l2)\nelse \nif length1 < length2 then (padZero (0::l1), l2)\nelse (padZero l1, (0::l2))", "min": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((padZero (0 :: l1)), l2)\n    else ((padZero l1), (0 :: l2));;\n", "out": "Characters 155-170:\n  if length1 < length2 then (padZero (0::l1), l2)\n                             ^^^^^^^^^^^^^^^\nError: This expression has type 'a -> 'b\n       but an expression was expected of type int list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = \nlet length1 = List.length(l1) in\nlet length2 = List.length(l2) in\nif length1 = length2 then (l1, l2)\nelse \nif length1 < length2 then (padZero (0::l1) l2)\nelse (padZero l1 (0::l2))", "min": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = \nlet length1 = List.length(l1) in\nlet length2 = List.length(l2) in\nif length1 = length2 then (l1, l2)\nelse \nif length1 < length2 then (padZero (0::l1) l2)\nelse (padZero l1 (0::l2))", "min": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = \nlet length1 = List.length(l1) in\nlet length2 = List.length(l2) in\nif length1 = length2 then (l1, l2)\nelse \nif length1 < length2 then (padZero (0::l1) l2)\nelse (padZero l1 (0::l2))", "min": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a b = a + (b*b) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a b = a + (b * b) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec padZero l1 l2 = \nlet length1 = List.length(l1) in\nlet length2 = List.length(l2) in\nif length1 = length2 then (l1, l2)\nelse \nif length1 < length2 then (padZero (0::l1) l2)\nelse (padZero l1 (0::l2))", "min": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x =  fun x -> a ( x y )  in \nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x x = a (x y) in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 43-44:\n  let f a x =  fun x -> a ( x y )  in \n                              ^\nError: Unbound value y\n"}, {"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x =  fun x -> a ( y x )  in \nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x x = a (y x) in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 41-42:\n  let f a x =  fun x -> a ( y x )  in \n                            ^\nError: Unbound value y\n"}, {"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =  fun y -> x ( a y )  in \nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x y = x (a y) in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let stringOfList f l = \"[\" ^ sepConcat ^ \";\" ^ (List.map f l) ^ \"]\"", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ (sepConcat ^ (\";\" ^ ((List.map f l) ^ \"]\")));;\n", "out": "Characters 29-38:\n  let stringOfList f l = \"[\" ^ sepConcat ^ \";\" ^ (List.map f l) ^ \"]\";;\n                               ^^^^^^^^^\nError: This expression has type string -> string list -> string\n       but an expression was expected of type string\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l = \"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = failwith \"to be implemented\"", "min": "\nlet rec mulByDigit i l = failwith \"to be implemented\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (cin, result) = a in\nlet (d1, d2) = h in\nlet s = d1 + d2 + cin in\n(s / 10, (s mod 10)::result) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (cin,result) = a in\n      let (d1,d2) = h in\n      let s = (d1 + d2) + cin in ((s / 10), ((s mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 93-94:\n  let (d1, d2) = h in\n                 ^\nError: Unbound value h\n"}, {"type": "", "in": "let rec mulByDigit i l = failwith \"to be implemented\"", "min": "\nlet rec mulByDigit i l = failwith \"to be implemented\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (cin, result) = a in\nlet (d1, d2) = x in\nlet s = d1 + d2 + cin in\n(s / 10, (s mod 10)::result) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (cin,result) = a in\n      let (d1,d2) = x in\n      let s = (d1 + d2) + cin in ((s / 10), ((s mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (d1, d2) = x in\nlet (cin, result) = a in\nlet s = d1 + d2 + cin in\n(s / 10, (s mod 10)::result) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (d1,d2) = x in\n      let (cin,result) = a in\n      let s = (d1 + d2) + cin in ((s / 10), ((s mod 10) :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (eFromList1, eFromList2) = x in\nlet (cin, result) = a in\nlet sum = eFromList1 + eFromList2 + cin in\nlet tens = (sum / 10) in\nlet ones = (sum mod 10) in\n(tens, ones::result) in\nlet base = (0,[]) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec mulByDigit i l = match i with\n| 0 -> []\n| 1 -> l\n| _ -> bigAdd (big 1 1) (mulByDigit (i-2) l)", "min": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd (big 1 1) (mulByDigit (i - 2) l);;\n", "out": "Characters 72-75:\n  | _ -> bigAdd (big 1 1) (mulByDigit (i-2) l);;\n                 ^^^\nError: Unbound value big\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec mulByDigit i l = match i with\n| 0 -> []\n| 1 -> l\n| _ -> bigAdd (bigAdd 1 1) (mulByDigit (i-2) l)", "min": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd (bigAdd 1 1) (mulByDigit (i - 2) l);;\n", "out": "Characters 79-80:\n  | _ -> bigAdd (bigAdd 1 1) (mulByDigit (i-2) l);;\n                        ^\nError: This expression has type int but an expression was expected of type\n         int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec mulByDigit i l = match i with\n| 0 -> []\n| 1 -> l\n| _ -> bigAdd ( (bigAdd 1 1) (mulByDigit (i-2) l) )", "min": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd ((bigAdd 1 1) (mulByDigit (i - 2) l));;\n", "out": "Characters 81-82:\n  | _ -> bigAdd ( (bigAdd 1 1) (mulByDigit (i-2) l) );;\n                          ^\nError: This expression has type int but an expression was expected of type\n         int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec mulByDigit i l = match i with\n| 0 -> []\n| 1 -> l\n| _ -> bigAdd ( (bigAdd 1 1) (mulByDigit (i-2) l) )", "min": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd ((bigAdd 1 1) (mulByDigit (i - 2) l));;\n", "out": "Characters 81-82:\n  | _ -> bigAdd ( (bigAdd 1 1) (mulByDigit (i-2) l) );;\n                          ^\nError: This expression has type int but an expression was expected of type\n         int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec mulByDigit i l = match i with\n| 0 -> []\n| 1 -> l\n| _ -> bigAdd ( (bigAdd l l) (mulByDigit (i-2) l) )", "min": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd ((bigAdd l l) (mulByDigit (i - 2) l));;\n", "out": "Characters 73-85:\n  | _ -> bigAdd ( (bigAdd l l) (mulByDigit (i-2) l) );;\n                  ^^^^^^^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse bigAdd ( (bigAdd l l) (mulByDigit (i-2) l) )", "min": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else if i = 1 then l else bigAdd ((bigAdd l l) (mulByDigit (i - 2) l));;\n", "out": "Characters 78-90:\n  else bigAdd ( (bigAdd l l) (mulByDigit (i-2) l) );;\n                ^^^^^^^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n"}, {"type": "type", "in": "let rec mulByDigit i l = match i with\n| 0 -> []\n| 1 -> l\n| _ -> bigAdd ( (bigAdd l l) (mulByDigit (i-2) l) )", "min": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd ((bigAdd l l) (mulByDigit (i - 2) l));;\n", "out": "Characters 73-85:\n  | _ -> bigAdd ( (bigAdd l l) (mulByDigit (i-2) l) );;\n                  ^^^^^^^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse bigAdd (bigAdd l l) (mulByDigit (i-2) l)", "min": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else if i = 1 then l else bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nif i = 0 then []\nelse if i = 1 then l\nelse bigAdd (bigAdd l l) (mulByDigit (i-2) l)", "min": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else if i = 1 then l else bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = match i with\n| (-1) -> []\n| 0  -> []\n| 1  -> l\n| _  -> bigAdd (bigAdd l l) (mulByDigit (i-2) l)", "min": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | (-1) -> []\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = match i with\n| (-1) -> []\n| 0    -> []\n| 1    -> l\n| _    -> bigAdd (bigAdd l l) (mulByDigit (i-2) l)", "min": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with\n  | (-1) -> []\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = ((mulByDigit x l1)@(clone 0 (List.length b)))::b in\nlet base = [] in\nlet args =  List.rev l2 in\n(* let (_, res) =*) List.fold_left f base args (*in\nres*)\nin List.fold_left bigAdd base g", "min": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  match i with\n  | (-1) -> []\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n\nlet _ =\n  let bigMul l1 l2 =\n    let f a x = ((mulByDigit x l1) @ (clone 0 (List.length b))) :: b in\n    let base = [] in let args = List.rev l2 in List.fold_left f base args in\n  List.fold_left bigAdd base g;;\n", "out": "Characters 73-74:\n  let f a x = ((mulByDigit x l1)@(clone 0 (List.length b)))::b in\n                                                       ^\nError: Unbound value b\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in\nlet base = [] in\nlet args =  List.rev l2 in\n(* let (_, res) =*) List.fold_left f base args (*in\nres*)\nin List.fold_left bigAdd base g", "min": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  match i with\n  | (-1) -> []\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n\nlet _ =\n  let bigMul l1 l2 =\n    let f a x = ((mulByDigit x l1) @ (clone 0 (List.length a))) :: a in\n    let base = [] in let args = List.rev l2 in List.fold_left f base args in\n  List.fold_left bigAdd base g;;\n", "out": "Characters 182-186:\n  in List.fold_left bigAdd base g;;\n                           ^^^^\nError: Unbound value base\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in\nlet base = [] in\nlet args =  List.rev l2 in\n(* let (_, res) =*) List.fold_left f base args (*in\nres*)\nin List.fold_left bigAdd [] g", "min": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  match i with\n  | (-1) -> []\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n\nlet _ =\n  let bigMul l1 l2 =\n    let f a x = ((mulByDigit x l1) @ (clone 0 (List.length a))) :: a in\n    let base = [] in let args = List.rev l2 in List.fold_left f base args in\n  List.fold_left bigAdd [] g;;\n", "out": "Characters 185-186:\n  in List.fold_left bigAdd [] g;;\n                              ^\nError: Unbound value g\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet thisFun = \nlet f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in\nlet base = [] in\nlet args =  List.rev l2 in\n(* let (_, res) =*) List.fold_left f base args (*in\nres*)\nin List.fold_left bigAdd [] thisFun", "min": "\nlet rec padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2 then padZero (0 :: l1) l2 else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (eFromList1,eFromList2) = x in\n      let (cin,result) = a in\n      let sum = (eFromList1 + eFromList2) + cin in\n      let tens = sum / 10 in\n      let ones = sum mod 10 in (tens, (ones :: result)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet rec mulByDigit i l =\n  match i with\n  | (-1) -> []\n  | 0 -> []\n  | 1 -> l\n  | _ -> bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n\nlet bigMul l1 l2 =\n  let thisFun =\n    let f a x = ((mulByDigit x l1) @ (clone 0 (List.length a))) :: a in\n    let base = [] in let args = List.rev l2 in List.fold_left f base args in\n  List.fold_left bigAdd [] thisFun;;\n", "out": ""}]}
