{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (x::xs') -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \nlet rec compareLists l1 l2 = \nmatch (l1, l2) with\n| ([],[]) -> true;\n| (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \nin \ncompareLists (explode w) (listReverse (explode w))", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (x::xs') -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \nlet rec compareLists l1 l2 = \nmatch (l1, l2) with\n| ([],[]) -> true;\n| (_::_, []) -> false\n| (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \nin \ncompareLists (explode w) (listReverse (explode w))", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \nlet rec compareLists l1 l2 = \nmatch (l1, l2) with\n| ([],[]) -> true;\n| (_::_, []) -> false\n| (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \nin \ncompareLists (explode w) (listReverse (explode w))", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \nlet rec compareLists l1 l2 = \nmatch (l1, l2) with\n| ([],[]) -> true;\n| (_::_, []) -> false\n| ([], _::_) -> false\n| (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \nin \ncompareLists (explode w) (listReverse (explode w))", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \nlet rec compareLists l1 l2 = \nmatch (l1, l2) with\n| ([],[]) -> true;\n| (_::_, []) -> false (* reaching the end of one list before the other *)\n| ([], _::_) -> false\n| (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \nin \ncompareLists (explode w) (listReverse (explode w))", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \nlet rec compareLists l1 l2 = \nmatch (l1, l2) with\n| ([],[]) -> true;\n| (_::_, []) -> false (* reaching the end of one list before the other *)\n| ([], _::_) -> false\n| (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \nin \ncompareLists (explode w) (listReverse (explode w))", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (x::xs') -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (x::xs') -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let digitsOfInt n = \nlet explodeNum =\nif (n > 0)\nthen (n mod 10) :: (digitsOfInt (n/10))\nelse []\nin listReverse explodeNum n", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum = if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse explodeNum n;;\n", "out": "Characters 100-111:\n  in listReverse explodeNum n;;\n     ^^^^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let digitsOfInt n = \nlet explodeNum =\nif (n > 0)\nthen (n mod 10) :: (digitsOfInt (n/10))\nelse []\nin listReverse (explodeNum n)", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum = if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n", "out": "Characters 113-123:\n  in listReverse (explodeNum n);;\n                  ^^^^^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nlet explodeNum n =\nif (n > 0)\nthen (n mod 10) :: (digitsOfInt (n/10))\nelse []\nin listReverse (explodeNum n)", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digits n = digitsOfInt (abs n)", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet digits n = digitsOfInt (abs n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = \nmatch l with\n| [] -> []\n| (x::l') -> (listReverse l') :: x :: []", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> [listReverse l'; x];;\n", "out": "Characters 62-78:\n  | (x::l') -> (listReverse l') :: x :: [];;\n               ^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let listReverse l = \nlet rec r e a =\nmatch a with\n| [] -> []\n| (x::l') -> x :: e :: r e l'\nin r [] l", "min": "\nlet listReverse l =\n  let rec r e a = match a with | [] -> [] | x::l' -> x :: e :: (r e l') in\n  r [] l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let listReverse l = \nlet rec r e a =\nmatch a with\n| [] -> []\n| (x::l') -> (r e l') :: x :: e\nin r [] l", "min": "\nlet listReverse l =\n  let rec r e a = match a with | [] -> [] | x::l' -> (r e l') :: x :: e in\n  r [] l;;\n", "out": "Characters 74-82:\n  | (x::l') -> (r e l') :: x :: e\n               ^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let listReverse l = \nlet rec r e a =\nmatch a with\n| [] -> e\n| (x::l') -> (r e l') :: x :: e\nin r [] l", "min": "\nlet listReverse l =\n  let rec r e a = match a with | [] -> e | x::l' -> (r e l') :: x :: e in\n  r [] l;;\n", "out": "Characters 73-81:\n  | (x::l') -> (r e l') :: x :: e\n               ^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (x::xs') -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let digitsOfInt n = \nlet explodeNum n =\nif (n > 0)\nthen (n mod 10) :: (explodeNum (n/10))\nelse []\nin listReverse (explodeNum n)", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (explodeNum (n / 10)) else [] in\n  listReverse (explodeNum n);;\n", "out": "Error: Unbound value explodeNum\nHint: Did you mean explode?\nError: Unbound value explodeNum\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 71-81:\n  then (n mod 10) :: (explodeNum (n/10))\n                      ^^^^^^^^^^\nError: Unbound value explodeNum\nHint: Did you mean explode?\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let digitsOfInt n = \nlet explodeNum n =\nif (n > 0)\nthen (n mod 10) :: (explodeNum (n/10))\nelse []\nin listReverse (explodeNum n)", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (explodeNum (n / 10)) else [] in\n  listReverse (explodeNum n);;\n", "out": "Error: Unbound value explodeNum\nHint: Did you mean explode?\nError: Unbound value explodeNum\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 71-81:\n  then (n mod 10) :: (explodeNum (n/10))\n                      ^^^^^^^^^^\nError: Unbound value explodeNum\nHint: Did you mean explode?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (x::xs') -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nlet rec explodeNum n =\nif (n > 0)\nthen (n mod 10) :: (explodeNum (n/10))\nelse []\nin listReverse (explodeNum n)", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let rec explodeNum n =\n    if n > 0 then (n mod 10) :: (explodeNum (n / 10)) else [] in\n  listReverse (explodeNum n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nlet rec explodeNum n =\nif (n > 0)\nthen (n mod 10) :: (explodeNum (n/10))\nelse []\nin listReverse (explodeNum n)", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let rec explodeNum n =\n    if n > 0 then (n mod 10) :: (explodeNum (n / 10)) else [] in\n  listReverse (explodeNum n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n =\nif (n > 0)\nthen (digitsOfInt (n/10)) @ [(n mod 10)]\nelse []", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n =\nif (n > 0)\nthen (digitsOfInt (n/10)) :: (n mod 10) :: []\nelse 0", "min": "\nlet rec digitsOfInt n = if n > 0 then [digitsOfInt (n / 10); n mod 10] else 0;;\n", "out": "Characters 40-60:\n  then (digitsOfInt (n/10)) :: (n mod 10) :: []\n       ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (x::xs') -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let listReverse l = \nlet rev [] o =\nmatch o with\n| [] -> []\n| (hd::tl) -> rev tl (hd::o)\nin rev l []", "min": "\nlet listReverse l =\n  let rev [] o = match o with | [] -> [] | hd::tl -> rev tl (hd :: o) in\n  rev l [];;\n", "out": "Characters 74-77:\n  | (hd::tl) -> rev tl (hd::o)\n                ^^^\nError: Unbound value rev\nHint: Did you mean ref?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let listReverse l = \nlet rec rev [] o =\nmatch o with\n| [] -> []\n| (hd::tl) -> rev tl (hd::o)\nin rev l []", "min": "\nlet listReverse l =\n  let rec rev [] o = match o with | [] -> [] | hd::tl -> rev tl (hd :: o) in\n  rev l [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let listReverse l = \nlet rec rev o = function\n| [] -> o\n| h::t -> rev (h::o) t\nin rev [] l", "min": "\nlet listReverse l =\n  let rec rev o = function | [] -> o | h::t -> rev (h :: o) t in rev [] l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let listReverse l = \nlet rec rev o = function\n| [] -> []\n| h::t -> rev (h::o) t\nin rev [] l", "min": "\nlet listReverse l =\n  let rec rev o = function | [] -> [] | h::t -> rev (h :: o) t in rev [] l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let listReverse l = \nlet rec rev o = function\n| [] -> o\n| h::t -> rev (h::o) t\nin rev [] l", "min": "\nlet listReverse l =\n  let rec rev o = function | [] -> o | h::t -> rev (h :: o) t in rev [] l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let listReverse l = \nlet rec rev o a = \nmatch a with \n| [] -> o\n| h::t -> rev (h::o) t\nin rev [] l", "min": "\nlet listReverse l =\n  let rec rev o a = match a with | [] -> o | h::t -> rev (h :: o) t in\n  rev [] l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let digitsOfInt n =\nlet rec digits o a = \nif (a > 0)\nthen digitsOfInt ((a mod 10)::o) (a/10)\nelse []\nin digits [] n", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digitsOfInt n =\n  let rec digits o a =\n    if a > 0 then digitsOfInt ((a mod 10) :: o) (a / 10) else [] in\n  digits [] n;;\n", "out": "Characters 58-69:\n  then digitsOfInt ((a mod 10)::o) (a/10)\n       ^^^^^^^^^^^\nError: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n =\nlet rec digits o a = \nif (a > 0)\nthen digits ((a mod 10)::o) (a/10)\nelse []\nin digits [] n", "min": "\nlet digitsOfInt n =\n  let rec digits o a =\n    if a > 0 then digits ((a mod 10) :: o) (a / 10) else [] in\n  digits [] n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n =\nlet rec digits o a = \nif (a > 0)\nthen digits ((a mod 10)::o) (a/10)\nelse o\nin digits [] n", "min": "\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (x::xs') -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (x::xs') -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (x::xs') -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
