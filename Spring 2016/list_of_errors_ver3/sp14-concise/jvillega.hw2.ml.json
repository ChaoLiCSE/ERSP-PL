{"event": "eval", "ocaml": [{"type": "type", "in": "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki tt\n| _ -> 0\nin\nhelper d k l", "min": "\nlet assoc (d,k,l) =\n  let rec helper di ki li =\n    match li with\n    | h::t ->\n        (match h with\n         | hh::tt -> if hh = ki then di else helper di ki tt\n         | _ -> 0) in\n  helper d k l;;\n", "out": "Characters 135-137:\n  | hh::tt -> if hh = ki then di else helper di ki tt\n                                                   ^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a list list\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n| _ -> 0\nin\nhelper d k l", "min": "\nlet assoc (d,k,l) =\n  let rec helper di ki li =\n    match li with\n    | h::t ->\n        (match h with\n         | hh::tt -> if hh = ki then di else helper di ki t\n         | _ -> 0) in\n  helper d k l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n| _ -> 0\nin\nhelper d k l", "min": "\nlet assoc (d,k,l) =\n  let rec helper di ki li =\n    match li with\n    | h::t ->\n        (match h with\n         | hh::tt -> if hh = ki then di else helper di ki t\n         | _ -> 0) in\n  helper d k l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n\n| _ -> 0\nin\nhelper d k l", "min": "\nlet assoc (d,k,l) =\n  let rec helper di ki li =\n    match li with\n    | h::t ->\n        (match h with\n         | hh::tt -> if hh = ki then di else helper di ki t\n         | _ -> 0) in\n  helper d k l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n| _ -> 0\nin\nhelper d k l", "min": "\nlet assoc (d,k,l) =\n  let rec helper di ki li =\n    match li with\n    | h::t ->\n        (match h with\n         | hh::tt -> if hh = ki then di else helper di ki t\n         | _ -> 0) in\n  helper d k l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let assoc (d,k,l) = \nmatch l with\n| h::t -> h", "min": "\nlet assoc (d,k,l) = match l with | h::t -> h;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let assoc (d,k,l) = \nmatch l with\n| h::t ->\nlet rec helper di ki li = \nmatch li with \n| h::t -> h\nin\nhelper d k t", "min": "\nlet assoc (d,k,l) =\n  match l with\n  | h::t ->\n      let rec helper di ki li = match li with | h::t -> h in helper d k t;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let assoc (d,k,l) = \nmatch l with\n| h::t ->\nlet rec helper di ki li = \nmatch li with \n| h::t -> h\nin\nhelper d k h", "min": "\nlet assoc (d,k,l) =\n  match l with\n  | h::t ->\n      let rec helper di ki li = match li with | h::t -> h in helper d k h;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let assoc (d,k,l) = \nmatch l with\n| h::t ->\nlet rec helper di ki li = \nlet (name,age) = li in\nif name = ki then di\nelse \nmatch li with\n| h::t -> helper di ki t\n| _-> di\nin\nhelper d k h", "min": "\nlet assoc (d,k,l) =\n  match l with\n  | h::t ->\n      let rec helper di ki li =\n        let (name,age) = li in\n        if name = ki\n        then di\n        else (match li with | h::t -> helper di ki t | _ -> di) in\n      helper d k h;;\n", "out": "Characters 137-141:\n  | h::t -> helper di ki t\n    ^^^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b * 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then d\nelse assoc(d,k,t)\n| _-> d\n\nin\nhelper d k h", "min": "\nlet assoc (d,k,l) =\n  match l with\n  | h::t ->\n      let rec helper di ki li = match li with | h::t -> h in helper d k h;;\n\nlet _ =\n  let assoc (d,k,l) =\n    match l with\n    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n    | _ -> d in\n  helper d k h;;\n", "out": "Characters 100-101:\n  else assoc(d,k,t)\n                 ^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then d\nelse assoc(d,k,t)\n| _-> d\n\nin\nhelper d k h", "min": "\nlet assoc (d,k,l) =\n  match l with\n  | h::t ->\n      let rec helper di ki li = match li with | h::t -> h in helper d k h;;\n\nlet _ =\n  let assoc (d,k,l) =\n    match l with\n    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n    | _ -> d in\n  helper d k h;;\n", "out": "Characters 100-101:\n  else assoc(d,k,t)\n                 ^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then d\nelse assoc(d,k,t)\n| _-> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then d\nelse assoc(d,k,t)\n| _-> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then age else assoc (d, k, t)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> if List.mem h seen \nthen\nlet seen' = seen in\nlet rest' = t in \nhelper (seen',rest') \n\nelse \nlet seen' = h::seen in\nlet rest' = t in\nhelper (seen', rest')\n| _-> []\nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        if List.mem h seen\n        then let seen' = seen in let rest' = t in helper (seen', rest')\n        else\n          (let seen' = h :: seen in let rest' = t in helper (seen', rest'))\n    | _ -> [] in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t ->  \nlet seen' = if List.mem h seen then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \n| _-> []\nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest')\n    | _ -> [] in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t ->  \nlet seen' = if List.mem h seen then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let wwhile (f,b) = \nlet (func, boo) = f in\nfunc", "min": "\nlet wwhile (f,b) = let (func,boo) = f in func;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet wwhile (f,b) = let (func,boo) = f in func;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": "Characters 54-55:\n  wwhile (f, 2);;\n          ^\nError: This expression has type int -> int * bool\n       but an expression was expected of type 'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let wwhile (f,b) = \nlet (func, boo) = f in\nfunc", "min": "\nlet wwhile (f,b) = let (func,boo) = f in func;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let wwhile (f,b) = f b", "min": "\nlet wwhile (f,b) = f b;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet wwhile (f,b) = f b;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = let func = f b in\nlet (value,boo) = func in\nif boo then wwhile (func, boo)\nelse value", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (func, boo) else value;;\n", "out": "Characters 87-91:\n  if boo then wwhile (func, boo)\n                      ^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = let func = f b in\nlet (value,boo) = func in\nif boo then wwhile (func)\nelse value", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile func else value;;\n", "out": "Characters 86-92:\n  if boo then wwhile (func)\n                     ^^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type ('b -> 'a * bool) * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = let func = f b in\nlet (value,boo) = func in\nif boo then wwhile (f)\nelse value", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in let (value,boo) = func in if boo then wwhile f else value;;\n", "out": "Characters 86-89:\n  if boo then wwhile (f)\n                     ^^^\nError: This expression has type 'a -> 'b * bool\n       but an expression was expected of type ('a -> 'b * bool) * 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = let func = f b in\nlet (value,boo) = func in\nif boo then wwhile (f,value)\nelse value", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t ->  \nlet seen' = if List.mem h seen then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet _ = let f x = let xx = x * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = let func = f b in\nlet (value,boo) = func in\nif boo then wwhile (f,value)\nelse value", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile (let xx = x*x*x in (xx, xx < 100),b)", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile (let xx = (x * x) * x in ((xx, (xx < 100)), b));;\n", "out": "Characters 38-39:\n  let fixpoint (f,b) = wwhile (let xx = x*x*x in (xx, xx < 100),b);;\n                                        ^\nError: Unbound value x\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile (let xx = f b in (xx, xx = b),b)", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile (let xx = f b in ((xx, (xx = b)), b));;\n", "out": "Characters 45-57:\n  let fixpoint (f,b) = wwhile (let xx = f b in (xx, xx = b),b);;\n                                               ^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((f b, xx = b),b)", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile (((f b), (xx = b)), b);;\n", "out": "Characters 29-42:\n  let fixpoint (f,b) = wwhile ((f b, xx = b),b);;\n                               ^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((f b, xx = b),b)", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile (((f b), (xx = b)), b);;\n", "out": "Characters 29-42:\n  let fixpoint (f,b) = wwhile ((f b, xx = b),b);;\n                               ^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile (let xx = x*x*x in (xx, xx < 100),b)", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile (let xx = (x * x) * x in ((xx, (xx < 100)), b));;\n", "out": "Characters 38-39:\n  let fixpoint (f,b) = wwhile (let xx = x*x*x in (xx, xx < 100),b);;\n                                        ^\nError: Unbound value x\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile (let xx = b*b*b in (xx, xx < 100),b)", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile (let xx = (b * b) * b in ((xx, (xx < 100)), b));;\n", "out": "Characters 47-61:\n  let fixpoint (f,b) = wwhile (let xx = b*b*b in (xx, xx < 100),b);;\n                                                 ^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile (let xx = x*x*x in (xx, xx < 100),b)", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile (let xx = (x * x) * x in ((xx, (xx < 100)), b));;\n", "out": "Characters 38-39:\n  let fixpoint (f,b) = wwhile (let xx = x*x*x in (xx, xx < 100),b);;\n                                        ^\nError: Unbound value x\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((b*b*b, b*b*b < 100),b)", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile ((((b * b) * b), (((b * b) * b) < 100)), b);;\n", "out": "Characters 29-49:\n  let fixpoint (f,b) = wwhile ((b*b*b, b*b*b < 100),b);;\n                               ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((b*b*b, b < 100),b)", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile ((((b * b) * b), (b < 100)), b);;\n", "out": "Characters 29-45:\n  let fixpoint (f,b) = wwhile ((b*b*b, b < 100),b);;\n                               ^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((f b, false),b)", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile (((f b), false), b);;\n", "out": "Characters 29-41:\n  let fixpoint (f,b) = wwhile ((f b, false),b);;\n                               ^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) =\n  wwhile ((let d x = let xx = f b in (xx, (xx = b)) in d), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((let d x = let xx = f b in (xx, xx=b) in d),b)", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) =\n  wwhile ((let d x = let xx = f b in (xx, (xx = b)) in d), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((let d x = let xx = f b in (xx, xx = b) in d),b)", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) =\n  wwhile ((let d x = let xx = f b in (xx, (xx = b)) in d), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((let d x = let xx = f x in (xx, xx = b) in d),b)", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) =\n  wwhile ((let d x = let xx = f x in (xx, (xx = b)) in d), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((let d x = let xx = f x in (xx, xx = b) in d b),b)", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) =\n  wwhile ((let d x = let xx = f x in (xx, (xx = b)) in d b), b);;\n", "out": "Characters 72-75:\n  let fixpoint (f,b) = wwhile ((let d x = let xx = f x in (xx, xx = b) in d b),b);;\n                                                                          ^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((let d x = let xx = f x in (xx, xx = b) in d),b)", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) =\n  wwhile ((let d x = let xx = f x in (xx, (xx = b)) in d), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) =\n  wwhile ((let d x = let xx = f x in (xx, (xx = b)) in d), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let d x = let xx = f x in (xx, xx = b) in d),b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let d x = let xx = f x in (xx, (xx = b)) in d), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let d x = let xx = f x in (xx, xx = b) in d),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let g x = let xx = f x in (xx, xx = b) in g),b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx = b)) in g), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = let xx = f x in (xx, xx = b) in g),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let g x = let xx = f x in (xx, xx = b) in g),b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx = b)) in g), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = let xx = f x in (xx, xx = b) in g),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let g x = let xx = (f x) in (xx, xx = b) in g),b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx = b)) in g), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = let xx = (f x) in (xx, xx = b) in g),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let g x = (f x, x = fx) in g),b)", "min": "\nlet fixpoint (f,b) = wwhile ((let g x = ((f x), (x = fx)) in g), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = (f x, x = fx) in g),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let g x = (f x, x = f x) in g),b)", "min": "\nlet fixpoint (f,b) = wwhile ((let g x = ((f x), (x = (f x))) in g), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = (f x, x = f x) in g),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let g x = let d = f x in (d, x = d) in g),b)", "min": "\nlet fixpoint (f,b) = wwhile ((let g x = let d = f x in (d, (x = d)) in g), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = let d = f x in (d, x = d) in g),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let g x = let d = (f x) in (d, x = d) in g),b)", "min": "\nlet fixpoint (f,b) = wwhile ((let g x = let d = f x in (d, (x = d)) in g), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = let d = (f x) in (d, x = d) in g),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let g x = let d = (f b) in (d, x = d) in g),b)", "min": "\nlet fixpoint (f,b) = wwhile ((let g x = let d = f b in (d, (x = d)) in g), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = let d = (f b) in (d, x = d) in g),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let g x = let d = (g b) in (d, x = d) in g),b)", "min": "\nlet fixpoint (f,b) = wwhile ((let g x = let d = g b in (d, (x = d)) in g), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = let d = (g b) in (d, x = d) in g),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let g x = let d = (f b) in (d, x != d) in g),b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let g x = let d = f b in (d, (x != d)) in g), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = let d = (f b) in (d, x != d) in g),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let g x = let d = (f b) in (d, x = d) in g),b)", "min": "\nlet fixpoint (f,b) = wwhile ((let g x = let d = f b in (d, (x = d)) in g), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = let d = (f b) in (d, x = d) in g),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let g x = let d = (f b) in (d, b = d) in g),b)", "min": "\nlet fixpoint (f,b) = wwhile ((let g x = let d = f b in (d, (b = d)) in g), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = let d = (f b) in (d, b = d) in g),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let g x = let d = (f x) in (d, x = d) in g b),b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let g x = let d = f x in (d, (x = d)) in g b), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = let d = (f x) in (d, x = d) in g b),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let g x = let d = (f x) in (d, x = d) in g),b)", "min": "\nlet fixpoint (f,b) = wwhile ((let g x = let d = f x in (d, (x = d)) in g), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = let d = (f x) in (d, x = d) in g),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let g x = let d = (f x) in (d, x = d) in g),b)", "min": "\nlet fixpoint (f,b) = wwhile ((let g x = let d = f x in (d, (x = d)) in g), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = let d = (f x) in (d, x = d) in g),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let g x = (f x, x = f x) in g),b)", "min": "\nlet fixpoint (f,b) = wwhile ((let g x = ((f x), (x = (f x))) in g), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = (f x, x = f x) in g),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let g x = (f x, x != f x) in g),b)", "min": "\nlet fixpoint (f,b) = wwhile ((let g x = ((f x), (x != (f x))) in g), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = (f x, x != f x) in g),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then age else assoc (d, k, t)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then age else assoc (d, k, t)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString ex = \nmatch ex with \n|VarX -> (\"x\")\n|VarY -> \"y\"\n|Sine(e) -> \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) -> \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) -> \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) -> exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString ex =\n  match ex with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^ ((exprToString e3) ^ (\":\" ^ (exprToString e4)))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString ex = \nmatch ex with \n|VarX -> (\"x\")\n|VarY -> \"y\"\n|Sine(e) -> \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) -> \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) -> \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) -> exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString ex =\n  match ex with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then age else assoc (d, k, t)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval e,x,y)\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/2\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos ((pi *. (eval e)), x, y)\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "out": "Characters 113-131:\n  |Cosine(e) -> cos(pi *. eval e,x,y)\n                   ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type float\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/2\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "out": "Characters 153-185:\n  |Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/2\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "out": "Characters 187-188:\n  |Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2\n                                                       ^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "out": "Characters 187-188:\n  |Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2\n                                                       ^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "out": "Characters 187-188:\n  |Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2\n                                                       ^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then age else assoc (d, k, t)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString ex =\n  match ex with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = 2", "min": "\nlet rec build (rand,depth) = 2;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec exprToString ex = \nmatch ex with \n|VarX -> \"x\"\n|VarY -> \"y\"\n|Sine(e) -> \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) -> \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) -> \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) -> exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"\n| _ -> \"\"^ex^\"\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString ex =\n  match ex with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | _ -> \"\" ^ (ex ^ \"\");;\n", "out": "Characters 394-396:\n  | _ -> \"\"^ex^\"\";;\n            ^^\nError: This expression has type expr but an expression was expected of type\n         string\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString ex = \nmatch ex with \n|VarX -> \"x\"\n|VarY -> \"y\"\n|Sine(e) -> \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) -> \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) -> \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) -> exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"\n| _ -> \"\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString ex =\n  match ex with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | _ -> \"\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString ex = \nmatch ex with \n|VarX -> \"x\"\n|VarY -> \"y\"\n|Sine(e) -> \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) -> \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) -> \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) -> exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString ex =\n  match ex with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = 2;;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString ex =\n  match ex with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 136-137:\n  let _ = print_string (exprToString e) in\n                                     ^\nError: This expression has type int but an expression was expected of type\n         expr\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth=0 then buildX() else\nlet randNum = rand 0 4 in\nmatch randNum with \n|0 -> buildSine(build(rand, depth-1))\n|1 -> buildCosine(build(rand, depth - 1))\n|2 -> buildTimes(build(rand, depth - 1),build(rand, depth - 1))\n|3 -> buildAverage(build(rand, depth - 1),build(rand, depth - 1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand 0 4 in\n     match randNum with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth=0 then buildX() else\nlet randNum = rand 0 4 in\nmatch randNum with \n|0 -> buildSine(build(rand, depth-1))\n|1 -> buildCosine(build(rand, depth - 1))\n|2 -> buildTimes(build(rand, depth - 1),build(rand, depth - 1))\n|3 -> buildAverage(build(rand, depth - 1),build(rand, depth - 1))\n|4 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand 0 4 in\n     match randNum with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth=0 then buildX() else\nlet randNum = rand 0 4 in\nmatch randNum with \n|0 -> buildSine(build(rand, depth-1))\n|1 -> buildCosine(build(rand, depth - 1))\n|2 -> buildTimes(build(rand, depth - 1),build(rand, depth - 1))\n|3 -> buildAverage(build(rand, depth - 1),build(rand, depth - 1))\n|_ -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand 0 4 in\n     match randNum with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth=0 then buildX() else\nlet randNum = rand 0 5 in\nmatch randNum with \n|0 -> buildSine(build(rand, depth-1))\n|1 -> buildCosine(build(rand, depth - 1))\n|2 -> buildTimes(build(rand, depth - 1),build(rand, depth - 1))\n|3 -> buildAverage(build(rand, depth - 1),build(rand, depth - 1))\n|_ -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand 0 5 in\n     match randNum with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let random = makeRand(5,16) in\nbuild(random,5)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand 0 5 in\n     match randNum with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildY ());;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = let random = makeRand (5, 16) in build (random, 5);;\n", "out": "Characters 37-43:\n  build(random,5);;\n        ^^^^^^\nError: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth=0 then buildX() else\nlet randNum = rand 0 5 in\nlet depth = depth - 1 in\nmatch randNum with \n|0 -> buildSine(build(rand, depth))\n|1 -> buildCosine(build(rand, depth))\n|2 -> buildTimes(build(rand, depth),build(rand, depth))\n|3 -> buildAverage(build(rand, depth),build(rand, depth))\n|_ -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand 0 5 in\n     let depth = depth - 1 in\n     match randNum with\n     | 0 -> buildSine (build (rand, depth))\n     | 1 -> buildCosine (build (rand, depth))\n     | 2 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n     | 3 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n     | _ -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nif depth=0 then buildX() else\nlet randNum = rand 0 5 in\nlet depth = depth - 1 in\nmatch randNum with \n|0 -> buildSine(build(makeRand(5,16), depth))\n|1 -> buildCosine(build(rand, depth))\n|2 -> buildTimes(build(rand, depth),build(rand, depth))\n|3 -> buildAverage(build(rand, depth),build(rand, depth))\n|_ -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand 0 5 in\n     let depth = depth - 1 in\n     match randNum with\n     | 0 -> buildSine (build ((makeRand (5, 16)), depth))\n     | 1 -> buildCosine (build (rand, depth))\n     | 2 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n     | 3 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n     | _ -> buildY ());;\n", "out": "Characters 154-168:\n  |0 -> buildSine(build(makeRand(5,16), depth))\n                        ^^^^^^^^^^^^^^\nError: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nif depth=0 then buildX() else\nlet randNum = rand 0 5 in\nlet depth = depth - 1 in\nmatch randNum with \n|0 -> buildSine(build(makeRand(5,16), depth))\n|1 -> buildCosine(build(makeRand(5,16), depth))\n|2 -> buildTimes(build(makeRand(5,16), depth),build(makeRand(5,16), depth))\n|3 -> buildAverage(build(makeRand(5,16), depth),build(makeRand(5,16), depth))\n|_ -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand 0 5 in\n     let depth = depth - 1 in\n     match randNum with\n     | 0 -> buildSine (build ((makeRand (5, 16)), depth))\n     | 1 -> buildCosine (build ((makeRand (5, 16)), depth))\n     | 2 ->\n         buildTimes\n           ((build ((makeRand (5, 16)), depth)),\n             (build ((makeRand (5, 16)), depth)))\n     | 3 ->\n         buildAverage\n           ((build ((makeRand (5, 16)), depth)),\n             (build ((makeRand (5, 16)), depth)))\n     | _ -> buildY ());;\n", "out": "Characters 154-168:\n  |0 -> buildSine(build(makeRand(5,16), depth))\n                        ^^^^^^^^^^^^^^\nError: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then age else assoc (d, k, t)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth=0 then buildX() else\nlet randNum = rand (0,5) in\nlet depth = depth - 1 in\nmatch randNum with \n|0 -> buildSine(build(rand, depth))\n|1 -> buildCosine(build(rand, depth))\n|2 -> buildTimes(build(rand, depth),build(rand, depth))\n|3 -> buildAverage(build(rand, depth),build(rand, depth))\n|_ -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand (0, 5) in\n     let depth = depth - 1 in\n     match randNum with\n     | 0 -> buildSine (build (rand, depth))\n     | 1 -> buildCosine (build (rand, depth))\n     | 2 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n     | 3 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n     | _ -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand (0, 5) in\n     let depth = depth - 1 in\n     match randNum with\n     | 0 -> buildSine (build (rand, depth))\n     | 1 -> buildCosine (build (rand, depth))\n     | 2 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n     | 3 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n     | _ -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString ex =\n  match ex with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then age else assoc (d, k, t)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then age else assoc (d, k, t)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then age else assoc (d, k, t)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then age else assoc (d, k, t)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then age else assoc (d, k, t)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then age else assoc (d, k, t)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| MyExpr1  of expr * expr * expr\n| MyExpr2  of expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString ex = \nmatch ex with \n|VarX -> \"x\"\n|VarY -> \"y\"\n|Sine(e) -> \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) -> \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) -> \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) -> exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"\n|MyExpr1 (e1,e2,e3) -> \"(sqrt(\"^exprToString e1^\")*sqrt(\"^exprToString e2^\")*\"^exprToString e3^\")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet rec exprToString ex =\n  match ex with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | MyExpr1 (e1,e2,e3) ->\n      \"(sqrt(\" ^\n        ((exprToString e1) ^\n           (\")*sqrt(\" ^\n              ((exprToString e2) ^ (\")*\" ^ ((exprToString e3) ^ \")\")))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec exprToString ex = \nmatch ex with \n|VarX -> \"x\"\n|VarY -> \"y\"\n|Sine(e) -> \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) -> \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) -> \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) -> exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"\n|MyExpr1 (e1,e2,e3) -> \"(sqrt(\"^exprToString e1^\")*sqrt(\"^exprToString e2^\")*\"^exprToString e3^\")\"\n|MyExpr2 (e) -> \"halve(\"^exprToString^\")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet rec exprToString ex =\n  match ex with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | MyExpr1 (e1,e2,e3) ->\n      \"(sqrt(\" ^\n        ((exprToString e1) ^\n           (\")*sqrt(\" ^\n              ((exprToString e2) ^ (\")*\" ^ ((exprToString e3) ^ \")\")))))\n  | MyExpr2 e -> \"halve(\" ^ (exprToString ^ \")\");;\n", "out": "Characters 508-520:\n  |MyExpr2 (e) -> \"halve(\"^exprToString^\")\";;\n                           ^^^^^^^^^^^^\nError: This expression has type expr -> string\n       but an expression was expected of type string\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString ex = \nmatch ex with \n|VarX -> \"x\"\n|VarY -> \"y\"\n|Sine(e) -> \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) -> \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) -> \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) -> exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"\n|MyExpr1 (e1,e2,e3) -> \"(sqrt(\"^exprToString e1^\")*sqrt(\"^exprToString e2^\")*\"^exprToString e3^\")\"\n|MyExpr2 (e) -> \"halve(\"^exprToString e^\")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet rec exprToString ex =\n  match ex with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | MyExpr1 (e1,e2,e3) ->\n      \"(sqrt(\" ^\n        ((exprToString e1) ^\n           (\")*sqrt(\" ^\n              ((exprToString e2) ^ (\")*\" ^ ((exprToString e3) ^ \")\")))))\n  | MyExpr2 e -> \"halve(\" ^ ((exprToString e) ^ \")\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildMyExpr1(a,b,c)            = MyExpr1(a,b,c)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet buildMyExpr1 (a,b,c) = MyExpr1 (a, b, c);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)\n|MyExpr1(e1,e2,e3) -> sqrt(eval (e1,x,y))*.sqrt(eval (e2,x,y))*.eval(e3,x,y)\n|MyExpr2(e) -> eval (e,x,y)*.0.5", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | MyExpr1 (e1,e2,e3) ->\n      ((sqrt (eval (e1, x, y))) *. (sqrt (eval (e2, x, y)))) *.\n        (eval (e3, x, y))\n  | MyExpr2 e -> (eval (e, x, y)) *. 0.5;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth=0 then buildX() else\nlet randNum = rand (0,8) in\nlet depth = depth - 1 in\nmatch randNum with \n|0 -> buildSine(build(rand, depth))\n|1 -> buildCosine(build(rand, depth))\n|2 -> buildTimes(build(rand, depth),build(rand, depth))\n|3 -> buildAverage(build(rand, depth),build(rand, depth))\n|4 -> buildY()\n|5 -> buildThresh(build(rand, depth),build(rand, depth),build(rand, depth),build(rand, depth))\n|6 -> buildMyExpr1(build(rand, depth),build(rand, depth),build(rand, depth))\n| _-> buildMyExpr2(build(rand, depth))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildMyExpr1 (a,b,c) = MyExpr1 (a, b, c);;\n\nlet buildMyExpr2 e = MyExpr2 e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand (0, 8) in\n     let depth = depth - 1 in\n     match randNum with\n     | 0 -> buildSine (build (rand, depth))\n     | 1 -> buildCosine (build (rand, depth))\n     | 2 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n     | 3 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n     | 4 -> buildY ()\n     | 5 ->\n         buildThresh\n           ((build (rand, depth)), (build (rand, depth)),\n             (build (rand, depth)), (build (rand, depth)))\n     | 6 ->\n         buildMyExpr1\n           ((build (rand, depth)), (build (rand, depth)),\n             (build (rand, depth)))\n     | _ -> buildMyExpr2 (build (rand, depth)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then age else assoc (d, k, t)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then age else assoc (d, k, t)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then age else assoc (d, k, t)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then age else assoc (d, k, t)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)\n|MyExpr1(e1,e2,e3) -> abs_float(sqrt(eval (e1,x,y)))*.abs_float(eval (e2,x,y))*.eval(e3,x,y)\n|MyExpr2(e) -> eval (e,x,y)*.0.5", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | MyExpr1 (e1,e2,e3) ->\n      ((abs_float (sqrt (eval (e1, x, y)))) *. (abs_float (eval (e2, x, y))))\n        *. (eval (e3, x, y))\n  | MyExpr2 e -> (eval (e, x, y)) *. 0.5;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then age else assoc (d, k, t)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)\n|MyExpr1(e1,e2,e3) -> Cosine(eval (e1,x,y))*.Sine(eval (e2,x,y))*.eval(e3,x,y)\n|MyExpr2(e) -> Sine(eval (e,x,y)*.0.5)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | MyExpr1 (e1,e2,e3) ->\n      ((Cosine (eval (e1, x, y))) *. (Sine (eval (e2, x, y)))) *.\n        (eval (e3, x, y))\n  | MyExpr2 e -> Sine ((eval (e, x, y)) *. 0.5);;\n", "out": "Characters 362-383:\n  |MyExpr1(e1,e2,e3) -> Cosine(eval (e1,x,y))*.Sine(eval (e2,x,y))*.eval(e3,x,y)\n                        ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)\n|MyExpr1(e1,e2,e3) -> cos(pi*.eval (e1,x,y))*.sin(pi*.eval (e2,x,y))*.eval(e3,x,y)\n|MyExpr2(e) -> Sine(eval (e,x,y)*.0.5)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | MyExpr1 (e1,e2,e3) ->\n      ((cos (pi *. (eval (e1, x, y)))) *. (sin (pi *. (eval (e2, x, y))))) *.\n        (eval (e3, x, y))\n  | MyExpr2 e -> Sine ((eval (e, x, y)) *. 0.5);;\n", "out": "Characters 438-461:\n  |MyExpr2(e) -> Sine(eval (e,x,y)*.0.5);;\n                 ^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)\n|MyExpr1(e1,e2,e3) -> cos(pi*.eval (e1,x,y))*.sin(pi*.eval (e2,x,y))*.eval(e3,x,y)\n|MyExpr2(e) -> sin(pi*.eval (e,x,y)*.0.5)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | MyExpr1 (e1,e2,e3) ->\n      ((cos (pi *. (eval (e1, x, y)))) *. (sin (pi *. (eval (e2, x, y))))) *.\n        (eval (e3, x, y))\n  | MyExpr2 e -> sin ((pi *. (eval (e, x, y))) *. 0.5);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)\n|MyExpr1(e1,e2,e3) -> cos(pi*.eval (e1,x,y))*.sin(pi*.eval (e2,x,y))*.eval(e3,x,y)\n|MyExpr2(e) -> sin(pi*.eval (e,x,y)*.0.5)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | MyExpr1 (e1,e2,e3) ->\n      ((cos (pi *. (eval (e1, x, y)))) *. (sin (pi *. (eval (e2, x, y))))) *.\n        (eval (e3, x, y))\n  | MyExpr2 e -> sin ((pi *. (eval (e, x, y))) *. 0.5);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then age else assoc (d, k, t)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then age else assoc (d, k, t)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString ex = \nmatch ex with \n|VarX -> \"x\"\n|VarY -> \"y\"\n|Sine(e) -> \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) -> \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) -> \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) -> exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"\n|MyExpr1 (e1,e2,e3) -> \"cos(pi*\"^exprToString e1^\")*sin(pi*\"^exprToString e2^\")*\"^exprToString e3^\")\"\n|MyExpr2 (e) -> \"sin(pi*halve(\"^exprToString e^\"))\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet rec exprToString ex =\n  match ex with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | MyExpr1 (e1,e2,e3) ->\n      \"cos(pi*\" ^\n        ((exprToString e1) ^\n           (\")*sin(pi*\" ^\n              ((exprToString e2) ^ (\")*\" ^ ((exprToString e3) ^ \")\")))))\n  | MyExpr2 e -> \"sin(pi*halve(\" ^ ((exprToString e) ^ \"))\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then age else assoc (d, k, t)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then age else assoc (d, k, t)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then age else assoc (d, k, t)\n  | _ -> d;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | h::t -> let (name,age) = h in if name = k then age else assoc (d, k, t)\n  | _ -> d;;\n", "out": ""}]}
