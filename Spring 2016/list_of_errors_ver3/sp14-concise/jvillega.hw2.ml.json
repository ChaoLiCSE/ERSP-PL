{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 135-137:\n  | hh::tt -> if hh = ki then di else helper di ki tt\n                                                   ^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a list list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet assoc (d,k,l) =\n  let rec helper di ki li =\n    match li with\n    | h::t ->\n        (match h with\n         | hh::tt -> if hh = ki then di else helper di ki tt\n         | _ -> 0) in\n  helper d k l;;\n", "in": "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki tt\n| _ -> 0\nin\nhelper d k l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n| _ -> 0\nin\nhelper d k l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n| _ -> 0\nin\nhelper d k l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n\n| _ -> 0\nin\nhelper d k l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n| _ -> 0\nin\nhelper d k l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let assoc (d,k,l) = \nmatch l with\n| h::t -> h"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let assoc (d,k,l) = \nmatch l with\n| h::t ->\nlet rec helper di ki li = \nmatch li with \n| h::t -> h\nin\nhelper d k t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let assoc (d,k,l) = \nmatch l with\n| h::t ->\nlet rec helper di ki li = \nmatch li with \n| h::t -> h\nin\nhelper d k h"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 137-141:\n  | h::t -> helper di ki t\n    ^^^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b * 'c\n", "min": "\nlet assoc (d,k,l) =\n  match l with\n  | h::t ->\n      let rec helper di ki li =\n        let (name,age) = li in\n        if name = ki\n        then di\n        else (match li with | h::t -> helper di ki t | _ -> di) in\n      helper d k h;;\n", "in": "let assoc (d,k,l) = \nmatch l with\n| h::t ->\nlet rec helper di ki li = \nlet (name,age) = li in\nif name = ki then di\nelse \nmatch li with\n| h::t -> helper di ki t\n| _-> di\nin\nhelper d k h"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 100-101:\n  else assoc(d,k,t)\n                 ^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n", "min": "\nlet assoc (d,k,l) =\n  match l with\n  | h::t ->\n      let rec helper di ki li = match li with | h::t -> h in helper d k h;;\n\nlet _ =\n  let assoc (d,k,l) =\n    match l with\n    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n    | _ -> d in\n  helper d k h;;\n", "in": "let assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then d\nelse assoc(d,k,t)\n| _-> d\n\nin\nhelper d k h"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 100-101:\n  else assoc(d,k,t)\n                 ^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type 'c list list\n       Type 'a * 'b is not compatible with type 'c list \n", "min": "\nlet assoc (d,k,l) =\n  match l with\n  | h::t ->\n      let rec helper di ki li = match li with | h::t -> h in helper d k h;;\n\nlet _ =\n  let assoc (d,k,l) =\n    match l with\n    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n    | _ -> d in\n  helper d k h;;\n", "in": "let assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then d\nelse assoc(d,k,t)\n| _-> d\n\nin\nhelper d k h"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then d\nelse assoc(d,k,t)\n| _-> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then d\nelse assoc(d,k,t)\n| _-> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> if List.mem h seen \nthen\nlet seen' = seen in\nlet rest' = t in \nhelper (seen',rest') \n\nelse \nlet seen' = h::seen in\nlet rest' = t in\nhelper (seen', rest')\n| _-> []\nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t ->  \nlet seen' = if List.mem h seen then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \n| _-> []\nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t ->  \nlet seen' = if List.mem h seen then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let wwhile (f,b) = \nlet (func, boo) = f in\nfunc"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 54-55:\n  wwhile (f, 2);;\n          ^\nError: This expression has type int -> int * bool\n       but an expression was expected of type 'a * 'b\n", "min": "\nlet wwhile (f,b) = let (func,boo) = f in func;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let wwhile (f,b) = \nlet (func, boo) = f in\nfunc"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let wwhile (f,b) = f b"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 87-91:\n  if boo then wwhile (func, boo)\n                      ^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (func, boo) else value;;\n", "in": "let rec wwhile (f,b) = let func = f b in\nlet (value,boo) = func in\nif boo then wwhile (func, boo)\nelse value"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 86-92:\n  if boo then wwhile (func)\n                     ^^^^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type ('b -> 'a * bool) * 'b\n", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile func else value;;\n", "in": "let rec wwhile (f,b) = let func = f b in\nlet (value,boo) = func in\nif boo then wwhile (func)\nelse value"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 86-89:\n  if boo then wwhile (f)\n                     ^^^\nError: This expression has type 'a -> 'b * bool\n       but an expression was expected of type ('a -> 'b * bool) * 'a\n", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in let (value,boo) = func in if boo then wwhile f else value;;\n", "in": "let rec wwhile (f,b) = let func = f b in\nlet (value,boo) = func in\nif boo then wwhile (f)\nelse value"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = let func = f b in\nlet (value,boo) = func in\nif boo then wwhile (f,value)\nelse value"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t ->  \nlet seen' = if List.mem h seen then seen else h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = let func = f b in\nlet (value,boo) = func in\nif boo then wwhile (f,value)\nelse value"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 38-39:\n  let fixpoint (f,b) = wwhile (let xx = x*x*x in (xx, xx < 100),b);;\n                                        ^\nError: Unbound value x\n", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile (let xx = (x * x) * x in ((xx, (xx < 100)), b));;\n", "in": "let fixpoint (f,b) = wwhile (let xx = x*x*x in (xx, xx < 100),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 45-57:\n  let fixpoint (f,b) = wwhile (let xx = f b in (xx, xx = b),b);;\n                                               ^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile (let xx = f b in ((xx, (xx = b)), b));;\n", "in": "let fixpoint (f,b) = wwhile (let xx = f b in (xx, xx = b),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-42:\n  let fixpoint (f,b) = wwhile ((f b, xx = b),b);;\n                               ^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile (((f b), (xx = b)), b);;\n", "in": "let fixpoint (f,b) = wwhile ((f b, xx = b),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-42:\n  let fixpoint (f,b) = wwhile ((f b, xx = b),b);;\n                               ^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile (((f b), (xx = b)), b);;\n", "in": "let fixpoint (f,b) = wwhile ((f b, xx = b),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 38-39:\n  let fixpoint (f,b) = wwhile (let xx = x*x*x in (xx, xx < 100),b);;\n                                        ^\nError: Unbound value x\n", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile (let xx = (x * x) * x in ((xx, (xx < 100)), b));;\n", "in": "let fixpoint (f,b) = wwhile (let xx = x*x*x in (xx, xx < 100),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 47-61:\n  let fixpoint (f,b) = wwhile (let xx = b*b*b in (xx, xx < 100),b);;\n                                                 ^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile (let xx = (b * b) * b in ((xx, (xx < 100)), b));;\n", "in": "let fixpoint (f,b) = wwhile (let xx = b*b*b in (xx, xx < 100),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 38-39:\n  let fixpoint (f,b) = wwhile (let xx = x*x*x in (xx, xx < 100),b);;\n                                        ^\nError: Unbound value x\n", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile (let xx = (x * x) * x in ((xx, (xx < 100)), b));;\n", "in": "let fixpoint (f,b) = wwhile (let xx = x*x*x in (xx, xx < 100),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-49:\n  let fixpoint (f,b) = wwhile ((b*b*b, b*b*b < 100),b);;\n                               ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile ((((b * b) * b), (((b * b) * b) < 100)), b);;\n", "in": "let fixpoint (f,b) = wwhile ((b*b*b, b*b*b < 100),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-45:\n  let fixpoint (f,b) = wwhile ((b*b*b, b < 100),b);;\n                               ^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile ((((b * b) * b), (b < 100)), b);;\n", "in": "let fixpoint (f,b) = wwhile ((b*b*b, b < 100),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-41:\n  let fixpoint (f,b) = wwhile ((f b, false),b);;\n                               ^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) = wwhile (((f b), false), b);;\n", "in": "let fixpoint (f,b) = wwhile ((f b, false),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((let d x = let xx = (f b) in (xx, xx=b) in d),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((let d x = let xx = f b in (xx, xx=b) in d),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((let d x = let xx = f b in (xx, xx = b) in d),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((let d x = let xx = f x in (xx, xx = b) in d),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 72-75:\n  let fixpoint (f,b) = wwhile ((let d x = let xx = f x in (xx, xx = b) in d b),b);;\n                                                                          ^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let func = f b in\n  let (value,boo) = func in if boo then wwhile (f, value) else value;;\n\nlet fixpoint (f,b) =\n  wwhile ((let d x = let xx = f x in (xx, (xx = b)) in d b), b);;\n", "in": "let fixpoint (f,b) = wwhile ((let d x = let xx = f x in (xx, xx = b) in d b),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((let d x = let xx = f x in (xx, xx = b) in d),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((let d x = let xx = f x in (xx, xx = b) in d),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let d x = let xx = f x in (xx, xx = b) in d),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let d x = let xx = f x in (xx, (xx = b)) in d), b);;\n", "in": "let fixpoint (f,b) = wwhile ((let g x = let xx = f x in (xx, xx = b) in g),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = let xx = f x in (xx, xx = b) in g),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx = b)) in g), b);;\n", "in": "let fixpoint (f,b) = wwhile ((let g x = let xx = f x in (xx, xx = b) in g),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = let xx = f x in (xx, xx = b) in g),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx = b)) in g), b);;\n", "in": "let fixpoint (f,b) = wwhile ((let g x = let xx = (f x) in (xx, xx = b) in g),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = let xx = (f x) in (xx, xx = b) in g),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx = b)) in g), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((let g x = (f x, x = fx) in g,b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = (f x, x = fx) in g),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((let g x = ((f x), (x = fx)) in g), b);;\n", "in": "let fixpoint (f,b) = wwhile ((let g x = (f x, x = f x) in g),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = (f x, x = f x) in g),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((let g x = ((f x), (x = (f x))) in g), b);;\n", "in": "let fixpoint (f,b) = wwhile ((let g x = let d = f x in (d, x = d) in g),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = let d = f x in (d, x = d) in g),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((let g x = let d = f x in (d, (x = d)) in g), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((let g x = let d = (f x) in (d, x = d) in g),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = let d = (f x) in (d, x = d) in g),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((let g x = let d = f x in (d, (x = d)) in g), b);;\n", "in": "let fixpoint (f,b) = wwhile ((let g x = let d = (f b) in (d, x = d) in g),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = let d = (f b) in (d, x = d) in g),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((let g x = let d = f b in (d, (x = d)) in g), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((let g x = let d = (g b) in (d, x = d) in g),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = let d = (g b) in (d, x = d) in g),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((let g x = let d = g b in (d, (x = d)) in g), b);;\n", "in": "let fixpoint (f,b) = wwhile ((let g x = let d = let (f b) in (d, x != d) in g),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = let d = (f b) in (d, x != d) in g),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let g x = let d = f b in (d, (x != d)) in g), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-16:\n  let _ = fixpoint (collatz, 9001);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "let fixpoint (f,b) = wwhile ((let g x = let d = (f b) in (d, x = d) in g),b)"}, {"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = let d = (f b) in (d, x = d) in g),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((let g x = let d = f b in (d, (x = d)) in g), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((let g x = let d = (f b) in (d, b = d) in g),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = let d = (f b) in (d, b = d) in g),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((let g x = let d = f b in (d, (b = d)) in g), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((let g x = let d = (f x) in (d, x = d) in g b),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = let d = (f x) in (d, x = d) in g b),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let g x = let d = f x in (d, (x = d)) in g b), b);;\n", "in": "let fixpoint (f,b) = wwhile ((let g x = let d = (f x) in (d, x = d) in g),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = let d = (f x) in (d, x = d) in g),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((let g x = let d = f x in (d, (x = d)) in g), b);;\n", "in": "let fixpoint (f,b) = wwhile ((let g x = let d = (f x) in (d, x = d) in g),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = let d = (f x) in (d, x = d) in g),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((let g x = let d = f x in (d, (x = d)) in g), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((let g x = (f x, x = f x) in g),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = (f x, x = f x) in g),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((let g x = ((f x), (x = (f x))) in g), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((let g x = (f x, x != f x) in g),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g x = (f x, x != f x) in g),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((let g x = ((f x), (x != (f x))) in g), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-16:\n  let _ = fixpoint (collatz, 9001);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString ex = \nmatch ex with \n|VarX -> (\"x\")\n|VarY -> \"y\"\n|Sine(e) -> \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) -> \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) -> \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) -> exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\nError: Unbound value sampleExpr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 14-24:\n  let _ = eval (sampleExpr,0.5,0.2);;\n                ^^^^^^^^^^\nError: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))"}, {"type": "", "out": "", "min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) ="}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = 2"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString ex = \nmatch ex with \n|VarX -> \"x\"\n|VarY -> \"y\"\n|Sine(e) -> \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) -> \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) -> \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) -> exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"\n| _ -> \"\"^ex^\"\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 394-396:\n  | _ -> \"\"^ex^\"\";;\n            ^^\nError: This expression has type expr but an expression was expected of type\n         string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString ex =\n  match ex with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | _ -> \"\" ^ (ex ^ \"\");;\n", "in": "let rec exprToString ex = \nmatch ex with \n|VarX -> \"x\"\n|VarY -> \"y\"\n|Sine(e) -> \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) -> \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) -> \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) -> exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"\n| _ -> \"\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString ex = \nmatch ex with \n|VarX -> \"x\"\n|VarY -> \"y\"\n|Sine(e) -> \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) -> \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) -> \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) -> exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth=0 then buildX() else\nlet randNum = rand 0 4 in\nmatch randNum with \n|0 -> buildSine(build(rand, depth-1))\n|1 -> buildCosine(build(rand, depth - 1))\n|2 -> buildTimes(build(rand, depth - 1),build(rand, depth - 1))\n|3 -> buildAverage(build(rand, depth - 1),build(rand, depth - 1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth=0 then buildX() else\nlet randNum = rand 0 4 in\nmatch randNum with \n|0 -> buildSine(build(rand, depth-1))\n|1 -> buildCosine(build(rand, depth - 1))\n|2 -> buildTimes(build(rand, depth - 1),build(rand, depth - 1))\n|3 -> buildAverage(build(rand, depth - 1),build(rand, depth - 1))\n|4 -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth=0 then buildX() else\nlet randNum = rand 0 4 in\nmatch randNum with \n|0 -> buildSine(build(rand, depth-1))\n|1 -> buildCosine(build(rand, depth - 1))\n|2 -> buildTimes(build(rand, depth - 1),build(rand, depth - 1))\n|3 -> buildAverage(build(rand, depth - 1),build(rand, depth - 1))\n|_ -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth=0 then buildX() else\nlet randNum = rand 0 5 in\nmatch randNum with \n|0 -> buildSine(build(rand, depth-1))\n|1 -> buildCosine(build(rand, depth - 1))\n|2 -> buildTimes(build(rand, depth - 1),build(rand, depth - 1))\n|3 -> buildAverage(build(rand, depth - 1),build(rand, depth - 1))\n|_ -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 14-28:\n  let _ = build(makeRand(5,16),5);;\n                ^^^^^^^^^^^^^^\nError: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand 0 5 in\n     match randNum with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildY ());;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = build ((makeRand (5, 16)), 5);;\n", "in": "let random = makeRand(5,16) in\nlet _ = build(random,5)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 37-43:\n  build(random,5);;\n        ^^^^^^\nError: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand 0 5 in\n     match randNum with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildY ());;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = let random = makeRand (5, 16) in build (random, 5);;\n", "in": "Let _ = let random = makeRand(5,16) in\nbuild(random,5)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 45-51:\n  build(random,5);;\n        ^^^^^^\nError: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand 0 5 in\n     match randNum with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildY ());;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = let random = makeRand (5, 16) in build (random, 5);;\n", "in": "let rec build (rand, depth) = \nif depth=0 then buildX() else\nlet randNum = rand 0 5 in\nlet depth = depth - 1 in\nmatch randNum with \n|0 -> buildSine(build(rand, depth))\n|1 -> buildCosine(build(rand, depth))\n|2 -> buildTimes(build(rand, depth),build(rand, depth))\n|3 -> buildAverage(build(rand, depth),build(rand, depth))\n|_ -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth=0 then buildX() else\nlet randNum = rand 0 5 in\nlet depth = depth - 1 in\nmatch randNum with \n|0 -> buildSine(build(makeRand(5,16), depth))\n|1 -> buildCosine(build(rand, depth))\n|2 -> buildTimes(build(rand, depth),build(rand, depth))\n|3 -> buildAverage(build(rand, depth),build(rand, depth))\n|_ -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 154-168:\n  |0 -> buildSine(build(makeRand(5,16), depth))\n                        ^^^^^^^^^^^^^^\nError: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand 0 5 in\n     let depth = depth - 1 in\n     match randNum with\n     | 0 -> buildSine (build ((makeRand (5, 16)), depth))\n     | 1 -> buildCosine (build (rand, depth))\n     | 2 -> buildTimes ((build (rand, depth)), (build (rand, depth)))\n     | 3 -> buildAverage ((build (rand, depth)), (build (rand, depth)))\n     | _ -> buildY ());;\n", "in": "let rec build (rand, depth) = \nif depth=0 then buildX() else\nlet randNum = rand 0 5 in\nlet depth = depth - 1 in\nmatch randNum with \n|0 -> buildSine(build(makeRand(5,16), depth))\n|1 -> buildCosine(build(makeRand(5,16), depth))\n|2 -> buildTimes(build(makeRand(5,16), depth),build(makeRand(5,16), depth))\n|3 -> buildAverage(build(makeRand(5,16), depth),build(makeRand(5,16), depth))\n|_ -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 154-168:\n  |0 -> buildSine(build(makeRand(5,16), depth))\n                        ^^^^^^^^^^^^^^\nError: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then buildX ()\n  else\n    (let randNum = rand 0 5 in\n     let depth = depth - 1 in\n     match randNum with\n     | 0 -> buildSine (build ((makeRand (5, 16)), depth))\n     | 1 -> buildCosine (build ((makeRand (5, 16)), depth))\n     | 2 ->\n         buildTimes\n           ((build ((makeRand (5, 16)), depth)),\n             (build ((makeRand (5, 16)), depth)))\n     | 3 ->\n         buildAverage\n           ((build ((makeRand (5, 16)), depth)),\n             (build ((makeRand (5, 16)), depth)))\n     | _ -> buildY ());;\n", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth=0 then buildX() else\nlet randNum = rand (0,5) in\nlet depth = depth - 1 in\nmatch randNum with \n|0 -> buildSine(build(rand, depth))\n|1 -> buildCosine(build(rand, depth))\n|2 -> buildTimes(build(rand, depth),build(rand, depth))\n|3 -> buildAverage(build(rand, depth),build(rand, depth))\n|_ -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| MyExpr1  of expr * expr * expr\n| MyExpr2  of expr"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 458-462:\n  |MyExpr1 (e1,e2,e3) -> \"(sqrt(\"^exprToString e1^\")*sqrt(\"^exprToString e2^\")*\"exprToString e3^\")\";;\n                                                                            ^^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet rec exprToString ex =\n  match ex with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | MyExpr1 (e1,e2,e3) ->\n      \"(sqrt(\" ^\n        ((exprToString e1) ^\n           (\")*sqrt(\" ^ ((exprToString e2) ^ ((\")*\" exprToString e3) ^ \")\"))));;\n", "in": "let rec exprToString ex = \nmatch ex with \n|VarX -> \"x\"\n|VarY -> \"y\"\n|Sine(e) -> \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) -> \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) -> \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) -> exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"\n|MyExpr1 (e1,e2,e3) -> \"(sqrt(\"^exprToString e1^\")*sqrt(\"^exprToString e2^\")*\"^exprToString e3^\")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString ex = \nmatch ex with \n|VarX -> \"x\"\n|VarY -> \"y\"\n|Sine(e) -> \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) -> \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) -> \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) -> exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"\n|MyExpr1 (e1,e2,e3) -> \"(sqrt(\"^exprToString e1^\")*sqrt(\"^exprToString e2^\")*\"^exprToString e3^\")\"\n|MyExpr2 (e) -> \"halve(\"^exprToString^\")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 508-520:\n  |MyExpr2 (e) -> \"halve(\"^exprToString^\")\";;\n                           ^^^^^^^^^^^^\nError: This expression has type expr -> string\n       but an expression was expected of type string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet rec exprToString ex =\n  match ex with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | MyExpr1 (e1,e2,e3) ->\n      \"(sqrt(\" ^\n        ((exprToString e1) ^\n           (\")*sqrt(\" ^\n              ((exprToString e2) ^ (\")*\" ^ ((exprToString e3) ^ \")\")))))\n  | MyExpr2 e -> \"halve(\" ^ (exprToString ^ \")\");;\n", "in": "let rec exprToString ex = \nmatch ex with \n|VarX -> \"x\"\n|VarY -> \"y\"\n|Sine(e) -> \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) -> \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) -> \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) -> exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"\n|MyExpr1 (e1,e2,e3) -> \"(sqrt(\"^exprToString e1^\")*sqrt(\"^exprToString e2^\")*\"^exprToString e3^\")\"\n|MyExpr2 (e) -> \"halve(\"^exprToString e^\")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 366-370:\n  |MyExpr1(e1,e2,e3) -> sqrt(e1)*.sqrt(e2)*.e3\n                            ^^^^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | MyExpr1 (e1,e2,e3) -> ((sqrt e1) *. (sqrt e2)) *. e3\n  | MyExpr2 e -> e *. 0.5;;\n", "in": "let buildMyExpr1(a,b,c)            = MyExpr1(a,b,c)"}, {"type": "", "out": "", "min": "", "in": "let buildMyExpr2(e)                = MyExpr2(e)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 366-370:\n  |MyExpr1(e1,e2,e3) -> sqrt(e1)*.sqrt(e2)*.e3\n                            ^^^^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | MyExpr1 (e1,e2,e3) -> ((sqrt e1) *. (sqrt e2)) *. e3\n  | MyExpr2 e -> e *. 0.5;;\n", "in": "let rec eval (e,x,y) = \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)\n|MyExpr1(e1,e2,e3) -> sqrt(eval (e1,x,y))*.sqrt(eval (e2,x,y))*.eval(e3,x,y)\n|MyExpr2(e) -> eval (e,x,y)*.0.5"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth=0 then buildX() else\nlet randNum = rand (0,8) in\nlet depth = depth - 1 in\nmatch randNum with \n|0 -> buildSine(build(rand, depth))\n|1 -> buildCosine(build(rand, depth))\n|2 -> buildTimes(build(rand, depth),build(rand, depth))\n|3 -> buildAverage(build(rand, depth),build(rand, depth))\n|4 -> buildY()\n|5 -> buildThresh(build(rand, depth),build(rand, depth),build(rand, depth),build(rand, depth))\n|6 -> buildMyExpr1(build(rand, depth),build(rand, depth),build(rand, depth))\n| _-> buildMyExpr2(build(rand, depth))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)\n|MyExpr1(e1,e2,e3) -> abs_float(sqrt(eval (e1,x,y)))*.abs_float(eval (e2,x,y))*.eval(e3,x,y)\n|MyExpr2(e) -> eval (e,x,y)*.0.5"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)\n|MyExpr1(e1,e2,e3) -> Cosine(eval (e1,x,y))*.Sine(eval (e2,x,y))*.eval(e3,x,y)\n|MyExpr2(e) -> Sine(eval (e,x,y)*.0.5)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 362-383:\n  |MyExpr1(e1,e2,e3) -> Cosine(eval (e1,x,y))*.Sine(eval (e2,x,y))*.eval(e3,x,y)\n                        ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | MyExpr1 (e1,e2,e3) ->\n      ((Cosine (eval (e1, x, y))) *. (Sine (eval (e2, x, y)))) *.\n        (eval (e3, x, y))\n  | MyExpr2 e -> Sine ((eval (e, x, y)) *. 0.5);;\n", "in": "let rec eval (e,x,y) = \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)\n|MyExpr1(e1,e2,e3) -> cos(pi*.eval (e1,x,y))*.sin(pi*.eval (e2,x,y))*.eval(e3,x,y)\n|MyExpr2(e) -> Sine(eval (e,x,y)*.0.5)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 438-461:\n  |MyExpr2(e) -> Sine(eval (e,x,y)*.0.5);;\n                 ^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | MyExpr1 of expr* expr* expr\n  | MyExpr2 of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | MyExpr1 (e1,e2,e3) ->\n      ((cos (pi *. (eval (e1, x, y)))) *. (sin (pi *. (eval (e2, x, y))))) *.\n        (eval (e3, x, y))\n  | MyExpr2 e -> Sine ((eval (e, x, y)) *. 0.5);;\n", "in": "let rec eval (e,x,y) = \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)\n|MyExpr1(e1,e2,e3) -> cos(pi*.eval (e1,x,y))*.sin(pi*.eval (e2,x,y))*.eval(e3,x,y)\n|MyExpr2(e) -> sin(pi*.eval (e,x,y)*.0.5)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = \nmatch e with \n|VarX -> x\n|VarY -> y\n|Sine(e) -> sin(pi *. eval (e,x,y))\n|Cosine(e) -> cos(pi *. eval (e,x,y))\n|Average(e1,e2) -> (eval (e1,x,y) +. eval (e2,x,y))/.2.0\n|Times (e1,e2) -> (eval (e1,x,y) *. eval (e2,x,y))\n|Thresh (e1,e2,e3,e4) -> \nif eval (e1,x,y) < eval (e2,x,y) \nthen eval (e3,x,y)\nelse eval (e4,x,y)\n|MyExpr1(e1,e2,e3) -> cos(pi*.eval (e1,x,y))*.sin(pi*.eval (e2,x,y))*.eval(e3,x,y)\n|MyExpr2(e) -> sin(pi*.eval (e,x,y)*.0.5)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString ex = \nmatch ex with \n|VarX -> \"x\"\n|VarY -> \"y\"\n|Sine(e) -> \"sin(pi*\"^exprToString e^\")\"\n|Cosine(e) -> \"cos(pi*\"^exprToString e^\")\"\n|Average(e1,e2) -> \"((\"^exprToString e1^\" + \"^exprToString e2^\")/2)\"\n|Times (e1,e2) -> exprToString e1^\"*\"^exprToString e2\n|Thresh (e1,e2,e3,e4) -> \"(\"^exprToString e1^\"<\"^exprToString e2^\"?\"^exprToString e3^\":\"^exprToString e4^\")\"\n|MyExpr1 (e1,e2,e3) -> \"cos(pi*\"^exprToString e1^\")*sin(pi*\"^exprToString e2^\")*\"^exprToString e3^\")\"\n|MyExpr2 (e) -> \"sin(pi*halve(\"^exprToString e^\"))\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| h::t -> let (name,age) = h in\nif name = k then age\nelse assoc(d,k,t)\n| _-> d"}]}
