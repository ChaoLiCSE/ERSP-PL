{"event": "eval", "ocaml": [{"in": "let rec sumList xs = failwith \"TBD:sumList\"", "out": "", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = failwith \"TBD:sumList\"", "out": "", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "out": "", "min": "\nlet rec sumList xs = match xs with | h::t -> h + (sumList t) | [] -> 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "out": "", "min": "\nlet rec sumList xs = match xs with | h::t -> h + (sumList t) | [] -> 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nmatch n > 0 with\n| true  -> [1] \n| false -> [2]", "out": "", "min": "\nlet rec digitsOfInt n = match n > 0 with | true  -> [1] | false  -> [2];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nmatch n > 0 with\n| true  -> digOfIntHelper::[n mod 10] \n| false -> []", "out": "Characters 53-67:\n  | true  -> digOfIntHelper::[n mod 10] \n             ^^^^^^^^^^^^^^\nError: Unbound value digOfIntHelper\n", "min": "\nlet rec digitsOfInt n =\n  match n > 0 with | true  -> [digOfIntHelper; n mod 10] | false  -> [];;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nmatch n > 0 with\n| true  -> digOfIntHelper::[n mod 10] \n| false -> []", "out": "Characters 70-78:\n  | true  -> digOfIntHelper::[n mod 10] \n                              ^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int -> int\n", "min": "\nlet rec digOfIntHelper h = match h > 0 with | true  -> 1 | false  -> 0;;\n\nlet rec digitsOfInt n =\n  match n > 0 with | true  -> [digOfIntHelper; n mod 10] | false  -> [];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nmatch n > 0 with\n| true  -> digOfIntHelper::[n % 10] \n| false -> []", "out": "Characters 72-73:\n  | true  -> digOfIntHelper::[n % 10] \n                                ^\nError: Unbound value %\n", "min": "\nlet rec digOfIntHelper h = match h > 0 with | true  -> 1 | false  -> 0;;\n\nlet rec digitsOfInt n =\n  match n > 0 with | true  -> [digOfIntHelper; n % 10] | false  -> [];;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nmatch n > 0 with\n| true  -> digOfIntHelper n::[n mod 10] \n| false -> []", "out": "", "min": "\nlet rec digOfIntHelper h = match h > 0 with | true  -> 1 | false  -> 0;;\n\nlet rec digitsOfInt n =\n  match n > 0 with | true  -> [digOfIntHelper n; n mod 10] | false  -> [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nmatch n > 0 with\n| true  -> digOfIntHelper n::[n mod 10] \n| false -> []", "out": "", "min": "\nlet rec digOfIntHelper h = match h > 0 with | true  -> 1 | false  -> 0;;\n\nlet rec digitsOfInt n =\n  match n > 0 with | true  -> [digOfIntHelper n; n mod 10] | false  -> [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nmatch n > 0 with\n| true  -> digOfIntHelper n::3::[n mod 10] \n| false -> []", "out": "", "min": "\nlet rec digOfIntHelper h = match h > 0 with | true  -> 1 | false  -> 0;;\n\nlet rec digitsOfInt n =\n  match n > 0 with | true  -> [digOfIntHelper n; 3; n mod 10] | false  -> [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nmatch n with\n| 0    -> []\n| [0]   -> []\n| 1     -> []\n| true  -> digOfIntHelper n::[]::[n mod 10] \n| false -> []", "out": "Characters 53-56:\n  | [0]   -> []\n    ^^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int\n", "min": "\nlet rec digOfIntHelper h = match h > 0 with | true  -> 1 | false  -> 0;;\n\nlet rec digitsOfInt n =\n  match n with\n  | 0 -> []\n  | 0::[] -> []\n  | 1 -> []\n  | true  -> [digOfIntHelper n; []; n mod 10]\n  | false  -> [];;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nmatch n > 0 with\n| true  -> digOfIntHelper n::[]::[n mod 10] \n| false -> []", "out": "Characters 71-73:\n  | true  -> digOfIntHelper n::[]::[n mod 10] \n                               ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digOfIntHelper h = match h > 0 with | true  -> 1 | false  -> 0;;\n\nlet rec digitsOfInt n =\n  match n > 0 with | true  -> [digOfIntHelper n; []; n mod 10] | false  -> [];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt n\n| true  -> digitsOfInt n mod 10", "out": "Characters 125-138:\n  | true  -> digitsOfInt n mod 10;;\n             ^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt n)\n       | true  -> (digitsOfInt n) mod 10);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "out": "", "min": "\nlet rec sumList xs = match xs with | h::t -> h + (sumList t) | [] -> 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt n\n| true  -> digitsOfInt (n mod 10)", "out": "", "min": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt n)\n       | true  -> digitsOfInt (n mod 10));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt (n / 10)\n| true  -> digitsOfInt (n mod 10)", "out": "", "min": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt (n / 10))\n       | true  -> digitsOfInt (n mod 10));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: []\n| true  -> digitsOfInt (n mod 10)", "out": "", "min": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with | false  -> [n] | true  -> digitsOfInt (n mod 10));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: []\n| true  -> digitsOfInt (n / 10) :: digitsOfInt (n mod 10)", "out": "Characters 114-134:\n  | true  -> digitsOfInt (n / 10) :: digitsOfInt (n mod 10);;\n             ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> [n]\n       | true  -> (digitsOfInt (n / 10)) :: (digitsOfInt (n mod 10)));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: []\n| true  -> (n / 10) :: digitsOfInt (n mod 10)", "out": "", "min": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> [n]\n       | true  -> (n / 10) :: (digitsOfInt (n mod 10)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: []\n| true  -> digitsOfInt (n / 10) ::  (n mod 10)", "out": "Characters 114-134:\n  | true  -> digitsOfInt (n / 10) ::  (n mod 10);;\n             ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> [n]\n       | true  -> (digitsOfInt (n / 10)) :: (n mod 10));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: []\n| true  -> n / 10 :: digitsOfInt (n / 10)", "out": "", "min": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> [n]\n       | true  -> (n / 10) :: (digitsOfInt (n / 10)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: []\n| true  -> 1 :: digitsOfInt( n mod 10 )", "out": "", "min": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> [n]\n       | true  -> 1 :: (digitsOfInt (n mod 10)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: []\n| true  -> n/10 :: digitsOfInt( n mod 10 )", "out": "", "min": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> [n]\n       | true  -> (n / 10) :: (digitsOfInt (n mod 10)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n/10)\n| true  -> n/10 :: digitsOfInt( n mod 10 )", "out": "", "min": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt (n / 10))\n       | true  -> (n / 10) :: (digitsOfInt (n mod 10)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> 1", "out": "Characters 134-135:\n  | true  -> 1;;\n             ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with | false  -> n :: (digitsOfInt (n / 10)) | true  -> 1);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> 1 :: 1", "out": "Characters 139-140:\n  | true  -> 1 :: 1;;\n                  ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt (n / 10))\n       | true  -> 1 :: 1);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> 1 :: []", "out": "", "min": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt (n / 10))\n       | true  -> [1]);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> 1 :: 2", "out": "Characters 139-140:\n  | true  -> 1 :: 2;;\n                  ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt (n / 10))\n       | true  -> 1 :: 2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 )", "out": "", "min": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt (n / 10))\n       | true  -> (n mod 10) :: (digitsOfInt (n / 10)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> digitsOfInt ( n / 10 ) :: [n mod 10]", "out": "Characters 134-156:\n  | true  -> digitsOfInt ( n / 10 ) :: [n mod 10];;\n             ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt (n / 10))\n       | true  -> [digitsOfInt (n / 10); n mod 10]);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "out": "", "min": "\nlet rec sumList xs = match xs with | h::t -> h + (sumList t) | [] -> 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> reverseHelper t h::revd \nin\nreverseHelper [] l", "out": "Characters 95-108:\n  | h::t  -> reverseHelper t h::revd \n             ^^^^^^^^^^^^^\nError: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> (reverseHelper t h) :: revd in\n  reverseHelper [] l;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> reverseHelper t h::revd \nin\nreverseHelper [] l", "out": "Characters 95-108:\n  | h::t  -> reverseHelper t h::revd \n             ^^^^^^^^^^^^^\nError: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> (reverseHelper t h) :: revd in\n  reverseHelper [] l;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l =\nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> reverseHelper t h::revd \nin\nreverseHelper [] l", "out": "Characters 91-104:\n  | h::t  -> reverseHelper t h::revd \n             ^^^^^^^^^^^^^\nError: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> (reverseHelper t h) :: revd in\n  reverseHelper [] l;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l =\nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> reverseHelper t (h::revd )\nin\nreverseHelper [] l", "out": "Characters 91-104:\n  | h::t  -> reverseHelper t (h::revd )\n             ^^^^^^^^^^^^^\nError: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> reverseHelper t (h :: revd) in\n  reverseHelper [] l;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l =\nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nreverseHelper [] l", "out": "Characters 119-132:\n  reverseHelper [] l;;\n  ^^^^^^^^^^^^^\nError: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec listReverse l = failwith \"TBD\";;\n\nlet listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  reverseHelper [] l;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nreverseHelper [] l", "out": "Characters 123-136:\n  reverseHelper [] l;;\n  ^^^^^^^^^^^^^\nError: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  reverseHelper [] l;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nlistReverse[] l", "out": "Characters 123-138:\n  listReverse[] l;;\n  ^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "min": "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  listReverse [] l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch revd with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nlistReverse [] l", "out": "Characters 123-139:\n  listReverse [] l;;\n  ^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "min": "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  listReverse [] l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nlistReverse l []", "out": "Characters 120-136:\n  listReverse l [];;\n  ^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "min": "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match l with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  listReverse l [];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nlistReverse [] l", "out": "Characters 120-136:\n  listReverse [] l;;\n  ^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "min": "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match l with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  listReverse [] l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nreverseHelper []", "out": "Characters 120-136:\n  reverseHelper [];;\n  ^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "min": "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match l with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  reverseHelper [];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t (h::revd )\nin\nreverseHelper l", "out": "Characters 120-135:\n  reverseHelper l;;\n  ^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "min": "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match l with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  reverseHelper l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::revd )\nin\nlistReverse l []", "out": "Characters 121-137:\n  listReverse l [];;\n  ^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "min": "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match l with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  listReverse l [];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::revd )\nin\nlistReverse [] l", "out": "Characters 121-137:\n  listReverse [] l;;\n  ^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "min": "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match l with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  listReverse [] l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "out": "", "min": "\nlet rec sumList xs = match xs with | h::t -> h + (sumList t) | [] -> 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet rec reverseHelper revd = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::revd )\nin\nreverseHelper [] l", "out": "Characters 121-134:\n  reverseHelper [] l;;\n  ^^^^^^^^^^^^^\nError: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec listReverse l =\n  let rec reverseHelper revd =\n    match l with | [] -> [] | h::t -> listReverse t (h :: revd) in\n  reverseHelper [] l;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet rec reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r )\nin\nlistReverse l []", "out": "Characters 115-131:\n  listReverse l [];;\n  ^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "min": "\nlet rec listReverse l =\n  let rec reverseHelper r =\n    match l with | [] -> [] | h::t -> listReverse t (h :: r) in\n  listReverse l [];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r )\nin\nlistReverse l []", "out": "Characters 111-127:\n  listReverse l [];;\n  ^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "min": "\nlet rec listReverse l =\n  let reverseHelper r =\n    match l with | [] -> [] | h::t -> listReverse t (h :: r) in\n  listReverse l [];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r ) \nin\nlistReverse l []", "out": "Characters 112-128:\n  listReverse l [];;\n  ^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "min": "\nlet rec listReverse l =\n  let reverseHelper r =\n    match l with | [] -> [] | h::t -> listReverse t (h :: r) in\n  listReverse l [];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r ) \nin\nlistReverse [] []", "out": "Characters 112-129:\n  listReverse [] [];;\n  ^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b list -> 'a list\n", "min": "\nlet rec listReverse l =\n  let reverseHelper r =\n    match l with | [] -> [] | h::t -> listReverse t (h :: r) in\n  listReverse [] [];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nlistReverse [] []", "out": "Characters 111-128:\n  listReverse [] [];;\n  ^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a list -> 'a list\n", "min": "\nlet rec listReverse l =\n  let reverseHelper r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  listReverse [] [];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper l []", "out": "Characters 111-124:\n  reverseHelper l [];;\n  ^^^^^^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec listReverse l =\n  let reverseHelper r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper l [];;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "out": "Characters 111-127:\n  reverseHelper [];;\n  ^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a list -> 'a list\n", "min": "\nlet rec listReverse l =\n  let reverseHelper r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper [];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nr", "out": "Characters 111-112:\n  r;;\n  ^\nError: Unbound value r\n", "min": "\nlet rec listReverse l =\n  let reverseHelper r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  r;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "out": "", "min": "\nlet rec listReverse l =\n  let reverseHelper l r =\n    match l with | [] -> l | h::t -> listReverse t (h :: r) in\n  reverseHelper [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> reverseHelper t ( h::r ) \nin\nreverseHelper []", "out": "Characters 86-99:\n  | h::t  -> reverseHelper t ( h::r ) \n             ^^^^^^^^^^^^^\nError: Unbound value reverseHelper\n", "min": "\nlet rec listReverse l =\n  let reverseHelper l r =\n    match l with | [] -> l | h::t -> reverseHelper t (h :: r) in\n  reverseHelper [];;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet rec reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> reverseHelper t ( h::r ) \nin\nreverseHelper []", "out": "", "min": "\nlet rec listReverse l =\n  let rec reverseHelper l r =\n    match l with | [] -> l | h::t -> reverseHelper t (h :: r) in\n  reverseHelper [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet rec reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> reverseHelper t ( h::r ) \nin\nreverseHelper []", "out": "", "min": "\nlet rec listReverse l =\n  let rec reverseHelper l r =\n    match l with | [] -> l | h::t -> reverseHelper t (h :: r) in\n  reverseHelper [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 )", "out": "", "min": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt (n / 10))\n       | true  -> (n mod 10) :: (digitsOfInt (n / 10)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l =\nlet rec reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> reverseHelper t ( h::r ) \nin\nreverseHelper []", "out": "", "min": "\nlet listReverse l =\n  let rec reverseHelper l r =\n    match l with | [] -> l | h::t -> reverseHelper t (h :: r) in\n  reverseHelper [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l =\nlet rec reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> reverseHelper t ( h::r ) \nin\nreverseHelper l []", "out": "", "min": "\nlet listReverse l =\n  let rec reverseHelper l r =\n    match l with | [] -> l | h::t -> reverseHelper t (h :: r) in\n  reverseHelper l [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l =\nlet rec reverseHelper l r = \nmatch l with\n| []    -> r\n| h::t  -> reverseHelper t ( h::r ) \nin\nreverseHelper l []", "out": "", "min": "\nlet listReverse l =\n  let rec reverseHelper l r =\n    match l with | [] -> r | h::t -> reverseHelper t (h :: r) in\n  reverseHelper l [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l =\nlet rec reverseHelper l rl = \nfunction\n| []    -> rl\n| h::t  -> reverseHelper t ( h::rl ) \nin\nreverseHelper l []", "out": "Characters 84-109:\n  | h::t  -> reverseHelper t ( h::rl ) \n             ^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list -> 'a list\n       but an expression was expected of type 'a list\n", "min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    function | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l =\nlet rec reverseHelper l rl = \nmatch l with\n| []    -> rl\n| h::t  -> reverseHelper t ( h::rl ) \nin\nreverseHelper l []", "out": "", "min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l =\nlet rec reverseHelper l rl = \nmatch l with\n| []    -> rl\n| h::t  -> reverseHelper t ( h::rl ) \nin\nreverseHelper l []", "out": "", "min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nreverse (\nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 ) )", "out": "", "min": "\nlet rec reverse l = match l with | h::t -> reverse t | [] -> [];;\n\nlet rec digitsOfInt n =\n  reverse\n    (match n > 0 with\n     | false  -> []\n     | true  ->\n         (match n > 9 with\n          | false  -> n :: (digitsOfInt (n / 10))\n          | true  -> (n mod 10) :: (digitsOfInt (n / 10))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \n(\nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 ) )", "out": "", "min": "\nlet rec digitsOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt (n / 10))\n       | true  -> (n mod 10) :: (digitsOfInt (n / 10)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nlistReverse (\nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 ) )", "out": "", "min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  listReverse\n    (match n > 0 with\n     | false  -> []\n     | true  ->\n         (match n > 9 with\n          | false  -> n :: (digitsOfInt (n / 10))\n          | true  -> (n mod 10) :: (digitsOfInt (n / 10))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nlet digOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 ) \nin\nlistReverse n", "out": "Characters 203-204:\n  listReverse n;;\n              ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  let digOfInt n =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: (digitsOfInt (n / 10))\n         | true  -> (n mod 10) :: (digitsOfInt (n / 10))) in\n  listReverse n;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nlet digOfInt n r = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 ) \nin\nlistReverse n r", "out": "Characters 193-204:\n  listReverse n r;;\n  ^^^^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  let digOfInt n r =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: (digitsOfInt (n / 10))\n         | true  -> (n mod 10) :: (digitsOfInt (n / 10))) in\n  listReverse n r;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nlet digOfInt n r = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 ) \nin\nlistReverse n r", "out": "Characters 193-204:\n  listReverse n r;;\n  ^^^^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  let digOfInt n r =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: (digitsOfInt (n / 10))\n         | true  -> (n mod 10) :: (digitsOfInt (n / 10))) in\n  listReverse n r;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nlet digOfInt n r = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 ) \nin\nlistReverse n", "out": "Characters 205-206:\n  listReverse n;;\n              ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  let digOfInt n r =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: (digitsOfInt (n / 10))\n         | true  -> (n mod 10) :: (digitsOfInt (n / 10))) in\n  listReverse n;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nlet digOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 ) \nin\nlistReverse n", "out": "Characters 203-204:\n  listReverse n;;\n              ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  let digOfInt n =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: (digitsOfInt (n / 10))\n         | true  -> (n mod 10) :: (digitsOfInt (n / 10))) in\n  listReverse n;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digOfInt = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 )", "out": "Characters 26-27:\n  match n > 0 with\n        ^\nError: Unbound value n\n", "min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  listReverse\n    (match n > 0 with\n     | false  -> []\n     | true  ->\n         (match n > 9 with\n          | false  -> n :: (digitsOfInt (n / 10))\n          | true  -> (n mod 10) :: (digitsOfInt (n / 10))));;\n\nlet rec digOfInt =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt (n / 10))\n       | true  -> (n mod 10) :: (digitsOfInt (n / 10)));;\n", "type": "scope"}, {"in": "let rec digitsOfInt n = listReverse (digOfInt n)", "out": "Characters 37-45:\n  let rec digitsOfInt n = listReverse (digOfInt n);;\n                                       ^^^^^^^^\nError: Unbound value digOfInt\nHint: Did you mean digitsOfInt?\n", "min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n = listReverse (digOfInt n);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digOfInt n = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: digitsOfInt ( n / 10 )\n| true  -> n mod 10 :: digitsOfInt ( n / 10 )", "out": "", "min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  listReverse\n    (match n > 0 with\n     | false  -> []\n     | true  ->\n         (match n > 9 with\n          | false  -> n :: (digitsOfInt (n / 10))\n          | true  -> (n mod 10) :: (digitsOfInt (n / 10))));;\n\nlet rec digOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt (n / 10))\n       | true  -> (n mod 10) :: (digitsOfInt (n / 10)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =  (digOfInt n)", "out": "", "min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  listReverse\n    (match n > 0 with\n     | false  -> []\n     | true  ->\n         (match n > 9 with\n          | false  -> n :: (digitsOfInt (n / 10))\n          | true  -> (n mod 10) :: (digitsOfInt (n / 10))));;\n\nlet rec digOfInt n =\n  match n > 0 with\n  | false  -> []\n  | true  ->\n      (match n > 9 with\n       | false  -> n :: (digitsOfInt (n / 10))\n       | true  -> (n mod 10) :: (digitsOfInt (n / 10)));;\n\nlet rec digitsOfInt n = digOfInt n;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =  \nlet rec digOfIntHelper n l = \nmatch n > 0 with\n| false -> []\n| true  -> match n > 9 with\n| false -> n :: l\n| true  -> digOfIntHelper (n / 10) ((n mod 10)::l)\nin\ndigOfIntHelper n []", "out": "", "min": "\nlet digitsOfInt n =\n  let rec digOfIntHelper n l =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: l\n         | true  -> digOfIntHelper (n / 10) ((n mod 10) :: l)) in\n  digOfIntHelper n [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "out": "", "min": "\nlet rec sumList xs = match xs with | h::t -> h + (sumList t) | [] -> 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "out": "", "min": "\nlet rec sumList xs = match xs with | h::t -> h + (sumList t) | [] -> 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \nlet rec addPerHelper n l =\nmatch l with\n| []    -> 0\n| [a]   -> n\n| h::t  -> addPerHelper (n + 1) t\nin\naddPerHelper 0 (digitsOfInt n)", "out": "", "min": "\nlet digitsOfInt n =\n  let rec digOfIntHelper n l =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: l\n         | true  -> digOfIntHelper (n / 10) ((n mod 10) :: l)) in\n  digOfIntHelper n [];;\n\nlet additivePersistence n =\n  let rec addPerHelper n l =\n    match l with | [] -> 0 | a::[] -> n | h::t -> addPerHelper (n + 1) t in\n  addPerHelper 0 (digitsOfInt n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \nlet rec addPerHelper n l =\nmatch l with\n| []    -> 0\n| [a]   -> n\n| _     -> addPerHelper (n + 1) (digitsOfInt(sumlist l))\nin\naddPerHelper 0 (digitsOfInt n)", "out": "Error: Unbound value sumlist\nHint: Did you mean sumList?\nError: Unbound value sumlist\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 140-147:\n  | _     -> addPerHelper (n + 1) (digitsOfInt(sumlist l))\n                                               ^^^^^^^\nError: Unbound value sumlist\nHint: Did you mean sumList?\n", "min": "\nlet digitsOfInt n =\n  let rec digOfIntHelper n l =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: l\n         | true  -> digOfIntHelper (n / 10) ((n mod 10) :: l)) in\n  digOfIntHelper n [];;\n\nlet additivePersistence n =\n  let rec addPerHelper n l =\n    match l with\n    | [] -> 0\n    | a::[] -> n\n    | _ -> addPerHelper (n + 1) (digitsOfInt (sumlist l)) in\n  addPerHelper 0 (digitsOfInt n);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \nlet rec addPerHelper n l =\nmatch l with\n| []    -> 0\n| [a]   -> n\n| _     -> addPerHelper (n + 1) (digitsOfInt(sumList l))\nin\naddPerHelper 0 (digitsOfInt n)", "out": "", "min": "\nlet digitsOfInt n =\n  let rec digOfIntHelper n l =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: l\n         | true  -> digOfIntHelper (n / 10) ((n mod 10) :: l)) in\n  digOfIntHelper n [];;\n\nlet rec sumList xs = match xs with | h::t -> h + (sumList t) | [] -> 0;;\n\nlet additivePersistence n =\n  let rec addPerHelper n l =\n    match l with\n    | [] -> 0\n    | a::[] -> n\n    | _ -> addPerHelper (n + 1) (digitsOfInt (sumList l)) in\n  addPerHelper 0 (digitsOfInt n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \nlet rec addPerHelper n l =\nmatch l with\n| []    -> 0\n| [a]   -> n\n| _     -> addPerHelper (n + 1) (digitsOfInt(sumList l))\nin\naddPerHelper 0 (digitsOfInt n)", "out": "", "min": "\nlet digitsOfInt n =\n  let rec digOfIntHelper n l =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: l\n         | true  -> digOfIntHelper (n / 10) ((n mod 10) :: l)) in\n  digOfIntHelper n [];;\n\nlet rec sumList xs = match xs with | h::t -> h + (sumList t) | [] -> 0;;\n\nlet additivePersistence n =\n  let rec addPerHelper n l =\n    match l with\n    | [] -> 0\n    | a::[] -> n\n    | _ -> addPerHelper (n + 1) (digitsOfInt (sumList l)) in\n  addPerHelper 0 (digitsOfInt n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \nlet rec addPerHelper n l =\nmatch l with\n| [a]   -> n\n| _     -> addPerHelper (n + 1) (digitsOfInt(sumList l))\nin\naddPerHelper 0 (digitsOfInt n)", "out": "", "min": "\nlet digitsOfInt n =\n  let rec digOfIntHelper n l =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: l\n         | true  -> digOfIntHelper (n / 10) ((n mod 10) :: l)) in\n  digOfIntHelper n [];;\n\nlet rec sumList xs = match xs with | h::t -> h + (sumList t) | [] -> 0;;\n\nlet additivePersistence n =\n  let rec addPerHelper n l =\n    match l with\n    | a::[] -> n\n    | _ -> addPerHelper (n + 1) (digitsOfInt (sumList l)) in\n  addPerHelper 0 (digitsOfInt n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digits n = digitsOfInt (abs n)", "out": "Characters 15-26:\n  let digits n = digitsOfInt (abs n);;\n                 ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet digits n = digitsOfInt (abs n);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \nlet rec addPerHelper n l =\nmatch l with\n| [a]   -> n\n| _     -> addPerHelper (n + 1) (digitsOfInt(sumList l))\nin\naddPerHelper 0 (digitsOfInt n)", "out": "Characters 115-126:\n  | _     -> addPerHelper (n + 1) (digitsOfInt(sumList l))\n                                   ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet additivePersistence n =\n  let rec addPerHelper n l =\n    match l with\n    | a::[] -> n\n    | _ -> addPerHelper (n + 1) (digitsOfInt (sumList l)) in\n  addPerHelper 0 (digitsOfInt n);;\n", "type": "scope"}, {"in": "let rec digitalRoot n = \nlet rec digRtHelper n l =\nmatch l with\n| [a]   -> a\n| _     -> digRtHelper (0) (digitsOfInt(sumList l))\nin\ndigRtHelper 0 (digitsOfInt n)", "out": "Characters 105-116:\n  | _     -> digRtHelper (0) (digitsOfInt(sumList l))\n                              ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet rec digitalRoot n =\n  let rec digRtHelper n l =\n    match l with | a::[] -> a | _ -> digRtHelper 0 (digitsOfInt (sumList l)) in\n  digRtHelper 0 (digitsOfInt n);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nmatch digitsOfInt(l) with\n| [a]   -> a\n| _     -> digitalRoot (digitsOfInt(sumList l))", "out": "Characters 31-42:\n  match digitsOfInt(l) with\n        ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet rec digitalRoot n =\n  match digitsOfInt l with\n  | a::[] -> a\n  | _ -> digitalRoot (digitsOfInt (sumList l));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nmatch digitsOfInt(n) with\n| [a]   -> a\n| _     -> digitalRoot (sumList(digitsOfInt l))", "out": "Characters 31-42:\n  match digitsOfInt(n) with\n        ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet rec digitalRoot n =\n  match digitsOfInt n with\n  | a::[] -> a\n  | _ -> digitalRoot (sumList (digitsOfInt l));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nmatch digitsOfInt(n) with\n| [a]   -> a\n| _     -> digitalRoot (sumList(digitsOfInt n))", "out": "Characters 31-42:\n  match digitsOfInt(n) with\n        ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet rec digitalRoot n =\n  match digitsOfInt n with\n  | a::[] -> a\n  | _ -> digitalRoot (sumList (digitsOfInt n));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nmatch digitsOfInt(n) with\n| [a]   -> a\n| _     -> digitalRoot (sumList(digitsOfInt n))", "out": "Characters 31-42:\n  match digitsOfInt(n) with\n        ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet rec digitalRoot n =\n  match digitsOfInt n with\n  | a::[] -> a\n  | _ -> digitalRoot (sumList (digitsOfInt n));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "out": "", "min": "\nlet rec sumList xs = match xs with | h::t -> h + (sumList t) | [] -> 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =  \nlet rec digOfIntHelper n l = \nif n > 0 \nthen (\nmatch n > 9 with\n| false -> n :: l\n| true  -> digOfIntHelper (n / 10) ((n mod 10)::l))\nelse ( \n[] )\nin\ndigOfIntHelper n []", "out": "", "min": "\nlet digitsOfInt n =\n  let rec digOfIntHelper n l =\n    if n > 0\n    then\n      match n > 9 with\n      | false  -> n :: l\n      | true  -> digOfIntHelper (n / 10) ((n mod 10) :: l)\n    else [] in\n  digOfIntHelper n [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "out": "", "min": "\nlet rec sumList xs = match xs with | h::t -> h + (sumList t) | [] -> 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =  \nlet rec digOfIntHelper n l = \nif (n > 0)\nthen (\nif (n > 9)\nthen (\ndigOfIntHelper (n / 10) ((n mod 10)::l) )\nelse (\nn :: l ) )\nelse ( \n[] )\nin\ndigOfIntHelper n []", "out": "", "min": "\nlet digitsOfInt n =\n  let rec digOfIntHelper n l =\n    if n > 0\n    then\n      (if n > 9 then digOfIntHelper (n / 10) ((n mod 10) :: l) else n :: l)\n    else [] in\n  digOfIntHelper n [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digits n = digitsOfInt (abs n)", "out": "", "min": "\nlet digitsOfInt n =\n  let rec digOfIntHelper n l =\n    if n > 0\n    then\n      (if n > 9 then digOfIntHelper (n / 10) ((n mod 10) :: l) else n :: l)\n    else [] in\n  digOfIntHelper n [];;\n\nlet digits n = digitsOfInt (abs n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = \nmatch w with\n| []    -> \n(match listReverse(w) with\n| []  -> true\n| _   -> false)\n| h::t  ->\n(match listReverse(w) with\n| []      -> true\n| h2::t2  -> if (h2 = h1)\nthen (\npalindrome t )\nelse (\nfalse ) )", "out": "Characters 180-182:\n  | h2::t2  -> if (h2 = h1)\n                        ^^\nError: Unbound value h1\n", "min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet palindrome w =\n  match w with\n  | [] -> (match listReverse w with | [] -> true | _ -> false)\n  | h::t ->\n      (match listReverse w with\n       | [] -> true\n       | h2::t2 -> if h2 = h1 then palindrome t else false);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = \nmatch w with\n| []    -> \n(match listReverse(w) with\n| []  -> true\n| _   -> false)\n| h::t  ->\n(match listReverse(w) with\n| []      -> true\n| h2::t2  -> if (h2 = h)\nthen (\npalindrome t )\nelse (\nfalse ) )", "out": "Characters 190-200:\n  palindrome t )\n  ^^^^^^^^^^\nError: Unbound value palindrome\n", "min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet palindrome w =\n  match w with\n  | [] -> (match listReverse w with | [] -> true | _ -> false)\n  | h::t ->\n      (match listReverse w with\n       | [] -> true\n       | h2::t2 -> if h2 = h then palindrome t else false);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec palindrome w = \nmatch w with\n| []    -> \n(match listReverse(w) with\n| []  -> true\n| _   -> false)\n| h::t  ->\n(match listReverse(w) with\n| []      -> true\n| h2::t2  -> if (h2 = h)\nthen (\npalindrome t )\nelse (\nfalse ) )", "out": "", "min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec palindrome w =\n  match w with\n  | [] -> (match listReverse w with | [] -> true | _ -> false)\n  | h::t ->\n      (match listReverse w with\n       | [] -> true\n       | h2::t2 -> if h2 = h then palindrome t else false);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec palindrome w = \nmatch w with\n| []    -> \n(match listReverse(w) with\n| []  -> true\n| _   -> false)\n| h::t  ->\n(match listReverse(w) with\n| []      -> true\n| h2::t2  -> if (h2 = h)\nthen (\npalindrome t )\nelse (\nfalse ) )", "out": "", "min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec palindrome w =\n  match w with\n  | [] -> (match listReverse w with | [] -> true | _ -> false)\n  | h::t ->\n      (match listReverse w with\n       | [] -> true\n       | h2::t2 -> if h2 = h then palindrome t else false);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = palind (explode w)", "out": "Characters 19-25:\n  let palindrome w = palind (explode w);;\n                     ^^^^^^\nError: Unbound value palind\n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w = palind (explode w);;\n", "type": "scope"}, {"in": "let rec palind w = \nmatch w with\n| []    -> \n(match listReverse(w) with\n| []  -> true\n| _   -> false)\n| h::t  ->\n(match listReverse(w) with\n| []      -> true\n| h2::t2  -> if (h2 = h)\nthen (\npalind t )\nelse (\nfalse ) )", "out": "", "min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec palind w =\n  match w with\n  | [] -> (match listReverse w with | [] -> true | _ -> false)\n  | h::t ->\n      (match listReverse w with\n       | [] -> true\n       | h2::t2 -> if h2 = h then palind t else false);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec palind w = \nmatch w with\n| []    -> \n(match listReverse(w) with\n| []  -> true\n| _   -> false)\n| h::t  ->\n(match listReverse(w) with\n| []      -> true\n| h2::t2  -> if (h2 = h)\nthen (\npalind t )\nelse (\nfalse ) )", "out": "", "min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec palind w =\n  match w with\n  | [] -> (match listReverse w with | [] -> true | _ -> false)\n  | h::t ->\n      (match listReverse w with\n       | [] -> true\n       | h2::t2 -> if h2 = h then palind t else false);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec palind w = \nmatch w with\n| []    -> true\n| h::t  ->\n(match listReverse(w) with\n| []      -> true\n| h2::t2  -> if (h2 = h)\nthen (\npalind t )\nelse (\nfalse ) )", "out": "", "min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec palind w =\n  match w with\n  | [] -> true\n  | h::t ->\n      (match listReverse w with\n       | [] -> true\n       | h2::t2 -> if h2 = h then palind t else false);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec palind w = \nmatch w with\n| []    -> true\n| h::t  ->\n(match listReverse(w) with\n| []      -> false\n| h2::t2  -> if (h2 = h)\nthen (\npalind t )\nelse (\nfalse ) )", "out": "", "min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec palind w =\n  match w with\n  | [] -> true\n  | h::t ->\n      (match listReverse w with\n       | [] -> false\n       | h2::t2 -> if h2 = h then palind t else false);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "out": "", "min": "\nlet rec sumList xs = match xs with | h::t -> h + (sumList t) | [] -> 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec palind w = \nmatch w with\n| []    -> true\n| h::t  ->\n(match listReverse(w) with\n| []      -> false\n| h2::t2  -> if (h2 = h)\nthen (\npalind t )\nelse (\ntrue ) )", "out": "", "min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec palind w =\n  match w with\n  | [] -> true\n  | h::t ->\n      (match listReverse w with\n       | [] -> false\n       | h2::t2 -> if h2 = h then palind t else true);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec palind w = \nmatch w with\n| []    -> true\n| h::t  ->\n(match listReverse(w) with\n| []      -> false\n| h2::t2  -> if (h2 = h)\nthen (\npalind t )\nelse (\nfalse ) )", "out": "", "min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec palind w =\n  match w with\n  | [] -> true\n  | h::t ->\n      (match listReverse w with\n       | [] -> false\n       | h2::t2 -> if h2 = h then palind t else false);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec palind w = \nmatch w with\n| []    -> true\n| h::t  ->\n(match listReverse(w) with\n| []      -> false\n| h2::t2  -> if (h2 = h)\nthen (\npalind t2 )\nelse (\nfalse ) )", "out": "", "min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec palind w =\n  match w with\n  | [] -> true\n  | h::t ->\n      (match listReverse w with\n       | [] -> false\n       | h2::t2 -> if h2 = h then palind t2 else false);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec palind w = \nmatch w with\n| []    -> true\n| h::t  -> w = (listReverse w)", "out": "", "min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec palind w = match w with | [] -> true | h::t -> w = (listReverse w);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = palind (explode w)", "out": "", "min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec palind w = match w with | [] -> true | h::t -> w = (listReverse w);;\n\nlet palindrome w = palind (explode w);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec palind w = \nmatch w with\n| []    -> true\n| h::t  -> w = (listReverse w)", "out": "", "min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec palind w = match w with | [] -> true | h::t -> w = (listReverse w);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "out": "", "min": "\nlet rec sumList xs = match xs with | h::t -> h + (sumList t) | [] -> 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l =\nlet rec reverseHelper l rl = \nmatch l with\n| []    -> rl\n| h::t  -> reverseHelper t ( h::rl ) \nin\nreverseHelper l []", "out": "", "min": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = lReverse (l, [])", "out": "Error: Unbound value lReverse\nHint: Did you mean listReverse?\nError: Unbound value lReverse\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 20-28:\n  let listReverse l = lReverse (l, []);;\n                      ^^^^^^^^\nError: Unbound value lReverse\nHint: Did you mean listReverse?\n", "min": "\nlet listReverse l = lReverse (l, []);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = lReverse (l, [])", "out": "", "min": "\nlet rec lReverse (l,rl) =\n  match l with | [] -> rl | h::t -> lReverse (t, (h :: rl));;\n\nlet listReverse l = lReverse (l, []);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "out": "", "min": "\nlet rec sumList xs = match xs with | h::t -> h + (sumList t) | [] -> 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| h::t  -> h + sumList t\n| []    -> 0", "out": "", "min": "\nlet rec sumList xs = match xs with | h::t -> h + (sumList t) | [] -> 0;;\n", "type": ""}]}
