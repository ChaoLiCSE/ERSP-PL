{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n[] -> 0\n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n[] -> 0\n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n / 10 = 0 then n else\ndigitalRoot ( sumList ( digits n ) )", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec loop n rem =\n       if n = 0 then rem else loop (n / 10) ((n mod 10) :: rem) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  if (n / 10) = 0 then n else digitalRoot (sumList (digits n));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n =\nif n / 10 = 0 then 0 else\n1 + additivePersistence ( sumList ( digits ( n ) ) )", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec loop n rem =\n       if n = 0 then rem else loop (n / 10) ((n mod 10) :: rem) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n =\nif n / 10 = 0 then 0 else\n1 + additivePersistence ( sumList ( digits ( n ) ) )", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec loop n rem =\n       if n = 0 then rem else loop (n / 10) ((n mod 10) :: rem) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let listReverse l = \nlet rec rev l2 l3 =\nmatch l3 with\n| [] -> l2\n| h::t -> rev ( h::l2 ) t in\nrev [] l", "min": "\nlet listReverse l =\n  let rec rev l2 l3 = match l3 with | [] -> l2 | h::t -> rev (h :: l2) t in\n  rev [] l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n[] -> 0\n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n[] -> 0\n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let listReverse l = \nlet rec rev l2 l3 =\nmatch l3 with\n| [] -> l2\n| h::t -> rev ( h::l2 ) t in\nrev [] l", "min": "\nlet listReverse l =\n  let rec rev l2 l3 = match l3 with | [] -> l2 | h::t -> rev (h :: l2) t in\n  rev [] l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs =\nmatch xs with\n[] -> 0\n| h::t -> h + sumList t", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "out": ""}]}
