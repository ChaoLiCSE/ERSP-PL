{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = x * x in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs = let f a x = x * x in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let sqsum xs = \nlet f a x = x * x in\nlet base = a in\nList.fold_left f base xs", "min": "\nlet sqsum xs = let f a x = x * x in let base = a in List.fold_left f base xs;;\n", "out": "Characters 48-49:\n  let base = a in\n             ^\nError: Unbound value a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = x * x in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs = let f a x = x * x in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let sqsum xs = \nlet f a x = base + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = base + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": "Characters 28-32:\n  let f a x = base + (x * x) in\n              ^^^^\nError: Unbound value base\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let sqsum xs = \nlet f a x = f base (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = f base (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": "Characters 28-29:\n  let f a x = f base (x * x) in\n              ^\nError: Unbound value f\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = (x * x) + a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = a in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = a in List.fold_left f base xs;;\n", "out": "Characters 54-55:\n  let base = a in\n             ^\nError: Unbound value a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\n(* Should this be able to hand strings or other types? *)\nlet base = 0 in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x f in\n(* Should this be able to hand strings or other types? *)\nlet base = 0 in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x f in let base = 0 in List.fold_left f base fs;;\n", "out": "Characters 29-30:\n  let f a x = x f in\n                ^\nError: Unbound value f\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\n(* Should this be able to hand strings or other types? *)\nlet base = 0 in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x a in\n(* Should this be able to hand strings or other types? *)\nlet base = x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = x in List.fold_left f base fs;;\n", "out": "Characters 46-47:\n  let base = x in\n             ^\nError: Unbound value x\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = x in List.fold_left f base fs;;\n", "out": "Characters 45-46:\n  let base = x in\n             ^\nError: Unbound value x\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = x in List.fold_left f base fs;;\n", "out": "Characters 45-46:\n  let base = x in\n             ^\nError: Unbound value x\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x a in\nlet base = base in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = base in List.fold_left f base fs;;\n", "out": "Characters 45-49:\n  let base = base in\n             ^^^^\nError: Unbound value base\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = pipe in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n\nlet pipe fs = let f a x = x a in let base = pipe in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let hi = pipe [] 3", "min": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n\nlet hi = pipe [] 3;;\n", "out": "Characters 9-13:\n  let hi = pipe [] 3;;\n           ^^^^\nError: This function has type (int -> int) list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ h  in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ h) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ h  in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ h) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h ^ sep ^ a  in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (sep ^ a) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x ^ sep ^ a  in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ (sep ^ a) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = [] in\nlet l = sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = [] in let l = sl in List.fold_left f base l;;\n", "out": "Characters 142-146:\n  List.fold_left f base l;;\n                   ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type string\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = h in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = \"\" in\nlet l = h :: t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = h :: t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l = \nList.map (sepConcat (\"; \"))", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"; \");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let stringOfList f l = \nList.map sepConcat (\"; \")", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat \"; \";;\n", "out": "Characters 43-49:\n  List.map sepConcat (\"; \");;\n                     ^^^^^^\nError: This expression has type string but an expression was expected of type\n         string list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let stringOfList f l = \nList.map sepConcat (\"; \" l)", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat (\"; \" l);;\n", "out": "Characters 44-48:\n  List.map sepConcat (\"; \" l);;\n                      ^^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let stringOfList f l = \nList.map sepConcat \"; \" l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat \"; \" l;;\n", "out": "Characters 24-32:\n  List.map sepConcat \"; \" l;;\n  ^^^^^^^^\nError: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l = \nList.map (sepConcat \"; \") l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"; \") l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let stringOfList f l = \nList.map (sepConcat \"; \") l l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"; \") l l;;\n", "out": "Characters 24-32:\n  List.map (sepConcat \"; \") l l;;\n  ^^^^^^^^\nError: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let stringOfList f l = \nList.map (sepConcat \"; \" l) l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"; \" l) l;;\n", "out": "Characters 33-51:\n  List.map (sepConcat \"; \" l) l;;\n           ^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let stringOfList f l = \nList.map (sepConcat (\"; \" l)) l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat (\"; \" l)) l;;\n", "out": "Characters 45-49:\n  List.map (sepConcat (\"; \" l)) l;;\n                       ^^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let stringOfList f l = \nList.map (sepConcat (\"; \" l))", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat (\"; \" l));;\n", "out": "Characters 45-49:\n  List.map (sepConcat (\"; \" l));;\n                       ^^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let stringOfList f l = \nList.map (sepConcat \"; \" l)", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"; \" l);;\n", "out": "Characters 33-51:\n  List.map (sepConcat \"; \" l);;\n           ^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let stringOfList f l = \nsepConcat \"; \" List.map f l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" List.map f l;;\n", "out": "Characters 24-33:\n  sepConcat \"; \" List.map f l;;\n  ^^^^^^^^^\nError: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l = \nsepConcat \"; \" (List.map f l)", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \"; \" (List.map f l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let stringOfList f l = \n\"[\" ^ sepConcat \"; \" (List.map f l) \"]\"", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l) \"]\");;\n", "out": "Characters 30-39:\n  \"[\" ^ sepConcat \"; \" (List.map f l) \"]\";;\n        ^^^^^^^^^\nError: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l = \n\"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = x in List.fold_left f base fs;;\n", "out": "Characters 45-46:\n  let base = x in\n             ^\nError: Unbound value x\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n", "out": "Characters 45-46:\n  let base = a in\n             ^\nError: Unbound value a\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fs in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "out": "Characters 73-75:\n  List.fold_left f base fs;;\n                        ^^\nError: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = [] in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = [] in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = () in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = () in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs\n\npipe [] 3", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = x a in let base x = x in List.fold_left f base fs pipe [] 3;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs\n\npipe [] 3", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = x a in let base x = x in List.fold_left f base fs pipe [] 3;;\n\nlet pipe fs =\n  let f a x = x a in let base x = x in List.fold_left f base fs pipe [] 3;;\n", "out": "Characters 85-89:\n  pipe [] 3;;\n  ^^^^\nError: This expression has type\n         (((((int -> int) -> int -> int) list -> int -> int) ->\n           ((int -> int) -> int -> int) list -> int -> int) ->\n          (((int -> int) -> int -> int) list -> int -> int) ->\n          ((int -> int) -> int -> int) list -> int -> int)\n         list -> int\n       but an expression was expected of type\n         (((((int -> int) -> int -> int) list -> int -> int) ->\n           ((int -> int) -> int -> int) list -> int -> int) ->\n          (((int -> int) -> int -> int) list -> int -> int) ->\n          ((int -> int) -> int -> int) list -> int -> int)\n         list -> 'a -> 'b\n       Type int is not compatible with type 'a -> 'b \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs\n\npipe [] 3", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = x a in let base x = x in List.fold_left f base fs pipe [] 3;;\n\nlet pipe fs =\n  let f a x = x a in let base x = x in List.fold_left f base fs pipe [] 3;;\n", "out": "Characters 85-89:\n  pipe [] 3;;\n  ^^^^\nError: This expression has type\n         (((((int -> int) -> int -> int) list -> int -> int) ->\n           ((int -> int) -> int -> int) list -> int -> int) ->\n          (((int -> int) -> int -> int) list -> int -> int) ->\n          ((int -> int) -> int -> int) list -> int -> int)\n         list -> int\n       but an expression was expected of type\n         (((((int -> int) -> int -> int) list -> int -> int) ->\n           ((int -> int) -> int -> int) list -> int -> int) ->\n          (((int -> int) -> int -> int) list -> int -> int) ->\n          ((int -> int) -> int -> int) list -> int -> int)\n         list -> 'a -> 'b\n       Type int is not compatible with type 'a -> 'b \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun ee -> ee in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base ee = ee in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = function e -> e in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = x a in let base = function | e -> e in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = [fun x -> x] in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = x a in let base = [(fun x  -> x)] in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = [] in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = [] in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = [] in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base = [] in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = a x in\nlet base = [] in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a x in let base = [] in List.fold_left f base fs;;\n", "out": "Characters 66-67:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x (a) in\nlet base = [] in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = [] in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = [] in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = [] in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = f in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fs in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "out": "Characters 73-75:\n  List.fold_left f base fs;;\n                        ^^\nError: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x a in\nlet base = base in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = base in List.fold_left f base fs;;\n", "out": "Characters 45-49:\n  let base = base in\n             ^^^^\nError: Unbound value base\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x a in\nlet base = base' in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = base' in List.fold_left f base fs;;\n", "out": "Characters 45-50:\n  let base = base' in\n             ^^^^^\nError: Unbound value base'\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = 3 in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = 3 in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  Nil in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = Nil in List.fold_left f base fs;;\n", "out": "Characters 46-49:\n  let base =  Nil in\n              ^^^\nError: Unbound constructor Nil\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x (a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x (a) in\nlet base = (fun x -> x) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x (a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 74-75:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = fun x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x x = a in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 81-82:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = fun x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x x = a in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 81-82:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun a -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = fun a -> a in\nlet base = fun x -> a in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x a = a in let base x = a in List.fold_left f base fs;;\n", "out": "Characters 61-62:\n  let base = fun x -> a in\n                      ^\nError: Unbound value a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun a -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun a -> x in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x a = x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun a -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x a = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = fun x -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 83-84:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun x -> a x in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x x = a x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = fun x -> x x in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x x = x x in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 38-39:\n  let f a x = fun x -> x x in\n                         ^\nError: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = fun a -> x x in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x a = x x in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 38-39:\n  let f a x = fun a -> x x in\n                         ^\nError: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun x -> fun a -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x x a = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun x -> fun a -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x x a = a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = fun x -> fun a -> x in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x x a = x in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 92-96:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'b -> 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun x -> fun a -> x (a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x x a = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = fun a -> fun x -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 94-98:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun x a -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x x a = a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = fun x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x x = a in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 81-82:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun a -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun a a -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x a a = a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun x a -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x x a = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun x -> x in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x x = x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun a -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x a = a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = fun a x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x a x = a in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 85-89:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'b -> 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = fun a x -> a in\nlet base = 0 in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x a x = a in let base = 0 in List.fold_left f base fs;;\n", "out": "Characters 76-80:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type int but an expression was expected of type\n         'a -> 'b -> 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = fun x a -> a in\nlet base = 0 in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x x a = a in let base = 0 in List.fold_left f base fs;;\n", "out": "Characters 76-80:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type int but an expression was expected of type\n         'a -> 'b -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = 0 in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = fun x -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = b in List.fold_left f base fs;;\n", "out": "Characters 55-56:\n  let base = fun x -> b in\n                      ^\nError: Unbound value b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = let a = x in x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = let a = x in x a in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 41-44:\n  let f a x = let a = x in x(a) in\n                            ^^^\nError: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = let a = x in a(a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = let a = x in a a in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 41-44:\n  let f a x = let a = x in a(a) in\n                            ^^^\nError: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = let a = x in a(x) in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = let a = x in a x in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 41-44:\n  let f a x = let a = x in a(x) in\n                            ^^^\nError: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = let a = x in x(x) in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = let a = x in x x in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 41-44:\n  let f a x = let a = x in x(x) in\n                            ^^^\nError: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun c -> c in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base c = c in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun y -> y in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = fun x -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x x = a in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 81-82:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = fun x -> x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 84-85:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = fun x -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 83-84:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun x -> fun a -> x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x x a = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun a -> fun a -> x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x a a = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun a -> fun a -> a(x) in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x a a = a x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = fun a -> fun a -> a(a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x a a = a a in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 46-49:\n  let f a x = fun a -> fun a -> a(a) in\n                                 ^^^\nError: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = fun a -> fun a -> x(x) in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x a a = x x in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 46-49:\n  let f a x = fun a -> fun a -> x(x) in\n                                 ^^^\nError: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun a -> fun a -> x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x a a = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun a -> fun a -> x in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x a a = x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = fun a -> fun x -> f x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x a x = f x a in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 45-46:\n  let f a x = fun a -> fun x -> f x a in\n                                ^\nError: Unbound value f\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = fun a -> fun x -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 94-98:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = fun a -> fun x -> x (a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 96-100:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = fun x -> (x a)  in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 86-87:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = fun x -> (x a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 85-86:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = fun x -> (x (a)) in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 87-88:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x in\nlet base = a in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base = a in List.fold_left f base fs;;\n", "out": "Characters 43-44:\n  let base = a in\n             ^\nError: Unbound value a\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x in\nlet base = f x in \nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base = f x in List.fold_left f base fs;;\n", "out": "Characters 45-46:\n  let base = f x in \n               ^\nError: Unbound value x\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = fun a -> a in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base a = a in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = fun x -> fun a -> a in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base x a = a in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = (x) in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun x -> x in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x x = x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = x(x) in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x x in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 28-31:\n  let f a x = x(x) in\n               ^^^\nError: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = a(x) in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 75-76:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = fun (x, a) -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x (x,a) = x a in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 90-94:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type ('a -> 'b) * 'a -> ('a -> 'b) * 'a\n       but an expression was expected of type ('a -> 'b) * 'a -> 'b\n       The type variable 'b occurs inside ('a -> 'b) * 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let pipe fs = \nlet f a x = fun (a, a) -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x (a,a) = x a in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 35-36:\n  let f a x = fun (a, a) -> x a in\n                      ^\nError: Variable a is bound several times in this matching\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = fun (a, x) -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x (a,x) = x a in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 90-94:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a * ('a -> 'b) -> 'a * ('a -> 'b)\n       but an expression was expected of type 'a * ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a * ('a -> 'b)\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let pipe fs = \nlet f a x = fun (x, x) -> x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x (x,x) = x a in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 35-36:\n  let f a x = fun (x, x) -> x a in\n                      ^\nError: Variable x is bound several times in this matching\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = fun (x, a) -> x x in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x (x,a) = x x in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 43-44:\n  let f a x = fun (x, a) -> x x in\n                              ^\nError: This expression has type 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = fun (x, a) -> a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x (x,a) = a in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 88-92:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a * 'b -> 'a * 'b\n       but an expression was expected of type 'a * 'b -> 'b\n       The type variable 'b occurs inside 'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = fun (x, a) -> x (a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x (x,a) = x a in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 92-96:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type ('a -> 'b) * 'a -> ('a -> 'b) * 'a\n       but an expression was expected of type ('a -> 'b) * 'a -> 'b\n       The type variable 'b occurs inside ('a -> 'b) * 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = fun (x, a) -> x(a) in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x (x,a) = x a in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 91-95:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type ('a -> 'b) * 'a -> ('a -> 'b) * 'a\n       but an expression was expected of type ('a -> 'b) * 'a -> 'b\n       The type variable 'b occurs inside ('a -> 'b) * 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec padZero l1 l2 = \n(clone 0 List.len l1 - l2)", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 = (clone 0 List.len l1) - l2;;\n", "out": "Characters 26-31:\n  (clone 0 List.len l1 - l2);;\n   ^^^^^\nError: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec padZero l1 l2 = \n(clone 0 (List.len l1 - l2)) @ smaller", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 = (clone 0 ((List.len l1) - l2)) @ smaller;;\n", "out": "Characters 35-43:\n  (clone 0 (List.len l1 - l2)) @ smaller;;\n            ^^^^^^^^\nError: Unbound value List.len\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec padZero l1 l2 = \n(clone 0 (List.length l1 - l2)) @ smaller", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 = (clone 0 ((List.length l1) - l2)) @ smaller;;\n", "out": "Characters 59-66:\n  (clone 0 (List.length l1 - l2)) @ smaller;;\n                                    ^^^^^^^\nError: Unbound value smaller\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec padZero l1 l2 = \n(clone 0 (List.length l1 - l2)) @ l2", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 = (clone 0 ((List.length l1) - l2)) @ l2;;\n", "out": "Characters 59-61:\n  (clone 0 (List.length l1 - l2)) @ l2;;\n                                    ^^\nError: This expression has type int but an expression was expected of type\n         int list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec padZero l1 l2 = \n(clone 0 (List.length l1 - List.length l2)) @ l2", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 = (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec padZero l1 l2 = \n(clone 0 (List.length l1 - List.length l2)) @ l2", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 = (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec padZero l1 l2 = \n(l1, (clone 0 (List.length l1 - List.length l2)) @ l2)", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec padZero l1 l2 = \nif List.length l1 > List.length l2\nthen (l1, (clone 0 (List.length l1 - List.length l2)) @ l2)\nelse (clone 0 (List.length l2 - List.length l1)) @ l1, l2", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec padZero l1 l2 = \nif List.length l1 > List.length l2\nthen (l1, (clone 0 (List.length l1 - List.length l2)) @ l2)\nelse (clone 0 (List.length l2 - List.length l1) @ l1, l2)", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l with\n[] -> []\n| h::t ->\nif h = 0\nthen removeZero t\nelse t", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else t;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l with\n[] -> []\n| h::t ->\nif h = 0\nthen removeZero t\nelse l", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = let x' = x' (x a) in x' x a in \nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = let x' = x' (x a) in x' x a in\n  let base x = x in List.fold_left f base fs;;\n", "out": "Characters 36-38:\n  let f a x = let x' = x' (x a) in x' x a in \n                       ^^\nError: Unbound value x'\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun x' -> a x in \nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x x' = a x in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = fun x' -> x' (a x) in \nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x x' = x' (a x) in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 92-96:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type ('a -> 'a) -> 'a -> 'a\n       but an expression was expected of type ('a -> 'a) -> 'a\n       The type variable 'a occurs inside 'a -> 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = fun x' -> x' (x a) in \nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x x' = x' (x a) in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 92-96:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun x' -> x (a x') in \nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x x' = x (a x') in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec padZero l1 l2 = \nif List.length l1 > List.length l2\nthen (l1, (clone 0 (List.length l1 - List.length l2)) @ l2)\nelse (clone 0 (List.length l2 - List.length l1) @ l1, l2)\n\npadZero [9;9] [8;8;8]", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) padZero\n      [9; 9] [8; 8; 8];;\n", "out": "Characters 125-177:\n  else (clone 0 (List.length l2 - List.length l1) @ l1, l2)\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec padZero l1 l2 = \nif List.length l1 > List.length l2\nthen (l1, (clone 0 (List.length l1 - List.length l2)) @ l2)\nelse (clone 0 (List.length l2 - List.length l1) @ l1, l2)", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 216-231:\n  removeZero (add (padZero l1 l2));;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type ('a -> 'b list) * 'a\n       Type int list is not compatible with type 'a -> 'b list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = (l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 218-233:\n  removeZero (add (padZero l1 l2));;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type ('a -> 'b list) * 'a\n       Type int list is not compatible with type 'a -> 'b list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 187-191:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = (0, 0) in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = (0, 0) in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 212-233:\n  removeZero (add (padZero l1 l2));;\n             ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [0] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [0] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 160-186:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 159-185:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [a] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [a] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 96-97:\n  let base = [a] in\n              ^\nError: Unbound value a\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 159-185:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [0, 0] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [(0, 0)] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 163-189:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type (int * int) list\n       but an expression was expected of type 'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = [(), ()] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [((), ())] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 165-191:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type (unit * unit) list\n       but an expression was expected of type 'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base =  res in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = res in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 96-99:\n  let base =  res in\n              ^^^\nError: Unbound value res\nHint: Did you mean ref?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base =  [0], [0]in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([0], [0]) in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base =  [0], [0] in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([0], [0]) in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base =  [0], [0] in\nlet args = l1, l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([0], [0]) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 166-170:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base =  [0], [0] in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([0], [0]) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 168-172:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base =  [0], [0] in\nlet args = List.rev (List.hd l1) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([0], [0]) in\n    let args = List.rev (List.hd l1) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 213-228:\n  removeZero (add (padZero l1 l2));;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type 'a list list * 'b\n       Type int is not compatible with type 'a list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base =  [0], [0] in\nlet args = List.rev (List.hd l1) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([0], [0]) in\n    let args = List.rev (List.hd l1) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 213-228:\n  removeZero (add (padZero l1 l2));;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type 'a list list * 'b\n       Type int is not compatible with type 'a list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base =  [0], [0] in\nlet args = List.rev (List.hd l1), List.rev (List.hd l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([0], [0]) in\n    let args = ((List.rev (List.hd l1)), (List.rev (List.hd l2))) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 204-208:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type 'a list * 'b list\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base =  [0], [0] in\nlet args = [List.rev (List.hd l1), List.rev (List.hd l2)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([0], [0]) in\n    let args = [((List.rev (List.hd l1)), (List.rev (List.hd l2)))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 238-253:\n  removeZero (add (padZero l1 l2));;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type 'a list list * 'b list list\n       Type int is not compatible with type 'a list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base =  [0], [0] in\nlet args = [List.rev (List.hd l1)], [List.rev (List.hd l2)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([0], [0]) in\n    let args = ([List.rev (List.hd l1)], [List.rev (List.hd l2)]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 208-212:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type 'a list list * 'b list list\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base =  [0], [0] in\nlet args = [List.rev (List.hd (l1))], [List.rev (List.hd l2)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([0], [0]) in\n    let args = ([List.rev (List.hd l1)], [List.rev (List.hd l2)]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 210-214:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type 'a list list * 'b list list\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base =  [0], [0] in\nlet args = [List.rev (List.hd (l1))], [List.rev (List.hd (l2))] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([0], [0]) in\n    let args = ([List.rev (List.hd l1)], [List.rev (List.hd l2)]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 212-216:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type 'a list list * 'b list list\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base =  [0], [0] in\nlet args = List.rev (List.hd (l1)), List.rev (List.hd (l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([0], [0]) in\n    let args = ((List.rev (List.hd l1)), (List.rev (List.hd l2))) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 208-212:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type 'a list * 'b list\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = fun x' x a -> x (a x') in \nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x x' x a = x (a x') in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 96-100:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type\n         'a -> ('b -> 'c) -> ('a -> 'b) -> 'c\n       The type variable 'a occurs inside ('b -> 'c) -> ('a -> 'b) -> 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun x'-> x (a x') in \nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x x' = x (a x') in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = fun x' a-> x (a x') in \nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x x' a = x (a x') in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 93-97:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'c\n       The type variable 'a occurs inside ('a -> 'b) -> 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun x'-> x (a x') in \nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x x' = x (a x') in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun x' -> x (a x') in \nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x x' = x (a x') in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x  in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun x' -> x (a x') in \nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x x' = x (a x') in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10, (sum % 10) :: a)\nin\nlet base =  0, [0] in\nlet args = List.rev (List.hd (l1)), List.rev (List.hd (l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), ((sum % 10) :: a)) in\n    let base = (0, [0]) in\n    let args = ((List.rev (List.hd l1)), (List.rev (List.hd l2))) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 119-120:\n  (sum / 10, (sum % 10) :: a)\n                  ^\nError: Unbound value %\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10, (sum mod 10) :: a)\nin\nlet base =  0, [0] in\nlet args = List.rev (List.hd (l1)), List.rev (List.hd (l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), ((sum mod 10) :: a)) in\n    let base = (0, [0]) in\n    let args = ((List.rev (List.hd l1)), (List.rev (List.hd l2))) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 251-252:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type\n         int list -> int * int -> int -> int * int list\n       but an expression was expected of type\n         int list -> int * int -> int list\n       Type int -> int * int list is not compatible with type int list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10, (sum mod 10) :: a)\nin\nlet base =  0, [0] in\nlet args = List.rev (List.combine (l1, l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), ((sum mod 10) :: a)) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine (l1, l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 192-200:\n  let args = List.rev (List.combine (l1, l2)) in\n                                    ^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10, (sum mod 10) :: a)\nin\nlet base =  0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), ((sum mod 10) :: a)) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 232-233:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type\n         int list -> int * int -> int -> int * int list\n       but an expression was expected of type\n         int list -> int * int -> int list\n       Type int -> int * int list is not compatible with type int list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10, (sum mod 10) :: a)\nin\nlet base =  0 [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), ((sum mod 10) :: a)) in\n    let base = 0 [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 148-149:\n  let base =  0 [0] in\n              ^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10, (sum mod 10) :: a)\nin\nlet base =  0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), ((sum mod 10) :: a)) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 232-233:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type\n         int list -> int * int -> int -> int * int list\n       but an expression was expected of type\n         int list -> int * int -> int list\n       Type int -> int * int list is not compatible with type int list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10, (sum mod 10) :: a)\nin\nlet base =  (0, [0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), ((sum mod 10) :: a)) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 234-235:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type\n         int list -> int * int -> int -> int * int list\n       but an expression was expected of type\n         int list -> int * int -> int list\n       Type int -> int * int list is not compatible with type int list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10, (sum mod 10) :: a)\nin\nlet base = [0], [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), ((sum mod 10) :: a)) in\n    let base = ([0], [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 233-234:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type\n         int list -> int * int -> int -> int * int list\n       but an expression was expected of type\n         int list -> int * int -> int list\n       Type int -> int * int list is not compatible with type int list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10, ((sum mod 10) :: a))\nin\nlet base = 0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), ((sum mod 10) :: a)) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 233-234:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type\n         int list -> int * int -> int -> int * int list\n       but an expression was expected of type\n         int list -> int * int -> int list\n       Type int -> int * int list is not compatible with type int list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10, (sum mod 10) :: a)\nin\nlet base = 0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), ((sum mod 10) :: a)) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 231-232:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type\n         int list -> int * int -> int -> int * int list\n       but an expression was expected of type\n         int list -> int * int -> int list\n       Type int -> int * int list is not compatible with type int list \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(x (sum / 10) :: (sum mod 10) :: a)\nin\nlet base = 0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in (x (sum / 10)) :: (sum mod 10) :: a in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 104-105:\n  (x (sum / 10) :: (sum mod 10) :: a)\n   ^\nError: This expression has type int * int\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\nx (sum / 10) :: (sum mod 10) :: a\nin\nlet base = 0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in (x (sum / 10)) :: (sum mod 10) :: a in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 103-104:\n  x (sum / 10) :: (sum mod 10) :: a\n  ^\nError: This expression has type int * int\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10) :: (sum mod 10) :: a\nin\nlet base = 0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in (sum / 10) :: (sum mod 10) :: a in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 233-234:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int list -> int * int -> int -> int list\n       but an expression was expected of type\n         int list -> int * int -> int list\n       Type int -> int list is not compatible with type int list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10), x :: (sum mod 10) :: a\nin\nlet base = 0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), (x :: (sum mod 10) :: a)) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 120-132:\n  (sum / 10), x :: (sum mod 10) :: a\n                   ^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int * int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n(sum / 10), (sum mod 10) :: a\nin\nlet base = 0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), ((sum mod 10) :: a)) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 231-232:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type\n         int list -> int * int -> int -> int * int list\n       but an expression was expected of type\n         int list -> int * int -> int list\n       Type int -> int * int list is not compatible with type int list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n((sum / 10), (sum mod 10)) :: a\nin\nlet base = 0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), (sum mod 10)) :: a in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 233-234:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type\n         (int * int) list -> int * int -> int -> (int * int) list\n       but an expression was expected of type\n         (int * int) list -> int * int -> (int * int) list\n       Type int -> (int * int) list is not compatible with type\n         (int * int) list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n((sum / 10) (sum mod 10)) :: a\nin\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10) (sum mod 10)) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 104-114:\n  ((sum / 10) (sum mod 10)) :: a\n   ^^^^^^^^^^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n((sum / 10) :: (sum mod 10)) :: a\nin\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10) :: (sum mod 10)) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 118-130:\n  ((sum / 10) :: (sum mod 10)) :: a\n                 ^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\n((sum / 10) :: ((sum mod 10)) :: a)\nin\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in (sum / 10) :: (sum mod 10) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 233-234:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int list -> int * int -> int -> int list\n       but an expression was expected of type\n         int list -> int * int -> int list\n       Type int -> int list is not compatible with type int list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\nList.split ( ((sum / 10) :: ((sum mod 10)) :: a) )\nin\nlet base = 0, [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in List.split ((sum / 10) :: (sum mod 10) :: a) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 117-127:\n  List.split ( ((sum / 10) :: ((sum mod 10)) :: a) )\n                ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\nList.split ( ((sum / 10), ((sum mod 10)) :: a) )\nin\nlet base = 0, [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in List.split ((sum / 10), ((sum mod 10) :: a)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 114-151:\n  List.split ( ((sum / 10), ((sum mod 10)) :: a) )\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\nList.split ( ((sum / 10), (sum mod 10)) :: a )\nin\nlet base = 0, [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in List.split (((sum / 10), (sum mod 10)) :: a) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 247-248:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type\n         (int * int) list -> int * int -> int -> int list * int list\n       but an expression was expected of type\n         (int * int) list -> int * int -> (int * int) list\n       Type int -> int list * int list is not compatible with type\n         (int * int) list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \nlet sum = c + s + t in\nList.split ( (sum / 10), (sum mod 10) :: a )\nin\nlet base = 0, [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in List.split ((sum / 10), ((sum mod 10) :: a)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 114-147:\n  List.split ( (sum / 10), (sum mod 10) :: a )\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun x' -> x (a x') in \nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x x' = x (a x') in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = fun c -> let (s, t) = x in \n( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a\nin\nlet base = 0, [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in ((((c + s) + t) / 10), (((c + s) + t) mod 10)) :: a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 227-228:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type\n         (int * int) list -> int * int -> int -> (int * int) list\n       but an expression was expected of type\n         (int * int) list -> int * int -> (int * int) list\n       Type int -> (int * int) list is not compatible with type\n         (int * int) list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (s, t) = x in \n( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a\nin\nlet base = 0, [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet c = 3;;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (s,t) = x in ((((c + s) + t) / 10), (((c + s) + t) mod 10)) :: a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 220-224:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type int * 'a list\n       but an expression was expected of type (int * int) list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (s, t) = x in \n( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a\nin\nlet base = 0, [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet c = 3;;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (s,t) = x in ((((c + s) + t) / 10), (((c + s) + t) mod 10)) :: a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 220-224:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type int * 'a list\n       but an expression was expected of type (int * int) list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (s, t) = x in \n( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a\nin\nlet base = 0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet c = 3;;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (s,t) = x in ((((c + s) + t) / 10), (((c + s) + t) mod 10)) :: a in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 221-225:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type int * int list\n       but an expression was expected of type (int * int) list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (s, t) = x in \n( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a\nin\nlet base = [0, 0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet c = 3;;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (s,t) = x in ((((c + s) + t) / 10), (((c + s) + t) mod 10)) :: a in\n    let base = [(0, 0)] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 204-230:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type (int * int) list\n       but an expression was expected of type 'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a\nin\nlet base = 0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in ((((c + s) + t) / 10), (((c + s) + t) mod 10)) :: a in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 104-105:\n  ( ((c + s + t) / 10), ((c + s + t) mod 10) ) :: a\n              ^\nError: Unbound value t\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) ) :: a\nin\nlet base = 0, [0] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in ((((c + x') + x'') / 10), (((c + x') + x'') mod 10))\n        :: a in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 146-147:\n  ( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) ) :: a\n                                                        ^\nError: This expression has type int * 'a\n       but an expression was expected of type (int * int) list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) ) :: a\nin\nlet base = 0, [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in ((((c + x') + x'') / 10), (((c + x') + x'') mod 10))\n        :: a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 146-147:\n  ( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) ) :: a\n                                                        ^\nError: This expression has type int * 'a\n       but an expression was expected of type (int * int) list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) ) :: a\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in ((((c + x') + x'') / 10), (((c + x') + x'') mod 10))\n        :: a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 146-147:\n  ( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) ) :: a\n                                                        ^\nError: This expression has type int * 'a\n       but an expression was expected of type (int * int) list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n( ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s)\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, [0]) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (List.len s == List.len x)\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.len s) == (List.len x)\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 96-104:\n  if (List.len s == List.len x)\n      ^^^^^^^^\nError: Unbound value List.len\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (List.lenth s == List.length x)\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.lenth s) == (List.length x)\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 96-106:\n  if (List.lenth s == List.length x)\n      ^^^^^^^^^^\nError: Unbound value List.lenth\nHint: Did you mean length?\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (List.length s == List.length x)\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) == (List.length x)\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 125-126:\n  if (List.length s == List.length x)\n                                   ^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (List.length s = List.length x)\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = (List.length x)\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 124-125:\n  if (List.length s = List.length x)\n                                  ^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ((List.length s) = (List.length x))\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = (List.length x)\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 127-128:\n  if ((List.length s) = (List.length x))\n                                     ^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ((List.length s) = (List.length (x)))\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = (List.length x)\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 127-130:\n  if ((List.length s) = (List.length (x)))\n                                     ^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ((List.length a) = (List.length x))\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length a) = (List.length x)\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 109-110:\n  if ((List.length a) = (List.length x))\n                   ^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ((List.length s) = (List.length x))\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = (List.length x)\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 127-128:\n  if ((List.length s) = (List.length x))\n                                     ^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ((List.length x) = (List.length s))\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length x) = (List.length s)\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 109-110:\n  if ((List.length x) = (List.length s))\n                   ^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ((h :: t) x = [])\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if ((h :: t) x) = []\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 97-98:\n  if ((h :: t) x = [])\n       ^\nError: Unbound value h\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (x = [])\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if x = []\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 100-102:\n  if (x = [])\n          ^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (x = [(), ()])\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if x = [((), ())]\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 100-108:\n  if (x = [(), ()])\n          ^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (List.length x = 5)\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length x) = 5\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 108-109:\n  if (List.length x = 5)\n                  ^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (List.length a = 5)\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length a) = 5\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 108-109:\n  if (List.length a = 5)\n                  ^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (List.length s = 5)\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = 5\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 133-184:\n  ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (s = [])\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if s = []\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 122-173:\n  ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (s != [])\nthen c :: s\nelse \n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if s != []\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 123-174:\n  ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (s != [])\nthen c :: s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if s != []\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 122-173:\n  else ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (s = [])\nthen c :: s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if s = []\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 121-172:\n  else ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif (s)\nthen c :: s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if s\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 109-110:\n  then c :: s\n            ^\nError: This expression has type bool but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch s with\n| [] -> c :: s\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match s with\n      | [] -> c :: s\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 127-178:\n  | _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch s with\n| [] -> (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match s with\n      | [] -> c :: s\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 129-180:\n  | _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch s with\n| [] -> ((c + x' + x'') :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match s with\n      | [] -> ((c + x') + x'') :: s\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 142-193:\n  | _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch s with\n| [] -> ((c + x' + x'' + 0) :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match s with\n      | [] -> (((c + x') + x'') + 0) :: s\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 146-197:\n  | _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch s with\n| [] -> ((c + 0) :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match s with\n      | [] -> (c + 0) :: s\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 135-186:\n  | _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> ((c + 0) :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match (c, s) with\n      | (c,[]) -> (c + 0) :: s\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 145-196:\n  | _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> ((c) :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match (c, s) with\n      | (c,[]) -> c :: s\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 141-192:\n  | _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match (c, s) with\n      | (c,[]) -> c :: s\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 139-190:\n  | _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nmatch (c, s) with\n| (c, []) -> c, (c :: s)\n| _ -> ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match (c, s) with\n      | (c,[]) -> (c, (c :: s))\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\n((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = (List.length a) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = (List.length a)\n      then (c, (c :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 128-129:\n  if ( (List.length s) = (List.length a) )\n                                      ^\nError: This expression has type 'a * 'b list\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = (List.length x) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = (List.length x)\n      then (c, (c :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 128-129:\n  if ( (List.length s) = (List.length x) )\n                                      ^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length x) = (List.length x) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length x) = (List.length x)\n      then (c, (c :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 110-111:\n  if ( (List.length x) = (List.length x) )\n                    ^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = (List.length s) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = (List.length s)\n      then (c, (c :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = (List.length a) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = (List.length a)\n      then (c, (c :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 128-129:\n  if ( (List.length s) = (List.length a) )\n                                      ^\nError: This expression has type 'a * 'b list\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = (List.length l1) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = (List.length l1)\n      then (c, (c :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = (List.length l2) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = (List.length l2)\n      then (c, (c :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = (List.length l2 + 1) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l2) + 1)\n      then (c, (c :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = (List.length l1 + 1) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) + 1)\n      then (c, (c :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = ((List.length l1) + 1) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) + 1)\n      then (c, (c :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = ((List.length l1) - 1) )\nthen c, c::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, (c :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = ((List.length l1) - 1) )\nthen c, (c + x' + x'') mod 10 ::s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = ((List.length l1) - 1) )\nthen c, ((c + x' + x'') / 10) :: ((c + x' + x'') mod 10) :: s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\n\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (x', x'') = x in \nlet (c, s) = a in\nif ( (List.length s) = ((List.length l1) - 1) )\nthen c, ((c + x' + x'') / 10) :: ((c + x' + x'') mod 10) :: s\nelse ((c + x' + x'') / 10), ((c + x' + x'') mod 10) :: s\nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nif i > 0\nthen bigAdd l (mulByDigit (i - 1) l)\nelse bigAdd l [0]", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else bigAdd l [0];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nif i > 0\nthen bigAdd l (mulByDigit (i - 1) l)\nelse bigAdd [0] l", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else bigAdd [0] l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec mulByDigit i l = \nif i > 0\nthen bigAdd l (mulByDigit (i - 1) l)\nelse bigAdd [0]", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else bigAdd [0];;\n", "out": "Characters 77-87:\n  else bigAdd [0];;\n       ^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type int list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nif i > 0\nthen bigAdd l (mulByDigit (i - 1) l)\nelse [0]", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = (1, []) in\nlet args = (List.rev l2), l1 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = (1, []) in\n  let args = ((List.rev l2), l1) in\n  let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 155-159:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type 'a list * 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l') l') in\nlet base = (1, l1) in\nlet args = (List.rev l2), l1 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,l) = x in\n    let (i',l') = a in\n    match i with | [] -> l' | h::t -> bigAdd ((mulByDigit h l') l') in\n  let base = (1, l1) in\n  let args = ((List.rev l2), l1) in\n  let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 114-131:\n  | h :: t -> bigAdd( (mulByDigit h l') l') in\n                      ^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l'), l') in\nlet base = (1, l1) in\nlet args = (List.rev l2), l1 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,l) = x in\n    let (i',l') = a in\n    match i with | [] -> l' | h::t -> bigAdd ((mulByDigit h l'), l') in\n  let base = (1, l1) in\n  let args = ((List.rev l2), l1) in\n  let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 112-136:\n  | h :: t -> bigAdd( (mulByDigit h l'), l') in\n                    ^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l') l') in\nlet base = (1, l1) in\nlet args = (List.rev l2), l1 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,l) = x in\n    let (i',l') = a in\n    match i with | [] -> l' | h::t -> bigAdd ((mulByDigit h l') l') in\n  let base = (1, l1) in\n  let args = ((List.rev l2), l1) in\n  let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 114-131:\n  | h :: t -> bigAdd( (mulByDigit h l') l') in\n                      ^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i' with\n| [] -> l'\n| h :: t -> bigAdd( (mulByDigit h l') l') in\nlet base = (1, l1) in\nlet args = (List.rev l2), l1 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,l) = x in\n    let (i',l') = a in\n    match i' with | [] -> l' | h::t -> bigAdd ((mulByDigit h l') l') in\n  let base = (1, l1) in\n  let args = ((List.rev l2), l1) in\n  let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 115-132:\n  | h :: t -> bigAdd( (mulByDigit h l') l') in\n                      ^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \nlet f a x = let (i, l) = x in\nlet (i', l') = a in\nmatch i' with\n| [] -> l'\n| h :: t -> t, bigAdd( (mulByDigit h l') l') in\nlet base = (1, l1) in\nlet args = (List.rev l2), l1 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,l) = x in\n    let (i',l') = a in\n    match i' with | [] -> l' | h::t -> (t, (bigAdd ((mulByDigit h l') l'))) in\n  let base = (1, l1) in\n  let args = ((List.rev l2), l1) in\n  let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 132-134:\n  | h :: t -> t, bigAdd( (mulByDigit h l') l') in\n                                       ^^\nError: This expression has type int list * 'a\n       but an expression was expected of type int list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \nlet f a x = match x with\n| [] -> a\n| h :: t -> bigAdd( (mulByDigit h a) a) in\nlet base = (l1) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x = match x with | [] -> a | h::t -> bigAdd ((mulByDigit h a) a) in\n  let base = l1 in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 75-91:\n  | h :: t -> bigAdd( (mulByDigit h a) a) in\n                      ^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \nlet f a x = match x with\n| [] -> a\n| h :: t -> bigAdd( (mulByDigit (h a)) a) in\nlet base = (l1) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x = match x with | [] -> a | h::t -> bigAdd ((mulByDigit (h a)) a) in\n  let base = l1 in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 67-96:\n  | h :: t -> bigAdd( (mulByDigit (h a)) a) in\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \nlet f a x = match x with\n| [] -> a\n| h :: t -> bigAdd( (mulByDigit (h a)) a) in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x = match x with | [] -> a | h::t -> bigAdd ((mulByDigit (h a)) a) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 67-96:\n  | h :: t -> bigAdd( (mulByDigit (h a)) a) in\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> a'\n| h :: t -> bigAdd( (mulByDigit (h a')) a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> a' | h::t -> bigAdd ((mulByDigit (h a')) a') in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 90-121:\n  | h :: t -> bigAdd( (mulByDigit (h a')) a') in\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> a'\n| h :: t -> bigAdd( (mulByDigit (h l1')) a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> a' | h::t -> bigAdd ((mulByDigit (h l1')) a') in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 90-122:\n  | h :: t -> bigAdd( (mulByDigit (h l1')) a') in\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> a'\n| h :: t -> bigAdd( (mulByDigit (h, l1')) a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> a' | h::t -> bigAdd ((mulByDigit (h, l1')) a') in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 110-118:\n  | h :: t -> bigAdd( (mulByDigit (h, l1')) a') in\n                                  ^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> a'\n| h :: t -> bigAdd( (mulByDigit (h l1')) a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> a' | h::t -> bigAdd ((mulByDigit (h l1')) a') in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 90-122:\n  | h :: t -> bigAdd( (mulByDigit (h l1')) a') in\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> a'\n| h :: t -> bigAdd( (mulByDigit (h l1')) a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> a' | h::t -> bigAdd ((mulByDigit (h l1')) a') in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 90-122:\n  | h :: t -> bigAdd( (mulByDigit (h l1')) a') in\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> a'\n| h :: t -> bigAdd( mulByDigit (h l1') a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> a' | h::t -> bigAdd (mulByDigit (h l1') a') in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 90-120:\n  | h :: t -> bigAdd( mulByDigit (h l1') a') in\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> a'\n| h :: t -> bigAdd (mulByDigit (h l1')) a' in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> a' | h::t -> bigAdd (mulByDigit (h l1')) a' in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 97-117:\n  | h :: t -> bigAdd (mulByDigit (h l1')) a' in\n                     ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type int list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = \nif i > 0\nthen bigAdd l (mulByDigit (i - 1) l)\nelse [0]", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1, a')\n| h :: t -> bigAdd (mulByDigit (h l1')) a' in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> (l1, a') | h::t -> bigAdd (mulByDigit (h l1')) a' in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 103-123:\n  | h :: t -> bigAdd (mulByDigit (h l1')) a' in\n                     ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1, a')\n| h :: t -> bigAdd ((mulByDigit (h l1')) a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> (l1, a') | h::t -> bigAdd ((mulByDigit (h l1')) a') in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 96-128:\n  | h :: t -> bigAdd ((mulByDigit (h l1')) a') in\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type 'a * int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1, a')\n| h :: t -> bigAdd (mulByDigit (h l1') a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> (l1, a') | h::t -> bigAdd (mulByDigit (h l1') a') in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 96-126:\n  | h :: t -> bigAdd (mulByDigit (h l1') a') in\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type 'a * int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = x in\nmatch a with\n| [] -> (l1, a')\n| h :: t -> bigAdd (mulByDigit (h l1') a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = x in\n    match a with | [] -> (l1, a') | h::t -> bigAdd (mulByDigit (h l1') a') in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 96-126:\n  | h :: t -> bigAdd (mulByDigit (h l1') a') in\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type 'a * int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = x in\nmatch a with\n| [] -> (l1, a')\n| h :: t -> bigAdd (mulByDigit (h l1') a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = x in\n    match a with | [] -> (l1, a') | h::t -> bigAdd (mulByDigit (h l1') a') in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 96-126:\n  | h :: t -> bigAdd (mulByDigit (h l1') a') in\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type 'a * int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = x in\nmatch a with\n| [] -> (l1', a')\n| h :: t -> bigAdd (mulByDigit (h l1') a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = x in\n    match a with | [] -> (l1', a') | h::t -> bigAdd (mulByDigit (h l1') a') in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 97-127:\n  | h :: t -> bigAdd (mulByDigit (h l1') a') in\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type 'a * int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> bigAdd (mulByDigit (h l1') a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> (l1', a') | h::t -> bigAdd (mulByDigit (h l1') a') in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 97-127:\n  | h :: t -> bigAdd (mulByDigit (h l1') a') in\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type 'a * int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> bigAdd (mulByDigit (h l1') a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> (l1', a') | h::t -> bigAdd (mulByDigit (h l1') a') in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 97-127:\n  | h :: t -> bigAdd (mulByDigit (h l1') a') in\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type 'a * int list\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> bigAdd (mulByDigit h (l1') a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> (l1', a') | h::t -> bigAdd (mulByDigit h l1' a') in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 105-115:\n  | h :: t -> bigAdd (mulByDigit h (l1') a') in\n                      ^^^^^^^^^^\nError: This function has type int -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> li', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with\n    | [] -> (l1', a')\n    | h::t -> (li', (bigAdd (mulByDigit h l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 97-100:\n  | h :: t -> li', (bigAdd (mulByDigit h (l1')) a') in\n              ^^^\nError: Unbound value li'\nHint: Did you mean l1'?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with\n    | [] -> (l1', a')\n    | h::t -> (l1, (bigAdd (mulByDigit h l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1, (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with\n    | [] -> (l1', a')\n    | h::t -> (l1, (bigAdd (mulByDigit h l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with\n    | [] -> (l1', a')\n    | h::t -> (l1', (bigAdd (mulByDigit h l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with\n    | [] -> (l1', a')\n    | h::t -> (l1', (bigAdd (mulByDigit h l1') a')) in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, 0) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with\n    | [] -> (l1', a')\n    | h::t -> (l1', (bigAdd (mulByDigit h l1') a')) in\n  let base = (l1, 0) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 220-224:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type int list * int\n       but an expression was expected of type int list * int list\n       Type int is not compatible with type int list \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, [0]) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with\n    | [] -> (l1', a')\n    | h::t -> (l1', (bigAdd (mulByDigit h l1') a')) in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, [0]) in\nlet args = (List.rev (List.hd l2)) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with\n    | [] -> (l1', a')\n    | h::t -> (l1', (bigAdd (mulByDigit h l1') a')) in\n  let base = (l1, [0]) in\n  let args = List.rev (List.hd l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, [0]) in\nlet args = (List.hd (List.rev List.hd l2)) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with\n    | [] -> (l1', a')\n    | h::t -> (l1', (bigAdd (mulByDigit h l1') a')) in\n  let base = (l1, [0]) in\n  let args = List.hd (List.rev List.hd l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 183-191:\n  let args = (List.hd (List.rev List.hd l2)) in\n                       ^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, [0]) in\nlet args = (List.hd (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with\n    | [] -> (l1', a')\n    | h::t -> (l1', (bigAdd (mulByDigit h l1') a')) in\n  let base = (l1, [0]) in\n  let args = List.hd (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, []) in\nlet args = (List.hd (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with\n    | [] -> (l1', a')\n    | h::t -> (l1', (bigAdd (mulByDigit h l1') a')) in\n  let base = (l1, []) in\n  let args = List.hd (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with\n    | [] -> (l1', a')\n    | h::t -> (l1', (bigAdd (mulByDigit h l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \n\nlet f a x = let (l1', a') = a in\nmatch x with\n| [] -> (l1', a')\n| h :: t -> l1', (bigAdd (mulByDigit h (l1')) a') in\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with\n    | [] -> (l1', a')\n    | h::t -> (l1', (bigAdd (mulByDigit h l1') a')) in\n  let base = (l1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \n\nlet f a x = match a with\n| (l1', a') -> l1', (bigAdd (mulByDigit x (List.rev l1')) a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (l1',a') -> (l1', (bigAdd (mulByDigit x (List.rev l1')) a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \n\nlet f a x = match a with\n| (l1', a') -> 0::l1', (bigAdd (mulByDigit x (List.rev l1')) a') in\nlet base = (l1, []) in\nlet args = (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (l1',a') -> ((0 :: l1'), (bigAdd (mulByDigit x (List.rev l1')) a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
