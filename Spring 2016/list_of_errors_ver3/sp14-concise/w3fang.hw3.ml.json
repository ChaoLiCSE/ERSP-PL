{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x^a in\nlet base = sep in\nlet l = List.rev sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (x ^ a) in\n      let base = sep in let l = List.rev sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^a in\nlet base = h^sep in\nlet l = List.rev sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = h ^ sep in let l = List.rev sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^a in\nlet base = sep in\nlet l = List.rev sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = sep in let l = List.rev sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^a^x in\nlet base = sep in\nlet l = List.rev sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (a ^ x) in\n      let base = sep in let l = List.rev sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^a^(sepConcat sep t) in\nlet base = sep in\nlet l = List.rev sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (a ^ (sepConcat sep t)) in\n      let base = sep in let l = List.rev sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^(sepConcat sep t) in\nlet base = h^sep in\nlet l = List.rev sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sepConcat sep t) in\n      let base = h ^ sep in let l = List.rev sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x in\nlet base = h^sep in\nlet l = List.rev sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = h ^ sep in let l = List.rev sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^a in\nlet base = h^sep in\nlet l = List.rev sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = h ^ sep in let l = List.rev sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x^(sepConcat sep t) in\nlet base = h^sep in\nlet l = List.rev sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (x ^ (sepConcat sep t)) in\n      let base = h ^ sep in let l = List.rev sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^(sepConcat sep t) in\nlet base = h^sep in\nlet l = List.rev sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sepConcat sep t) in\n      let base = h ^ sep in let l = List.rev sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^(sepConcat sep t) in\nlet base = sep in\nlet l = List.rev sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sepConcat sep t) in\n      let base = sep in let l = List.rev sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x^a in\nlet base = sep in\nlet l = List.rev sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (x ^ a) in\n      let base = sep in let l = List.rev sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^a in\nlet base = sep in\nlet l = sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = sep in let l = sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^a in\nlet base = sep in\nlet l = sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = sep in let l = sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = List.rev x^a in\nlet base = sep in\nlet l = sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (List.rev x) ^ a in\n      let base = sep in let l = sl in List.fold_left f base l;;\n", "out": "Characters 78-88:\n  let f a x = List.rev x^a in\n              ^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type string\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = List.rev t^a in\nlet base = h^sep in\nlet l = sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (List.rev t) ^ a in\n      let base = h ^ sep in let l = sl in List.fold_left f base l;;\n", "out": "Characters 78-88:\n  let f a x = List.rev t^a in\n              ^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type string\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^a in\nlet base = h^sep in\nlet l = sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = h ^ sep in let l = sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^a in\nlet base = h^sep in\nlet l = List.rev sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = h ^ sep in let l = List.rev sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x^(sepConcat sep t) in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (x ^ (sepConcat sep t)) in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x^a in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (x ^ a) in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (List.hd t) ^a in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (List.hd t) ^ a in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^(a^x) in\nlet base = h in\nlet l = List.rev t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (a ^ x) in\n      let base = h in let l = List.rev t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^(a^x) in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (a ^ x) in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^(a^(sepConcat sep t)) in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (a ^ (sepConcat sep t)) in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a+x*x in\nlet base = 0\nin\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (x^a)^x in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (x ^ a) ^ x in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (a^x)^a in\nlet base = h in\nlet l = List.rev t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (a ^ x) ^ a in\n      let base = h in let l = List.rev t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (a^x)^a in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (a ^ x) ^ a in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (h^a)^x^a in\nlet base = sep in\nlet l = List.rev t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (h ^ a) ^ (x ^ a) in\n      let base = sep in let l = List.rev t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^x^a in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (x ^ a) in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ (sepConcat a x)in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sepConcat a x) in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n", "out": "Characters 164-165:\n  List.fold_left f base l;;\n                        ^\nError: This expression has type string list\n       but an expression was expected of type string list list\n       Type string is not compatible with type string list \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ (x^a)in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (x ^ a) in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ (x^a)in\nlet base = h^sep in\nlet l = sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (x ^ a) in\n      let base = h ^ sep in let l = sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^ a ^ x in\nlet base = h^sep in\nlet l = sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (a ^ x) in\n      let base = h ^ sep in let l = sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a*10+x*10 in\nlet base = List.hd l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a * 10) + (x * 10) in\n    let base = List.hd l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 122-148:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a+x in\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 108-134:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = [a+x] in\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = [a + x] in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 125-126:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int -> int -> int list\n       but an expression was expected of type int -> int -> int\n       Type int list is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = [a+x] in\nlet base = List.hd l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = [a + x] in\n    let base = List.hd l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 133-134:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int -> int -> int list\n       but an expression was expected of type int -> int -> int\n       Type int list is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = add(List.combine a x)in\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = add (List.combine a x) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 52-55:\n  let f a x = add(List.combine a x)in\n              ^^^\nError: Unbound value add\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (+)(List.combine a x)in\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (+) (List.combine a x) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 55-73:\n  let f a x = (+)(List.combine a x)in\n                 ^^^^^^^^^^^^^^^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (+) List. hd (List.combine a x)in\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = List.hd + (List.combine a x) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 56-64:\n  let f a x = (+) List. hd (List.combine a x)in\n                  ^^^^^^^^\nError: This expression has type 'a list -> 'a\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a+x in\nlet base = List.hd l1 in\nlet args = List.hd l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = List.hd l1 in\n    let args = List.hd l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 124-150:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = List.map (+) a x in\nlet base = List.hd (L1) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = List.map (+) a x in\n    let base = List.hd L1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 52-60:\n  let f a x = List.map (+) a x in\n              ^^^^^^^^\nError: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = List.map (a+x) in\nlet base = List.hd (L1) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = List.map (a + x) in\n    let base = List.hd L1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 61-66:\n  let f a x = List.map (a+x) in\n                       ^^^^^\nError: This expression has type int but an expression was expected of type\n         'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = List.map (fun x->x+a)(x) in\nlet base = List.hd (L1) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = List.map (fun x  -> x + a) x in\n    let base = List.hd L1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 100-102:\n  let base = List.hd (L1) in\n                      ^^\nError: This variant expression is expected to have type 'a list\n       The constructor L1 does not belong to type list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = List.map (fun x->x+a)(x) in\nlet base = List.hd l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = List.map (fun x  -> x + a) x in\n    let base = List.hd l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 152-153:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int -> int list -> int list\n       but an expression was expected of type int -> int list -> int\n       Type int list is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^ sep ^ a in\nlet base = h in\nlet l = List.rev t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ (sep ^ a) in\n      let base = h in let l = List.rev t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^ sep ^ a in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ (sep ^ a) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a+x*x in\nlet base = 0\nin\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet(w,res)=a in \nlet (y,z)=x in \nlet total = y+z+w in\n(total/10, (total mod 10)::res) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev(0::l1))(List.rev(0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (w,res) = a in\n      let (y,z) = x in\n      let total = (y + z) + w in ((total / 10), ((total mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 277-287:\n  removeZero (add (padZero l1 l2));;\n  ^^^^^^^^^^\nError: Unbound value removeZero\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l  with\n| []-> []\n|  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)", "min": "\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else [h] @ (removeZero t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = \nlet l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\nlet l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n(l1,l2)", "min": "\nlet padZero l1 l2 =\n  let l1 = if (List.length l1) < (List.length l2) then [0; 0] @ l1 else l1 in\n  let l2 = if (List.length l2) < (List.length l1) then [0; 0] @ l2 else l2 in\n  (l1, l2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let add (l1, l2) = \nlet f a x = \nlet(w,res)=a in \nlet (y,z)=x in \nlet total = y+z+w in\n(total/10, (total mod 10)::res) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev(0::l1))(List.rev(0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet padZero l1 l2 =\n  let l1 = if (List.length l1) < (List.length l2) then [0; 0] @ l1 else l1 in\n  let l2 = if (List.length l2) < (List.length l1) then [0; 0] @ l2 else l2 in\n  (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else [h] @ (removeZero t);;\n\nlet _ =\n  let add (l1,l2) =\n    let f a x =\n      let (w,res) = a in\n      let (y,z) = x in\n      let total = (y + z) + w in ((total / 10), ((total mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 282-284:\n  removeZero (add (padZero l1 l2));;\n                           ^^\nError: Unbound value l1\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet(w,res)=a in \nlet (y,z)=x in \nlet total = y+z+w in\n(total/10, (total mod 10)::res) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev(0::l1))(List.rev(0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet padZero l1 l2 =\n  let l1 = if (List.length l1) < (List.length l2) then [0; 0] @ l1 else l1 in\n  let l2 = if (List.length l2) < (List.length l1) then [0; 0] @ l2 else l2 in\n  (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else [h] @ (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (w,res) = a in\n      let (y,z) = x in\n      let total = (y + z) + w in ((total / 10), ((total mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = let add (l1, l2) = let f a x = let (w, res) = a in let (y, z) = x in let total = y + z + w in (total / 10, (total mod 10) :: res) in let base = (0, []) in let args = List.combine (List.rev(0 :: l1)) (List.rev(0 :: l2)) in let (_, res) = List.fold_left f base args in res in removeZero (add (padZero l1 l2))", "min": "\nlet padZero l1 l2 =\n  let l1 = if (List.length l1) < (List.length l2) then [0; 0] @ l1 else l1 in\n  let l2 = if (List.length l2) < (List.length l1) then [0; 0] @ l2 else l2 in\n  (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else [h] @ (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (w,res) = a in\n      let (y,z) = x in\n      let total = (y + z) + w in ((total / 10), ((total mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
