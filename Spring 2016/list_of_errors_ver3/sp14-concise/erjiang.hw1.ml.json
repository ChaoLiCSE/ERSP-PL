{"event": "eval", "ocaml": [{"in": "let rec sumList xs = failwith \"TBD:sumList\"", "out": "", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = failwith \"TBD:sumList\"", "out": "", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = failwith \"TBD:sumList\"", "out": "", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with \n| []     -> 0\n| (h::t) -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with \n| []     -> 0\n| (h::t) -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse if n mod 10 = 0 then 0::digitsOfInt (n/10)\nelse if (n-1) mod 10 = 0 then 1::digitsOfInt ((n-1)/10)\nelse if (n-2) mod 10 = 0 then 1::digitsOfInt ((n-2)/10)\nelse if (n-3) mod 10 = 0 then 1::digitsOfInt ((n-3)/10)\nelse if (n-4) mod 10 = 0 then 1::digitsOfInt ((n-4)/10)\nelse if (n-5) mod 10 = 0 then 1::digitsOfInt ((n-5)/10)\nelse if (n-6) mod 10 = 0 then 1::digitsOfInt ((n-6)/10)\nelse if (n-7) mod 10 = 0 then 1::digitsOfInt ((n-7)/10)\nelse if (n-8) mod 10 = 0 then 1::digitsOfInt ((n-8)/10)\nelse if (n-9) mod 10 = 0 then 1::digitsOfInt ((n-9)/10)", "out": "Characters 570-572:\n  else if (n-9) mod 10 = 0 then 1::digitsOfInt ((n-9)/10);;\n                                 ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    if (n mod 10) = 0\n    then 0 :: (digitsOfInt (n / 10))\n    else\n      if ((n - 1) mod 10) = 0\n      then 1 :: (digitsOfInt ((n - 1) / 10))\n      else\n        if ((n - 2) mod 10) = 0\n        then 1 :: (digitsOfInt ((n - 2) / 10))\n        else\n          if ((n - 3) mod 10) = 0\n          then 1 :: (digitsOfInt ((n - 3) / 10))\n          else\n            if ((n - 4) mod 10) = 0\n            then 1 :: (digitsOfInt ((n - 4) / 10))\n            else\n              if ((n - 5) mod 10) = 0\n              then 1 :: (digitsOfInt ((n - 5) / 10))\n              else\n                if ((n - 6) mod 10) = 0\n                then 1 :: (digitsOfInt ((n - 6) / 10))\n                else\n                  if ((n - 7) mod 10) = 0\n                  then 1 :: (digitsOfInt ((n - 7) / 10))\n                  else\n                    if ((n - 8) mod 10) = 0\n                    then 1 :: (digitsOfInt ((n - 8) / 10))\n                    else\n                      if ((n - 9) mod 10) = 0\n                      then 1 :: (digitsOfInt ((n - 9) / 10));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse if n mod 10 = 0 then 0::digitsOfInt (n/10)\nelse if (n-1) mod 10 = 0 then 1::digitsOfInt ((n-1)/10)\nelse if (n-2) mod 10 = 0 then 2::digitsOfInt ((n-2)/10)\nelse if (n-3) mod 10 = 0 then 3::digitsOfInt ((n-3)/10)\nelse if (n-4) mod 10 = 0 then 4::digitsOfInt ((n-4)/10)\nelse if (n-5) mod 10 = 0 then 5::digitsOfInt ((n-5)/10)\nelse if (n-6) mod 10 = 0 then 6::digitsOfInt ((n-6)/10)\nelse if (n-7) mod 10 = 0 then 7::digitsOfInt ((n-7)/10)\nelse if (n-8) mod 10 = 0 then 8::digitsOfInt ((n-8)/10)\nelse if (n-9) mod 10 = 0 then 9::digitsOfInt ((n-9)/10)", "out": "Characters 570-572:\n  else if (n-9) mod 10 = 0 then 9::digitsOfInt ((n-9)/10);;\n                                 ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    if (n mod 10) = 0\n    then 0 :: (digitsOfInt (n / 10))\n    else\n      if ((n - 1) mod 10) = 0\n      then 1 :: (digitsOfInt ((n - 1) / 10))\n      else\n        if ((n - 2) mod 10) = 0\n        then 2 :: (digitsOfInt ((n - 2) / 10))\n        else\n          if ((n - 3) mod 10) = 0\n          then 3 :: (digitsOfInt ((n - 3) / 10))\n          else\n            if ((n - 4) mod 10) = 0\n            then 4 :: (digitsOfInt ((n - 4) / 10))\n            else\n              if ((n - 5) mod 10) = 0\n              then 5 :: (digitsOfInt ((n - 5) / 10))\n              else\n                if ((n - 6) mod 10) = 0\n                then 6 :: (digitsOfInt ((n - 6) / 10))\n                else\n                  if ((n - 7) mod 10) = 0\n                  then 7 :: (digitsOfInt ((n - 7) / 10))\n                  else\n                    if ((n - 8) mod 10) = 0\n                    then 8 :: (digitsOfInt ((n - 8) / 10))\n                    else\n                      if ((n - 9) mod 10) = 0\n                      then 9 :: (digitsOfInt ((n - 9) / 10));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse if n mod 10 = 0 then 0::digitsOfInt (n/10)\nelse if ((n-1) mod 10) = 0 then 1::digitsOfInt ((n-1)/10)\nelse if ((n-2) mod 10) = 0 then 2::digitsOfInt ((n-2)/10)\nelse if ((n-3) mod 10) = 0 then 3::digitsOfInt ((n-3)/10)\nelse if ((n-4) mod 10) = 0 then 4::digitsOfInt ((n-4)/10)\nelse if ((n-5) mod 10) = 0 then 5::digitsOfInt ((n-5)/10)\nelse if ((n-6) mod 10) = 0 then 6::digitsOfInt ((n-6)/10)\nelse if ((n-7) mod 10) = 0 then 7::digitsOfInt ((n-7)/10)\nelse if ((n-8) mod 10) = 0 then 8::digitsOfInt ((n-8)/10)\nelse if ((n-9) mod 10) = 0 then 9::digitsOfInt ((n-9)/10)", "out": "Characters 588-590:\n  else if ((n-9) mod 10) = 0 then 9::digitsOfInt ((n-9)/10);;\n                                   ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    if (n mod 10) = 0\n    then 0 :: (digitsOfInt (n / 10))\n    else\n      if ((n - 1) mod 10) = 0\n      then 1 :: (digitsOfInt ((n - 1) / 10))\n      else\n        if ((n - 2) mod 10) = 0\n        then 2 :: (digitsOfInt ((n - 2) / 10))\n        else\n          if ((n - 3) mod 10) = 0\n          then 3 :: (digitsOfInt ((n - 3) / 10))\n          else\n            if ((n - 4) mod 10) = 0\n            then 4 :: (digitsOfInt ((n - 4) / 10))\n            else\n              if ((n - 5) mod 10) = 0\n              then 5 :: (digitsOfInt ((n - 5) / 10))\n              else\n                if ((n - 6) mod 10) = 0\n                then 6 :: (digitsOfInt ((n - 6) / 10))\n                else\n                  if ((n - 7) mod 10) = 0\n                  then 7 :: (digitsOfInt ((n - 7) / 10))\n                  else\n                    if ((n - 8) mod 10) = 0\n                    then 8 :: (digitsOfInt ((n - 8) / 10))\n                    else\n                      if ((n - 9) mod 10) = 0\n                      then 9 :: (digitsOfInt ((n - 9) / 10));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse if n mod 10 = 0 then 0::digitsOfInt (n/10)\nelse if ((n-1) mod 10) = 0 then (1::digitsOfInt ((n-1)/10))", "out": "Characters 125-127:\n  else if ((n-1) mod 10) = 0 then (1::digitsOfInt ((n-1)/10));;\n                                    ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    if (n mod 10) = 0\n    then 0 :: (digitsOfInt (n / 10))\n    else if ((n - 1) mod 10) = 0 then 1 :: (digitsOfInt ((n - 1) / 10));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse if n mod 10 = 0 then 0::digitsOfInt (n/10)\nelse if ((n-1) mod 10) = 0 then (1::(digitsOfInt ((n-1)/10)))", "out": "Characters 125-127:\n  else if ((n-1) mod 10) = 0 then (1::(digitsOfInt ((n-1)/10)));;\n                                    ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    if (n mod 10) = 0\n    then 0 :: (digitsOfInt (n / 10))\n    else if ((n - 1) mod 10) = 0 then 1 :: (digitsOfInt ((n - 1) / 10));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digits n digitList = \nif n = 0 then digitList\nelse digits (n/10) ((n mod 10)::digitList) in\nmatch n with\n| 0 -> [0]\n| _ -> digits n []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digits n digitList =\n       if n = 0 then digitList else digits (n / 10) ((n mod 10) :: digitList) in\n     match n with | 0 -> [0] | _ -> digits n []);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digits n digitList = \nif n = 0 then digitList\nelse digits (n/10) ((n mod 10)::digitList) in\nmatch n with\n| 0 -> [0]\n| _ -> digits n []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digits n digitList =\n       if n = 0 then digitList else digits (n / 10) ((n mod 10) :: digitList) in\n     match n with | 0 -> [0] | _ -> digits n []);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digits n = digitsOfInt (abs n)", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digits n digitList =\n       if n = 0 then digitList else digits (n / 10) ((n mod 10) :: digitList) in\n     match n with | 0 -> [0] | _ -> digits n []);;\n\nlet digits n = digitsOfInt (abs n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [0]\nelse\nlet rec digits n digitList = \nif n = 0 then digitList\nelse digits (n/10) ((n mod 10)::digitList) in \ndigits n []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n = 0\n    then [0]\n    else\n      (let rec digits n digitList =\n         if n = 0\n         then digitList\n         else digits (n / 10) ((n mod 10) :: digitList) in\n       digits n []);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digits n = digitsOfInt (abs n)", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n = 0\n    then [0]\n    else\n      (let rec digits n digitList =\n         if n = 0\n         then digitList\n         else digits (n / 10) ((n mod 10) :: digitList) in\n       digits n []);;\n\nlet digits n = digitsOfInt (abs n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n =\nif n < 10 then 0\nelse 1 + additivePersistence (sumList (digits n))", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n = 0\n    then [0]\n    else\n      (let rec digits n digitList =\n         if n = 0\n         then digitList\n         else digits (n / 10) ((n mod 10) :: digitList) in\n       digits n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [0]\nelse (n mod 10)::digitsOfInt (n/10)", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [0] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [0]\nelse\nlet rec digits n digitList = \nif n = 0 then digitList\nelse digits (n/10) ((n mod 10)::digitList) in \ndigits n []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n = 0\n    then [0]\n    else\n      (let rec digits n digitList =\n         if n = 0\n         then digitList\n         else digits (n / 10) ((n mod 10) :: digitList) in\n       digits n []);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [0]\nelse\nlet rec getDigits n dList = \nif n = 0 then dList\nelse getDigits (n/10) ((n mod 10)::dList) in \ngetDigits n []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n = 0\n    then [0]\n    else\n      (let rec getDigits n dList =\n         if n = 0 then dList else getDigits (n / 10) ((n mod 10) :: dList) in\n       getDigits n []);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\n(List.hd l)::listReverse (List.tl l)", "out": "", "min": "\nlet rec listReverse l = (List.hd l) :: (listReverse (List.tl l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> l\n| (h::t) -> (List.hd l) :: listReverse (List.tl l)", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> l | h::t -> (List.hd l) :: (listReverse (List.tl l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> l\n| (h::t) -> (listReverse t)::[h]", "out": "Characters 59-74:\n  | (h::t) -> (listReverse t)::[h];;\n              ^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l = match l with | [] -> l | h::t -> [listReverse t; h];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| []     -> l\n| (h::t) -> (listReverse t)@[h]", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> l | h::t -> (listReverse t) @ [h];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w =\nif explode w = listReverse (explode w) then true else false", "out": "", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> l | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  if (explode w) = (listReverse (explode w)) then true else false;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| []     -> l\n| (h::t) -> (listReverse t)@[h]", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> l | h::t -> (listReverse t) @ [h];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [0]\nelse ((n mod 10)::digitsOfInt (n/10))", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [0] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [0]\nelse ((n mod 10)::digitsOfInt (n/10))", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [0] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n < 0 then []\n(* else if n = 0 then [0] *)\nelse \nmatch n with\n| 0 -> [0]\n| _ -> ((n mod 10)::digitsOfInt (n/10))", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | _ -> (n mod 10) :: (digitsOfInt (n / 10)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [0]\nelse\nlet rec getDigits n dList = \nif n = 0 then dList\nelse getDigits (n/10) ((n mod 10)::dList) in \ngetDigits n []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n = 0\n    then [0]\n    else\n      (let rec getDigits n dList =\n         if n = 0 then dList else getDigits (n / 10) ((n mod 10) :: dList) in\n       getDigits n []);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with \n| []     -> 0\n| (h::t) -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| []     -> l\n| [_]    -> l\n| (h::t) -> (List.hd (listReverse t))::[h]", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> l | _::[] -> l | h::t -> [List.hd (listReverse t); h];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| []     -> l\n| (h::t) -> (List.hd (listReverse t))::[h]", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> l | h::t -> [List.hd (listReverse t); h];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| []     -> l\n| (h::t) -> (listReverse t)@[h]", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> l | h::t -> (listReverse t) @ [h];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet rec rev origList revList = \nmatch origList with\n| [] -> revList\n| (h::t) -> rev t (h::revList) in\nrev l []", "out": "", "min": "\nlet rec listReverse l =\n  let rec rev origList revList =\n    match origList with | [] -> revList | h::t -> rev t (h :: revList) in\n  rev l [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet rec rev origList revList = \nmatch origList with\n| [] -> revList\n| (h::t) -> rev t (h::revList) in\nrev l []", "out": "", "min": "\nlet rec listReverse l =\n  let rec rev origList revList =\n    match origList with | [] -> revList | h::t -> rev t (h :: revList) in\n  rev l [];;\n", "type": ""}]}
