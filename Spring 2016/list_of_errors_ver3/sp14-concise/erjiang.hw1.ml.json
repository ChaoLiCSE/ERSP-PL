{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with \n| []     -> 0\n| (h::t) -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with \n| []     -> 0\n| (h::t) -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 570-572:\n  else if (n-9) mod 10 = 0 then 1::digitsOfInt ((n-9)/10);;\n                                 ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    if (n mod 10) = 0\n    then 0 :: (digitsOfInt (n / 10))\n    else\n      if ((n - 1) mod 10) = 0\n      then 1 :: (digitsOfInt ((n - 1) / 10))\n      else\n        if ((n - 2) mod 10) = 0\n        then 1 :: (digitsOfInt ((n - 2) / 10))\n        else\n          if ((n - 3) mod 10) = 0\n          then 1 :: (digitsOfInt ((n - 3) / 10))\n          else\n            if ((n - 4) mod 10) = 0\n            then 1 :: (digitsOfInt ((n - 4) / 10))\n            else\n              if ((n - 5) mod 10) = 0\n              then 1 :: (digitsOfInt ((n - 5) / 10))\n              else\n                if ((n - 6) mod 10) = 0\n                then 1 :: (digitsOfInt ((n - 6) / 10))\n                else\n                  if ((n - 7) mod 10) = 0\n                  then 1 :: (digitsOfInt ((n - 7) / 10))\n                  else\n                    if ((n - 8) mod 10) = 0\n                    then 1 :: (digitsOfInt ((n - 8) / 10))\n                    else\n                      if ((n - 9) mod 10) = 0\n                      then 1 :: (digitsOfInt ((n - 9) / 10));;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse if n mod 10 = 0 then 0::digitsOfInt (n/10)\nelse if (n-1) mod 10 = 0 then 1::digitsOfInt ((n-1)/10)\nelse if (n-2) mod 10 = 0 then 1::digitsOfInt ((n-2)/10)\nelse if (n-3) mod 10 = 0 then 1::digitsOfInt ((n-3)/10)\nelse if (n-4) mod 10 = 0 then 1::digitsOfInt ((n-4)/10)\nelse if (n-5) mod 10 = 0 then 1::digitsOfInt ((n-5)/10)\nelse if (n-6) mod 10 = 0 then 1::digitsOfInt ((n-6)/10)\nelse if (n-7) mod 10 = 0 then 1::digitsOfInt ((n-7)/10)\nelse if (n-8) mod 10 = 0 then 1::digitsOfInt ((n-8)/10)\nelse if (n-9) mod 10 = 0 then 1::digitsOfInt ((n-9)/10)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 570-572:\n  else if (n-9) mod 10 = 0 then 9::digitsOfInt ((n-9)/10);;\n                                 ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    if (n mod 10) = 0\n    then 0 :: (digitsOfInt (n / 10))\n    else\n      if ((n - 1) mod 10) = 0\n      then 1 :: (digitsOfInt ((n - 1) / 10))\n      else\n        if ((n - 2) mod 10) = 0\n        then 2 :: (digitsOfInt ((n - 2) / 10))\n        else\n          if ((n - 3) mod 10) = 0\n          then 3 :: (digitsOfInt ((n - 3) / 10))\n          else\n            if ((n - 4) mod 10) = 0\n            then 4 :: (digitsOfInt ((n - 4) / 10))\n            else\n              if ((n - 5) mod 10) = 0\n              then 5 :: (digitsOfInt ((n - 5) / 10))\n              else\n                if ((n - 6) mod 10) = 0\n                then 6 :: (digitsOfInt ((n - 6) / 10))\n                else\n                  if ((n - 7) mod 10) = 0\n                  then 7 :: (digitsOfInt ((n - 7) / 10))\n                  else\n                    if ((n - 8) mod 10) = 0\n                    then 8 :: (digitsOfInt ((n - 8) / 10))\n                    else\n                      if ((n - 9) mod 10) = 0\n                      then 9 :: (digitsOfInt ((n - 9) / 10));;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse if n mod 10 = 0 then 0::digitsOfInt (n/10)\nelse if (n-1) mod 10 = 0 then 1::digitsOfInt ((n-1)/10)\nelse if (n-2) mod 10 = 0 then 2::digitsOfInt ((n-2)/10)\nelse if (n-3) mod 10 = 0 then 3::digitsOfInt ((n-3)/10)\nelse if (n-4) mod 10 = 0 then 4::digitsOfInt ((n-4)/10)\nelse if (n-5) mod 10 = 0 then 5::digitsOfInt ((n-5)/10)\nelse if (n-6) mod 10 = 0 then 6::digitsOfInt ((n-6)/10)\nelse if (n-7) mod 10 = 0 then 7::digitsOfInt ((n-7)/10)\nelse if (n-8) mod 10 = 0 then 8::digitsOfInt ((n-8)/10)\nelse if (n-9) mod 10 = 0 then 9::digitsOfInt ((n-9)/10)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 588-590:\n  else if ((n-9) mod 10) = 0 then 9::digitsOfInt ((n-9)/10);;\n                                   ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    if (n mod 10) = 0\n    then 0 :: (digitsOfInt (n / 10))\n    else\n      if ((n - 1) mod 10) = 0\n      then 1 :: (digitsOfInt ((n - 1) / 10))\n      else\n        if ((n - 2) mod 10) = 0\n        then 2 :: (digitsOfInt ((n - 2) / 10))\n        else\n          if ((n - 3) mod 10) = 0\n          then 3 :: (digitsOfInt ((n - 3) / 10))\n          else\n            if ((n - 4) mod 10) = 0\n            then 4 :: (digitsOfInt ((n - 4) / 10))\n            else\n              if ((n - 5) mod 10) = 0\n              then 5 :: (digitsOfInt ((n - 5) / 10))\n              else\n                if ((n - 6) mod 10) = 0\n                then 6 :: (digitsOfInt ((n - 6) / 10))\n                else\n                  if ((n - 7) mod 10) = 0\n                  then 7 :: (digitsOfInt ((n - 7) / 10))\n                  else\n                    if ((n - 8) mod 10) = 0\n                    then 8 :: (digitsOfInt ((n - 8) / 10))\n                    else\n                      if ((n - 9) mod 10) = 0\n                      then 9 :: (digitsOfInt ((n - 9) / 10));;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse if n mod 10 = 0 then 0::digitsOfInt (n/10)\nelse if ((n-1) mod 10) = 0 then 1::digitsOfInt ((n-1)/10)\nelse if ((n-2) mod 10) = 0 then 2::digitsOfInt ((n-2)/10)\nelse if ((n-3) mod 10) = 0 then 3::digitsOfInt ((n-3)/10)\nelse if ((n-4) mod 10) = 0 then 4::digitsOfInt ((n-4)/10)\nelse if ((n-5) mod 10) = 0 then 5::digitsOfInt ((n-5)/10)\nelse if ((n-6) mod 10) = 0 then 6::digitsOfInt ((n-6)/10)\nelse if ((n-7) mod 10) = 0 then 7::digitsOfInt ((n-7)/10)\nelse if ((n-8) mod 10) = 0 then 8::digitsOfInt ((n-8)/10)\nelse if ((n-9) mod 10) = 0 then 9::digitsOfInt ((n-9)/10)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 125-127:\n  else if ((n-1) mod 10) = 0 then (1::digitsOfInt ((n-1)/10));;\n                                    ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    if (n mod 10) = 0\n    then 0 :: (digitsOfInt (n / 10))\n    else if ((n - 1) mod 10) = 0 then 1 :: (digitsOfInt ((n - 1) / 10));;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse if n mod 10 = 0 then 0::digitsOfInt (n/10)\nelse if ((n-1) mod 10) = 0 then (1::digitsOfInt ((n-1)/10))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 125-127:\n  else if ((n-1) mod 10) = 0 then (1::(digitsOfInt ((n-1)/10)));;\n                                    ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    if (n mod 10) = 0\n    then 0 :: (digitsOfInt (n / 10))\n    else if ((n - 1) mod 10) = 0 then 1 :: (digitsOfInt ((n - 1) / 10));;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then []\nelse if n mod 10 = 0 then 0::digitsOfInt (n/10)\nelse if ((n-1) mod 10) = 0 then (1::(digitsOfInt ((n-1)/10)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digits n digitList = \nif n = 0 then digitList\nelse digits (n/10) ((n mod 10)::digitList) in\nmatch n with\n| 0 -> [0]\n| _ -> digits n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse\nlet rec digits n digitList = \nif n = 0 then digitList\nelse digits (n/10) ((n mod 10)::digitList) in\nmatch n with\n| 0 -> [0]\n| _ -> digits n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [0]\nelse\nlet rec digits n digitList = \nif n = 0 then digitList\nelse digits (n/10) ((n mod 10)::digitList) in \ndigits n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n =\nif n < 10 then 0\nelse 1 + additivePersistence (sumList (digits n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [0]\nelse (n mod 10)::digitsOfInt (n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [0]\nelse\nlet rec digits n digitList = \nif n = 0 then digitList\nelse digits (n/10) ((n mod 10)::digitList) in \ndigits n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [0]\nelse\nlet rec getDigits n dList = \nif n = 0 then dList\nelse getDigits (n/10) ((n mod 10)::dList) in \ngetDigits n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\n(List.hd l)::listReverse (List.tl l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nmatch l with\n| [] -> l\n| (h::t) -> (List.hd l) :: listReverse (List.tl l)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 59-74:\n  | (h::t) -> (listReverse t)::[h];;\n              ^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l = match l with | [] -> l | h::t -> [listReverse t; h];;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> l\n| (h::t) -> (listReverse t)::[h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nmatch l with\n| []     -> l\n| (h::t) -> (listReverse t)@[h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w =\nif explode w = listReverse (explode w) then true else false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nmatch l with\n| []     -> l\n| (h::t) -> (listReverse t)@[h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [0]\nelse ((n mod 10)::digitsOfInt (n/10))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [0]\nelse ((n mod 10)::digitsOfInt (n/10))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\n(* else if n = 0 then [0] *)\nelse \nmatch n with\n| 0 -> [0]\n| _ -> ((n mod 10)::digitsOfInt (n/10))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n = 0 then [0]\nelse\nlet rec getDigits n dList = \nif n = 0 then dList\nelse getDigits (n/10) ((n mod 10)::dList) in \ngetDigits n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with \n| []     -> 0\n| (h::t) -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nmatch l with\n| []     -> l\n| [_]    -> l\n| (h::t) -> (List.hd (listReverse t))::[h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nmatch l with\n| []     -> l\n| (h::t) -> (List.hd (listReverse t))::[h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nmatch l with\n| []     -> l\n| (h::t) -> (listReverse t)@[h]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nlet rec rev origList revList = \nmatch origList with\n| [] -> revList\n| (h::t) -> rev t (h::revList) in\nrev l []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nlet rec rev origList revList = \nmatch origList with\n| [] -> revList\n| (h::t) -> rev t (h::revList) in\nrev l []"}]}
