{"event": "eval", "ocaml": [{"type": "type", "in": "let rec assoc (d,k,l) = \nlet temp = l in\nlet rec helper acc (d,k,l) = \nmatch temp with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper (d,k,l) t\nin helper (d,k,l) acc", "min": "\nlet rec assoc (d,k,l) =\n  let temp = l in\n  let rec helper acc (d,k,l) =\n    match temp with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper (d, k, l) t) in\n  helper (d, k, l) acc;;\n", "out": "Characters 168-169:\n  helper (d,k,l) t\n                 ^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type 'b * 'a * 'c\n"}, {"type": "scope", "in": "uncomment after implementing assoc", "min": "\nlet _ = uncomment after implementing assoc;;\n", "out": "Characters 0-9:\n  uncomment after implementing assoc;;\n  ^^^^^^^^^\nError: Unbound value uncomment\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper (d,k,l) acc", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper (d, k, l) acc;;\n", "out": "Characters 178-185:\n  in helper (d,k,l) acc;;\n            ^^^^^^^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type ('d * 'e) list\n"}, {"type": "scope", "in": "uncomment after implementing assoc", "min": "\nlet _ = uncomment after implementing assoc;;\n", "out": "Characters 0-9:\n  uncomment after implementing assoc;;\n  ^^^^^^^^^\nError: Unbound value uncomment\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nmatch f b with\n(k,v) -> \nif v\nthen wwhile (f, k)\nelse k", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (k,v) -> if v then wwhile (f, k) else k;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((let g x = let xx = (f x) in (xx, xx!=x) in g),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (k,v) -> if v then wwhile (f, k) else k;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != x)) in g), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((let g x = let xx = (f x) in (xx, xx!=x) in g),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (k,v) -> if v then wwhile (f, k) else k;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != x)) in g), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 2) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (1, 7) with\n     | 1 -> buildX ()\n     | 2 -> buildY ()\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildCosine (build (rand, (depth - 1)))\n     | 5 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand,depth) =\nif depth = 0 \nthen\nmatch rand(1,2) with\n1 -> buildX()\n| 2 -> buildY()\nelse \nmatch rand(1,7) with\n1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine( build(rand,depth-1) ) \n| 4 -> buildCosine( build(rand,depth-1) )\n| 5 -> buildAverage( (build(rand,depth-1)), build(rand,depth-1) )\n| 6 -> buildTimes( (build(rand,depth-1)), build(rand,depth-1) )\n| 7 -> buildThresh( build(rand,depth-1), build(rand,depth-1), build(rand,depth-1), build(rand,depth-1) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 2) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (1, 7) with\n     | 1 -> buildX ()\n     | 2 -> buildY ()\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildCosine (build (rand, (depth - 1)))\n     | 5 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand,depth) =\nif depth = 0 \nthen\nmatch rand(1,2) with\n1 -> buildX()\n| 2 -> buildY()\nelse \nmatch rand(1,7) with\n1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine( build(rand,depth-1) ) \n| 4 -> buildCosine( build(rand,depth-1) )\n| 5 -> buildAverage( (build(rand,depth-1)), build(rand,depth-1) )\n| 6 -> buildTimes( (build(rand,depth-1)), build(rand,depth-1) )\n| 7 -> buildThresh( build(rand,depth-1), build(rand,depth-1), build(rand,depth-1), build(rand,depth-1) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 2) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (1, 7) with\n     | 1 -> buildX ()\n     | 2 -> buildY ()\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildCosine (build (rand, (depth - 1)))\n     | 5 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 2) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (1, 7) with\n     | 1 -> buildX ()\n     | 2 -> buildY ()\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildCosine (build (rand, (depth - 1)))\n     | 5 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen)\nthen \nseen\nelse \nh :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand,depth) =\nif depth = 0 \nthen\nmatch rand(1,3) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse \nmatch rand(3,8) with\n| 3 -> buildSine( build(rand,depth-1) ) \n| 4 -> buildCosine( build(rand,depth-1) )\n| 5 -> buildAverage( (build(rand,depth-1)), build(rand,depth-1) )\n| 6 -> buildTimes( (build(rand,depth-1)), build(rand,depth-1) )\n| 7 -> buildThresh( build(rand,depth-1), build(rand,depth-1), build(rand,depth-1), build(rand,depth-1) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (3, 8) with\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildCosine (build (rand, (depth - 1)))\n     | 5 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin(pi*\" ^ (exprToString a) ^ \")\"\n| Cosine a -> \"cos(pi*\" ^ (exprToString a) ^ \")\"\n| Average (a,b) -> \"((\" ^ (exprToString a) ^ \"+\" ^ (exprToString b) ^ \")/2)\"\n| Times (a,b) -> (exprToString a) ^ \"*\" ^ (exprToString b)\n| Thresh (a,b,c,d) -> \"(\" ^ (exprToString a) ^ \"<\" ^ (exprToString b) ^ \"?\" ^ (exprToString c) ^ \":\" ^ (exprToString d) ^ \")\"\n| _ -> \"_\"\n| Cube a -> \"(\" ^ (exprToString a) ^ \"*\" ^ (exprToString a) ^ \"*\" ^ (exprToString a) ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Cube a ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString a) ^ (\"*\" ^ ((exprToString a) ^ \")\")))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\n| Cube     of expr\n| Addition of expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin(pi*\" ^ (exprToString a) ^ \")\"\n| Cosine a -> \"cos(pi*\" ^ (exprToString a) ^ \")\"\n| Average (a,b) -> \"((\" ^ (exprToString a) ^ \"+\" ^ (exprToString b) ^ \")/2)\"\n| Times (a,b) -> (exprToString a) ^ \"*\" ^ (exprToString b)\n| Thresh (a,b,c,d) -> \"(\" ^ (exprToString a) ^ \"<\" ^ (exprToString b) ^ \"?\" ^ (exprToString c) ^ \":\" ^ (exprToString d) ^ \")\"\n| _ -> \"_\"\n| Cube a -> \"(\" ^ (exprToString a) ^ \"*\" ^ (exprToString a) ^ \"*\" ^ (exprToString a) ^ \")\"\n| Addition (a,b) -> \"(\" ^ (exprToString a) ^ \"+\" ^ (exprToString b) ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Cube a ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString a) ^ (\"*\" ^ ((exprToString a) ^ \")\")))))\n  | Addition (a,b) ->\n      \"(\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")\")));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with\nVarX -> x\n| VarY -> y\n| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )\n| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )\n| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)\n| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )\n| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))\nthen (eval (c,x,y))\nelse (eval (d,x,y))\n| Cube a -> (eval a) * (eval  a) *(eval a)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval a) * (eval a)) * (eval a);;\n", "out": "Characters 391-392:\n  | Cube a -> (eval a) * (eval  a) *(eval a);;\n                    ^\nError: This expression has type expr but an expression was expected of type\n         expr * float * float\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with\nVarX -> x\n| VarY -> y\n| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )\n| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )\n| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)\n| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )\n| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))\nthen (eval (c,x,y))\nelse (eval (d,x,y))\n| Cube a -> (eval (a,x,y) ) * (eval  (a,x,y) ) * (eval (a,x,y) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval (a, x, y)) * (eval (a, x, y))) * (eval (a, x, y));;\n", "out": "Characters 385-400:\n  | Cube a -> (eval (a,x,y) ) * (eval  (a,x,y) ) * (eval (a,x,y) );;\n              ^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with\nVarX -> x\n| VarY -> y\n| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )\n| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )\n| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)\n| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )\n| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))\nthen (eval (c,x,y))\nelse (eval (d,x,y))\n| Cube a -> (eval (a,x,y) ) *. (eval  (a,x,y) ) *. (eval (a,x,y) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval (a, x, y)) *. (eval (a, x, y))) *. (eval (a, x, y));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with\nVarX -> x\n| VarY -> y\n| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )\n| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )\n| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)\n| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )\n| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))\nthen (eval (c,x,y))\nelse (eval (d,x,y))\n| Cube a -> (eval (a,x,y) ) *. (eval  (a,x,y) ) *. (eval (a,x,y) )\n| Addition (a,b) -> eval(a,x,y) +. eval", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval (a, x, y)) *. (eval (a, x, y))) *. (eval (a, x, y))\n  | Addition (a,b) -> (eval (a, x, y)) +. eval;;\n", "out": "Characters 475-479:\n  | Addition (a,b) -> eval(a,x,y) +. eval;;\n                                     ^^^^\nError: This expression has type expr * float * float -> float\n       but an expression was expected of type float\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with\nVarX -> x\n| VarY -> y\n| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )\n| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )\n| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)\n| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )\n| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))\nthen (eval (c,x,y))\nelse (eval (d,x,y))\n| Cube a -> (eval (a,x,y) ) *. (eval  (a,x,y) ) *. (eval (a,x,y) )\n| Addition (a,b) -> eval(a,x,y) +. eval(b,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval (a, x, y)) *. (eval (a, x, y))) *. (eval (a, x, y))\n  | Addition (a,b) -> (eval (a, x, y)) +. (eval (b, x, y));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand,depth) =\nif depth = 0 \nthen\nmatch rand(1,3) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse \nmatch rand(3,10) with\n(* | 1 -> buildX()\n| 2 -> buildY() *)\n| 3 -> buildSine( build(rand,depth-1) ) \n| 4 -> buildCosine( build(rand,depth-1) )\n| 5 -> buildAverage( (build(rand,depth-1)), build(rand,depth-1) )\n| 6 -> buildTimes( (build(rand,depth-1)), build(rand,depth-1) )\n| 7 -> buildThresh( build(rand,depth-1), build(rand,depth-1), build(rand,depth-1), build(rand,depth-1) )\n| 8 -> buildCube( build(rand,depth-1) )\n| 9 -> buildAddition ( build(rand,depth-1),  build(rand,depth-1) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet buildAddition (e1,e2) = Addition (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCube e = Cube e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (3, 10) with\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildCosine (build (rand, (depth - 1)))\n     | 5 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 -> buildCube (build (rand, (depth - 1)))\n     | 9 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval (a, x, y)) *. (eval (a, x, y))) *. (eval (a, x, y))\n  | Addition (a,b) -> (eval (a, x, y)) +. (eval (b, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet buildAddition (e1,e2) = Addition (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCube e = Cube e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (3, 10) with\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildCosine (build (rand, (depth - 1)))\n     | 5 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 -> buildCube (build (rand, (depth - 1)))\n     | 9 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Cube a ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString a) ^ (\"*\" ^ ((exprToString a) ^ \")\")))))\n  | Addition (a,b) ->\n      \"(\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand,depth) =\nif depth = 0 \nthen\nmatch rand(1,3) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse \nmatch rand(4,10) with\n(* | 1 -> buildX()\n| 2 -> buildY() *)\n| 3 -> buildSine( build(rand,depth-1) ) \n| 4 -> buildCosine( build(rand,depth-1) )\n| 5 -> buildAverage( (build(rand,depth-1)), build(rand,depth-1) )\n| 6 -> buildTimes( (build(rand,depth-1)), build(rand,depth-1) )\n| 7 -> buildThresh( build(rand,depth-1), build(rand,depth-1), build(rand,depth-1), build(rand,depth-1) )\n| 8 -> buildCube( build(rand,depth-1) )\n| 9 -> buildAddition ( build(rand,depth-1),  build(rand,depth-1) )", "min": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (4, 10) with\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildCosine (build (rand, (depth - 1)))\n     | 5 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 -> buildCube (build (rand, (depth - 1)))\n     | 9 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": "Characters 76-82:\n  | 1 -> buildX()\n         ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand,depth) =\nif depth = 0 \nthen\nmatch rand(1,3) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse \nmatch rand(1,10) with\n| 3 -> buildSine( build(rand,depth-1) ) \n| 4 -> buildCosine( build(rand,depth-1) )\n| 5 -> buildAverage( (build(rand,depth-1)), build(rand,depth-1) )\n| 6 -> buildTimes( (build(rand,depth-1)), build(rand,depth-1) )\n| 7 -> buildThresh( build(rand,depth-1), build(rand,depth-1), build(rand,depth-1), build(rand,depth-1) )\n| 8 -> buildCube( build(rand,depth-1) )\n| 9 -> buildAddition ( build(rand,depth-1),  build(rand,depth-1) )\n| _ -> buildAddition ( build(rand,depth) )", "min": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (1, 10) with\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildCosine (build (rand, (depth - 1)))\n     | 5 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 -> buildCube (build (rand, (depth - 1)))\n     | 9 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> buildAddition (build (rand, depth)));;\n", "out": "Characters 76-82:\n  | 1 -> buildX()\n         ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand,depth) =\nif depth = 0 \nthen\nmatch rand(1,3) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse \nmatch rand(1,10) with\n| 3 -> buildSine( build(rand,depth-1) ) \n| 4 -> buildCosine( build(rand,depth-1) )\n| 5 -> buildAverage( (build(rand,depth-1)), build(rand,depth-1) )\n| 6 -> buildTimes( (build(rand,depth-1)), build(rand,depth-1) )\n| 7 -> buildThresh( build(rand,depth-1), build(rand,depth-1), build(rand,depth-1), build(rand,depth-1) )\n| 8 -> buildCube( build(rand,depth-1) )\n| 9 -> buildAddition ( build(rand,depth-1),  build(rand,depth-1) )\n| _ -> build(rand,depth)", "min": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (1, 10) with\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildCosine (build (rand, (depth - 1)))\n     | 5 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 -> buildCube (build (rand, (depth - 1)))\n     | 9 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> build (rand, depth));;\n", "out": "Characters 76-82:\n  | 1 -> buildX()\n         ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand,depth) =\nif depth = 0 \nthen\nmatch rand(1,3) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse \nmatch rand(1, 10) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine( build(rand,depth-1) ) \n| 4 -> buildCosine( build(rand,depth-1) )\n| 5 -> buildAverage( (build(rand,depth-1)), build(rand,depth-1) )\n| 6 -> buildTimes( (build(rand,depth-1)), build(rand,depth-1) )\n| 7 -> buildThresh( build(rand,depth-1), build(rand,depth-1), build(rand,depth-1), build(rand,depth-1) )\n| 8 -> buildCube( build(rand,depth-1) )\n| 9 -> buildAdd ( build(rand,depth-1),  build(rand,depth-1) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCube e = Cube e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (1, 10) with\n     | 1 -> buildX ()\n     | 2 -> buildY ()\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildCosine (build (rand, (depth - 1)))\n     | 5 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 -> buildCube (build (rand, (depth - 1)))\n     | 9 ->\n         buildAdd ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": "Characters 527-535:\n  | 9 -> buildAdd ( build(rand,depth-1),  build(rand,depth-1) );;\n         ^^^^^^^^\nError: Unbound value buildAdd\nHint: Did you mean build, buildY or buildX?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand,depth) =\nif depth = 0 \nthen\nmatch rand(1,3) with\n| 1 -> buildX()\n| 2 -> buildY()\n| _ -> build(rand,depth)\nelse \nmatch rand(1, 10) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine( build(rand,depth-1) ) \n| 4 -> buildCosine( build(rand,depth-1) )\n| 5 -> buildAverage( (build(rand,depth-1)), build(rand,depth-1) )\n| 6 -> buildTimes( (build(rand,depth-1)), build(rand,depth-1) )\n| 7 -> buildThresh( build(rand,depth-1), build(rand,depth-1), build(rand,depth-1), build(rand,depth-1) )\n| 8 -> buildCube( build(rand,depth-1) )\n| 9 -> buildAddition ( build(rand,depth-1),  build(rand,depth-1) )\n| _ -> build(rand,depth)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet buildAddition (e1,e2) = Addition (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCube e = Cube e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    match rand (1, 3) with\n    | 1 -> buildX ()\n    | 2 -> buildY ()\n    | _ -> build (rand, depth)\n  else\n    (match rand (1, 10) with\n     | 1 -> buildX ()\n     | 2 -> buildY ()\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildCosine (build (rand, (depth - 1)))\n     | 5 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 -> buildCube (build (rand, (depth - 1)))\n     | 9 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> build (rand, depth));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen)\nthen \nseen\nelse \nh :: seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand,depth) =\nif depth = 0 \nthen\nmatch rand(1,3) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse \nmatch rand(1, 10) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine( build(rand,depth-1) ) \n| 4 -> buildCosine( build(rand,depth-1) )\n| 5 -> buildAverage( (build(rand,depth-1)), build(rand,depth-1) )\n| 6 -> buildTimes( (build(rand,depth-1)), build(rand,depth-1) )\n| 7 -> buildThresh( build(rand,depth-1), build(rand,depth-1), build(rand,depth-1), build(rand,depth-1) )\n| 8 -> buildCube( build(rand,depth-1) )\n| 9 -> buildAddition ( build(rand,depth-1),  build(rand,depth-1) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet buildAddition (e1,e2) = Addition (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCube e = Cube e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (1, 10) with\n     | 1 -> buildX ()\n     | 2 -> buildY ()\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildCosine (build (rand, (depth - 1)))\n     | 5 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 -> buildCube (build (rand, (depth - 1)))\n     | 9 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand,depth) =\nif depth = 0 \nthen\nmatch rand(1,3) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse \nmatch rand(1, 10) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine( build(rand,depth-1) ) \n| 4 -> buildCosine( build(rand,depth-1) )\n| 5 -> buildAverage( (build(rand,depth-1)), build(rand,depth-1) )\n| 6 -> buildTimes( (build(rand,depth-1)), build(rand,depth-1) )\n| 7 -> buildThresh( build(rand,depth-1), build(rand,depth-1), build(rand,depth-1), build(rand,depth-1) )\n| 8 -> buildCube( build(rand,depth-1) )\n| 9 -> buildAddition ( build(rand,depth-1),  build(rand,depth-1) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet buildAddition (e1,e2) = Addition (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCube e = Cube e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (1, 10) with\n     | 1 -> buildX ()\n     | 2 -> buildY ()\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildCosine (build (rand, (depth - 1)))\n     | 5 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 7 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 -> buildCube (build (rand, (depth - 1)))\n     | 9 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand,depth) =\nif depth = 0 \nthen\nmatch rand(1,3) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse \nmatch rand(3, 18) with\n| 3 -> buildSine( build(rand,depth-1) ) \n| 4 -> buildSine( build(rand,depth-1) ) \n| 5 -> buildSine( build(rand,depth-1) ) \n| 6 -> buildSine( build(rand,depth-1) ) \n| 7 -> buildCosine( build(rand,depth-1) )\n| 8 -> buildCosine( build(rand,depth-1) )\n| 9 -> buildCosine( build(rand,depth-1) )\n| 10 -> buildCosine( build(rand,depth-1) )\n| 11 -> buildCosine( build(rand,depth-1) )\n| 12 -> buildAverage( (build(rand,depth-1)), build(rand,depth-1) )\n| 13 -> buildTimes( (build(rand,depth-1)), build(rand,depth-1) )\n| 14 -> buildThresh(  buildCosine( build(rand,depth-2) ), buildSine( build(rand,depth-2) ), buildSine( build(rand,depth-2) ) , buildCosine( build(rand,depth-2) ) )\n| 15 -> buildThresh(  buildCosine( build(rand,depth-2) ), buildSine( build(rand,depth-2) ), buildSine( build(rand,depth-2) ) , buildCosine( build(rand,depth-2) ) )\n| 16 -> buildCube( build(rand,depth-1) )\n| 17 -> buildAddition ( build(rand,depth-1),  build(rand,depth-1) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet buildAddition (e1,e2) = Addition (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCube e = Cube e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (3, 18) with\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildSine (build (rand, (depth - 1)))\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 8 -> buildCosine (build (rand, (depth - 1)))\n     | 9 -> buildCosine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildCosine (build (rand, (depth - 1)))\n     | 12 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 13 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 14 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 15 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 16 -> buildCube (build (rand, (depth - 1)))\n     | 17 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval (a, x, y)) *. (eval (a, x, y))) *. (eval (a, x, y))\n  | Addition (a,b) -> (eval (a, x, y)) +. (eval (b, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet buildAddition (e1,e2) = Addition (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCube e = Cube e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (3, 18) with\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildSine (build (rand, (depth - 1)))\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 8 -> buildCosine (build (rand, (depth - 1)))\n     | 9 -> buildCosine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildCosine (build (rand, (depth - 1)))\n     | 12 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 13 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 14 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 15 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 16 -> buildCube (build (rand, (depth - 1)))\n     | 17 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Cube a ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString a) ^ (\"*\" ^ ((exprToString a) ^ \")\")))))\n  | Addition (a,b) ->\n      \"(\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval (a, x, y)) *. (eval (a, x, y))) *. (eval (a, x, y))\n  | Addition (a,b) -> (eval (a, x, y)) +. (eval (b, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet buildAddition (e1,e2) = Addition (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCube e = Cube e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (3, 18) with\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildSine (build (rand, (depth - 1)))\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 8 -> buildCosine (build (rand, (depth - 1)))\n     | 9 -> buildCosine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildCosine (build (rand, (depth - 1)))\n     | 12 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 13 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 14 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 15 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 16 -> buildCube (build (rand, (depth - 1)))\n     | 17 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Cube a ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString a) ^ (\"*\" ^ ((exprToString a) ^ \")\")))))\n  | Addition (a,b) ->\n      \"(\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval (a, x, y)) *. (eval (a, x, y))) *. (eval (a, x, y))\n  | Addition (a,b) -> (eval (a, x, y)) +. (eval (b, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet buildAddition (e1,e2) = Addition (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCube e = Cube e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (3, 18) with\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildSine (build (rand, (depth - 1)))\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 8 -> buildCosine (build (rand, (depth - 1)))\n     | 9 -> buildCosine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildCosine (build (rand, (depth - 1)))\n     | 12 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 13 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 14 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 15 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 16 -> buildCube (build (rand, (depth - 1)))\n     | 17 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Cube a ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString a) ^ (\"*\" ^ ((exprToString a) ^ \")\")))))\n  | Addition (a,b) ->\n      \"(\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval (a, x, y)) *. (eval (a, x, y))) *. (eval (a, x, y))\n  | Addition (a,b) -> (eval (a, x, y)) +. (eval (b, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet buildAddition (e1,e2) = Addition (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCube e = Cube e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (3, 18) with\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildSine (build (rand, (depth - 1)))\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 8 -> buildCosine (build (rand, (depth - 1)))\n     | 9 -> buildCosine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildCosine (build (rand, (depth - 1)))\n     | 12 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 13 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 14 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 15 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 16 -> buildCube (build (rand, (depth - 1)))\n     | 17 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Cube a ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString a) ^ (\"*\" ^ ((exprToString a) ^ \")\")))))\n  | Addition (a,b) ->\n      \"(\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval (a, x, y)) *. (eval (a, x, y))) *. (eval (a, x, y))\n  | Addition (a,b) -> (eval (a, x, y)) +. (eval (b, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet buildAddition (e1,e2) = Addition (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCube e = Cube e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (3, 18) with\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildSine (build (rand, (depth - 1)))\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 8 -> buildCosine (build (rand, (depth - 1)))\n     | 9 -> buildCosine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildCosine (build (rand, (depth - 1)))\n     | 12 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 13 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 14 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 15 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 16 -> buildCube (build (rand, (depth - 1)))\n     | 17 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Cube a ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString a) ^ (\"*\" ^ ((exprToString a) ^ \")\")))))\n  | Addition (a,b) ->\n      \"(\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval (a, x, y)) *. (eval (a, x, y))) *. (eval (a, x, y))\n  | Addition (a,b) -> (eval (a, x, y)) +. (eval (b, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet buildAddition (e1,e2) = Addition (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCube e = Cube e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (3, 18) with\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildSine (build (rand, (depth - 1)))\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 8 -> buildCosine (build (rand, (depth - 1)))\n     | 9 -> buildCosine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildCosine (build (rand, (depth - 1)))\n     | 12 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 13 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 14 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 15 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 16 -> buildCube (build (rand, (depth - 1)))\n     | 17 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Cube a ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString a) ^ (\"*\" ^ ((exprToString a) ^ \")\")))))\n  | Addition (a,b) ->\n      \"(\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval (a, x, y)) *. (eval (a, x, y))) *. (eval (a, x, y))\n  | Addition (a,b) -> (eval (a, x, y)) +. (eval (b, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet buildAddition (e1,e2) = Addition (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCube e = Cube e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (3, 18) with\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildSine (build (rand, (depth - 1)))\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 8 -> buildCosine (build (rand, (depth - 1)))\n     | 9 -> buildCosine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildCosine (build (rand, (depth - 1)))\n     | 12 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 13 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 14 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 15 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 16 -> buildCube (build (rand, (depth - 1)))\n     | 17 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Cube a ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString a) ^ (\"*\" ^ ((exprToString a) ^ \")\")))))\n  | Addition (a,b) ->\n      \"(\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval (a, x, y)) *. (eval (a, x, y))) *. (eval (a, x, y))\n  | Addition (a,b) -> (eval (a, x, y)) +. (eval (b, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet buildAddition (e1,e2) = Addition (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCube e = Cube e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (3, 18) with\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildSine (build (rand, (depth - 1)))\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 8 -> buildCosine (build (rand, (depth - 1)))\n     | 9 -> buildCosine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildCosine (build (rand, (depth - 1)))\n     | 12 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 13 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 14 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 15 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 16 -> buildCube (build (rand, (depth - 1)))\n     | 17 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Cube a ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString a) ^ (\"*\" ^ ((exprToString a) ^ \")\")))))\n  | Addition (a,b) ->\n      \"(\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval (a, x, y)) *. (eval (a, x, y))) *. (eval (a, x, y))\n  | Addition (a,b) -> (eval (a, x, y)) +. (eval (b, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet buildAddition (e1,e2) = Addition (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCube e = Cube e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (3, 18) with\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildSine (build (rand, (depth - 1)))\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 8 -> buildCosine (build (rand, (depth - 1)))\n     | 9 -> buildCosine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildCosine (build (rand, (depth - 1)))\n     | 12 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 13 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 14 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 15 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 16 -> buildCube (build (rand, (depth - 1)))\n     | 17 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Cube a ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString a) ^ (\"*\" ^ ((exprToString a) ^ \")\")))))\n  | Addition (a,b) ->\n      \"(\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval (a, x, y)) *. (eval (a, x, y))) *. (eval (a, x, y))\n  | Addition (a,b) -> (eval (a, x, y)) +. (eval (b, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet buildAddition (e1,e2) = Addition (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCube e = Cube e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (3, 18) with\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildSine (build (rand, (depth - 1)))\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 8 -> buildCosine (build (rand, (depth - 1)))\n     | 9 -> buildCosine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildCosine (build (rand, (depth - 1)))\n     | 12 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 13 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 14 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 15 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 16 -> buildCube (build (rand, (depth - 1)))\n     | 17 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Cube a ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString a) ^ (\"*\" ^ ((exprToString a) ^ \")\")))))\n  | Addition (a,b) ->\n      \"(\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval (a, x, y)) *. (eval (a, x, y))) *. (eval (a, x, y))\n  | Addition (a,b) -> (eval (a, x, y)) +. (eval (b, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet buildAddition (e1,e2) = Addition (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCube e = Cube e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (3, 18) with\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildSine (build (rand, (depth - 1)))\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 8 -> buildCosine (build (rand, (depth - 1)))\n     | 9 -> buildCosine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildCosine (build (rand, (depth - 1)))\n     | 12 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 13 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 14 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 15 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 16 -> buildCube (build (rand, (depth - 1)))\n     | 17 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Cube a ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString a) ^ (\"*\" ^ ((exprToString a) ^ \")\")))))\n  | Addition (a,b) ->\n      \"(\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval (a, x, y)) *. (eval (a, x, y))) *. (eval (a, x, y))\n  | Addition (a,b) -> (eval (a, x, y)) +. (eval (b, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet buildAddition (e1,e2) = Addition (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCube e = Cube e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (3, 18) with\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildSine (build (rand, (depth - 1)))\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 8 -> buildCosine (build (rand, (depth - 1)))\n     | 9 -> buildCosine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildCosine (build (rand, (depth - 1)))\n     | 12 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 13 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 14 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 15 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 16 -> buildCube (build (rand, (depth - 1)))\n     | 17 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Cube a ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString a) ^ (\"*\" ^ ((exprToString a) ^ \")\")))))\n  | Addition (a,b) ->\n      \"(\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval (a, x, y)) *. (eval (a, x, y))) *. (eval (a, x, y))\n  | Addition (a,b) -> (eval (a, x, y)) +. (eval (b, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet buildAddition (e1,e2) = Addition (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCube e = Cube e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (3, 18) with\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildSine (build (rand, (depth - 1)))\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 8 -> buildCosine (build (rand, (depth - 1)))\n     | 9 -> buildCosine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildCosine (build (rand, (depth - 1)))\n     | 12 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 13 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 14 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 15 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 16 -> buildCube (build (rand, (depth - 1)))\n     | 17 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Cube a ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString a) ^ (\"*\" ^ ((exprToString a) ^ \")\")))))\n  | Addition (a,b) ->\n      \"(\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand,depth) =\nif depth = 0 \nthen\nmatch rand(1,3) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse \nmatch rand(1, 18) with\n| 1 -> buildSine( build(rand,depth-1) ) \n| 2 -> buildCosine( build(rand,depth-1) )\n| 3 -> buildSine( build(rand,depth-1) ) \n| 4 -> buildSine( build(rand,depth-1) ) \n| 5 -> buildSine( build(rand,depth-1) ) \n| 6 -> buildSine( build(rand,depth-1) ) \n| 7 -> buildCosine( build(rand,depth-1) )\n| 8 -> buildCosine( build(rand,depth-1) )\n| 9 -> buildCosine( build(rand,depth-1) )\n| 10 -> buildCosine( build(rand,depth-1) )\n| 11 -> buildCosine( build(rand,depth-1) )\n| 12 -> buildAverage( (build(rand,depth-1)), build(rand,depth-1) )\n| 13 -> buildTimes( (build(rand,depth-1)), build(rand,depth-1) )\n| 14 -> buildThresh(  buildCosine( build(rand,depth-2) ), buildSine( build(rand,depth-2) ), buildSine( build(rand,depth-2) ) , buildCosine( build(rand,depth-2) ) )\n| 15 -> buildThresh(  buildCosine( build(rand,depth-2) ), buildSine( build(rand,depth-2) ), buildSine( build(rand,depth-2) ) , buildCosine( build(rand,depth-2) ) )\n| 16 -> buildCube( build(rand,depth-1) )\n| 17 -> buildAddition ( build(rand,depth-1),  build(rand,depth-1) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet buildAddition (e1,e2) = Addition (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCube e = Cube e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (1, 18) with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildSine (build (rand, (depth - 1)))\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 8 -> buildCosine (build (rand, (depth - 1)))\n     | 9 -> buildCosine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildCosine (build (rand, (depth - 1)))\n     | 12 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 13 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 14 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 15 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 16 -> buildCube (build (rand, (depth - 1)))\n     | 17 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval (a, x, y)) *. (eval (a, x, y))) *. (eval (a, x, y))\n  | Addition (a,b) -> (eval (a, x, y)) +. (eval (b, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet buildAddition (e1,e2) = Addition (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCube e = Cube e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (1, 18) with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildSine (build (rand, (depth - 1)))\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 8 -> buildCosine (build (rand, (depth - 1)))\n     | 9 -> buildCosine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildCosine (build (rand, (depth - 1)))\n     | 12 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 13 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 14 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 15 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 16 -> buildCube (build (rand, (depth - 1)))\n     | 17 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Cube a ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString a) ^ (\"*\" ^ ((exprToString a) ^ \")\")))))\n  | Addition (a,b) ->\n      \"(\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval (a, x, y)) *. (eval (a, x, y))) *. (eval (a, x, y))\n  | Addition (a,b) -> (eval (a, x, y)) +. (eval (b, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet buildAddition (e1,e2) = Addition (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCube e = Cube e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (1, 18) with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildSine (build (rand, (depth - 1)))\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 8 -> buildCosine (build (rand, (depth - 1)))\n     | 9 -> buildCosine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildCosine (build (rand, (depth - 1)))\n     | 12 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 13 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 14 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 15 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 16 -> buildCube (build (rand, (depth - 1)))\n     | 17 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Cube a ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString a) ^ (\"*\" ^ ((exprToString a) ^ \")\")))))\n  | Addition (a,b) ->\n      \"(\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval (a, x, y)) *. (eval (a, x, y))) *. (eval (a, x, y))\n  | Addition (a,b) -> (eval (a, x, y)) +. (eval (b, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet buildAddition (e1,e2) = Addition (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCube e = Cube e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (1, 18) with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildSine (build (rand, (depth - 1)))\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 8 -> buildCosine (build (rand, (depth - 1)))\n     | 9 -> buildCosine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildCosine (build (rand, (depth - 1)))\n     | 12 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 13 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 14 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 15 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 16 -> buildCube (build (rand, (depth - 1)))\n     | 17 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Cube a ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString a) ^ (\"*\" ^ ((exprToString a) ^ \")\")))))\n  | Addition (a,b) ->\n      \"(\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval (a, x, y)) *. (eval (a, x, y))) *. (eval (a, x, y))\n  | Addition (a,b) -> (eval (a, x, y)) +. (eval (b, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet buildAddition (e1,e2) = Addition (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCube e = Cube e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (1, 18) with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildSine (build (rand, (depth - 1)))\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 8 -> buildCosine (build (rand, (depth - 1)))\n     | 9 -> buildCosine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildCosine (build (rand, (depth - 1)))\n     | 12 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 13 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 14 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 15 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 16 -> buildCube (build (rand, (depth - 1)))\n     | 17 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Cube a ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString a) ^ (\"*\" ^ ((exprToString a) ^ \")\")))))\n  | Addition (a,b) ->\n      \"(\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand,depth) =\nif depth = 0 \nthen\nmatch rand(1,3) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse \nmatch rand(1, 18) with\n| 1 -> build(rand,depth-1)\n| 2 -> buildCosine( build(rand,depth-1) )\n| 3 -> buildSine( build(rand,depth-1) ) \n| 4 -> buildSine( build(rand,depth-1) ) \n| 5 -> buildSine( build(rand,depth-1) ) \n| 6 -> buildSine( build(rand,depth-1) ) \n| 7 -> buildCosine( build(rand,depth-1) )\n| 8 -> buildCosine( build(rand,depth-1) )\n| 9 -> buildCosine( build(rand,depth-1) )\n| 10 -> buildCosine( build(rand,depth-1) )\n| 11 -> buildCosine( build(rand,depth-1) )\n| 12 -> buildAverage( (build(rand,depth-1)), build(rand,depth-1) )\n| 13 -> buildTimes( (build(rand,depth-1)), build(rand,depth-1) )\n| 14 -> buildThresh(  buildCosine( build(rand,depth-2) ), buildSine( build(rand,depth-2) ), buildSine( build(rand,depth-2) ) , buildCosine( build(rand,depth-2) ) )\n| 15 -> buildThresh(  buildCosine( build(rand,depth-2) ), buildSine( build(rand,depth-2) ), buildSine( build(rand,depth-2) ) , buildCosine( build(rand,depth-2) ) )\n| 16 -> buildCube( build(rand,depth-1) )\n| 17 -> buildAddition ( build(rand,depth-1),  build(rand,depth-1) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet buildAddition (e1,e2) = Addition (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCube e = Cube e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (1, 18) with\n     | 1 -> build (rand, (depth - 1))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildSine (build (rand, (depth - 1)))\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 8 -> buildCosine (build (rand, (depth - 1)))\n     | 9 -> buildCosine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildCosine (build (rand, (depth - 1)))\n     | 12 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 13 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 14 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 15 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 16 -> buildCube (build (rand, (depth - 1)))\n     | 17 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval (a, x, y)) *. (eval (a, x, y))) *. (eval (a, x, y))\n  | Addition (a,b) -> (eval (a, x, y)) +. (eval (b, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet buildAddition (e1,e2) = Addition (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCube e = Cube e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (1, 18) with\n     | 1 -> build (rand, (depth - 1))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildSine (build (rand, (depth - 1)))\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 8 -> buildCosine (build (rand, (depth - 1)))\n     | 9 -> buildCosine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildCosine (build (rand, (depth - 1)))\n     | 12 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 13 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 14 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 15 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 16 -> buildCube (build (rand, (depth - 1)))\n     | 17 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Cube a ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString a) ^ (\"*\" ^ ((exprToString a) ^ \")\")))))\n  | Addition (a,b) ->\n      \"(\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval (a, x, y)) *. (eval (a, x, y))) *. (eval (a, x, y))\n  | Addition (a,b) -> (eval (a, x, y)) +. (eval (b, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet buildAddition (e1,e2) = Addition (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCube e = Cube e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (1, 18) with\n     | 1 -> build (rand, (depth - 1))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildSine (build (rand, (depth - 1)))\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 8 -> buildCosine (build (rand, (depth - 1)))\n     | 9 -> buildCosine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildCosine (build (rand, (depth - 1)))\n     | 12 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 13 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 14 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 15 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 16 -> buildCube (build (rand, (depth - 1)))\n     | 17 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Cube a ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString a) ^ (\"*\" ^ ((exprToString a) ^ \")\")))))\n  | Addition (a,b) ->\n      \"(\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Cube a -> ((eval (a, x, y)) *. (eval (a, x, y))) *. (eval (a, x, y))\n  | Addition (a,b) -> (eval (a, x, y)) +. (eval (b, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet buildAddition (e1,e2) = Addition (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCube e = Cube e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (1, 18) with\n     | 1 -> build (rand, (depth - 1))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildSine (build (rand, (depth - 1)))\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 8 -> buildCosine (build (rand, (depth - 1)))\n     | 9 -> buildCosine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildCosine (build (rand, (depth - 1)))\n     | 12 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 13 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 14 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 15 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 16 -> buildCube (build (rand, (depth - 1)))\n     | 17 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Cube a ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString a) ^ (\"*\" ^ ((exprToString a) ^ \")\")))))\n  | Addition (a,b) ->\n      \"(\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand,depth) =\nif depth <= 0 \nthen\nmatch rand(1,3) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse \nmatch rand(1, 18) with\n| 1 -> build(rand,depth-1)\n| 2 -> buildCosine( build(rand,depth-1) )\n| 3 -> buildSine( build(rand,depth-1) ) \n| 4 -> buildSine( build(rand,depth-1) ) \n| 5 -> buildSine( build(rand,depth-1) ) \n| 6 -> buildSine( build(rand,depth-1) ) \n| 7 -> buildCosine( build(rand,depth-1) )\n| 8 -> buildCosine( build(rand,depth-1) )\n| 9 -> buildCosine( build(rand,depth-1) )\n| 10 -> buildCosine( build(rand,depth-1) )\n| 11 -> buildCosine( build(rand,depth-1) )\n| 12 -> buildAverage( (build(rand,depth-1)), build(rand,depth-1) )\n| 13 -> buildTimes( (build(rand,depth-1)), build(rand,depth-1) )\n| 14 -> buildThresh(  buildCosine( build(rand,depth-2) ), buildSine( build(rand,depth-2) ), buildSine( build(rand,depth-2) ) , buildCosine( build(rand,depth-2) ) )\n| 15 -> buildThresh(  buildCosine( build(rand,depth-2) ), buildSine( build(rand,depth-2) ), buildSine( build(rand,depth-2) ) , buildCosine( build(rand,depth-2) ) )\n| 16 -> buildCube( build(rand,depth-1) )\n| 17 -> buildAddition ( build(rand,depth-1),  build(rand,depth-1) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Cube of expr\n  | Addition of expr* expr;;\n\nlet buildAddition (e1,e2) = Addition (e1, e2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildCube e = Cube e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (1, 18) with\n     | 1 -> build (rand, (depth - 1))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildSine (build (rand, (depth - 1)))\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 8 -> buildCosine (build (rand, (depth - 1)))\n     | 9 -> buildCosine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildCosine (build (rand, (depth - 1)))\n     | 12 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 13 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 14 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 15 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 16 -> buildCube (build (rand, (depth - 1)))\n     | 17 ->\n         buildAddition\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec exprToString e = \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin(pi*\" ^ (exprToString a) ^ \")\"\n| Cosine a -> \"cos(pi*\" ^ (exprToString a) ^ \")\"\n| Average (a,b) -> \"((\" ^ (exprToString a) ^ \"+\" ^ (exprToString b) ^ \")/2)\"\n| Times (a,b) -> (exprToString a) ^ \"*\" ^ (exprToString b)\n| Thresh (a,b,c,d) -> \"(\" ^ (exprToString a) ^ \"<\" ^ (exprToString b) ^ \"?\" ^ (exprToString c) ^ \":\" ^ (exprToString d) ^ \")\"\n| _ -> \"_\"\n| Tan a -> \"tan(pi*\" ^ (exprToString a) ^ \")\"\n| Arc (a,b,c) -> \"sin(pi*\" ^ (exprToString (a (b,c)) ) ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Arc of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Tan a -> \"tan(pi*\" ^ ((exprToString a) ^ \")\")\n  | Arc (a,b,c) -> \"sin(pi*\" ^ ((exprToString (a (b, c))) ^ \")\");;\n", "out": "Characters 524-525:\n  | Arc (a,b,c) -> \"sin(pi*\" ^ (exprToString (a (b,c)) ) ^ \")\";;\n                                              ^\nError: This expression has type expr\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\n| Tan      of expr\n| Sin_Avg  of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sin_Avg of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin(pi*\" ^ (exprToString a) ^ \")\"\n| Cosine a -> \"cos(pi*\" ^ (exprToString a) ^ \")\"\n| Average (a,b) -> \"((\" ^ (exprToString a) ^ \"+\" ^ (exprToString b) ^ \")/2)\"\n| Times (a,b) -> (exprToString a) ^ \"*\" ^ (exprToString b)\n| Thresh (a,b,c,d) -> \"(\" ^ (exprToString a) ^ \"<\" ^ (exprToString b) ^ \"?\" ^ (exprToString c) ^ \":\" ^ (exprToString d) ^ \")\"\n| _ -> \"_\"\n| Tan a -> \"tan(pi*\" ^ (exprToString a) ^ \")\"\n| Sin_Avg (a,b,c) -> \"sin(pi*(\" ^ (exprToString  a) ^ \"+\" ^ (exprToString  b) ^ (exprToString c) ^ \")/3)\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sin_Avg of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Tan a -> \"tan(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sin_Avg (a,b,c) ->\n      \"sin(pi*(\" ^\n        ((exprToString a) ^\n           (\"+\" ^ ((exprToString b) ^ ((exprToString c) ^ \")/3)\"))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "exprToString Sin_Avg(1,2,3)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sin_Avg of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Tan a -> \"tan(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sin_Avg (a,b,c) ->\n      \"sin(pi*(\" ^\n        ((exprToString a) ^\n           (\"+\" ^ ((exprToString b) ^ ((exprToString c) ^ \")/3)\"))));;\n\nlet _ = exprToString Sin_Avg (1, 2, 3);;\n", "out": "Characters 0-12:\n  exprToString Sin_Avg(1,2,3);;\n  ^^^^^^^^^^^^\nError: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "exprToString (Sin_Avg(1,2,3))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sin_Avg of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Tan a -> \"tan(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sin_Avg (a,b,c) ->\n      \"sin(pi*(\" ^\n        ((exprToString a) ^\n           (\"+\" ^ ((exprToString b) ^ ((exprToString c) ^ \")/3)\"))));;\n\nlet _ = exprToString (Sin_Avg (1, 2, 3));;\n", "out": "Characters 22-23:\n  exprToString (Sin_Avg(1,2,3));;\n                        ^\nError: This expression has type int but an expression was expected of type\n         expr\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "exprToString (Sin_Avg(VarX(),VarY(),VarX()))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sin_Avg of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Tan a -> \"tan(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sin_Avg (a,b,c) ->\n      \"sin(pi*(\" ^\n        ((exprToString a) ^\n           (\"+\" ^ ((exprToString b) ^ ((exprToString c) ^ \")/3)\"))));;\n\nlet _ = exprToString (Sin_Avg ((VarX ()), (VarY ()), (VarX ())));;\n", "out": "Characters 22-28:\n  exprToString (Sin_Avg(VarX(),VarY(),VarX()));;\n                        ^^^^^^\nError: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "exprToString (Sin_Avg (VarX(), VarY(), VarX()))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sin_Avg of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Tan a -> \"tan(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sin_Avg (a,b,c) ->\n      \"sin(pi*(\" ^\n        ((exprToString a) ^\n           (\"+\" ^ ((exprToString b) ^ ((exprToString c) ^ \")/3)\"))));;\n\nlet _ = exprToString (Sin_Avg ((VarX ()), (VarY ()), (VarX ())));;\n", "out": "Characters 23-29:\n  exprToString (Sin_Avg (VarX(), VarY(), VarX()));;\n                         ^^^^^^\nError: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "exprToString (Sin_Avg (Average(VarX(),VarY()), VarY(), VarX()))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sin_Avg of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Tan a -> \"tan(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sin_Avg (a,b,c) ->\n      \"sin(pi*(\" ^\n        ((exprToString a) ^\n           (\"+\" ^ ((exprToString b) ^ ((exprToString c) ^ \")/3)\"))));;\n\nlet _ =\n  exprToString\n    (Sin_Avg ((Average ((VarX ()), (VarY ()))), (VarY ()), (VarX ())));;\n", "out": "Characters 31-37:\n  exprToString (Sin_Avg (Average(VarX(),VarY()), VarY(), VarX()));;\n                                 ^^^^^^\nError: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "exprToString (Sin_Avg (VarX, VarY, VarX))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sin_Avg of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Tan a -> \"tan(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sin_Avg (a,b,c) ->\n      \"sin(pi*(\" ^\n        ((exprToString a) ^\n           (\"+\" ^ ((exprToString b) ^ ((exprToString c) ^ \")/3)\"))));;\n\nlet _ = exprToString (Sin_Avg (VarX, VarY, VarX));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "exprToString (Tan VarX)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sin_Avg of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Tan a -> \"tan(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sin_Avg (a,b,c) ->\n      \"sin(pi*(\" ^\n        ((exprToString a) ^\n           (\"+\" ^ ((exprToString b) ^ ((exprToString c) ^ \")/3)\"))));;\n\nlet _ = exprToString (Tan VarX);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin(pi*\" ^ (exprToString a) ^ \")\"\n| Cosine a -> \"cos(pi*\" ^ (exprToString a) ^ \")\"\n| Average (a,b) -> \"((\" ^ (exprToString a) ^ \"+\" ^ (exprToString b) ^ \")/2)\"\n| Times (a,b) -> (exprToString a) ^ \"*\" ^ (exprToString b)\n| Thresh (a,b,c,d) -> \"(\" ^ (exprToString a) ^ \"<\" ^ (exprToString b) ^ \"?\" ^ (exprToString c) ^ \":\" ^ (exprToString d) ^ \")\"\n| _ -> \"_\"\n| Tan a -> \"tan(pi*\" ^ (exprToString a) ^ \")\"\n| Sin_Avg (a,b,c) -> \"sin(pi*(\" ^ (exprToString  a) ^ \"+\" ^ (exprToString  b) ^ (exprToString c) ^ \")/3)\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sin_Avg of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Tan a -> \"tan(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sin_Avg (a,b,c) ->\n      \"sin(pi*(\" ^\n        ((exprToString a) ^\n           (\"+\" ^ ((exprToString b) ^ ((exprToString c) ^ \")/3)\"))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "exprToString (Tan VarX)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sin_Avg of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | _ -> \"_\"\n  | Tan a -> \"tan(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sin_Avg (a,b,c) ->\n      \"sin(pi*(\" ^\n        ((exprToString a) ^\n           (\"+\" ^ ((exprToString b) ^ ((exprToString c) ^ \")/3)\"))));;\n\nlet _ = exprToString (Tan VarX);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin(pi*\" ^ (exprToString a) ^ \")\"\n| Cosine a -> \"cos(pi*\" ^ (exprToString a) ^ \")\"\n| Average (a,b) -> \"((\" ^ (exprToString a) ^ \"+\" ^ (exprToString b) ^ \")/2)\"\n| Times (a,b) -> (exprToString a) ^ \"*\" ^ (exprToString b)\n| Thresh (a,b,c,d) -> \"(\" ^ (exprToString a) ^ \"<\" ^ (exprToString b) ^ \"?\" ^ (exprToString c) ^ \":\" ^ (exprToString d) ^ \")\"\n| Tan a -> \"tan(pi*\" ^ (exprToString a) ^ \")\"\n| Sin_Avg (a,b,c) -> \"sin(pi*(\" ^ (exprToString  a) ^ \"+\" ^ (exprToString  b) ^ (exprToString c) ^ \")/3)\"\n| _ -> \"_\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sin_Avg of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Tan a -> \"tan(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sin_Avg (a,b,c) ->\n      \"sin(pi*(\" ^\n        ((exprToString a) ^\n           (\"+\" ^ ((exprToString b) ^ ((exprToString c) ^ \")/3)\"))))\n  | _ -> \"_\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "exprToString (Tan VarX)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sin_Avg of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Tan a -> \"tan(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sin_Avg (a,b,c) ->\n      \"sin(pi*(\" ^\n        ((exprToString a) ^\n           (\"+\" ^ ((exprToString b) ^ ((exprToString c) ^ \")/3)\"))))\n  | _ -> \"_\";;\n\nlet _ = exprToString (Tan VarX);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin(pi*\" ^ (exprToString a) ^ \")\"\n| Cosine a -> \"cos(pi*\" ^ (exprToString a) ^ \")\"\n| Average (a,b) -> \"((\" ^ (exprToString a) ^ \"+\" ^ (exprToString b) ^ \")/2)\"\n| Times (a,b) -> (exprToString a) ^ \"*\" ^ (exprToString b)\n| Thresh (a,b,c,d) -> \"(\" ^ (exprToString a) ^ \"<\" ^ (exprToString b) ^ \"?\" ^ (exprToString c) ^ \":\" ^ (exprToString d) ^ \")\"\n| Tan a -> \"tan(pi*\" ^ (exprToString a) ^ \")\"\n| Sin_Avg (a,b,c) -> \"sin(pi*(\" ^ (exprToString  a) ^ \"+\" ^ (exprToString  b) ^ (exprToString c) ^ \")/3)\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sin_Avg of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Tan a -> \"tan(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sin_Avg (a,b,c) ->\n      \"sin(pi*(\" ^\n        ((exprToString a) ^\n           (\"+\" ^ ((exprToString b) ^ ((exprToString c) ^ \")/3)\"))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin(pi*\" ^ (exprToString a) ^ \")\"\n| Cosine a -> \"cos(pi*\" ^ (exprToString a) ^ \")\"\n| Average (a,b) -> \"((\" ^ (exprToString a) ^ \"+\" ^ (exprToString b) ^ \")/2)\"\n| Times (a,b) -> (exprToString a) ^ \"*\" ^ (exprToString b)\n| Thresh (a,b,c,d) -> \"(\" ^ (exprToString a) ^ \"<\" ^ (exprToString b) ^ \"?\" ^ (exprToString c) ^ \":\" ^ (exprToString d) ^ \")\"\n| Tan a -> \"tan(pi*\" ^ (exprToString a) ^ \")\"\n| Sin_Avg (a,b,c) -> \"sin(pi*((\" ^ (exprToString  a) ^ \"+\" ^ (exprToString  b) ^ \"+\" ^ (exprToString c) ^ \"))/3)\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sin_Avg of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Tan a -> \"tan(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sin_Avg (a,b,c) ->\n      \"sin(pi*((\" ^\n        ((exprToString a) ^\n           (\"+\" ^ ((exprToString b) ^ (\"+\" ^ ((exprToString c) ^ \"))/3)\")))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin(pi*\" ^ (exprToString a) ^ \")\"\n| Cosine a -> \"cos(pi*\" ^ (exprToString a) ^ \")\"\n| Average (a,b) -> \"((\" ^ (exprToString a) ^ \"+\" ^ (exprToString b) ^ \")/2)\"\n| Times (a,b) -> (exprToString a) ^ \"*\" ^ (exprToString b)\n| Thresh (a,b,c,d) -> \"(\" ^ (exprToString a) ^ \"<\" ^ (exprToString b) ^ \"?\" ^ (exprToString c) ^ \":\" ^ (exprToString d) ^ \")\"\n| Tan a -> \"tan(pi*\" ^ (exprToString a) ^ \")\"\n| Sin_Avg (a,b,c) -> \"sin(pi*(\" ^ (exprToString  a) ^ \"+\" ^ (exprToString  b) ^ \"+\" ^ (exprToString c) ^ \")/3)\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sin_Avg of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Tan a -> \"tan(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sin_Avg (a,b,c) ->\n      \"sin(pi*(\" ^\n        ((exprToString a) ^\n           (\"+\" ^ ((exprToString b) ^ (\"+\" ^ ((exprToString c) ^ \")/3)\")))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin(pi*\" ^ (exprToString a) ^ \")\"\n| Cosine a -> \"cos(pi*\" ^ (exprToString a) ^ \")\"\n| Average (a,b) -> \"((\" ^ (exprToString a) ^ \"+\" ^ (exprToString b) ^ \")/2)\"\n| Times (a,b) -> (exprToString a) ^ \"*\" ^ (exprToString b)\n| Thresh (a,b,c,d) -> \"(\" ^ (exprToString a) ^ \"<\" ^ (exprToString b) ^ \"?\" ^ (exprToString c) ^ \":\" ^ (exprToString d) ^ \")\"\n| Tan a -> \"tan(pi*\" ^ (exprToString a) ^ \")\"\n| Sin_Avg (a,b,c) -> \"sin(pi*((\" ^ (exprToString  a) ^ \"+\" ^ (exprToString  b) ^ \"+\" ^ (exprToString c) ^ \")/3))\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sin_Avg of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Tan a -> \"tan(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sin_Avg (a,b,c) ->\n      \"sin(pi*((\" ^\n        ((exprToString a) ^\n           (\"+\" ^ ((exprToString b) ^ (\"+\" ^ ((exprToString c) ^ \")/3))\")))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "exprToString (Sin_Avg (VarX,VarY,VarX))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sin_Avg of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Tan a -> \"tan(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sin_Avg (a,b,c) ->\n      \"sin(pi*((\" ^\n        ((exprToString a) ^\n           (\"+\" ^ ((exprToString b) ^ (\"+\" ^ ((exprToString c) ^ \")/3))\")))));;\n\nlet _ = exprToString (Sin_Avg (VarX, VarY, VarX));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\n| Tan      of expr\n| Sin_Avg  of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sin_Avg of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let buildSine_Avg(e1,e2)           = Sine_Avg(e1,e2, e3)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sine_Avg of expr* expr* expr;;\n\nlet buildSine_Avg (e1,e2) = Sine_Avg (e1, e2, e3);;\n", "out": "Characters 53-55:\n  let buildSine_Avg(e1,e2)           = Sine_Avg(e1,e2, e3);;\n                                                       ^^\nError: Unbound value e3\n"}, {"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )\n| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )\n| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)\n| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )\n| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))\nthen (eval (c,x,y))\nelse (eval (d,x,y))\n| Tan a -> eval(a, tan(pi*.(x)), tan(pi*.(y)) )\n| Sine_Avg (a,b,c) -> eval( eval (a, sin(pi*x), sin(pi*y)) , eval (b, sin(pi*x), sin(pi*y)), eval (c, sin(pi*x), sin(pi*y)) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sine_Avg of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Tan a -> eval (a, (tan (pi *. x)), (tan (pi *. y)))\n  | Sine_Avg (a,b,c) ->\n      eval\n        ((eval (a, (sin (pi * x)), (sin (pi * y)))),\n          (eval (b, (sin (pi * x)), (sin (pi * y)))),\n          (eval (c, (sin (pi * x)), (sin (pi * y)))));;\n", "out": "Characters 464-466:\n  | Sine_Avg (a,b,c) -> eval( eval (a, sin(pi*x), sin(pi*y)) , eval (b, sin(pi*x), sin(pi*y)), eval (c, sin(pi*x), sin(pi*y)) );;\n                                           ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildSine_Avg(e1,e2, e3)           = Sine_Avg(e1,e2, e3)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sine_Avg of expr* expr* expr;;\n\nlet buildSine_Avg (e1,e2,e3) = Sine_Avg (e1, e2, e3);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )\n| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )\n| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)\n| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )\n| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))\nthen (eval (c,x,y))\nelse (eval (d,x,y))\n| Tan a -> eval(a, tan(pi*.(x)), tan(pi*.(y)) )\n| Sine_Avg (a,b,c) -> eval( eval (a, sin(pi*.(x)), sin(pi*.y)) , eval (b, sin(pi*.x), sin(pi*.y)), eval (c, sin(pi*.x), sin(pi*.y)) )/.(3.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sine_Avg of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Tan a -> eval (a, (tan (pi *. x)), (tan (pi *. y)))\n  | Sine_Avg (a,b,c) ->\n      (eval\n         ((eval (a, (sin (pi *. x)), (sin (pi *. y)))),\n           (eval (b, (sin (pi *. x)), (sin (pi *. y)))),\n           (eval (c, (sin (pi *. x)), (sin (pi *. y))))))\n        /. 3.0;;\n", "out": "Characters 451-485:\n  | Sine_Avg (a,b,c) -> eval( eval (a, sin(pi*.(x)), sin(pi*.y)) , eval (b, sin(pi*.x), sin(pi*.y)), eval (c, sin(pi*.x), sin(pi*.y)) )/.(3.0);;\n                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         expr\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )\n| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )\n| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)\n| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )\n| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))\nthen (eval (c,x,y))\nelse (eval (d,x,y))\n| Tan a -> eval(a, tan(pi*.(x)), tan(pi*.(y)) )\n| Sine_Avg (a,b,c) -> ( eval (a, sin(pi*.(x)), sin(pi*.y)) + eval (b, sin(pi*.x), sin(pi*.y)) + eval (c, sin(pi*.x), sin(pi*.y)) )/.(3.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sine_Avg of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Tan a -> eval (a, (tan (pi *. x)), (tan (pi *. y)))\n  | Sine_Avg (a,b,c) ->\n      (((eval (a, (sin (pi *. x)), (sin (pi *. y)))) +\n          (eval (b, (sin (pi *. x)), (sin (pi *. y)))))\n         + (eval (c, (sin (pi *. x)), (sin (pi *. y)))))\n        /. 3.0;;\n", "out": "Characters 447-481:\n  | Sine_Avg (a,b,c) -> ( eval (a, sin(pi*.(x)), sin(pi*.y)) + eval (b, sin(pi*.x), sin(pi*.y)) + eval (c, sin(pi*.x), sin(pi*.y)) )/.(3.0);;\n                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> eval(a, sin(pi*.(x)), sin(pi*.(y)) )\n| Cosine a -> eval(a, cos(pi*.(x)), cos(pi*.(y)) )\n| Average (a,b) -> ( (eval (a,x,y))  +. (eval(b,x,y) ))/.(2.0)\n| Times (a,b) -> ( (eval (a,x,y)) *. (eval (b,x,y)) )\n| Thresh (a, b, c, d)-> if (eval (a,x,y))<(eval (b,x,y))\nthen (eval (c,x,y))\nelse (eval (d,x,y))\n| Tan a -> eval(a, tan(pi*.(x)), tan(pi*.(y)) )\n| Sine_Avg (a,b,c) -> ( eval (a, sin(pi*.(x)), sin(pi*.y)) +. eval (b, sin(pi*.x), sin(pi*.y)) +. eval (c, sin(pi*.x), sin(pi*.y)) )/.(3.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sine_Avg of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Tan a -> eval (a, (tan (pi *. x)), (tan (pi *. y)))\n  | Sine_Avg (a,b,c) ->\n      (((eval (a, (sin (pi *. x)), (sin (pi *. y)))) +.\n          (eval (b, (sin (pi *. x)), (sin (pi *. y)))))\n         +. (eval (c, (sin (pi *. x)), (sin (pi *. y)))))\n        /. 3.0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand,depth) =\nif depth <= 0 \nthen\nmatch rand(1,3) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse \nmatch rand(1, 18) with\n| 1 -> build(rand,depth-1)\n| 2 -> buildCosine( build(rand,depth-1) )\n| 3 -> buildSine( build(rand,depth-1) ) \n| 4 -> buildSine( build(rand,depth-1) ) \n| 5 -> buildSine( build(rand,depth-1) ) \n| 6 -> buildSine( build(rand,depth-1) ) \n| 7 -> buildCosine( build(rand,depth-1) )\n| 8 -> buildCosine( build(rand,depth-1) )\n| 9 -> buildCosine( build(rand,depth-1) )\n| 10 -> buildCosine( build(rand,depth-1) )\n| 11 -> buildCosine( build(rand,depth-1) )\n| 12 -> buildAverage( (build(rand,depth-1)), build(rand,depth-1) )\n| 13 -> buildTimes( (build(rand,depth-1)), build(rand,depth-1) )\n| 14 -> buildThresh(  buildCosine( build(rand,depth-2) ), buildSine( build(rand,depth-2) ), buildSine( build(rand,depth-2) ) , buildCosine( build(rand,depth-2) ) )\n| 15 -> buildThresh(  buildCosine( build(rand,depth-2) ), buildSine( build(rand,depth-2) ), buildSine( build(rand,depth-2) ) , buildCosine( build(rand,depth-2) ) )\n| 16 -> buildTan( build(rand,depth-1) )\n| 17 -> buildSine_Avg ( build(rand,depth-1),  build(rand,depth-1), build(rand,depth-1) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sine_Avg of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSine_Avg (e1,e2,e3) = Sine_Avg (e1, e2, e3);;\n\nlet buildTan e = Tan e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (1, 18) with\n     | 1 -> build (rand, (depth - 1))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildSine (build (rand, (depth - 1)))\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 8 -> buildCosine (build (rand, (depth - 1)))\n     | 9 -> buildCosine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildCosine (build (rand, (depth - 1)))\n     | 12 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 13 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 14 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 15 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 16 -> buildTan (build (rand, (depth - 1)))\n     | 17 ->\n         buildSine_Avg\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> eval (a, (sin (pi *. x)), (sin (pi *. y)))\n  | Cosine a -> eval (a, (cos (pi *. x)), (cos (pi *. y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Tan a -> eval (a, (tan (pi *. x)), (tan (pi *. y)))\n  | Sine_Avg (a,b,c) ->\n      (((eval (a, (sin (pi *. x)), (sin (pi *. y)))) +.\n          (eval (b, (sin (pi *. x)), (sin (pi *. y)))))\n         +. (eval (c, (sin (pi *. x)), (sin (pi *. y)))))\n        /. 3.0;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Tan of expr\n  | Sine_Avg of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSine_Avg (e1,e2,e3) = Sine_Avg (e1, e2, e3);;\n\nlet buildTan e = Tan e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth <= 0\n  then match rand (1, 3) with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (match rand (1, 18) with\n     | 1 -> build (rand, (depth - 1))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 -> buildSine (build (rand, (depth - 1)))\n     | 4 -> buildSine (build (rand, (depth - 1)))\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 8 -> buildCosine (build (rand, (depth - 1)))\n     | 9 -> buildCosine (build (rand, (depth - 1)))\n     | 10 -> buildCosine (build (rand, (depth - 1)))\n     | 11 -> buildCosine (build (rand, (depth - 1)))\n     | 12 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 13 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 14 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 15 ->\n         buildThresh\n           ((buildCosine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildSine (build (rand, (depth - 2)))),\n             (buildCosine (build (rand, (depth - 2)))))\n     | 16 -> buildTan (build (rand, (depth - 1)))\n     | 17 ->\n         buildSine_Avg\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Tan a -> \"tan(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sine_Avg (a,b,c) ->\n      \"sin(pi*((\" ^\n        ((exprToString a) ^\n           (\"+\" ^ ((exprToString b) ^ (\"+\" ^ ((exprToString c) ^ \")/3))\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper acc (d, k, l);;\n", "out": ""}]}
