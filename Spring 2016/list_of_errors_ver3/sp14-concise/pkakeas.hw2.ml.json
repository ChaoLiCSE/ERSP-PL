{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> []\n| (num,name)::tail ->\nif (num, name) = (d, k) then name\nelse assoc (d, k, tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (num,name)::tail ->\nif num = k then name\nelse assoc(d, k, tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n(* If list is empty, then return the first int *)\n| [] -> d\n(* IF it is of this pattern, check if the number is equal to the tuple's number *)\n| (name,num)::tail ->\n(* If it is, return the number *)\nif name = k then num\nelse assoc(d, k, tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n(* If list is empty, then return the first int *)\n| [] -> d\n(* IF it is of this pattern, check if the number is equal to the tuple's number *)\n| (name,num)::tail ->\n(* If it is, return the number; else recursively call with remainder *)\nif name = k then num\nelse assoc(d, k, tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n(* If list is empty, then return the first int *)\n| [] -> d\n(* IF it is of this pattern, check if the number is equal to the tuple's number *)\n| (name,num)::tail ->\n(* If it is, return the number; else recursively call with remainder *)\nif name = k then num\nelse assoc(d, k, tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n(* If list is empty, then return the first int *)\n| [] -> d\n(* If it is of this pattern, check if the number is equal to the tuple's number *)\n| (name,num)::tail ->\n(* If it is, return the number; else recursively call with remainder *)\nif name = k then num\nelse assoc(d, k, tail)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 139-144:\n  if List.mem h l then h::seen' \n                          ^^^^^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        if List.mem h l\n        then h :: seen'\n        else (let rest' = t in helper (seen', rest')) in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = h in\nif List.mem h l then h::seen' \nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = seen in\nif List.mem h seen' then h::seen \nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = seen in\nif List.mem h seen then h::seen' \nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = seen in\nif List.mem h seen then h::seen' \nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 142-147:\n  if List.mem h seen then h::seen' \n                             ^^^^^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        if List.mem h seen\n        then h :: seen'\n        else (let rest' = t in helper (seen', rest')) in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = h in\nif List.mem h seen then h::seen' \nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = l in\nif List.mem h l then h::seen' \nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = seen in\nif List.mem h seen then h::seen' \nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = l in\nif List.mem h seen then h::seen' \nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = l in\nif List.mem h seen then h::seen \nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = l in\nif List.mem h seen' then h::seen \nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = seen in\nif List.mem h seen then h::seen'\nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = l in\nif List.mem h seen' then h::seen\nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \n(* Seen' should hold only the unique ones *)\nlet seen' = l in\nif List.mem h seen' = false then h::seen\nelse \n(* If the head is NOT in the list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n(* If list is empty, then return the first int *)\n| [] -> d\n(* I it is of this pattern, check if the number is equal to the tuple's number *)\n| (name,num)::tail ->\n(* If it is, return the number; else recursively call with remainder *)\nif name = k then num\nelse assoc(d, k, tail)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 144-146:\n  if List.mem h seen = false then h::seen\n                                   ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then h :: seen in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t ->\n(* Seen' should hold only the unique ones *)\nlet seen' =  \nif List.mem h seen = false then h::seen\nin\n(* If the head is NOT in hte list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t ->\n(* Seen' should hold only the unique ones *)\nlet seen' =  \nif List.mem h seen = false then h::seen\nelse seen\nin\n(* If the head is NOT in hte list, put it there, else recurse on rest of it *)\n(* Rest' holds the duplicates *)\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n(* If list is empty, then return the first int *)\n| [] -> d\n(* I it is of this pattern, check if the number is equal to the tuple's number *)\n| (name,num)::tail ->\n(* If it is, return the number; else recursively call with remainder *)\nif name = k then num\nelse assoc(d, k, tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n(* If list is empty, then return the first int *)\n| [] -> d\n(* I it is of this pattern, check if the number is equal to the tuple's number *)\n| (name,num)::tail ->\n(* If it is, return the number; else recursively call with remainder *)\nif name = k then num\nelse assoc(d, k, tail)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 97-100:\n  else num\n       ^^^\nError: Unbound value num\n", "min": "\nlet rec wwhile (f,b) =\n  match (f, b) with\n  | (func,param) -> if param = true then func param else num\n  | _ -> 0;;\n", "in": "let rec wwhile (f,b) = match (f,b) with\n| (func, param) ->\nif param = true then func param \nelse num\n| _ -> 0"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 97-100:\n  else num\n       ^^^\nError: Unbound value num\n", "min": "\nlet rec wwhile (f,b) =\n  match (f, b) with\n  | (func,param) -> if param = true then func param else num\n  | _ -> b;;\n", "in": "let rec wwhile (f,b) = match (f,b) with\n| (func, param) ->\nif param = true then func param \nelse num\n| _ -> b"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = match (f,b) with\n| (func, param) ->\nif param = true then func param \nelse param\n| _ -> b"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 103-104:\n  | _ -> b;;\n         ^\nError: This expression has type bool but an expression was expected of type\n         int\n", "min": "\nlet rec wwhile (f,b) =\n  match (f, b) with\n  | (func,param) -> if param = true then f param else 0\n  | _ -> b;;\n", "in": "let rec wwhile (f,b) = match (f,b) with\n| (func, param) ->\nif param = true then f param \nelse 0\n| _ -> b"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = match (f,b) with\n| (func, param) ->\nif param = true then f param \nelse 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = match b with\n| (v, b) ->\nif b = true then f v \nelse  f (v-1)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 83-84:\n  else wwhile f e;;\n              ^\nError: This expression has type 'a but an expression was expected of type\n         'a * (('b -> 'c) * bool)\n       The type variable 'a occurs inside 'a * (('b -> 'c) * bool)\n", "min": "\nlet rec wwhile (f,b) =\n  match b with | (e,boo) -> if boo = true then e else wwhile f e;;\n", "in": "let rec wwhile (f,b) = match b with\n| (e, boo) ->\nif boo = true then e\nelse wwhile f e"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 83-84:\n  else wwhile e b;;\n              ^\nError: This expression has type 'a -> 'b\n       but an expression was expected of type 'c * (('a -> 'b) * bool)\n", "min": "\nlet rec wwhile (f,b) =\n  match b with | (e,boo) -> if boo = true then e else wwhile e b;;\n", "in": "let rec wwhile (f,b) = match b with\n| (e, boo) ->\nif boo = true then e\nelse wwhile e b"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 83-84:\n  else wwhile b;;\n              ^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b * ('a * bool)\n", "min": "\nlet rec wwhile (f,b) =\n  match b with | (e,boo) -> if boo = true then e else wwhile b;;\n", "in": "let rec wwhile (f,b) = match b with\n| (e, boo) ->\nif boo = true then e\nelse wwhile b"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 83-84:\n  else wwhile f b;;\n              ^\nError: This expression has type 'a but an expression was expected of type\n         'a * (('b -> 'c) * bool)\n       The type variable 'a occurs inside 'a * (('b -> 'c) * bool)\n", "min": "\nlet rec wwhile (f,b) =\n  match b with | (e,boo) -> if boo = true then e else wwhile f b;;\n", "in": "let rec wwhile (f,b) = match b with\n| (e, boo) ->\nif boo = true then e\nelse wwhile f b"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = match b with\n| (e, boo) ->\nif boo = true then e"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 71-72:\n  if boo = true then e b;;\n                       ^\nError: This expression has type ('a -> 'b) * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b) * bool\n", "min": "\nlet rec wwhile (f,b) = match b with | (e,boo) -> if boo = true then e b;;\n", "in": "let rec wwhile (f,b) = match b with\n| (e, boo) ->\nif boo = true then e b"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 85-92:\n  if boo = true then wwhile(f, express)\n                               ^^^^^^^\nError: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match b with\n  | (express,boo) -> if boo = true then wwhile (f, express) else express;;\n", "in": "let rec wwhile (f,b) = match b with\n| (express, boo) ->\nif boo = true then wwhile(f, express)\nelse express"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = match b with\n| (express, boo) ->\nif boo = true then wwhile(express, b)\nelse express"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 57-58:\n  wwhile (f, 2);;\n             ^\nError: This expression has type int but an expression was expected of type\n         (int -> int * bool) * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match b with\n  | (express,boo) -> if boo = true then wwhile (express, b) else express;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet ans = f b in\nmatch ans with\n| (num, boo) ->\nif boo = true then wwhile(f, num)\nelse num"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \n(* Save the function and parameter into an expression *)\nlet ans = f b in\nmatch ans with\n| (num, tf) ->\n(* If boolean is true, then loop again on new value *)\nif tf = true then wwhile(f, num)\n(* Otherwise, return old value *)\nelse num"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((\nlet xx b = \nlet cal = f b in \nif b == cal then (cal, false) else (cal, true) in xx\n),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nwwhile \n((let xx y = \nlet cal = f y in \nif y == cal then (cal, false)\nelse (cal, true) in xx\n),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 114-116:\n  else (cal, true) in xx\n                      ^^\nError: Unbound value xx\n", "min": "\nlet rec wwhile (f,b) =\n  let ans = f b in\n  match ans with | (num,tf) -> if tf = true then wwhile (f, num) else num;;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let func p =\n        let cal = f p in if p == cal then (cal, false) else (cal, true) in\n      xx), b);;\n", "in": "let fixpoint (f,b) = \nwwhile \n((let func p = \nlet cal = f p in \nif p == cal then (cal, false)\nelse (cal, true) in xx\n),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nwwhile \n((let func p = \nlet cal = f p in \nif p == cal then (cal, false)\nelse (cal, true) in func\n),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n(* If list is empty, then return the first int *)\n| [] -> d\n(* I it is of this pattern, check if the number is equal to the tuple's number *)\n| (name,num)::tail ->\n(* If it is, return the number; else recursively call with remainder *)\nif name = k then num\nelse assoc(d, k, tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nwwhile \n((let func p = \nlet func2 = f p in \nif p == func2 then (func2, false)\nelse (func2, true) in func\n),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nwwhile \n((let func p = \nlet ans = f p in \nif p = ans then (ans, false)\nelse (ans, true) in func\n),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n(* If list is empty, then return the first int *)\n| [] -> d\n(* I it is of this pattern, check if the number is equal to the tuple's number *)\n| (name,num)::tail ->\n(* If it is, return the number; else recursively call with remainder *)\nif name = k then num\nelse assoc(d, k, tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n(* If list is empty, then return the first int *)\n| [] -> d\n(* I it is of this pattern, check if the number is equal to the tuple's number *)\n| (name,num)::tail ->\n(* If it is, return the number; else recursively call with remainder *)\nif name = k then num\nelse assoc(d, k, tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\nVarX -> \"X\"\n| VarY -> \"Y\"\n| Sine sin  -> \"sin\"\n| Cosine cos -> \"cos\"\n| Average (n1, n2) ->  \"(n1 + n2 / 2 )\"\n| Times (t1, t2) -> \"(t1 * t2)\"\n| Thresh (th1, th2, th3, th4) -> \"thresh\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"X\"\n| VarY -> \"Y\"\n| Sine sin  -> \"sin\"\n| Cosine cos -> \"cos\"\n| Average (n1, n2) ->  \"(n1 + n2 / 2 )\"\n| Times (t1, t2) -> \"(t1 * t2)\"\n| Thresh (th1, th2, th3, th4) -> \"thresh\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"X\"\n| VarY -> \"Y\"\n| Sine sin  -> \"( sin \"\n| Cosine cos -> \"cos\"\n| Average (n1, n2) ->  \"( \" ^ (exprToString n1) ^ \"+\" ^ (exprToString n2) ^ \")/2\"\n| Times (t1, t2) -> \"(t1 * t2)\"\n| Thresh (th1, th2, th3, th4) -> \"bullshit\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\nVarX -> \"X\"\n| VarY -> \"Y\"\n| Sine sin  -> \"( sin \"\n| Cosine cos -> \"cos\"\n| Average (n1, n2) ->  \"( \" ^ (exprToString n1) ^ \"+\" ^ (exprToString n2) ^ \")/2\"\n| Times (t1, t2) -> \"(t1 * t2)\"\n| Thresh (th1, th2, th3, th4) -> \"bullshit\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n(* If list is empty, then return the first int *)\n| [] -> d\n(* I it is of this pattern, check if the number is equal to the tuple's number *)\n| (name,num)::tail ->\n(* If it is, return the number; else recursively call with remainder *)\nif name = k then num\nelse assoc(d, k, tail)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 301-304:\n  | Times (t1, t2) -> \"(\" ^ (exprToString t1) ^ \"*\" (exprToString t2) ^ \")\"\n                                                ^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine sin -> \"(sin(pi*\" ^ ((exprToString sin) ^ \")\")\n  | Cosine cos -> \"(cos(pi*\" ^ ((exprToString cos) ^ \")\")\n  | Average (n1,n2) ->\n      \"( \" ^ ((exprToString n1) ^ (\"+\" ^ ((exprToString n2) ^ \")/2\")))\n  | Times (t1,t2) ->\n      \"(\" ^ ((exprToString t1) ^ ((\"*\" (exprToString t2)) ^ \")\"))\n  | Thresh (th1,th2,th3,th4) -> \"bullshit\";;\n", "in": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine sin  -> \"(sin(pi*\" ^ (exprToString sin) ^ \")\"  \n| Cosine cos -> \"(cos(pi*\" ^ (exprToString cos) ^ \")\"\n| Average (n1, n2) ->  \"( \" ^ (exprToString n1) ^ \"+\" ^ (exprToString n2) ^ \")/2\"\n| Times (t1, t2) -> \"(\" ^ (exprToString t1) ^ \"*\" (exprToString t2) ^ \")\"\n| Thresh (th1, th2, th3, th4) -> \"bullshit\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine sin  -> \"(sin(pi*\" ^ (exprToString sin) ^ \")\"  \n| Cosine cos -> \"(cos(pi*\" ^ (exprToString cos) ^ \")\"\n| Average (n1, n2) ->  \"( \" ^ (exprToString n1) ^ \"+\" ^ (exprToString n2) ^ \")/2\"\n| Times (t1, t2) -> \"(\" ^ (exprToString t1) ^ \"*\" ^ (exprToString t2) ^ \")\"\n| Thresh (th1, th2, th3, th4) -> \"bullshit\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine sin  -> \"(sin(pi*\" ^ (exprToString sin) ^ \")\"  \n| Cosine cos -> \"(cos(pi*\" ^ (exprToString cos) ^ \")\"\n| Average (n1, n2) ->  \"( \" ^ (exprToString n1) ^ \"+\" ^ (exprToString n2) ^ \")/2\"\n| Times (t1, t2) -> \"(\" ^ (exprToString t1) ^ \"*\" ^ (exprToString t2) ^ \")\"\n| Thresh (th1, th2, th3, th4) -> \"(\" ^ (exprToString th1) ^ \"<\" ^ \n(exprToString th2) ^ \"?\" ^ (exprToString th3) ^ \n\":\" ^ (exprToString th4) ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine sin  -> \"(sin(pi*\" ^ (exprToString sin) ^ \")\"  \n| Cosine cos -> \"(cos(pi*\" ^ (exprToString cos) ^ \")\"\n| Average (n1, n2) ->  \"( \" ^ (exprToString n1) ^ \"+\" ^ (exprToString n2) ^ \")/2\"\n| Times (t1, t2) -> \"(\" ^ (exprToString t1) ^ \"*\" ^ (exprToString t2) ^ \")\"\n| Thresh (th1, th2, th3, th4) -> \"(\" ^ (exprToString th1) ^ \"<\" ^ \n(exprToString th2) ^ \"?\" ^ (exprToString th3) ^ \n\":\" ^ (exprToString th4) ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine sin  -> \"sin(pi*\" ^ (exprToString sin) ^ \")\"  \n| Cosine cos -> \"cos(pi*\" ^ (exprToString cos) ^ \")\"\n| Average (n1, n2) ->  \"( \" ^ (exprToString n1) ^ \"+\" ^ (exprToString n2) ^ \")/2\"\n| Times (t1, t2) -> \"(\" ^ (exprToString t1) ^ \"*\" ^ (exprToString t2) ^ \")\"\n| Thresh (th1, th2, th3, th4) -> \"(\" ^ (exprToString th1) ^ \"<\" ^ \n(exprToString th2) ^ \"?\" ^ (exprToString th3) ^ \n\":\" ^ (exprToString th4) ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine sin  -> \"sin(pi*\" ^ (exprToString sin) ^ \")\"  \n| Cosine cos -> \"cos(pi*\" ^ (exprToString cos) ^ \")\"\n| Average (n1, n2) ->  \"(\" ^ (exprToString n1) ^ \"+\" ^ (exprToString n2) ^ \")/2\"\n| Times (t1, t2) -> (exprToString t1) ^ \"*\" ^ (exprToString t2) \n| Thresh (th1, th2, th3, th4) -> \"(\" ^ (exprToString th1) ^ \"<\" ^ \n(exprToString th2) ^ \"?\" ^ (exprToString th3) ^ \n\":\" ^ (exprToString th4) ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine sin  -> \"sin(pi*\" ^ (exprToString sin) ^ \")\"  \n| Cosine cos -> \"cos(pi*\" ^ (exprToString cos) ^ \")\"\n| Average (n1, n2) ->  \"((\" ^ (exprToString n1) ^ \"+\" ^ (exprToString n2) ^ \")/2)\"\n| Times (t1, t2) -> (exprToString t1) ^ \"*\" ^ (exprToString t2) \n| Thresh (th1, th2, th3, th4) -> \"(\" ^ (exprToString th1) ^ \"<\" ^ \n(exprToString th2) ^ \"?\" ^ (exprToString th3) ^ \n\":\" ^ (exprToString th4) ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nwwhile \n((let func b = \n(* Save the return value of the function to compare with b *)\nlet ans = f b in \n(* If it's equal, say false to quit, else keep going *)\nif b = ans then (ans, false)\nelse (ans, true) in func\n),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = \nlet pi = 4.0 *. atan 1.0 in \nmatch e with \nVarX -> x\n| VarY -> y\n| Sine e -> sin (pi *. eval(e, x, y)) \n| Cosine e -> cos (pi *. eval(e, x, y))\n| Average (a1, a2) -> ( (eval(a1, x, y) +. eval(a2, x, y)) /. 2.0)\n| Times (t1, t2) -> (eval(t1, x, y) *. (eval(t2, x,y)))\n| Thresh (th1, th2, th3, th4) -> \nif (eval(th1, x, y)) < (eval(th2, x, y)) \nthen eval(th3, x, y) \nelse eval(th4, x, y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = \nlet pi = 4.0 *. atan 1.0 in \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine e -> sin (pi *. eval(e, x, y)) \n| Cosine e -> cos (pi *. eval(e, x, y))\n| Average (a1, a2) -> ( (eval(a1, x, y) +. eval(a2, x, y)) /. 2.0)\n| Times (t1, t2) -> (eval(t1, x, y) *. (eval(t2, x,y)))\n| Thresh (th1, th2, th3, th4) -> \nif (eval(th1, x, y)) < (eval(th2, x, y)) \nthen eval(th3, x, y) \nelse eval(th4, x, y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = \nlet pi = 4.0 *. atan 1.0 in \nmatch e with \nVarX -> x\n| VarY -> y\n| Sine e -> sin (pi *. eval(e, x, y)) \n| Cosine e -> cos (pi *. eval(e, x, y))\n| Average (a1, a2) -> ( (eval(a1, x, y) +. eval(a2, x, y)) /. 2.0)\n| Times (t1, t2) -> (eval(t1, x, y) *. (eval(t2, x,y)))\n| Thresh (th1, th2, th3, th4) -> \nif (eval(th1, x, y)) < (eval(th2, x, y)) \nthen eval(th3, x, y) \nelse eval(th4, x, y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n(* If list is empty, then return the first int *)\n| [] -> d\n(* I it is of this pattern, check if the number is equal to the tuple's number *)\n| (name,num)::tail ->\n(* If it is, return the number; else recursively call with remainder *)\nif name = k then num\nelse assoc(d, k, tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = \nlet pi = 4.0 *. atan 1.0 in \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine e -> sin (pi *. eval(e, x, y)) \n| Cosine e -> cos (pi *. eval(e, x, y))\n| Average (a1, a2) -> ( (eval(a1, x, y) +. eval(a2, x, y)) /. 2.0)\n| Times (t1, t2) -> (eval(t1, x, y) *. (eval(t2, x,y)))\n| Thresh (th1, th2, th3, th4) -> \nif (eval(th1, x, y)) < (eval(th2, x, y)) \nthen eval(th3, x, y) \nelse eval(th4, x, y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n(* If list is empty, then return the first int *)\n| [] -> d\n(* If it is of this pattern, check if the number is equal to the tuple's number *)\n| (name,num)::tail ->\n(* If it is, return the number; else recursively call with remainder *)\nif name = k then num\nelse assoc(d, k, tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = \nlet pi = 4.0 *. atan 1.0 in \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine e -> sin (pi *. eval(e, x, y)) \n| Cosine e -> cos (pi *. eval(e, x, y))\n| Average (a1, a2) -> ( (eval(a1, x, y) +. eval(a2, x, y)) /. 2.0)\n| Times (t1, t2) -> (eval(t1, x, y) *. (eval(t2, x,y)))\n| Thresh (th1, th2, th3, th4) -> \nif (eval(th1, x, y)) < (eval(th2, x, y)) \nthen eval(th3, x, y) \nelse eval(th4, x, y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\nif depth = 0 then \nlet rand1 = rand(0,2) in\nmatch rand1 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \nlet rand2 = rand(0, 5) in\nlet param = build(rand, (depth - 1)) in\nmatch rand2 with\n| 0 -> buildSine(param)\n| 1 -> buildCosine(param)\n| 2 -> buildAverage(param, param)\n| 3 -> buildTimes(param, param)\n| 4 -> buildThresh(param, param, param, param)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n(* If list is empty, then return the first int *)\n| [] -> d\n(* If it is of this pattern, check if the number is equal to the tuple's number *)\n| (name,num)::tail ->\n(* If it is, return the number; else recursively call with remainder *)\nif name = k then num\nelse assoc(d, k, tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 29-31:\n  if tf = true then wwhile(f, num)\n     ^^\nError: Unbound value tf\n", "min": "\nlet rec wwhile (f,b) = if tf = true then wwhile (f, num) else num;;\n", "in": "let rec wwhile (f,b) = \n(* Save the function and parameter into an expression *)\n(*let ans = f b in\nmatch ans with\n| (num, tf) ->\n(* If boolean is true, then loop again on new value *)\nif tf = true then wwhile(f, num)\n(* Otherwise, return old value *)\nelse num;;*)\nlet (p,k) = f(b) in\nif k then wwhile(f, p) else p"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 12-13:\n  let (p,k) = f(b) in\n              ^\nError: Unbound value f\n", "min": "\nlet rec wwhile (f,b) =\n  let ans = f b in\n  match ans with | (num,tf) -> if tf = true then wwhile (f, num) else num;;\n\nlet _ = let (p,k) = f b in if k then wwhile (f, p) else p;;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| DivAdd   of expr * expr * expr * expr\n| TriMult  of expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 591-609:\n  \"+\" ^ (exprToString ds4) \"))\"\n        ^^^^^^^^^^^^^^^^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | DivAdd of expr* expr* expr* expr\n  | TriMult of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine sin -> \"sin(pi*\" ^ ((exprToString sin) ^ \")\")\n  | Cosine cos -> \"cos(pi*\" ^ ((exprToString cos) ^ \")\")\n  | Average (n1,n2) ->\n      \"((\" ^ ((exprToString n1) ^ (\"+\" ^ ((exprToString n2) ^ \")/2)\")))\n  | Times (t1,t2) -> (exprToString t1) ^ (\"*\" ^ (exprToString t2))\n  | Thresh (th1,th2,th3,th4) ->\n      \"(\" ^\n        ((exprToString th1) ^\n           (\"<\" ^\n              ((exprToString th2) ^\n                 (\"?\" ^\n                    ((exprToString th3) ^ (\":\" ^ ((exprToString th4) ^ \")\")))))))\n  | DivAdd (ds1,ds2,ds3,ds4) ->\n      \"((\" ^\n        ((exprToString ds1) ^\n           (\"+\" ^\n              ((exprToString ds2) ^\n                 (\") / (\" ^\n                    ((exprToString ds3) ^ (\"+\" ^ ((exprToString ds4) \"))\")))))))\n  | TriMult (tm1,tm2,tm3) ->\n      \"(\" ^\n        ((exprToString tm1) ^\n           (\"*\" ^ ((exprToString tm2) ^ ((\"*\" (exprToString tm3)) ^ \")\"))));;\n", "in": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine sin  -> \"sin(pi*\" ^ (exprToString sin) ^ \")\"  \n| Cosine cos -> \"cos(pi*\" ^ (exprToString cos) ^ \")\"\n| Average (n1, n2) ->  \"((\" ^ (exprToString n1) ^ \"+\" ^ (exprToString n2) ^ \")/2)\"\n| Times (t1, t2) -> (exprToString t1) ^ \"*\" ^ (exprToString t2) \n| Thresh (th1, th2, th3, th4) -> \"(\" ^ (exprToString th1) ^ \"<\" ^ \n(exprToString th2) ^ \"?\" ^ (exprToString th3) ^ \n\":\" ^ (exprToString th4) ^ \")\"\n| DivAdd (ds1, ds2, ds3, ds4) -> \"((\" ^ (exprToString ds1) ^ \"+\" ^\n(exprToString ds2) ^ \") / (\" ^ (exprToString ds3) ^\n\"+\" ^ (exprToString ds4) \"))\"\n| TriMult (tm1, tm2, tm3) -> \"(\" ^ (exprToString tm1) ^ \"*\" ^ (exprToString tm2) ^\n\"*\" (exprToString tm3) ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 591-609:\n  \"+\" ^ (exprToString ds4) \"))\"\n        ^^^^^^^^^^^^^^^^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | DivAdd of expr* expr* expr* expr\n  | TriMult of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine sin -> \"sin(pi*\" ^ ((exprToString sin) ^ \")\")\n  | Cosine cos -> \"cos(pi*\" ^ ((exprToString cos) ^ \")\")\n  | Average (n1,n2) ->\n      \"((\" ^ ((exprToString n1) ^ (\"+\" ^ ((exprToString n2) ^ \")/2)\")))\n  | Times (t1,t2) -> (exprToString t1) ^ (\"*\" ^ (exprToString t2))\n  | Thresh (th1,th2,th3,th4) ->\n      \"(\" ^\n        ((exprToString th1) ^\n           (\"<\" ^\n              ((exprToString th2) ^\n                 (\"?\" ^\n                    ((exprToString th3) ^ (\":\" ^ ((exprToString th4) ^ \")\")))))))\n  | DivAdd (ds1,ds2,ds3,ds4) ->\n      \"((\" ^\n        ((exprToString ds1) ^\n           (\"+\" ^\n              ((exprToString ds2) ^\n                 (\") / (\" ^\n                    ((exprToString ds3) ^ (\"+\" ^ ((exprToString ds4) \"))\")))))))\n  | TriMult (tm1,tm2,tm3) ->\n      \"(\" ^\n        ((exprToString tm1) ^\n           (\"*\" ^ ((exprToString tm2) ^ ((\"*\" (exprToString tm3)) ^ \")\"))));;\n", "in": "let rec assoc (d,k,l) = match l with\n(* If list is empty, then return the first int *)\n| [] -> d\n(* If it is of this pattern, check if the number is equal to the tuple's number *)\n| (name,num)::tail ->\n(* If it is, return the number; else recursively call with remainder *)\nif name = k then num\nelse assoc(d, k, tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine sin  -> \"sin(pi*\" ^ (exprToString sin) ^ \")\"  \n| Cosine cos -> \"cos(pi*\" ^ (exprToString cos) ^ \")\"\n| Average (n1, n2) ->  \"((\" ^ (exprToString n1) ^ \"+\" ^ (exprToString n2) ^ \")/2)\"\n| Times (t1, t2) -> (exprToString t1) ^ \"*\" ^ (exprToString t2) \n| Thresh (th1, th2, th3, th4) -> \"(\" ^ (exprToString th1) ^ \"<\" ^ \n(exprToString th2) ^ \"?\" ^ (exprToString th3) ^ \n\":\" ^ (exprToString th4) ^ \")\"\n| DivAdd (ds1, ds2, ds3, ds4) -> \"((\" ^ (exprToString ds1) ^ \"+\" ^\n(exprToString ds2) ^ \") / (\" ^ (exprToString ds3) ^\n\"+\" ^ (exprToString ds4) ^ \"))\"\n| TriMult (tm1, tm2, tm3) -> \"(\" ^ (exprToString tm1) ^ \"*\" ^ (exprToString tm2) ^\n\"*\" ^ (exprToString tm3) ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 700-703:\n  \"*\" (exprToString tm3) ^ \")\";;\n  ^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | DivAdd of expr* expr* expr* expr\n  | TriMult of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine sin -> \"sin(pi*\" ^ ((exprToString sin) ^ \")\")\n  | Cosine cos -> \"cos(pi*\" ^ ((exprToString cos) ^ \")\")\n  | Average (n1,n2) ->\n      \"((\" ^ ((exprToString n1) ^ (\"+\" ^ ((exprToString n2) ^ \")/2)\")))\n  | Times (t1,t2) -> (exprToString t1) ^ (\"*\" ^ (exprToString t2))\n  | Thresh (th1,th2,th3,th4) ->\n      \"(\" ^\n        ((exprToString th1) ^\n           (\"<\" ^\n              ((exprToString th2) ^\n                 (\"?\" ^\n                    ((exprToString th3) ^ (\":\" ^ ((exprToString th4) ^ \")\")))))))\n  | DivAdd (ds1,ds2,ds3,ds4) ->\n      \"((\" ^\n        ((exprToString ds1) ^\n           (\"+\" ^\n              ((exprToString ds2) ^\n                 (\") / (\" ^\n                    ((exprToString ds3) ^ (\"+\" ^ ((exprToString ds4) ^ \"))\")))))))\n  | TriMult (tm1,tm2,tm3) ->\n      \"(\" ^\n        ((exprToString tm1) ^\n           (\"*\" ^ ((exprToString tm2) ^ ((\"*\" (exprToString tm3)) ^ \")\"))));;\n", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| DivAdd   of expr * expr * expr * expr\n| TriMult  of expr * expr * expr"}, {"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine sin  -> \"sin(pi*\" ^ (exprToString sin) ^ \")\"  \n| Cosine cos -> \"cos(pi*\" ^ (exprToString cos) ^ \")\"\n| Average (n1, n2) ->  \"((\" ^ (exprToString n1) ^ \"+\" ^ (exprToString n2) ^ \")/2)\"\n| Times (t1, t2) -> (exprToString t1) ^ \"*\" ^ (exprToString t2) \n| Thresh (th1, th2, th3, th4) -> \"(\" ^ (exprToString th1) ^ \"<\" ^ \n(exprToString th2) ^ \"?\" ^ (exprToString th3) ^ \n\":\" ^ (exprToString th4) ^ \")\"\n| DivAdd (ds1, ds2, ds3, ds4) -> \"((\" ^ (exprToString ds1) ^ \"+\" ^\n(exprToString ds2) ^ \") / (\" ^ (exprToString ds3) ^\n\"+\" ^ (exprToString ds4) ^ \"))\"\n| TriMult (tm1, tm2, tm3) -> \"(\" ^ (exprToString tm1) ^ \"*\" ^ (exprToString tm2) ^\n\"*\" ^ (exprToString tm3) ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine sin  -> \"sin(pi*\" ^ (exprToString sin) ^ \")\"  \n| Cosine cos -> \"cos(pi*\" ^ (exprToString cos) ^ \")\"\n| Average (n1, n2) ->  \"((\" ^ (exprToString n1) ^ \"+\" ^ (exprToString n2) ^ \")/2)\"\n| Times (t1, t2) -> (exprToString t1) ^ \"*\" ^ (exprToString t2) \n| Thresh (th1, th2, th3, th4) -> \"(\" ^ (exprToString th1) ^ \"<\" ^ \n(exprToString th2) ^ \"?\" ^ (exprToString th3) ^ \n\":\" ^ (exprToString th4) ^ \")\"\n| DivAdd (ds1, ds2, ds3, ds4) -> \"((\" ^ (exprToString ds1) ^ \"+\" ^\n(exprToString ds2) ^ \") / (\" ^ (exprToString ds3) ^\n\"+\" ^ (exprToString ds4) ^ \"))\"\n| TriMult (tm1, tm2, tm3) -> \"(\" ^ (exprToString tm1) ^ \"*\" ^ (exprToString tm2) ^\n\"*\" ^ (exprToString tm3) ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n(* If list is empty, then return the first int *)\n| [] -> d\n(* If it is of this pattern, check if the number is equal to the tuple's number *)\n| (name,num)::tail ->\n(* If it is, return the number; else recursively call with remainder *)\nif name = k then num\nelse assoc(d, k, tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n(* If list is empty, then return the first int *)\n| [] -> d\n(* If it is of this pattern, check if the number is equal to the tuple's number *)\n| (name,num)::tail ->\n(* If it is, return the number; else recursively call with remainder *)\nif name = k then num\nelse assoc(d, k, tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n(* If list is empty, then return the first int *)\n| [] -> d\n(* If it is of this pattern, check if the number is equal to the tuple's number *)\n| (name,num)::tail ->\n(* If it is, return the number; else recursively call with remainder *)\nif name = k then num\nelse assoc(d, k, tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n(* If list is empty, then return the first int *)\n| [] -> d\n(* If it is of this pattern, check if the number is equal to the tuple's number *)\n| (name,num)::tail ->\n(* If it is, return the number; else recursively call with remainder *)\nif name = k then num\nelse assoc(d, k, tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\n(* No depth, so just return either X or Y *)\nif depth <= 0 then \nlet rand1 = rand(0,2) in\nmatch rand1 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \n(* Otherwise, depth is bigger than 0, so start recursing on other expressions *)\nlet rand2 = rand(0, 5) in\nlet param = build(rand, (depth - 1)) in\nmatch rand2 with\n| 0 -> buildSine(param)\n| 1 -> buildCosine(param)\n| 2 -> buildAverage(param, param)\n| 3 -> buildTimes(param, param)\n| 4 -> buildThresh(param, param, param, param)\n| 5 -> buildDivAdd(param, param, param, param)\n| 6 -> buildTriMult(param, param, param)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n(* If list is empty, then return the first int *)\n| [] -> d\n(* If it is of this pattern, check if the number is equal to the tuple's number *)\n| (name,num)::tail ->\n(* If it is, return the number; else recursively call with remainder *)\nif name = k then num\nelse assoc(d, k, tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\n(* No depth, so just return either X or Y *)\nif depth <= 0 then \nlet rand1 = rand(0,2) in\nmatch rand1 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \n(* Otherwise, depth is bigger than 0, so start recursing on other expressions *)\nlet rand2 = rand(0, 7) in\nlet param = build(rand, (depth - 1)) in\nmatch rand2 with\n| 0 -> buildSine(param)\n| 1 -> buildCosine(param)\n| 2 -> buildAverage(param, param)\n| 3 -> buildTimes(param, param)\n| 4 -> buildThresh(param, param, param, param)\n| 5 -> buildDivAdd(param, param, param, param)\n| 6 -> buildTriMult(param, param, param)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\n(* No depth, so just return either X or Y *)\nif depth <= 0 then \nlet rand1 = rand(0,2) in\nmatch rand1 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \n(* Otherwise, depth is bigger than 0, so start recursing on other expressions *)\nlet rand2 = rand(0, 7) in\nlet param = build(rand, (depth - 1)) in\nmatch rand2 with\n| 0 -> buildSine(param)\n| 1 -> buildCosine(param)\n| 2 -> buildAverage(param, param)\n| 3 -> buildTimes(param, param)\n| 4 -> buildThresh(param, param, param, param)\n| 5 -> buildDivAdd(param, param, param, param)\n| 6 -> buildTriMult(param, param, param)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n(* If list is empty, then return the first int *)\n| [] -> d\n(* If it is of this pattern, check if the number is equal to the tuple's number *)\n| (name,num)::tail ->\n(* If it is, return the number; else recursively call with remainder *)\nif name = k then num\nelse assoc(d, k, tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\n(* No depth, so just return either X or Y *)\nif depth <= 0 then \nlet rand1 = rand(0,2) in\nmatch rand1 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \n(* Otherwise, depth is bigger than 0, so start recursing on other expressions *)\nlet rand2 = rand(0, 7) in\nlet param = build(rand, (depth - 1)) in\nmatch rand2 with\n| 0 -> buildSine(param)\n| 1 -> buildCosine(param)\n| 2 -> buildAverage(param, param)\n| 3 -> buildTimes(param, param)\n| 4 -> buildThresh(param, param, param, param)\n| 5 -> buildDivAdd(param, param, param, param)\n| 6 -> buildTriMult(param, param, param)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n(* If list is empty, then return the first int *)\n| [] -> d\n(* If it is of this pattern, check if the number is equal to the tuple's number *)\n| (name,num)::tail ->\n(* If it is, return the number; else recursively call with remainder *)\nif name = k then num\nelse assoc(d, k, tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n(* If list is empty, then return the first int *)\n| [] -> d\n(* If it is of this pattern, check if the number is equal to the tuple's number *)\n| (name,num)::tail ->\n(* If it is, return the number; else recursively call with remainder *)\nif name = k then num\nelse assoc(d, k, tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\n(* No depth, so just return either X or Y *)\nif depth <= 0 then \nlet rand1 = rand(0,2) in\nmatch rand1 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \n(* Otherwise, depth is bigger than 0, so start recursing on other expressions *)\nlet rand2 = rand(0, 7) in\nlet param = build(rand, (depth - 1)) in\nmatch rand2 with\n| 0 -> buildSine(param)\n| 1 -> buildCosine(param)\n| 2 -> buildAverage(param, param)\n| 3 -> buildTimes(param, param)\n| 4 -> buildThresh(param, param, param, param)\n| 5 -> buildDivAdd(param, param, param, param)\n| 6 -> buildTriMult(param, param, param)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n(* If list is empty, then return the first int *)\n| [] -> d\n(* If it is of this pattern, check if the number is equal to the tuple's number *)\n| (name,num)::tail ->\n(* If it is, return the number; else recursively call with remainder *)\nif name = k then num\nelse assoc(d, k, tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\n(* No depth, so just return either X or Y *)\nif depth <= 0 then \nlet rand1 = rand(0,2) in\nmatch rand1 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \n(* Otherwise, depth is bigger than 0, so start recursing on other expressions *)\nlet rand2 = rand(0, 7) in\nlet param = build(rand, (depth - 1)) in\nmatch rand2 with\n| 0 -> buildSine(param)\n| 1 -> buildCosine(param)\n| 2 -> buildAverage(param, param)\n| 3 -> buildTimes(param, param)\n| 4 -> buildThresh(param, param, param, param)\n| 5 -> buildDivAdd(param, param, param, param)\n| 6 -> buildTriMult(param, param, param)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n(* If list is empty, then return the first int *)\n| [] -> d\n(* If it is of this pattern, check if the number is equal to the tuple's number *)\n| (name,num)::tail ->\n(* If it is, return the number; else recursively call with remainder *)\nif name = k then num\nelse assoc(d, k, tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n(* If list is empty, then return the first int *)\n| [] -> d\n(* If it is of this pattern, check if the number is equal to the tuple's number *)\n| (name,num)::tail ->\n(* If it is, return the number; else recursively call with remainder *)\nif name = k then num\nelse assoc(d, k, tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n(* If list is empty, then return the first int *)\n| [] -> d\n(* If it is of this pattern, check if the number is equal to the tuple's number *)\n| (name,num)::tail ->\n(* If it is, return the number; else recursively call with remainder *)\nif name = k then num\nelse assoc(d, k, tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\n(* No depth, so just return either X or Y *)\nif depth <= 0 then \nlet rand1 = rand(0,2) in\nmatch rand1 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \n(* Otherwise, depth is bigger than 0, so start recursing on other expressions *)\nlet rand2 = rand(0, 7) in\nlet param = build(rand, (depth - 1)) in\nmatch rand2 with\n| 0 -> buildSine(param)\n| 1 -> buildCosine(param)\n| 2 -> buildAverage(param, param)\n| 3 -> buildTimes(param, param)\n| 4 -> buildThresh(param, param, param, param)\n| 5 -> buildDivAdd(param, param, param, param)\n| 6 -> buildTriMult(param, param, param)\n| _ -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\n(* No depth, so just return either X or Y *)\nif depth <= 0 then \nlet rand1 = rand(0,2) in\nmatch rand1 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \n(* Otherwise, depth is bigger than 0, so start recursing on other expressions *)\nlet rand2 = rand(0, 5) in\nlet param = build(rand, (depth - 1)) in\nmatch rand2 with\n| 0 -> buildSine(param)\n| 1 -> buildCosine(param)\n| 2 -> buildAverage(param, param)\n| 3 -> buildTimes(param, param)\n| 4 -> buildThresh(param, param, param, param)\n| 5 -> buildDivAdd(param, param, param, param)\n| 6 -> buildTriMult(param, param, param)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\n(* No depth, so just return either X or Y *)\nif depth <= 0 then \nlet rand1 = rand(0,2) in\nmatch rand1 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \n(* Otherwise, depth is bigger than 0, so start recursing on other expressions *)\nlet rand2 = rand(0, 5) in\nlet param = build(rand, (depth - 1)) in\nmatch rand2 with\n| 0 -> buildSine(param)\n| 1 -> buildCosine(param)\n| 2 -> buildAverage(param, param)\n| 3 -> buildTimes(param, param)\n| 4 -> buildThresh(param, param, param, param)\n| 5 -> buildDivAdd(param, param, param, param)\n| 6 -> buildTriMult(param, param, param)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) =\n(* No depth, so just return either X or Y *)\nif depth <= 0 then \nlet rand1 = rand(0,2) in\nmatch rand1 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \n(* Otherwise, depth is bigger than 0, so start recursing on other expressions *)\nlet rand2 = rand(0, 5) in\nlet param = build(rand, (depth - 1)) in\nmatch rand2 with\n| 0 -> buildSine(param)\n| 1 -> buildCosine(param)\n| 2 -> buildAverage(param, param)\n| 3 -> buildTimes(param, param)\n| 4 -> buildThresh(param, param, param, param)\n| 5 -> buildDivAdd(param, param, param, param)\n| 6 -> buildTriMult(param, param, param)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n(* If list is empty, then return the first int *)\n| [] -> d\n(* If it is of this pattern, check if the number is equal to the tuple's number *)\n| (name,num)::tail ->\n(* If it is, return the number; else recursively call with remainder *)\nif name = k then num\nelse assoc(d, k, tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nwwhile ((fun b -> if (f b = b) then (f b, false) else(f b, true)),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nwwhile ((\nfun helper -> \nif (f b = helper) then (f b, false) \nelse(f b, true)),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nwwhile ((\nfun b -> \nif (f b = b) then (f b, false) \nelse(f b, true)),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nwwhile ((\nfun b -> \n(* Check if the function's return equals the second parameter passed in *)\nif (f b = b) then (f b, false)\nelse(f b, true)),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nwwhile ((\nfun helper -> \n(* Check if the function's return equals the second parameter passed in *)\nif (f helper = b) then (f helper, false)\nelse(f b, true)),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nwwhile \n((let func b = \n(* Save the return value of the function to compare with b *)\nlet ans = f b in \n(* If it's equal, say false to quit, else keep going *)\nif b = ans then (ans, false)\nelse (ans, true) in func\n),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n(* If list is empty, then return the first int *)\n| [] -> d\n(* If it is of this pattern, check if the number is equal to the tuple's number *)\n| (name,num)::tail ->\n(* If it is, return the number; else recursively call with remainder *)\nif name = k then num\nelse assoc(d, k, tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n(* If list is empty, then return the first int *)\n| [] -> d\n(* If it is of this pattern, check if the number is equal to the tuple's number *)\n| (name,num)::tail ->\n(* If it is, return the number; else recursively call with remainder *)\nif name = k then num\nelse assoc(d, k, tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n(* If list is empty, then return the first int *)\n| [] -> d\n(* If it is of this pattern, check if the number is equal to the tuple's number *)\n| (name,num)::tail ->\n(* If it is, return the number; else recursively call with remainder *)\nif name = k then num\nelse assoc(d, k, tail)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
