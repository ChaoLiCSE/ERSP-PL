{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc(d,k,l) =\nmatch l with\n| [] -> d\n| (x,y) :: t -> x", "min": "\nlet rec assoc (d,k,l) = match l with | [] -> d | (x,y)::t -> x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc(d,k,l) =\nmatch l with\n| [] -> d\n| (x,y) :: t -> y", "min": "\nlet rec assoc (d,k,l) = match l with | [] -> d | (x,y)::t -> y;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc(d,k,l) =\nmatch l with\n| [] -> d\n| (x,y) :: t -> y", "min": "\nlet rec assoc (d,k,l) = match l with | [] -> d | (x,y)::t -> y;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc(d,k,l) =\nmatch l with\n| [] -> d\n| (x,y) :: t -> \nif (x = k)\nthen y\nelse assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (x,y)::t -> if x = k then y else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc(d,k,l) =\nmatch l with\n| [] -> d\n| (x,y) :: t -> \nif (x = k)\nthen y\nelse assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (x,y)::t -> if x = k then y else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc(d,k,l) =\nmatch l with\n| [] -> d\n| (x,y) :: t -> \nif (x = k)\nthen y\nelse assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (x,y)::t -> if x = k then y else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \n(if List.mem h seen\nthen seen\nelse h :: seen)\nin\nlet rest' = t\nin helper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) =\nmatch f(b) with\n| (_, false) -> b\n| (bb, true) -> wwhile(f, bb)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (_,false ) -> b | (bb,true ) -> wwhile (f, bb);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) =\nmatch f(b-1) with\n| (_, false) -> b\n| (bb, true) -> wwhile(f, bb)", "min": "\nlet rec wwhile (f,b) =\n  match f (b - 1) with | (_,false ) -> b | (bb,true ) -> wwhile (f, bb);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) =\nmatch f(b-1) with\n| (bb, false) -> bb\n| (bb, true) -> wwhile(f, bb)", "min": "\nlet rec wwhile (f,b) =\n  match f (b - 1) with | (bb,false ) -> bb | (bb,true ) -> wwhile (f, bb);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) =\nmatch f(b) with\n| (bb, false) -> bb\n| (bb, true) -> wwhile(f, bb)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (bb,false ) -> bb | (bb,true ) -> wwhile (f, bb);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (bb,false ) -> bb | (bb,true ) -> wwhile (f, bb);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc(d,k,l) =\nmatch l with\n| [] -> d\n| (x,y) :: t -> \nif (x = k)\nthen y\nelse assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (x,y)::t -> if x = k then y else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) =\nmatch f(b) with\n| (bb, false) -> bb\n| (bb, true) -> wwhile(f, bb)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (bb,false ) -> bb | (bb,true ) -> wwhile (f, bb);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let fixpoint (f, b) = wwhile (fun ff b -> (f(b), f(b) = f(b-1)) ,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (bb,false ) -> bb | (bb,true ) -> wwhile (f, bb);;\n\nlet fixpoint (f,b) =\n  wwhile (fun ff  -> fun b  -> (((f b), ((f b) = (f (b - 1)))), b));;\n", "out": "Characters 29-67:\n  let fixpoint (f, b) = wwhile (fun ff b -> (f(b), f(b) = f(b-1)) ,b);;\n                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let fixpoint (f, b) = wwhile (fun ff b -> (f(b), f(b) != f(b-1)) ,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (bb,false ) -> bb | (bb,true ) -> wwhile (f, bb);;\n\nlet fixpoint (f,b) =\n  wwhile (fun ff  -> fun b  -> (((f b), ((f b) != (f (b - 1)))), b));;\n", "out": "Characters 29-68:\n  let fixpoint (f, b) = wwhile (fun ff b -> (f(b), f(b) != f(b-1)) ,b);;\n                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f, b) = \nlet ff (b) =\n(f(b), f(b) != f(b-1))\nin\nwwhile (ff, b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (bb,false ) -> bb | (bb,true ) -> wwhile (f, bb);;\n\nlet fixpoint (f,b) =\n  let ff b = ((f b), ((f b) != (f (b - 1)))) in wwhile (ff, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f, b) = \nlet ff (b) =\n(f(b), f(b) != b || f(b) != f(b-1))\nin\nwwhile (ff, b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (bb,false ) -> bb | (bb,true ) -> wwhile (f, bb);;\n\nlet fixpoint (f,b) =\n  let ff b = ((f b), (((f b) != b) || ((f b) != (f (b - 1))))) in\n  wwhile (ff, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f, b) = \nlet ff (b) =\n(f(b), f(b) != b || b != f(b-1))\nin\nwwhile (ff, b)", "min": "\nlet fixpoint (f,b) =\n  let ff b = ((f b), (((f b) != b) || (b != (f (b - 1))))) in wwhile (ff, b);;\n", "out": "Characters 72-78:\n  wwhile (ff, b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f, b) = \nlet ff (b) =\n(f(b), f(b) != b || b != f(b-1))\nin\nwwhile (ff, b)", "min": "\nlet fixpoint (f,b) =\n  let ff b = ((f b), (((f b) != b) || (b != (f (b - 1))))) in wwhile (ff, b);;\n", "out": "Characters 72-78:\n  wwhile (ff, b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || b != f(b-1))), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((fun b  -> ((f b), (((f b) != b) || (b != (f (b - 1)))))), b);;\n", "out": "Characters 21-27:\n  let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || b != f(b-1))), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint(f, b) = wwhile((fun b -> (f b, f b != b || b != f b-1)), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((fun b  -> ((f b), (((f b) != b) || (b != ((f b) - 1))))), b);;\n", "out": "Characters 21-27:\n  let fixpoint(f, b) = wwhile((fun b -> (f b, f b != b || b != f b-1)), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || b != f b-1)), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((fun b  -> ((f b), (((f b) != b) || (b != ((f b) - 1))))), b);;\n", "out": "Characters 21-27:\n  let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || b != f b-1)), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || b != f (b-1))), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((fun b  -> ((f b), (((f b) != b) || (b != (f (b - 1)))))), b);;\n", "out": "Characters 21-27:\n  let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || b != f (b-1))), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((fun b  -> ((f b), (((f b) != b) || ((f b) != (f (f b)))))), b);;\n", "out": "Characters 21-27:\n  let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((fun b  -> ((f b), (((f b) != b) || ((f b) != (f (f b)))))), b);;\n", "out": "Characters 21-27:\n  let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint(f, b) = wwhile((fun b -> (f(b), not (f(b) = b) || not (f(b) != f(f(b))))) , b)", "min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((fun b  -> ((f b), ((not ((f b) = b)) || (not ((f b) != (f (f b))))))),\n      b);;\n", "out": "Characters 21-27:\n  let fixpoint(f, b) = wwhile((fun b -> (f(b), not (f(b) = b) || not (f(b) != f(f(b))))) , b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint(f, b) = wwhile((fun b -> (f(b), not (f(b) = b) || not (f(b) = f(f(b))))) , b)", "min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((fun b  -> ((f b), ((not ((f b) = b)) || (not ((f b) = (f (f b))))))),\n      b);;\n", "out": "Characters 21-27:\n  let fixpoint(f, b) = wwhile((fun b -> (f(b), not (f(b) = b) || not (f(b) = f(f(b))))) , b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n", "min": "\ntype expr =\n  | VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with\n| VarX _ -> \"x\"\n| VarY _ -> \"y\"\n| Sine x -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine x -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Average (x,y) -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^\")/2)\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX _ -> \"x\"\n  | VarY _ -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec exprToString e = \nmatch e with\n| VarX _\t    -> \"x\"\n| VarY _\t    -> \"y\"\n| Sine x\t    -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine x\t    -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Average (x,y)     -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^\")/2)\"\n| Times (x,y)       -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (a,b,c,d)  -> \n\"(\" ^ exprToString(a) ^ \"<\" exprToString(y) ^ \"?\" ^ \nexprToString(c) ^ \":\" ^ exprToString(d)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX _ -> \"x\"\n  | VarY _ -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           ((\"<\" exprToString y) ^\n              (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d))))));;\n", "out": "Characters 370-373:\n  \"(\" ^ exprToString(a) ^ \"<\" exprToString(y) ^ \"?\" ^ \n                          ^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = \nmatch e with\n| VarX _\t    -> \"x\"\n| VarY _\t    -> \"y\"\n| Sine x\t    -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine x\t    -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Average (x,y)     -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^\")/2)\"\n| Times (x,y)       -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (a,b,c,d)  -> \n\"(\" ^ exprToString(a) ^ \"<\" ^ exprToString(y) ^ \"?\" ^ \nexprToString(c) ^ \":\" ^ exprToString(d)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX _ -> \"x\"\n  | VarY _ -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString y) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d)))))));;\n", "out": "Characters 388-391:\n  \"(\" ^ exprToString(a) ^ \"<\" ^ exprToString(y) ^ \"?\" ^ \n                                            ^^^\nError: Unbound value y\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with\n| VarX _\t    -> \"x\"\n| VarY _\t    -> \"y\"\n| Sine x\t    -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine x\t    -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Average (x,y)     -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^\")/2)\"\n| Times (x,y)       -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (a,b,c,d)  -> \n\"(\" ^ exprToString(a) ^ \"<\" ^ exprToString(b) ^ \"?\" ^ \nexprToString(c) ^ \":\" ^ exprToString(d)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX _ -> \"x\"\n  | VarY _ -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d)))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t    -> \"x\"\n| VarY\t\t    -> \"y\"\n| Sine x\t    -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine x\t    -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Average (x,y)     -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^\")/2)\"\n| Times (x,y)       -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (a,b,c,d)  -> \n\"(\" ^ exprToString(a) ^ \"<\" ^ exprToString(b) ^ \"?\" ^ \nexprToString(c) ^ \":\" ^ exprToString(d)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ (exprToString d)))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc(d,k,l) =\nmatch l with\n| [] -> d\n| (x,y) :: t -> \nif (x = k)\nthen y\nelse assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (x,y)::t -> if x = k then y else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nmatch e with\n| VarX\t\t    -> \"x\"\n| VarY\t\t    -> \"y\"\n| Sine x\t    -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine x\t    -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Average (x,y)     -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^\")/2)\"\n| Times (x,y)       -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (a,b,c,d)  -> \n\"(\" ^ exprToString(a) ^ \"<\" ^ exprToString(b) ^ \"?\" ^ \nexprToString(c) ^ \":\" ^ exprToString(d) ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc(d,k,l) =\nmatch l with\n| [] -> d\n| (x,y) :: t -> \nif (x = k)\nthen y\nelse assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (x,y)::t -> if x = k then y else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi * eval (a,x,y))\n| Cosine a -> cos (pi * eval (a,x,y))\n| Average (a,b) -> (eval(a,x,y) + eval(b,x,y)) /. 2.\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | Cosine a -> cos (pi * (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) + (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": "Characters 77-79:\n  | Sine a -> sin (pi * eval (a,x,y))\n                   ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi *. eval (a,x,y))\n| Cosine a -> cos (pi *. eval (a,x,y))\n| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) then eval(c,x,y) else eval(d,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc(d,k,l) =\nmatch l with\n| [] -> d\n| (x,y) :: t -> \nif (x = k)\nthen y\nelse assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (x,y)::t -> if x = k then y else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = failwith \"to be implemented\"", "min": "\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth)=\nmatch depth with\n| 0 -> \n(match rand(1,2) with\n| 1 -> VarX\n| 2 -> VarY\n)\n| _ ->\n(match rand(1,5) with\n| 1 -> Sine(build(rand, depth-1))\n| 2 -> Cosine(build(rand, depth-1))\n| 3 -> Average(build(rand, depth-1),build(rand, depth-1))\n| 4 -> Times(build(rand, depth-1),build(rand, depth-1))\n| 5 -> Thresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> VarX | 2 -> VarY)\n  | _ ->\n      (match rand (1, 5) with\n       | 1 -> Sine (build (rand, (depth - 1)))\n       | 2 -> Cosine (build (rand, (depth - 1)))\n       | 3 ->\n           Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           Thresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth)=\nmatch depth with\n| 0 -> \n(match rand(1,2) with\n| 1 -> VarX\n| 2 -> VarY\n| _ -> VarX\n)\n| _ ->\n(match rand(1,5) with\n| 1 -> Sine(build(rand, depth-1))\n| 2 -> Cosine(build(rand, depth-1))\n| 3 -> Average(build(rand, depth-1),build(rand, depth-1))\n| 4 -> Times(build(rand, depth-1),build(rand, depth-1))\n| 5 -> Thresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\n| _ -> VarX\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> VarX | 2 -> VarY | _ -> VarX)\n  | _ ->\n      (match rand (1, 5) with\n       | 1 -> Sine (build (rand, (depth - 1)))\n       | 2 -> Cosine (build (rand, (depth - 1)))\n       | 3 ->\n           Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           Thresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ -> VarX);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "build(makeRand(312,385), 15)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> VarX | 2 -> VarY | _ -> VarX)\n  | _ ->\n      (match rand (1, 5) with\n       | 1 -> Sine (build (rand, (depth - 1)))\n       | 2 -> Cosine (build (rand, (depth - 1)))\n       | 3 ->\n           Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           Thresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ -> VarX);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = build ((makeRand (312, 385)), 15);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> VarX | 2 -> VarY | _ -> VarX)\n  | _ ->\n      (match rand (1, 5) with\n       | 1 -> Sine (build (rand, (depth - 1)))\n       | 2 -> Cosine (build (rand, (depth - 1)))\n       | 3 ->\n           Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           Thresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ -> VarX);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc(d,k,l) =\nmatch l with\n| [] -> d\n| (x,y) :: t -> \nif (x = k)\nthen y\nelse assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (x,y)::t -> if x = k then y else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 2) with | 1 -> VarX | 2 -> VarY | _ -> VarX)\n  | _ ->\n      (match rand (1, 5) with\n       | 1 -> Sine (build (rand, (depth - 1)))\n       | 2 -> Cosine (build (rand, (depth - 1)))\n       | 3 ->\n           Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           Thresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ -> VarX);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth)=\nmatch depth with\n| 0 -> \n(match rand(1,3) with\n| 1 -> VarX\n| 2 -> VarY\n| _ -> VarX\n)\n| _ ->\n(match rand(1,6) with\n| 1 -> Sine(build(rand, depth-1))\n| 2 -> Cosine(build(rand, depth-1))\n| 3 -> Average(build(rand, depth-1),build(rand, depth-1))\n| 4 -> Times(build(rand, depth-1),build(rand, depth-1))\n| 5 -> Thresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\n| _ -> VarX\n)", "min": "\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> VarX | 2 -> VarY | _ -> VarX)\n  | _ ->\n      (match rand (1, 6) with\n       | 1 -> Sine (build (rand, (depth - 1)))\n       | 2 -> Cosine (build (rand, (depth - 1)))\n       | 3 ->\n           Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           Thresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ -> VarX);;\n", "out": "Characters 83-87:\n  | 1 -> VarX\n         ^^^^\nError: Unbound constructor VarX\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc(d,k,l) =\nmatch l with\n| [] -> d\n| (x,y) :: t -> \nif (x = k)\nthen y\nelse assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (x,y)::t -> if x = k then y else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc(d,k,l) =\nmatch l with\n| [] -> d\n| (x,y) :: t -> \nif (x = k)\nthen y\nelse assoc(d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (x,y)::t -> if x = k then y else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\n| SinCos   of expr\n| LimSin   of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SinCos of expr\n  | LimSin of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | SinCos a -> sin (pi *. (cos (pi *. (eval (a, x, y)))))\n  | LimSin (a,b,c) ->\n      sin\n        (((pi *. (eval (a, x, y))) *. (eval (b, x, y))) +. (eval (c, x, y)));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SinCos of expr\n  | LimSin of expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> VarX | 2 -> VarY | _ -> VarX)\n  | _ ->\n      (match rand (1, 8) with\n       | 1 -> Sine (build (rand, (depth - 1)))\n       | 2 -> Cosine (build (rand, (depth - 1)))\n       | 3 ->\n           Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           Thresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 -> SinCos (build (rand, (depth - 1)))\n       | 7 ->\n           LimSin\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> VarX);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | SinCos x -> \"sin(pi*cos(pi*\" ^ ((exprToString x) ^ \"))\")\n  | LimSin (a,b,c) ->\n      \"sin(pi*\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString b) ^ (\"+\" ^ ((exprToString c) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | SinCos a -> sin (pi *. (cos (pi *. (eval (a, x, y)))))\n  | LimSin (a,b,c) ->\n      sin\n        (((pi *. (eval (a, x, y))) *. (eval (b, x, y))) +. (eval (c, x, y)));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SinCos of expr\n  | LimSin of expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> VarX | 2 -> VarY | _ -> VarX)\n  | _ ->\n      (match rand (1, 8) with\n       | 1 -> Sine (build (rand, (depth - 1)))\n       | 2 -> Cosine (build (rand, (depth - 1)))\n       | 3 ->\n           Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           Thresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 -> SinCos (build (rand, (depth - 1)))\n       | 7 ->\n           LimSin\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> VarX);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | SinCos x -> \"sin(pi*cos(pi*\" ^ ((exprToString x) ^ \"))\")\n  | LimSin (a,b,c) ->\n      \"sin(pi*\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString b) ^ (\"+\" ^ ((exprToString c) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | SinCos a -> sin (pi *. (cos (pi *. (eval (a, x, y)))))\n  | LimSin (a,b,c) ->\n      sin\n        (((pi *. (eval (a, x, y))) *. (eval (b, x, y))) +. (eval (c, x, y)));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SinCos of expr\n  | LimSin of expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> VarX | 2 -> VarY | _ -> VarX)\n  | _ ->\n      (match rand (1, 8) with\n       | 1 -> Sine (build (rand, (depth - 1)))\n       | 2 -> Cosine (build (rand, (depth - 1)))\n       | 3 ->\n           Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           Thresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 -> SinCos (build (rand, (depth - 1)))\n       | 7 ->\n           LimSin\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> VarX);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | SinCos x -> \"sin(pi*cos(pi*\" ^ ((exprToString x) ^ \"))\")\n  | LimSin (a,b,c) ->\n      \"sin(pi*\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString b) ^ (\"+\" ^ ((exprToString c) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | SinCos a -> sin (pi *. (cos (pi *. (eval (a, x, y)))))\n  | LimSin (a,b,c) ->\n      sin\n        (((pi *. (eval (a, x, y))) *. (eval (b, x, y))) +. (eval (c, x, y)));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SinCos of expr\n  | LimSin of expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> VarX | 2 -> VarY | _ -> VarX)\n  | _ ->\n      (match rand (1, 8) with\n       | 1 -> Sine (build (rand, (depth - 1)))\n       | 2 -> Cosine (build (rand, (depth - 1)))\n       | 3 ->\n           Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           Thresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 -> SinCos (build (rand, (depth - 1)))\n       | 7 ->\n           LimSin\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> VarX);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | SinCos x -> \"sin(pi*cos(pi*\" ^ ((exprToString x) ^ \"))\")\n  | LimSin (a,b,c) ->\n      \"sin(pi*\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString b) ^ (\"+\" ^ ((exprToString c) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | SinCos a -> sin (pi *. (cos (pi *. (eval (a, x, y)))))\n  | LimSin (a,b,c) ->\n      sin\n        (((pi *. (eval (a, x, y))) *. (eval (b, x, y))) +. (eval (c, x, y)));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SinCos of expr\n  | LimSin of expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> VarX | 2 -> VarY | _ -> VarX)\n  | _ ->\n      (match rand (1, 8) with\n       | 1 -> Sine (build (rand, (depth - 1)))\n       | 2 -> Cosine (build (rand, (depth - 1)))\n       | 3 ->\n           Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           Thresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 -> SinCos (build (rand, (depth - 1)))\n       | 7 ->\n           LimSin\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> VarX);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | SinCos x -> \"sin(pi*cos(pi*\" ^ ((exprToString x) ^ \"))\")\n  | LimSin (a,b,c) ->\n      \"sin(pi*\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString b) ^ (\"+\" ^ ((exprToString c) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | SinCos a -> sin (pi *. (cos (pi *. (eval (a, x, y)))))\n  | LimSin (a,b,c) ->\n      sin\n        (((pi *. (eval (a, x, y))) *. (eval (b, x, y))) +. (eval (c, x, y)));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | SinCos of expr\n  | LimSin of expr* expr* expr;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> VarX | 2 -> VarY | _ -> VarX)\n  | _ ->\n      (match rand (1, 8) with\n       | 1 -> Sine (build (rand, (depth - 1)))\n       | 2 -> Cosine (build (rand, (depth - 1)))\n       | 3 ->\n           Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 ->\n           Thresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 -> SinCos (build (rand, (depth - 1)))\n       | 7 ->\n           LimSin\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | _ -> VarX);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | SinCos x -> \"sin(pi*cos(pi*\" ^ ((exprToString x) ^ \"))\")\n  | LimSin (a,b,c) ->\n      \"sin(pi*\" ^\n        ((exprToString a) ^\n           (\"*\" ^ ((exprToString b) ^ (\"+\" ^ ((exprToString c) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
