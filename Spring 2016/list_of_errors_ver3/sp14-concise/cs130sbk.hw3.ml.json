{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 28-33:\n  let f a x = a + x^2 in\n              ^^^^^\nError: This expression has type int but an expression was expected of type\n         string\n", "min": "\nlet sqsum xs =\n  let f a x = (a + x) ^ 2 in let base = 0 in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = a + x^2 in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 38-39:\n  let f a x = a +. x ** 2in\n                        ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\nlet sqsum xs =\n  let f a x = a +. (x ** 2) in let base = 0 in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = a +. x ** 2in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 78-82:\n  List.fold_left f base xs;;\n                   ^^^^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\nlet sqsum xs =\n  let f a x = a +. (x ** 2.0) in let base = 0 in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = a +. x ** 2.0 in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 45-46:\n  let base = x in\n             ^\nError: Unbound value x\n", "min": "\nlet pipe fs = let f a x = a x in let base = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base = x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 50-51:\n  let base = x in\n             ^\nError: Unbound value x\n", "min": "\nlet pipe fs =\n  let f a x = fs (a x) in let base = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fs (a x) in\nlet base = x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 86-88:\n  List.fold_left f base fs;;\n                        ^^\nError: This expression has type 'a -> 'a -> 'a\n       but an expression was expected of type 'a list\n", "min": "\nlet pipe fs =\n  let f a x = fs (a x) in let base y = y in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = fs (a x) in\nlet base = fun y -> y in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 86-90:\n  | h::tl -> iter (h curr) tl in\n                     ^^^^\nError: This expression has type ('a -> 'b) list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b) list\n", "min": "\nlet pipe fs =\n  let rec iter acc curr =\n    match curr with | [] -> acc | h::tl -> iter (h curr) tl in\n  iter (fun y  -> y) fs;;\n", "in": "let pipe fs =\nlet rec iter acc curr = \nmatch curr with \n|[] -> acc\n| h::tl -> iter (h curr) tl in\niter (fun y-> y) fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs =\nlet rec iter acc curr = \nmatch curr with \n|[] -> acc\n| h::tl -> iter (h acc) tl in\niter (fun y-> y) fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs =\nlet rec iter acc curr = \nmatch curr with \n|[] -> acc\n| h::tl -> iter (h (acc)) tl in\niter (fun y-> y) fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs =\nlet rec iter acc curr = \nmatch curr with \n|[] -> acc\n| h::tl -> iter (h acc) tl in\niter (fun y-> y) fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs =\nlet rec iter acc curr = \nmatch curr with \n|[] -> acc\n| h::tl -> iter (h acc) tl in\niter (fun y-> y) fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs =\nlet rec iter acc curr = \nmatch curr with \n|[] -> acc\n| h::tl -> iter (h acc) tl in\niter id fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs =\nlet rec iter acc curr = \nmatch curr with \n|[] -> acc\n| h::tl -> iter (h acc) tl in\niter id fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs =\nlet rec iter acc curr = \nmatch curr with \n|[] -> acc\n| h::tl -> iter (fun x -> (h (acc x))) tl in\niter id fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x =  fun y -> (a (x y))   in\nlet base = fun y -> y in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x =  fun y -> (x (a y))   in\nlet base = fun y -> y in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x =  x ^ sep ^ a in\nlet base = h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x =  a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = failwith \"to be implemented\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 30-42:\n  \"[\" ^ List.map f l ^ \"]\";;\n        ^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type string\n", "min": "\nlet stringOfList f l = \"[\" ^ ((List.map f l) ^ \"]\");;\n", "in": "let stringOfList f l = \n\"[\" ^ List.map f l ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = \n\"[\" ^ List.fold_left (^) \n\"\"\n(List.map f l) ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 24-27:\n  \"[\" (fun x acc -> x ^ \"; \" ^ acc) \n  ^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\nlet stringOfList f l =\n  (\"[\" (fun x  -> fun acc  -> x ^ (\"; \" ^ acc)) List.fold_left (^) \"\"\n     (List.map f l))\n    ^ \"]\";;\n", "in": "let stringOfList f l = \n\"[\" (fun x acc -> x ^ \"; \" ^ acc) \nList.fold_left (^) \n\"\"\n(List.map f l) ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = \n\"[\" ^\nList.fold_left (fun x acc -> x ^ \"; \" ^ acc) \n\"\"\n(List.map f l) ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 77-79:\n  \"\"\n  ^^\nError: This expression has type string but an expression was expected of type\n         string list\n", "min": "\nlet stringOfList f l =\n  \"[\" ^\n    ((List.fold_right (fun x  -> fun acc  -> x ^ (\"; \" ^ acc)) \"\"\n        (List.map f l))\n       ^ \"]\");;\n", "in": "let stringOfList f l = \n\"[\" ^\nList.fold_right (fun x acc -> x ^ \"; \" ^ acc) \n\"\"\n(List.map f l) ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = \n\"[\" ^\n(List.fold_right (fun x acc -> x ^ \"; \" ^ acc) \n(List.map f l) \n\"\")\n^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = \n\"[\" ^\n(List.fold_left (fun acc x -> acc ^ \"; \" ^ x) \n\"\"\n(List.map f l) )\n^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = \n\"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = \nif (n <= 0) then []\nelse \nx :: (clone x (n-1))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 32-40:\n  let len1 = List.len l1 in\n             ^^^^^^^^\nError: Unbound value List.len\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.len l1 in\n  let len2 = List.len l2 in\n  (((clone 0 (len2 - len1)) @ l1), ((clone 0 (len1 - len2)) @ l2));;\n", "in": "let padZero l1 l2 = \nlet len1 = List.len l1 in\nlet len2 = List.len l2 in\n( clone 0 (len2 - len1) @ l1,\nclone 0 (len1 - len2)@  l2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\n( clone 0 (len2 - len1) @ l1,\nclone 0 (len1 - len2)@  l2)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 92-99:\n  clone 0 -diff @  l2);;\n  ^^^^^^^\nError: This expression has type int -> int list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), (((clone 0) - diff) @ l2));;\n", "in": "let padZero l1 l2 = \nlet diff = (List.length l2) - (List.length l1) in\n( clone 0 diff @ l1,\nclone 0 -diff @  l2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = \nlet diff = (List.length l2) - (List.length l1) in\n( clone 0 diff @ l1,\nclone 0 (-diff) @  l2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec removeZero l = match l with\n| [] -> l\n| h :: t -> if (h = 0) then t \nelse l"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 74-83:\n  | h :: t -> if (h = 0) then removeZer t \n                              ^^^^^^^^^\nError: Unbound value removeZer\nHint: Did you mean removeZero?\n", "min": "\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZer t else l;;\n", "in": "let rec removeZero l = match l with\n| [] -> l\n| h :: t -> if (h = 0) then removeZer t \nelse l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec removeZero l = match l with\n| [] -> l\n| h :: t -> if (h = 0) then removeZero t \nelse l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = failwith \"to be implemented\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 150-154:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((x / 10), 1) in\n    let base = (0, 0) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (x / 10, 1 ) in\nlet base = (0 , 0) in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 52-60:\n  let f a x = failWith \"\" in\n              ^^^^^^^^\nError: Unbound value failWith\nHint: Did you mean failwith?\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failWith \"\" in\n    let base = (0, 0) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failWith \"\" in\nlet base = (0 , 0) in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 149-153:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"\" in\n    let base = (0, 0) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"\" in\nlet base = (0 , 0) in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}, {"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = failwith \"to be implemented\""}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 19-27:\n  let bigAdd l1 l2 = failWith \"moo\";;\n                     ^^^^^^^^\nError: Unbound value failWith\nHint: Did you mean failwith?\n", "min": "\nlet bigAdd l1 l2 = failWith \"moo\";;\n", "in": "let bigAdd l1 l2 = failWith \"moo\""}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 19-27:\n  let bigAdd l1 l2 = failWith \"moo\";;\n                     ^^^^^^^^\nError: Unbound value failWith\nHint: Did you mean failwith?\n", "min": "\nlet bigAdd l1 l2 = failWith \"moo\";;\n", "in": "let bigAdd l1 l2 = failWith \"moo\""}, {"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = failwith \"to be implemented\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = failwith \"moo\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 178-199:\n  removeZero (add (padZero l1 l2));;\n             ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"\" in\n    let base = (0, 0) in\n    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"\" in\nlet base = (0 , 0) in\nlet args = [(l1, l2)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 263-275:\n  (if addit > 10 then addit mod 10\n                      ^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int * int list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          (match x with\n           | (carry,num) ->\n               let addit = ((List.hd l1) + (List.hd l2)) + carry in\n               if addit > 10 then addit mod 10 else (0, ((addit / 10) :: x))) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with \n| ([], []) ->  let (carry, num) = x in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) -> \nmatch x with\n| (carry, num) -> let addit = List.hd l1 + List.hd l2 + carry in\n(if addit > 10 then addit mod 10\nelse 0 , addit / 10 :: x)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 263-275:\n  (if addit > 10 then addit mod 10\n                      ^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int * int list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          (match x with\n           | (carry,num) ->\n               let addit = ((List.hd l1) + (List.hd l2)) + carry in\n               if addit > 10 then addit mod 10 else (0, ((addit / 10) :: x))) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with \n| ([], []) ->  let (carry, num) = x in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) -> \nmatch x with\n| (carry, num) -> let addit = List.hd l1 + List.hd l2 + carry in\n(if addit > 10 then addit mod 10\nelse 0 , (addit / 10) :: x)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 303-304:\n  else 0) , (addit / 10) :: x)\n                            ^\nError: This expression has type int * int list\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          (match x with\n           | (carry,num) ->\n               let addit = ((List.hd l1) + (List.hd l2)) + carry in\n               ((if addit > 10 then addit mod 10 else 0), ((addit / 10) ::\n                 x))) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with \n| ([], []) ->  let (carry, num) = x in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) -> \nmatch x with\n| (carry, num) -> let addit = List.hd l1 + List.hd l2 + carry in\n((if addit > 10 then addit mod 10\nelse 0) , (addit / 10) :: x)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 303-304:\n  (addit / 10) :: x)\n                  ^\nError: This expression has type int * int list\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          (match x with\n           | (carry,num) ->\n               let addit = ((List.hd l1) + (List.hd l2)) + carry in\n               ((if addit > 10 then addit mod 10 else 0), ((addit / 10) ::\n                 x))) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with \n| ([], []) ->  let (carry, num) = x in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) -> \nmatch x with\n| (carry, num) -> let addit = List.hd l1 + List.hd l2 + carry in\n((if addit > 10 then addit mod 10 else 0) ,\n(addit / 10) :: x)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 301-302:\n  addit / 10 :: x)\n                ^\nError: This expression has type int * int list\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          (match x with\n           | (carry,num) ->\n               let addit = ((List.hd l1) + (List.hd l2)) + carry in\n               ((if addit > 10 then addit mod 10 else 0), ((addit / 10) ::\n                 x))) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with \n| ([], []) ->  let (carry, num) = x in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) -> \nmatch x with\n| (carry, num) -> let addit = List.hd l1 + List.hd l2 + carry in\n((if addit > 10 then addit mod 10 else 0) ,\naddit / 10 :: x)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 294-295:\n  addit / 10 :: x)\n                ^\nError: This expression has type int * int list\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = x in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: x)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with \n| ([], []) ->  let (carry, num) = x in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) ->  let (carry, num) = x in\nlet addit = List.hd l1 + List.hd l2 + carry in\n((if addit > 10 then addit mod 10 else 0) ,\naddit / 10 :: x)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 294-295:\n  addit / 10 :: x)\n                ^\nError: This expression has type int * int list\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = x in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: x)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with \n| ([], []) ->  let (carry, num) = x in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) ->  let (carry, num) = x in\nlet addit = List.hd l1 + List.hd l2 + carry in\n((if addit > 10 then addit mod 10 else 0) ,\naddit / 10 :: x)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 296-297:\n  addit / 10 :: x)\n                ^\nError: This expression has type int * int list\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = x in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: x)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with \n| ([], []) ->  let (carry, num) = x in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) ->  let (carry, num) = x in\nlet addit = List.hd l1 + List.hd l2 + carry in\n((if (addit > 10) then addit mod 10 else 0) ,\naddit / 10 :: x)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 298-299:\n  addit / 10 :: x)\n                ^\nError: This expression has type int * int list\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = x in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: x)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch a with \n| ([], []) ->  let (carry, num) = x in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) ->  let (carry, num) = x in\nlet addit = List.hd l1 + List.hd l2 + carry in\n((if (addit > 10) then (addit mod 10) else 0) ,\naddit / 10 :: x)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 298-299:\n  addit / 10 :: x)\n                ^\nError: This expression has type int list * int list\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: x)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch x with \n| ([], []) ->  let (carry, num) = a in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) ->  let (carry, num) = a in\nlet addit = List.hd l1 + List.hd l2 + carry in\n((if (addit > 10) then (addit mod 10) else 0) ,\naddit / 10 :: x)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 298-299:\n  addit / 10 :: x)\n                ^\nError: This expression has type int list * int list\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: x)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch x with \n| ([], []) ->  let (carry, num) = a in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) ->  let (carry, num) = a in\nlet addit = List.hd l1 + List.hd l2 + carry in\n((if (addit > 10) then (addit mod 10) else 0) ,\naddit / 10 :: x)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 298-299:\n  addit / 10 :: a)\n                ^\nError: This expression has type int * int list\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: a)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch x with \n| ([], []) ->  let (carry, num) = a in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) ->  let (carry, num) = a in\nlet addit = List.hd l1 + List.hd l2 + carry in\n((if (addit > 10) then (addit mod 10) else 0) ,\naddit / 10 :: a)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 298-299:\n  addit / 10 :: a)\n                ^\nError: This expression has type int * int list\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: a)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch x with \n| ([], []) ->  let (carry, num) = a in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) ->  let (carry, num) = a in\nlet addit = List.hd l1 + List.hd l2 + carry in\n((if (addit > 10) then (addit mod 10) else 0) ,\naddit / 10 :: a)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 300-301:\n  (addit / 10) :: a)\n                  ^\nError: This expression has type int * int list\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: a)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch x with \n| ([], []) ->  let (carry, num) = a in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) ->  let (carry, num) = a in\nlet addit = List.hd l1 + List.hd l2 + carry in\n((if (addit > 10) then (addit mod 10) else 0) ,\n(addit / 10) :: a)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 299-300:\n  ((if (addit > 10) then (addit mod 10) else 0), (addit / 10) :: a)\n                                                                 ^\nError: This expression has type int * int list\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: a)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch x with \n| ([], []) ->  let (carry, num) = a in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) ->  let (carry, num) = a in\nlet addit = List.hd l1 + List.hd l2 + carry in\n((if (addit > 10) then (addit mod 10) else 0), (addit / 10) :: a)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 395-399:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type int * int\n       but an expression was expected of type int * int list\n       Type int is not compatible with type int list \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch x with \n| ([], []) ->  let (carry, num) = a in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) ->  let (carry, num) = a in\nlet addit = List.hd l1 + List.hd l2 + carry in\n((if (addit > 10) then (addit mod 10) else 0), \n(addit / 10) :: num)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 395-399:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type int * int\n       but an expression was expected of type int * int list\n       Type int is not compatible with type int list \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch x with \n| ([], []) ->  let (carry, num) = a in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) ->  let (carry, num) = a in\nlet addit = List.hd l1 + List.hd l2 + carry in\n((if (addit > 10) then (addit mod 10) else 0), \n(addit / 10) :: num)\nin\nlet base = (0 , 0) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 433-448:\n  removeZero (add (padZero l1 l2));;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type int list list * int list list\n       Type int is not compatible with type int list \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch x with \n| ([], []) ->  let (carry, num) = a in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) ->  let (carry, num) = a in\nlet addit = List.hd l1 + List.hd l2 + carry in\n((if (addit > 10) then (addit mod 10) else 0), \n(addit / 10) :: num)\nin\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 433-448:\n  removeZero (add (padZero l1 l2));;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type int list list * int list list\n       Type int is not compatible with type int list \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nmatch x with \n| ([], []) ->  let (carry, num) = a in\n(0, if carry > 0 then carry :: num else num)\n| (l1, l2) ->  let (carry, num) = a in\nlet addit = List.hd l1 + List.hd l2 + carry in\n((if (addit > 10) then (addit mod 10) else 0), \n(addit / 10) :: num)\nin\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec removeZero l = match l with\n| [] -> l\n| h :: t -> if (h = 0) then removeZero t \nelse l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 411-426:\n  removeZero (add (padZero l1 l2));;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type int list list * int list list\n       Type int is not compatible with type int list \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      match x with\n      | ([],[]) -> (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nmatch x with \n| ([], []) ->  (0, if carry > 0 then carry :: num else num)\n| (l1, l2) -> \nlet addit = List.hd l1 + List.hd l2 + carry in\n((if (addit > 10) then (addit mod 10) else 0), \n(addit / 10) :: num)\t  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 415-430:\n  removeZero (add (padZero l1 l2));;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type int list list * int list list\n       Type int is not compatible with type int list \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      match x with\n      | ([],[]) -> (0, (if carry > 0 then carry :: num else num))\n      | (l1',l2') ->\n          let addit = ((List.hd l1') + (List.hd l2')) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nmatch x with \n| ([], []) ->  (0, if carry > 0 then carry :: num else num)\n| (l1', l2') -> \nlet addit = List.hd l1' + List.hd l2' + carry in\n((if (addit > 10) then (addit mod 10) else 0), \n(addit / 10) :: num)\t  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 415-430:\n  removeZero (add (padZero l1 l2));;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type int list list * int list list\n       Type int is not compatible with type int list \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      match x with\n      | ([],[]) -> (0, (if carry > 0 then carry :: num else num))\n      | (l1',l2') ->\n          let addit = ((List.hd l1') + (List.hd l2')) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nmatch x with \n| ([], []) ->  (0, if carry > 0 then carry :: num else num)\n| (l1', l2') -> \nlet addit = List.hd l1' + List.hd l2' + carry in\n((if (addit > 10) then (addit mod 10) else 0), \n(addit / 10) :: num)\t  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 179-182:\n  let addit = l1' + l2' + carry in\n              ^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      match x with\n      | ([],[]) -> (0, (if carry > 0 then carry :: num else num))\n      | (l1',l2') ->\n          let addit = (l1' + l2') + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nmatch x with \n| ([], []) ->  (0, if carry > 0 then carry :: num else num)\n| (l1', l2') -> \nlet addit = l1' + l2' + carry in\n((if (addit > 10) then (addit mod 10) else 0), \n(addit / 10) :: num)\t  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 378-382:\n  let (_, res) = List.fold_left f base args in res\n                                       ^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      match x with\n      | [] -> (0, (if carry > 0 then carry :: num else num))\n      | h::t ->\n          let (l1',l2') = h in\n          let addit = (l1' + l2') + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nmatch x with \n| [] -> (0, if carry > 0 then carry :: num else num)\n| h :: t -> let (l1', l2') = h in \nlet addit = l1' + l2' + carry in\n((if (addit > 10) then (addit mod 10) else 0), \n(addit / 10) :: num)\t  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x =  fun y -> (x (a y))   in\nlet base = fun y -> y in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n((if (addit > 10) then (addit mod 10) else 0), \n(addit / 10) :: num)\t  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x*x - a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x =  fun y -> (x (a y))   in\nlet base = fun y -> y in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n((if (addit > 10) then (addit / 10) else 0), \n( addit mod 10 :: num)\t)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n((if (addit > 10) then 1 else 0), \n( addit mod 10 :: num))  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec removeZero l = match l with\n| [] -> l\n| h :: t -> if (h = 0) then removeZero t \nelse l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 282-283:\n  let (_, res) = List.fold_right f args base in res\n                                 ^\nError: This expression has type int * int list -> int * int -> int * int list\n       but an expression was expected of type\n         int * int list -> int * int -> int * int\n       Type int list is not compatible with type int \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((if addit > 10 then 1 else 0), ((addit mod 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_right f args base in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n((if (addit > 10) then 1 else 0), \n( addit mod 10 :: num))  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_right f args base in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f x a = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n((if (addit > 10) then 1 else 0), \n( addit mod 10 :: num))  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_right f args base in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n((if (addit > 10) then 1 else 0), \n( addit mod 10 :: num))  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n((if (addit >= 10) then 1 else 0), \n( addit mod 10 :: num))  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n((if (addit > 9) then 1 else 0), \n( addit mod 10 :: num))  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\naddit / 10, \n( addit mod 10 :: num)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, ( addit mod 10 :: num))  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 273-274:\n  let (_, res) = List.fold_left f base args in res\n                                ^\nError: This expression has type\n         ((int -> unit) -> int -> int) * int list ->\n         int * int -> int * int list\n       but an expression was expected of type\n         ((int -> unit) -> int -> int) * int list ->\n         int * int -> ((int -> unit) -> int -> int) * int list\n       Type int is not compatible with type (int -> unit) -> int -> int \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + (carry print_int l1') in\n      ((addit / 10), ((addit mod 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry \nprint_int l1' in\n(addit / 10, ( addit mod 10 :: num)) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, ((addit mod 10) :: num)) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, ((addit mod 10) :: num)) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 259-260:\n  let (_, res) = List.fold_left f base args in res\n                                ^\nError: This expression has type int * int -> int * int list -> int * int list\n       but an expression was expected of type\n         int * int -> int * int list -> int * int\n       Type int list is not compatible with type int \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = x in\n      let (l1',l2') = a in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), ((addit mod 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = x in\nlet (l1', l2') = a in \nlet addit = l1' + l2' + carry in\n(addit / 10, ((addit mod 10) :: num)) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, ((addit mod 10) :: num)) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 153-154:\n  let (_, res) = List.fold_left f base args in res\n                                ^\nError: This expression has type 'a list -> 'a -> int * 'a list\n       but an expression was expected of type 'a list -> 'a -> 'a list\n       Type int * 'a list is not compatible with type 'a list \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, (x :: a)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  (0, x :: a) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 153-154:\n  let (_, res) = List.fold_left f base args in res\n                                ^\nError: This expression has type 'a list -> 'a -> int * 'a list\n       but an expression was expected of type 'a list -> 'a -> 'a list\n       Type int * 'a list is not compatible with type 'a list \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, (x :: a)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  (0, x :: a) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 175-176:\n  let (_, res) = List.fold_left f base args in res\n                                ^\nError: This expression has type 'a list -> 'b * 'a -> int * 'a list\n       but an expression was expected of type 'a list -> 'b * 'a -> 'a list\n       Type int * 'a list is not compatible with type 'a list \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (l1,l2) = x in (0, (l2 :: a)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  let (l1, l2) = x in\n(0, l2 :: a)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 175-176:\n  let (_, res) = List.fold_left f base args in res\n                                ^\nError: This expression has type 'a list -> 'b * 'a -> int * 'a list\n       but an expression was expected of type 'a list -> 'b * 'a -> 'a list\n       Type int * 'a list is not compatible with type 'a list \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (l1,l2) = x in (0, (l2 :: a)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  let (l1, l2) = x in\n(0, l2 :: a)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 175-176:\n  let (_, res) = List.fold_left f base args in res\n                                ^\nError: This expression has type 'a list -> 'a * 'b -> int * 'a list\n       but an expression was expected of type 'a list -> 'a * 'b -> 'a list\n       Type int * 'a list is not compatible with type 'a list \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (l1,l2) = x in (0, (l1 :: a)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  let (l1, l2) = x in\n(0, l1 :: a)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 110-113:\n  (0, l1 :: num)  in\n            ^^^\nError: Unbound value num\nHint: Did you mean nume?\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (carry,nume) = a in let (l1,l2) = x in (0, (l1 :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  \nlet (carry, nume ) = a in \nlet (l1, l2) = x in\n(0, l1 :: num)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 110-113:\n  (0, l1 :: num)  in\n            ^^^\nError: Unbound value num\nHint: Did you mean nume?\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (carry,nume) = a in let (l1,l2) = x in (0, (l1 :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  \nlet (carry, nume ) = a in \nlet (l1, l2) = x in\n(0, l1 :: num)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  \nlet (carry, num) = a in \nlet (l1, l2) = x in\n(0, l1 :: num)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  \nlet (carry, num) = a in \nlet (l1, l2) = x in\n(0, l1 :: num)  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =  \nlet (carry, num) = a in \nlet (l1, l2) = x in\n(0, num @ [l1] )  in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 151-168:\n  (addit / 10, num @ ((addit mod 10) )) in\n                     ^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), (num @ (addit mod 10))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ ((addit mod 10) )) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 151-165:\n  (addit / 10, num @ (addit mod 10) ) in\n                     ^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), (num @ (addit mod 10))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ (addit mod 10) ) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 151-165:\n  (addit / 10, num @ (addit mod 10) ) in\n                     ^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), (num @ (addit mod 10))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ (addit mod 10) ) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ [(addit mod 10)]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ [(addit mod 10)]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ [(addit mod 10)]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (car, res) = List.fold_left f base args in car\nin \n(add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value removeZeros\nHint: Did you mean removeZero?\nError: Unbound value removeZeros\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 283-294:\n  removeZeros (add (padZero l1 l2));;\n  ^^^^^^^^^^^\nError: Unbound value removeZeros\nHint: Did you mean removeZero?\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (car,res) = List.fold_left f base args in res in\n  removeZeros (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ [(addit mod 10)]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZeros (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = l1' + l2' + carry in\n(addit / 10, num @ [(addit mod 10)]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10, num @ [(addit mod 10)]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 162-185:\n  (if addit >= 10 then 1 else 0, num @ [addit mod 10]) in\n                              ^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      if addit >= 10 then 1 else (0, (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(if addit >= 10 then 1 else 0, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 162-185:\n  (if addit >= 10 then 1 else 0, num @ [addit mod 10]) in\n                              ^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      if addit >= 10 then 1 else (0, (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(if addit >= 10 then 1 else 0, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine l1 l2 in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x =  a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 329-344:\n  removeZero (add (padZero l1 l2));;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type int * int\n       Type int list is not compatible with type int \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine [0; l1] [0; l2] in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine [0; l1] [0; l2] in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nfailwith \"hi %s\" addit\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nfailwith \"hi %d\" addit\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 143-149:\n  failwith printf.sprintf \"hi %d\" addit\n           ^^^^^^\nError: Unbound value printf\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      failwith printf.sprintf \"hi %d\" addit\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nfailwith printf.sprintf \"hi %d\" addit\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 143-157:\n  failwith Printf.sprintf \"hi %d\" addit\n           ^^^^^^^^^^^^^^\nError: This expression has type ('a, unit, string) format -> 'a\n       but an expression was expected of type string\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      failwith Printf.sprintf \"hi %d\" addit\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nfailwith Printf.sprintf \"hi %d\" addit\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nfailwith (Printf.sprintf \"hi %d\" addit)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nfailwith (Printf.sprintf \"hi %d\" car) res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 148-155:\n  Printf.printf \"hi %d\" car \n                ^^^^^^^\nError: This expression has type\n         ('a -> 'b, out_channel, unit, unit, unit, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, out_channel, unit, unit, unit, unit)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type unit \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"hi %d\" car\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf \"hi %d\" car \n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 157-160:\n  (Printf.printf \"hi %d\" car )\n                         ^^^\nError: Unbound value car\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.printf \"hi %d\" car)\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" car )\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 157-160:\n  (Printf.printf \"hi %d\" car );\n                         ^^^\nError: Unbound value car\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"hi %d\" car;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" car );\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 157-160:\n  (Printf.printf \"hi %d\" car; )\n                         ^^^\nError: Unbound value car\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.printf \"hi %d\" car)\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" car; )\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 134-165:\n  (Printf.printf \"hi %d\" carry; )\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type unit\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.printf \"hi %d\" carry)\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry; )\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 134-167:\n  (Printf.printf (\"hi %d\") carry; )\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type unit\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.printf \"hi %d\" carry)\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (\"hi %d\") carry; )\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 134-165:\n  (Printf.printf (\"hi %d\") carry)\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type unit\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.printf \"hi %d\" carry)\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (\"hi %d\") carry)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 150-159:\n  (Printf.kprintf (\"hi %d\") carry)\n                  ^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         string -> 'a\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.kprintf \"hi %d\" carry)\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.kprintf (\"hi %d\") carry)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 134-165:\n  (Printf.printf (\"hi %d\") carry)\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type unit\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.printf \"hi %d\" carry)\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (\"hi %d\") carry)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 134-163:\n  (Printf.printf \"hi %d\" carry)\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type unit\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.printf \"hi %d\" carry)\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 150-157:\n  (Printf.printf (\"hi %d\" carry))\n                  ^^^^^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.printf (\"hi %d\" carry))\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (\"hi %d\" carry))\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 134-163:\n  (Printf.printf \"hi %d\" carry)\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type unit\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.printf \"hi %d\" carry)\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry)\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %d\" carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 157-162:\n  (Printf.printf \"hi %s\" carry;\n                         ^^^^^\nError: This expression has type int but an expression was expected of type\n         string\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"hi %s\" carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"hi %s\" carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\\n\" addit; in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\\n\" 1; in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 143-162:\n  let () = Printf.printf \"%d\"; in\n           ^^^^^^^^^^^^^^^^^^^\nError: This expression has type int -> unit\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      let () = Printf.printf \"%d\" in\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet () = Printf.printf \"%d\"; in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf \"%d\";\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf \"1\\n\";\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf \"%d\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%d\\n\" addit);\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 149-155:\n  Printf.printf (\"%d\\n\" addit);\n                 ^^^^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf (\"%d\\n\" addit);\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf (\"%d\\n\" addit);\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 148-163:\n  Printf.printf (\"%d\\n\", addit);\n                ^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type\n         ('c, out_channel, unit) format =\n           ('c, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf (\"%d\\n\", addit);\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf (\"%d\\n\", addit);\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf \"%d\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf \"%3d\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nPrintf.printf \"%8d%8d%8d\\n\" l1' l2' carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%8d%8d%8d\\n\" l1' l2' carry;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 164-167:\n  (Printf.printf \"%8d%8d%8d\\n\"; l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\n                                ^^^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%8d%8d%8d\\n\";\n      l1' l2' carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%8d%8d%8d\\n\"; l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%8d%8d%8d\\n\"; l1'; l2'; carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 149-163:\n  (Printf.printf Printf.sprintf \"%8d%8d%8d\\n\"; l1'; l2'; carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\n                 ^^^^^^^^^^^^^^\nError: This expression has type ('a, unit, string) format -> 'a\n       but an expression was expected of type\n         ('b -> 'c, out_channel, unit) format =\n           ('b -> 'c, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf Printf.sprintf \"%8d%8d%8d\\n\";\n      l1';\n      l2';\n      carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf Printf.sprintf \"%8d%8d%8d\\n\"; l1'; l2'; carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf; Printf.sprintf \"%8d%8d%8d\\n\"; l1'; l2'; carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf; Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 149-163:\n  (Printf.printf Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\n                 ^^^^^^^^^^^^^^\nError: This expression has type ('a, unit, string) format -> 'a\n       but an expression was expected of type\n         ('b -> 'c -> 'd -> 'e -> 'f, out_channel, unit) format =\n           ('b -> 'c -> 'd -> 'e -> 'f, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 149-193:\n  (Printf.printf (Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry); ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         ('a, out_channel, unit) format =\n           ('a, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf (Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry);\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf (Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry); ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 149-154:\n  (Printf.printf \"%s \"Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\n                 ^^^^^\nError: This expression has type\n         ('a -> 'b -> 'c -> 'd -> 'e, out_channel, unit, unit, unit,\n          'a -> 'b -> 'c -> 'd -> 'e)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b -> 'c -> 'd -> 'e, out_channel, unit, unit, unit, unit)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b -> 'c -> 'd -> 'e is not compatible with type unit \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s \" Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s \"Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 149-153:\n  (Printf.printf \"%s\" Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\n                 ^^^^\nError: This expression has type\n         ('a -> 'b -> 'c -> 'd -> 'e, out_channel, unit, unit, unit,\n          'a -> 'b -> 'c -> 'd -> 'e)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b -> 'c -> 'd -> 'e, out_channel, unit, unit, unit, unit)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b -> 'c -> 'd -> 'e is not compatible with type unit \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\" Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\" Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\"; Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"1\"; Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\"; Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry; ((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 149-155:\n  (Printf.printf \"%s\\n\" addit\n                 ^^^^^^\nError: This expression has type\n         ('a -> 'b, out_channel, unit, unit, unit, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, out_channel, unit, unit, unit, unit)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type unit \n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\\n\" addit\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 156-161:\n  (Printf.printf \"%s\\n\" addit;\n                        ^^^^^\nError: This expression has type int but an expression was expected of type\n         string\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\\n\" addit;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 156-161:\n  (Printf.printf \"%s\\n\" addit;\n                        ^^^^^\nError: This expression has type int but an expression was expected of type\n         string\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\\n\" addit;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 156-161:\n  (Printf.printf \"%s\\n\" addit;\n                        ^^^^^\nError: This expression has type int but an expression was expected of type\n         string\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\\n\" addit;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 156-161:\n  (Printf.printf \"%s\\n\" addit;\n                        ^^^^^\nError: This expression has type int but an expression was expected of type\n         string\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\\n\" addit;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 156-161:\n  (Printf.printf \"%s\\n\" addit;\n                        ^^^^^\nError: This expression has type int but an expression was expected of type\n         string\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\\n\" addit;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 156-161:\n  (Printf.printf \"%s\\n\" addit;\n                        ^^^^^\nError: This expression has type int but an expression was expected of type\n         string\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\\n\" addit;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(Printf.printf \"%s\\n\" addit;\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 157-162:\n  ((Printf.printf \"%s\\n\" addit);\n                         ^^^^^\nError: This expression has type int but an expression was expected of type\n         string\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\\n\" addit;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((Printf.printf \"%s\\n\" addit);\n((if addit >= 10 then 1 else 0), num @ [addit mod 10])) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = Printf.printf \"%d\\n\" addit in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = (Printf.printf \"%d\\n\" addit) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = Printf.printf \"%d\\n\" addit in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 156-169:\n  let _ = Printf.printf string_of_int addit in\n                        ^^^^^^^^^^^^^\nError: This expression has type int -> string\n       but an expression was expected of type\n         ('a -> 'b, out_channel, unit) format =\n           ('a -> 'b, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      let _ = Printf.printf string_of_int addit in\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = Printf.printf string_of_int addit in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 156-177:\n  let _ = Printf.printf (string_of_int addit) in\n                        ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         ('a, out_channel, unit) format =\n           ('a, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      let _ = Printf.printf (string_of_int addit) in\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = Printf.printf (string_of_int addit) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 156-177:\n  let _ = Printf.printf (string_of_int addit) in\n                        ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         ('a, out_channel, unit) format =\n           ('a, out_channel, unit, unit, unit, unit)\n           CamlinternalFormatBasics.format6\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      let _ = Printf.printf (string_of_int addit) in\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\nlet _ = Printf.printf (string_of_int addit) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + 1) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n((if addit >= 10 then 1 else 0), num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine ([0] @ l1) ([0]@ l2) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 220-232:\n  let args = List.combine (List.reverse ([0] @ l1)) (List.Reverse ([0]@ l2)) in\n                           ^^^^^^^^^^^^\nError: Unbound value List.reverse\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args =\n      List.combine (List.reverse ([0] @ l1)) (List.Reverse ([0] @ l2)) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine (List.reverse ([0] @ l1)) (List.Reverse ([0]@ l2)) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine (List.rev ([0] @ l1)) (List.rev ([0]@ l2)) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 313-322:\n  List.reve res\n  ^^^^^^^^^\nError: Unbound value List.reve\nHint: Did you mean rev?\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine (List.rev ([0] @ l1)) (List.rev ([0] @ l2)) in\n    let (car,res) = List.fold_left f base args in List.reve res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine (List.rev ([0] @ l1)) (List.rev ([0]@ l2)) in\nlet (car, res) = List.fold_left f base args in \nList.reve res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10, num @ [addit mod 10]) in\nlet base = (0 , []) in\nlet args = List.combine (List.rev ([0] @ l1)) (List.rev ([0]@ l2)) in\nlet (car, res) = List.fold_left f base args in \nList.rev res\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10, (addit mod 10) :: num) in\nlet base = (0 , []) in\nlet args = List.combine (List.rev ([0] @ l1)) (List.rev ([0]@ l2)) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10, (addit mod 10) :: num) in\nlet base = (0 , []) in\nlet args = List.combine (List.rev ([0] @ l1)) (List.rev ([0]@ l2)) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = mulByDigit (i - 1)\n(bigAdd l l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = mulByDigit (i - 1) (bigAdd l l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = if i = 0 then l \nelse mulByDigit (i - 1) (bigAdd l l)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-18:\n  let _ = mulByDigit 9 [9;9;9;9];;\n          ^^^^^^^^^^\nError: Unbound value mulByDigit\n", "min": "\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "in": "let rec mulByDigit i l = if i = 1 then l \nelse mulByDigit (i - 1) (bigAdd l l)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-18:\n  let _ = mulByDigit 9 [9;9;9;9];;\n          ^^^^^^^^^^\nError: Unbound value mulByDigit\n", "min": "\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "in": "let rec mulByDigit i l = if i = 0 then 0\nelse if i = 1 then l \nelse l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = if i = 0 then 0\nelse if i = 1 then l \nelse (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)\nelse bigAdd l (mulByDibit (i - 1) l)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 108-114:\n  else if (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)\n                                               ^^^^^^\nError: Unbound value bigAdd\n", "min": "\nlet rec mulByDigit i l =\n  if i = 0\n  then 0\n  else\n    if i = 1\n    then l\n    else\n      if (i mod 2) = 0\n      then mulByDigit (i / 2) (bigAdd l l)\n      else bigAdd l (mulByDibit (i - 1) l);;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (carry, num) = a in\nlet (l1', l2') = x in \nlet addit = (l1' + l2' + carry) in\n(addit / 10, (addit mod 10) :: num) in\nlet base = (0 , []) in\nlet args = List.combine (List.rev ([0] @ l1)) (List.rev ([0]@ l2)) in\nlet (car, res) = List.fold_left f base args in \nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-14:\n  let _ = bigAdd [9;9;9;9] [9;9;9];;\n          ^^^^^^\nError: Unbound value bigAdd\n", "min": "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "in": "let rec mulByDigit i l = if i = 0 then 0\nelse if i = 1 then l \nelse if (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)\nelse bigAdd l (mulByDibit (i - 1) l)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 108-114:\n  else if (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)\n                                               ^^^^^^\nError: Unbound value bigAdd\n", "min": "\nlet rec mulByDigit i l =\n  if i = 0\n  then 0\n  else\n    if i = 1\n    then l\n    else\n      if (i mod 2) = 0\n      then mulByDigit (i / 2) (bigAdd l l)\n      else bigAdd l (mulByDibit (i - 1) l);;\n", "in": "let rec mulByDigit i l = if (i = 0) then 0\nelse if (i = 1) then l \nelse if (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)\nelse bigAdd l (mulByDibit (i - 1) l)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 112-118:\n  else if (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)\n                                               ^^^^^^\nError: Unbound value bigAdd\n", "min": "\nlet rec mulByDigit i l =\n  if i = 0\n  then 0\n  else\n    if i = 1\n    then l\n    else\n      if (i mod 2) = 0\n      then mulByDigit (i / 2) (bigAdd l l)\n      else bigAdd l (mulByDibit (i - 1) l);;\n", "in": "let rec mulByDigit i l = if (i = 0) then 0\nelse if (i = 1) then l \nelse if (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)\nelse bigAdd l (mulByDigit (i - 1) l)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 112-118:\n  else if (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)\n                                               ^^^^^^\nError: Unbound value bigAdd\n", "min": "\nlet rec mulByDigit i l =\n  if i = 0\n  then 0\n  else\n    if i = 1\n    then l\n    else\n      if (i mod 2) = 0\n      then mulByDigit (i / 2) (bigAdd l l)\n      else bigAdd l (mulByDigit (i - 1) l);;\n", "in": "let rec mulByDigit i l = if (i = 0) then []\nelse if (i = 1) then l \nelse if (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)\nelse bigAdd l (mulByDigit (i - 1) l)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 21-30:\n  let _ = mulByDigit 9 [9;9;9;9];;\n                       ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l = if i = 0 then 0 else if i = 1 then l else l;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "in": "let rec mulByDigit i l = if (i = 0) then []\nelse if (i = 1) then l \nelse bigAdd l (mulByDigit (i - 1) l)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 21-30:\n  let _ = mulByDigit 9 [9;9;9;9];;\n                       ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l = if i = 0 then 0 else if i = 1 then l else l;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "in": "let rec mulByDigit i l = if (i = 0) then []\nelse if (i = 1) then l \nelse if (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)\nelse bigAdd l (mulByDigit (i - 1) l)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 21-30:\n  let _ = mulByDigit 9 [9;9;9;9];;\n                       ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l = if i = 0 then 0 else if i = 1 then l else l;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "in": "let rec mulByDigit i l = if (i = 0) then []\nelse if (i = 1) then l \nelse if (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)\nelse bigAdd l (mulByDigit (i - 1) l)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 113-119:\n  else if (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)\n                                               ^^^^^^\nError: Unbound value bigAdd\n", "min": "\nlet rec mulByDigit i l =\n  if i = 0\n  then []\n  else\n    if i = 1\n    then l\n    else\n      if (i mod 2) = 0\n      then mulByDigit (i / 2) (bigAdd l l)\n      else bigAdd l (mulByDigit (i - 1) l);;\n", "in": "let rec mulByDigit i l = if (i = 0) then []\nelse if (i = 1) then l \nelse if (i mod 2 = 0) then mulByDigit (i/2) (bigAdd l l)\nelse bigAdd l (mulByDigit (i - 1) l)"}, {"type": "type", "out": "Characters 21-30:\n  let _ = mulByDigit 9 [9;9;9;9];;\n                       ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l = if i = 0 then 0 else if i = 1 then l else l;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "in": "let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 21-30:\n  let _ = mulByDigit 9 [9;9;9;9];;\n                       ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l = if i = 0 then 0 else if i = 1 then l else l;;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement =  10 ** place  in\n(addit / 10, (addit mod 10) :: num) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 74-76:\n  let placement =  10 ** place  in\n                   ^^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,num) = a in\n    let placement = 10 ** place in ((addit / 10), ((addit mod 10) :: num)) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(addit / 10, (addit mod 10) :: num) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 138-143:\n  (addit / 10, (addit mod 10) :: num) in\n   ^^^^^\nError: Unbound value addit\n", "min": "\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,num) = a in\n    let placement =\n      ((float_of_int 10) ** (float_of_int place)) |> int_of_float in\n    ((addit / 10), ((addit mod 10) :: num)) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(bigAdd a mulByDigit (x * place) l1) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 138-144:\n  (bigAdd a mulByDigit (x * place) l1) in\n   ^^^^^^\nError: Unbound value bigAdd\n", "min": "\nlet rec mulByDigit i l = if i = 0 then 0 else if i = 1 then l else l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,num) = a in\n    let placement =\n      ((float_of_int 10) ** (float_of_int place)) |> int_of_float in\n    bigAdd a mulByDigit (x * place) l1 in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(bigAdd a mulByDigit ((x * place) l1)) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 138-144:\n  (bigAdd a mulByDigit ((x * place) l1)) in\n   ^^^^^^\nError: Unbound value bigAdd\n", "min": "\nlet rec mulByDigit i l = if i = 0 then 0 else if i = 1 then l else l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,num) = a in\n    let placement =\n      ((float_of_int 10) ** (float_of_int place)) |> int_of_float in\n    bigAdd a mulByDigit ((x * place) l1) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(bigAdd a (mulByDigit (x * place) l1)) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 138-144:\n  (bigAdd a (mulByDigit (x * place) l1)) in\n   ^^^^^^\nError: Unbound value bigAdd\n", "min": "\nlet rec mulByDigit i l = if i = 0 then 0 else if i = 1 then l else l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,num) = a in\n    let placement =\n      ((float_of_int 10) ** (float_of_int place)) |> int_of_float in\n    bigAdd a (mulByDigit (x * place) l1) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(place + 1 , bigAdd num (mulByDigit (x * place) l1)) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 150-156:\n  (place + 1 , bigAdd num (mulByDigit (x * place) l1)) in\n               ^^^^^^\nError: Unbound value bigAdd\n", "min": "\nlet rec mulByDigit i l = if i = 0 then 0 else if i = 1 then l else l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,num) = a in\n    let placement =\n      ((float_of_int 10) ** (float_of_int place)) |> int_of_float in\n    ((place + 1), (bigAdd num (mulByDigit (x * place) l1))) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(place + 1 ,bigAdd num (mulByDigit (x * place) l1)) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (place, num) = a in\nlet placement = (float_of_int 10) ** (float_of_int place) |> int_of_float   \nin\n(place + 1 ,bigAdd num (mulByDigit (x * placement) l1)) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
