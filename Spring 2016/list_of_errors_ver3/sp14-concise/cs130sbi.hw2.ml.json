{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 82-87:\n  | (a,b) ->\n    ^^^^^\nError: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type unit\n", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with | () -> d | (a,b) -> if a = k then b else assoc (d, k, t));;\n", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> match h with\n| () -> d\n| (a,b) ->\nif a = k\nthen b\nelse\nassoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> let (a,b) = h in\nif a = k\nthen b\nelse\nassoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 128-132:\n  let rest' =  if list.mem h seen then rest else h::rest in \n                  ^^^^\nError: Unbound value list\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = if list.mem h seen then rest else h :: rest in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nlet rest' =  if list.mem h seen then rest else h::rest in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 179-184:\n  helper (seen',rest') \n          ^^^^^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h in\n        let rest' = if List.mem h seen then rest else h :: rest in\n        helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nlet rest' =  if List.mem h seen then rest else h::rest in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' =  if List.mem h seen then seen else h::seen in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> let (a,b) = h in\nif a = k\nthen b\nelse\nassoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = failwith \"to be written\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = failwith \"to be written\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 65-67:\n  b';;\n  ^^\nError: This expression has type 'a but an expression was expected of type\n         'a * bool\n       The type variable 'a occurs inside 'a * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then f b' else b';;\n", "in": "let rec wwhile (f,b) =\nlet (b',c') = f b in\nif c'\nthen f b'\nelse\nb'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) =\nlet (b',c') = f b in\nif c'\nthen wwhile (f, b')\nelse\nb'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "wwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) =\nlet (b',c') = f b in\nif c'\nthen wwhile (f, b')\nelse\nb'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)\n\n(* uncomment after implementing fixpoint *)\n*\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (f,b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 28-81:\n  let fixpoint (f,b) = wwhile (fun x -> if(f x)=x then (b,false) else (f x,true),b);;\n                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (fun x  -> if (f x) = x then (b, false) else (((f x), true), b));;\n", "in": "let fixpoint (f,b) = wwhile (fun x -> if(f x)=x then (b,false) else (f x,true),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 28-80:\n  let fixpoint (f,b) = wwhile (fun x -> if (x=b) then (b,false) else (f x,true),b);;\n                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (fun x  -> if x = b then (b, false) else (((f x), true), b));;\n", "in": "let fixpoint (f,b) = wwhile (fun x -> if (x=b) then (b,false) else (f x,true),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((fun x -> if (x=b) then (b,false) else (f x,true)),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((fun x -> if (f(x)=x) then (x,false) else (f x,true)),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "fixpoint (g,0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "fixpoint (g,0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((fun x -> if ((f x)=x) then (x,false) else ((f x),true)),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((fun x -> if ((b)=x) then (x,false) else ((f x),true)),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((fun x -> if ((f x)=x) then (x,false) else ((f x),true)),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 47-53:\n  VarX -> printf \"A\"\n          ^^^^^^\nError: Unbound value printf\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> printf \"A\"\n  | VarY  -> printf \"A\"\n  | Sine x -> printf \"A\"\n  | Cosine x -> printf \"A\"\n  | Average (x,y) -> printf \"A\"\n  | Times (x,y) -> printf \"A\"\n  | Thresh (x,y,z,w) -> printf \"A\";;\n", "in": "let rec exprToString e = match e with \nVarX -> printf \"A\"\n| VarY-> printf \"A\"\n| Sine x -> printf \"A\"\n| Cosine  x -> printf \"A\"\n| Average (x,y) -> printf \"A\"\n| Times  (x,y)  -> printf \"A\"\n| Thresh  (x,y,z,w) -> printf \"A\""}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 74-80:\n  | VarY-> printf \"A\"\n           ^^^^^^\nError: Unbound value printf\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.printf \"A\"\n  | VarY  -> printf \"A\"\n  | Sine x -> printf \"A\"\n  | Cosine x -> printf \"A\"\n  | Average (x,y) -> printf \"A\"\n  | Times (x,y) -> printf \"A\"\n  | Thresh (x,y,z,w) -> printf \"A\";;\n", "in": "let rec exprToString e = match e with \nVarX -> Printf.printf \"A\"\n| VarY-> printf \"A\"\n| Sine x -> printf \"A\"\n| Cosine  x -> printf \"A\"\n| Average (x,y) -> printf \"A\"\n| Times  (x,y)  -> printf \"A\"\n| Thresh  (x,y,z,w) -> printf \"A\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with \nVarX -> 1\n| VarY-> 1\n| Sine x -> 1\n| Cosine  x -> 1\n| Average (x,y) -> 1\n| Times  (x,y)  -> 1\n| Thresh  (x,y,z,w) -> 1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with \nVarX -> 1\n| VarY-> 1\n| Sine x -> 1\n| Cosine  x -> 1\n| Average (x,y) -> 2\n| Times  (x,y)  -> 1\n| Thresh  (x,y,z,w) -> 1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with \nVarX -> 1\n| VarY-> 2\n| Sine x ->3\n| Cosine  x -> 4\n| Average (x,y) -> 5\n| Times  (x,y)  -> 6\n| Thresh  (x,y,z,w) -> 7"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 47-54:\n  VarX -> sprintf(\"x\")\n          ^^^^^^^\nError: Unbound value sprintf\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> sprintf \"x\"\n  | VarY  -> sprintf \"x\"\n  | Sine x -> 3\n  | Cosine x -> 4\n  | Average (x,y) -> 5\n  | Times (x,y) -> 6\n  | Thresh (x,y,z,w) -> ((sprintf \"%s<%s?%s:\" x), y, z);;\n", "in": "let rec exprToString e = match e with \nVarX -> sprintf(\"x\")\n| VarY-> sprintf(\"x\")\n| Sine x ->3\n| Cosine  x -> 4\n| Average (x,y) -> 5\n| Times  (x,y)  -> 6\n| Thresh  (x,y,z,w) -> sprintf(\"%s<%s?%s:\") x,y,z"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 76-83:\n  | VarY-> sprintf(\"x\")\n           ^^^^^^^\nError: Unbound value sprintf\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> sprintf \"x\"\n  | Sine x -> 3\n  | Cosine x -> 4\n  | Average (x,y) -> 5\n  | Times (x,y) -> 6\n  | Thresh (x,y,z,w) -> ((sprintf \"%s<%s?%s:\" x), y, z);;\n", "in": "let rec exprToString e = match e with \nVarX -> Printf.sprintf(\"x\")\n| VarY-> sprintf(\"x\")\n| Sine x ->3\n| Cosine  x -> 4\n| Average (x,y) -> 5\n| Times  (x,y)  -> 6\n| Thresh  (x,y,z,w) -> sprintf(\"%s<%s?%s:\") x,y,z"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 263-296:\n  | Thresh  (x,y,z,w) -> Printf.sprintf(\"%s<%s?%s:\") x,y,z;;\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"x\"\n  | Sine x -> Printf.sprintf \"\"\n  | Cosine x -> Printf.sprintf \"\"\n  | Average (x,y) -> Printf.sprintf \"\"\n  | Times (x,y) -> Printf.sprintf \"\"\n  | Thresh (x,y,z,w) -> ((Printf.sprintf \"%s<%s?%s:\" x), y, z);;\n", "in": "let rec exprToString e = match e with \nVarX -> Printf.sprintf(\"x\")\n| VarY-> Printf.sprintf(\"x\")\n| Sine x ->Printf.sprintf (\"\")\n| Cosine  x -> Printf.sprintf (\"\")\n| Average (x,y) -> Printf.sprintf (\"\")\n| Times  (x,y)  -> Printf.sprintf (\"\")\n| Thresh  (x,y,z,w) -> Printf.sprintf(\"%s<%s?%s:\") x,y,z"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 253-285:\n  | Thresh  (x,y,z,w) -> Printf.sprintf \"%s<%s?%s:\" x,y,z;;\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"x\"\n  | Sine x -> Printf.sprintf \"\"\n  | Cosine x -> Printf.sprintf \"\"\n  | Average (x,y) -> Printf.sprintf \"\"\n  | Times (x,y) -> Printf.sprintf \"\"\n  | Thresh (x,y,z,w) -> ((Printf.sprintf \"%s<%s?%s:\" x), y, z);;\n", "in": "let rec exprToString e = match e with \nVarX -> Printf.sprintf \"x\"\n| VarY-> Printf.sprintf \"x\"\n| Sine x ->Printf.sprintf \"\"\n| Cosine  x -> Printf.sprintf \"\"\n| Average (x,y) -> Printf.sprintf \"\"\n| Times  (x,y)  -> Printf.sprintf \"\"\n| Thresh  (x,y,z,w) -> Printf.sprintf \"%s<%s?%s:\" x,y,z"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 280-281:\n  | Thresh  (x,y,z,w) -> Printf.sprintf \"%s<%s?%s:\" x y z;;\n                                                    ^\nError: This expression has type expr but an expression was expected of type\n         string\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"x\"\n  | Sine x -> Printf.sprintf \"\"\n  | Cosine x -> Printf.sprintf \"\"\n  | Average (x,y) -> Printf.sprintf \"\"\n  | Times (x,y) -> Printf.sprintf \"\"\n  | Thresh (x,y,z,w) -> Printf.sprintf \"%s<%s?%s:\" x y z;;\n", "in": "let rec exprToString e = match e with \nVarX -> Printf.sprintf \"x\"\n| VarY-> Printf.sprintf \"x\"\n| Sine x ->Printf.sprintf \"\"\n| Cosine  x -> Printf.sprintf \"\"\n| Average (x,y) -> Printf.sprintf \"\"\n| Times  (x,y)  -> Printf.sprintf \"\"\n| Thresh  (x,y,z,w) -> Printf.sprintf \"%s<%s?%s:\" x y z"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 268-279:\n  | Thresh  (x,y,z,w) -> Printf.sprintf \"%s<%s?%s:\" exprToString x exprToString y exprToStringz;;\n                                        ^^^^^^^^^^^\nError: This expression has type\n         ('a -> 'b -> 'c, unit, string, string, string, 'a -> 'b -> 'c)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b -> 'c, unit, string, string, string, string)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b -> 'c is not compatible with type string \n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"\"\n  | Cosine x -> Printf.sprintf \"\"\n  | Average (x,y) -> Printf.sprintf \"\"\n  | Times (x,y) -> Printf.sprintf \"\"\n  | Thresh (x,y,z,w) ->\n      Printf.sprintf \"%s<%s?%s:\" exprToString x exprToString y exprToStringz;;\n", "in": "let rec exprToString e = match e with \nVarX -> Printf.sprintf \"x\"\n| VarY-> Printf.sprintf \"y\"\n| Sine x ->Printf.sprintf \"\"\n| Cosine  x -> Printf.sprintf \"\"\n| Average (x,y) -> Printf.sprintf \"\"\n| Times  (x,y)  -> Printf.sprintf \"\"\n| Thresh  (x,y,z,w) -> Printf.sprintf \"%s<%s?%s:\" exprToString x exprToString y exprToStringz"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with \nVarX -> Printf.sprintf \"x\"\n| VarY-> Printf.sprintf \"y\"\n| Sine x ->Printf.sprintf \"\"\n| Cosine  x -> Printf.sprintf \"\"\n| Average (x,y) -> Printf.sprintf \"\"\n| Times  (x,y)  -> Printf.sprintf \"\"\n| Thresh  (x,y,z,w) -> Printf.sprintf \"%s<%s?%s:\" (exprToString x) (exprToString y) (exprToString z)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 327-332:\n  | Times  (x,y)  -> Printf.sprintf \"e*e\" (exprToString x) (exprToString y)\n                                    ^^^^^\nError: This expression has type\n         ('a -> 'b -> 'c, unit, string, string, string, 'a -> 'b -> 'c)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b -> 'c, unit, string, string, string, string)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b -> 'c is not compatible with type string \n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n  | Cosine x -> Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n  | Average (x,y) ->\n      Printf.sprintf \"((%s+%s)/2) \" (exprToString x) (exprToString y)\n  | Times (x,y) -> Printf.sprintf \"e*e\" (exprToString x) (exprToString y)\n  | Thresh (x,y,z,w) ->\n      Printf.sprintf \"%s<%s?%s:\" (exprToString x) (exprToString y)\n        (exprToString z);;\n", "in": "let rec exprToString e = match e with \nVarX -> Printf.sprintf \"x\"\n| VarY-> Printf.sprintf \"y\"\n| Sine x ->Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n| Cosine  x -> Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n| Average (x,y) -> Printf.sprintf \"((%s+%s)/2) \" (exprToString x) (exprToString y)\n| Times  (x,y)  -> Printf.sprintf \"e*e\" (exprToString x) (exprToString y)\n| Thresh  (x,y,z,w) -> Printf.sprintf \"%s<%s?%s:\" (exprToString x) (exprToString y) (exprToString z)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with \nVarX -> Printf.sprintf \"x\"\n| VarY-> Printf.sprintf \"y\"\n| Sine x ->Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n| Cosine  x -> Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n| Average (x,y) -> Printf.sprintf \"((%s+%s)/2) \" (exprToString x) (exprToString y)\n| Times  (x,y)  -> Printf.sprintf \"%s*%s\" (exprToString x) (exprToString y)\n| Thresh  (x,y,z,w) -> Printf.sprintf \"%s<%s?%s:\" (exprToString x) (exprToString y) (exprToString z)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with \nVarX -> Printf.sprintf \"x\"\n| VarY-> Printf.sprintf \"y\"\n| Sine x ->Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n| Cosine  x -> Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n| Average (x,y) -> Printf.sprintf \"((%s+%s)/2) \" (exprToString x) (exprToString y)\n| Times  (x,y)  -> Printf.sprintf \"%s*%s\" (exprToString x) (exprToString y)\n| Thresh  (x,y,z,w) -> Printf.sprintf \"%s<%s?%s:%s\" (exprToString x) (exprToString y) (exprToString z) (exprToString w)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with \nVarX -> Printf.sprintf \"x\"\n| VarY-> Printf.sprintf \"y\"\n| Sine x ->Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n| Cosine  x -> Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n| Average (x,y) -> Printf.sprintf \"((%s+%s)/2)\" (exprToString x) (exprToString y)\n| Times  (x,y)  -> Printf.sprintf \"%s*%s\" (exprToString x) (exprToString y)\n| Thresh  (x,y,z,w) -> Printf.sprintf \"%s<%s?%s:%s\" (exprToString x) (exprToString y) (exprToString z) (exprToString w)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with \nVarX -> Printf.sprintf \"x\"\n| VarY-> Printf.sprintf \"y\"\n| Sine x ->Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n| Cosine  x -> Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n| Average (x,y) -> Printf.sprintf \"((%s+%s)/2)\" (exprToString x) (exprToString y)\n| Times  (x,y)  -> Printf.sprintf \"%s*%s\" (exprToString x) (exprToString y)\n| Thresh  (x,y,z,w) -> Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString x) (exprToString y) (exprToString z) (exprToString w)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with \nVarX -> Printf.sprintf \"x\"\n| VarY-> Printf.sprintf \"y\"\n| Sine x -> Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n| Cosine  x -> Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n| Average (x,y) -> Printf.sprintf \"((%s+%s)/2)\" (exprToString x) (exprToString y)\n| Times  (x,y)  -> Printf.sprintf \"%s*%s\" (exprToString x) (exprToString y)\n| Thresh  (x,y,z,w) -> Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString x) (exprToString y) (exprToString z) (exprToString w)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with \nVarX -> Printf.sprintf \"x\"\n| VarY -> Printf.sprintf \"y\"\n| Sine x -> Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n| Cosine x -> Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n| Average (x,y) -> Printf.sprintf \"((%s+%s)/2)\" (exprToString x) (exprToString y)\n| Times (x,y) -> Printf.sprintf \"%s*%s\" (exprToString x) (exprToString y)\n| Thresh (x,y,z,w) -> Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString x) (exprToString y) (exprToString z) (exprToString w)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 73-93:\n  | Sine a -> sin(eval(buildX(),a,y))\n                 ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet buildX () = VarX;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval ((buildX ()), a, y))\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n", "in": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(buildX(),a,y))\n| Cosine a -> x\n| Average (a,b) -> x\n| Times (a,b) -> x\n| Thresh (a,b,c,d) ->x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y))\n| Cosine a -> x\n| Average (a,b) -> x\n| Times (a,b) -> x\n| Thresh (a,b,c,d) -> x"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 4-13:\n  eval(Sine(0));;\n      ^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         expr * float * float\n", "min": "\nlet a = (1, 2);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n\nlet _ = eval (Sine 0);;\n", "in": "eval(Sine(0))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 16-17:\n  eval(Sine(VarX),0,0);;\n                  ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\nlet a = (1, 2);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n\nlet _ = eval ((Sine VarX), 0, 0);;\n", "in": "eval(Sine(VarX),0,0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "eval(Sine(VarX),0.,0.)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "eval(Sine(VarX),1.,0.)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 74-76:\n  | Sine a -> sin(pi*eval(a,x,y))\n                  ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n", "in": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(pi*eval(a,x,y))\n| Cosine a -> x\n| Average (a,b) -> x\n| Times (a,b) -> x\n| Thresh (a,b,c,d) -> x"}, {"type": "", "out": "", "min": "", "in": "eval(Sine(VarX),1.,0.)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 74-76:\n  | Sine a -> sin(pi*eval(a,x,y))\n                  ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n", "in": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(pi*eval(a,x,y))\n| Cosine a -> x\n| Average (a,b) -> x\n| Times (a,b) -> x\n| Thresh (a,b,c,d) -> x"}, {"type": "", "out": "", "min": "", "in": "eval(Sine(VarX),1.,0.)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 74-76:\n  | Sine a -> sin(pi*eval(a,x,y))\n                  ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n", "in": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(pi*eval(a,x,y))\n| Cosine a -> x\n| Average (a,b) -> x\n| Times (a,b) -> x\n| Thresh (a,b,c,d) -> x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y))\n| Cosine a -> x\n| Average (a,b) -> x\n| Times (a,b) -> x\n| Thresh (a,b,c,d) -> x"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 86-88:\n  | Sine a -> sin(eval(a,x,y)*pi)\n                              ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) * pi)\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n", "in": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y)*pi)\n| Cosine a -> x\n| Average (a,b) -> x\n| Times (a,b) -> x\n| Thresh (a,b,c,d) -> x"}, {"type": "", "out": "", "min": "", "in": "eval(Sine(VarX),1.,0.)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildCosine(e)                 = Cosine(e)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildAverage(e1,e2)            = Average(e1,e2)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 86-88:\n  | Sine a -> sin(eval(a,x,y)*2.)\n                              ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) * 2.)\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n", "in": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y)*2.)\n| Cosine a -> x\n| Average (a,b) -> x\n| Times (a,b) -> x\n| Thresh (a,b,c,d) -> x"}, {"type": "", "out": "", "min": "", "in": "eval(Sine(VarX),1.,0.)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 5-6:\n  eval(a,x,y)*2.;;\n       ^\nError: This expression has type int * int\n       but an expression was expected of type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n\nlet _ = (eval (a, x, y)) * 2.;;\n", "in": "eval(a,x,y)*2."}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 87-89:\n  | Sine a -> sin((eval(a,x,y)*2.))\n                               ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) * 2.)\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n", "in": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin((eval(a,x,y)*2.))\n| Cosine a -> x\n| Average (a,b) -> x\n| Times (a,b) -> x\n| Thresh (a,b,c,d) -> x"}, {"type": "", "out": "", "min": "", "in": "eval(Sine(VarX),1.,0.)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y)*.pi)\n| Cosine a -> x\n| Average (a,b) -> x\n| Times (a,b) -> x\n| Thresh (a,b,c,d) -> x"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 176-177:\n  | Average (a,b) -> (eval(a,x,y) +. eval(b,x,y) /. 2)\n                                                    ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) *. pi)\n  | Cosine a -> cos ((eval (a, x, y)) *. pi)\n  | Average (a,b) -> (eval (a, x, y)) +. ((eval (b, x, y)) /. 2)\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n", "in": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y)*.pi)\n| Cosine a -> cos(eval(a,x,y)*.pi)\n| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y) /. 2)\n| Times (a,b) -> x\n| Thresh (a,b,c,d) -> x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y)*.pi)\n| Cosine a -> cos(eval(a,x,y)*.pi)\n| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y) /. 2.)\n| Times (a,b) -> x\n| Thresh (a,b,c,d) -> x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y)*.pi)\n| Cosine a -> cos(eval(a,x,y)*.pi)\n| Average (a,b) -> (eval(a,x,y) +. eval(b,x,y) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y)*.pi)\n| Cosine a -> cos(eval(a,x,y)*.pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y)*.pi)\n| Cosine a -> cos(eval(a,x,y)*.pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> eval(d,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> eval(a,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) ->x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> let (a,b) = h in\nif a = k\nthen b\nelse\nassoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = failwith \"to be implemented\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nrand(0,1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \ndepth"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 6-10:\n  build(rand,1);;\n        ^^^^\nError: Unbound value rand\nHint: Did you mean land?\n", "min": "\nlet rec build (rand,depth) = depth;;\n\nlet _ = build (rand, 1);;\n", "in": "build(rand,1)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 217-222:\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n                                       ^^^^^\nError: This expression has type expr but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet (c,d) = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) *. pi)\n  | Cosine a -> cos ((eval (a, x, y)) *. pi)\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = depth;;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n  | Cosine x -> Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n  | Average (x,y) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString x) (exprToString y)\n  | Times (x,y) -> Printf.sprintf \"%s*%s\" (exprToString x) (exprToString y)\n  | Thresh (x,y,z,w) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString x) (exprToString y)\n        (exprToString z) (exprToString w);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 217-222:\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n                                       ^^^^^\nError: This expression has type expr but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet (c,d) = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) *. pi)\n  | Cosine a -> cos ((eval (a, x, y)) *. pi)\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = depth;;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> Printf.sprintf \"x\"\n  | VarY  -> Printf.sprintf \"y\"\n  | Sine x -> Printf.sprintf \"sin(pi*%s)\" (exprToString x)\n  | Cosine x -> Printf.sprintf \"cos(pi*%s)\" (exprToString x)\n  | Average (x,y) ->\n      Printf.sprintf \"((%s+%s)/2)\" (exprToString x) (exprToString y)\n  | Times (x,y) -> Printf.sprintf \"%s*%s\" (exprToString x) (exprToString y)\n  | Thresh (x,y,z,w) ->\n      Printf.sprintf \"(%s<%s?%s:%s)\" (exprToString x) (exprToString y)\n        (exprToString z) (exprToString w);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \n\nfailwith \"to be implemented\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \n\nfailwith \"to be implemented\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> let (a,b) = h in\nif a = k\nthen b\nelse\nassoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "build(0,1)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value buildSin\nHint: Did you mean buildSine?\nError: Unbound value buildSin\nHint: Did you mean build, buildY or buildX?\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 152-160:\n  |0 -> buildSin(build(rand,depth))\n        ^^^^^^^^\nError: Unbound value buildSin\nHint: Did you mean buildSine?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 2\n  then let x = rand (0, 2) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (0, 5) in\n     match x with\n     | 0 -> buildSin (build (rand, depth))\n     | 1 -> buildCosin (build (rand, depth)));;\n", "in": "let rec build (rand, depth) = \nif depth<2\nthen let x=rand(0,2) in\nmatch x with\n|0 -> buildX()\n|1 -> buildY()\nelse\nlet x=rand(0,5) in\nmatch x with\n|0 -> buildSin(build(rand,depth))\n|1 -> buildCosin(build(rand,depth))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth<2\nthen let x=rand(0,2) in\nmatch x with\n|0 -> buildX()\n|1 -> buildY()\nelse\nlet x=rand(0,5) in\nmatch x with\n|0 -> buildSine(build(rand,depth))\n|1 -> buildCosine(build(rand,depth))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth<2\nthen let x=rand(0,1) in\nmatch x with\n|0 -> buildX()\n|1 -> buildY()\nelse\nlet x=rand(0,5) in\nmatch x with\n|0 -> buildSine(build(rand,depth))\n|1 -> buildCosine(build(rand,depth))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth<2\nthen let x=rand(0,0) in\nmatch x with\n|0 -> buildX()\n|1 -> buildY()\nelse\nlet x=rand(0,5) in\nmatch x with\n|0 -> buildSine(build(rand,depth))\n|1 -> buildCosine(build(rand,depth))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth<2\nthen let x=rand(0,2) in\nmatch x with\n|0 -> buildX()\n|1 -> buildY()\nelse\nlet x=rand(0,5) in\nmatch x with\n|0 -> buildSine(build(rand,depth))\n|1 -> buildCosine(build(rand,depth))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 358-359:\n  |4 -> buildThresh(a,b,a_less,b_less);;\n                    ^\nError: This expression has type int * int\n       but an expression was expected of type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet a = (1, 2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 2\n  then let x = rand (0, 2) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (0, 5) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 -> buildThresh (a, b, a_less, b_less));;\n", "in": "let rec build (rand, depth) = \nif depth<2\nthen let x=rand(0,2) in\nmatch x with\n|0 -> buildX()\n|1 -> buildY()\nelse\nlet x=rand(0,5) in\nmatch x with\n|0 -> buildSine(build(rand,depth-1))\n|1 -> buildCosine(build(rand,depth-1))\n|2 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n|3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n|4 -> buildThresh(a,b,a_less,b_less)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth<2\nthen let x=rand(0,2) in\nmatch x with\n|0 -> buildX()\n|1 -> buildY()\nelse\nlet x=rand(0,5) in\nmatch x with\n|0 -> buildSine(build(rand,depth-1))\n|1 -> buildCosine(build(rand,depth-1))\n|2 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n|3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth=0\nthen let x=rand(0,2) in\nmatch x with\n|0 -> buildX()\n|1 -> buildY()\nelse\nlet x=rand(0,5) in\nmatch x with\n|0 -> buildSine(build(rand,depth-1))\n|1 -> buildCosine(build(rand,depth-1))\n|2 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n|3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 6-10:\n  build(rand,1);;\n        ^^^^\nError: Unbound value rand\nHint: Did you mean land?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 2) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (0, 5) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet _ = build (rand, 1);;\n", "in": "build(rand,1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth=0\nthen let x=rand(0,2) in\nmatch x with\n|0 -> buildX()\n|1 -> buildY()\nelse\nlet x=rand(0,5) in\nmatch x with\n|0 -> buildSine(build(rand,depth-1))\n|1 -> buildCosine(build(rand,depth-1))\n|2 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n|3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n|4 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\n| Foo      of expr * expr\n| Clamp    of expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))\n| Clamp (a,b,c) -> if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))\n| Clamp (a,b,c) -> if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildFoo(a,b)                  = Foo(a,b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))\n| Clamp (a,b,c) -> if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 0-4:\n  eval(Clamp(VarX.VarY),1,2);;\n  ^^^^\nError: Unbound value eval\n", "min": "\nlet _ = eval ((Clamp VarX.VarY), 1, 2);;\n", "in": "let buildClamp(a,b,c)              = Clamp(a,b,c)"}, {"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))\n| Clamp (a,b,c) -> if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 0-4:\n  eval(Clamp(Sine(Varx),VarX,VarY),1,2);;\n  ^^^^\nError: Unbound value eval\n", "min": "\nlet _ = eval ((Clamp ((Sine Varx), VarX, VarY)), 1, 2);;\n", "in": "eval(Clamp(Sine(VarX),VarX,VarY),1,2)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 0-4:\n  eval(Clamp(Sine(VarX),VarX,VarY),1,2);;\n  ^^^^\nError: Unbound value eval\n", "min": "\nlet _ = eval ((Clamp ((Sine VarX), VarX, VarY)), 1, 2);;\n", "in": "eval(Clamp(Sine(VarX),VarX,VarY),1.,2.)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 0-4:\n  eval(Clamp(Sine(VarX),VarX,VarY),1.,2.);;\n  ^^^^\nError: Unbound value eval\n", "min": "\nlet _ = eval ((Clamp ((Sine VarX), VarX, VarY)), 1., 2.);;\n", "in": "eval(Clamp(Sine(0.),VarX,VarY),1.,2.)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 0-4:\n  eval(Clamp(Sine(0.),VarX,VarY),1.,2.);;\n  ^^^^\nError: Unbound value eval\n", "min": "\nlet _ = eval ((Clamp ((Sine 0.), VarX, VarY)), 1., 2.);;\n", "in": "eval(Clamp(Sine(VarX),VarX,VarY),0.,2.)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 0-4:\n  eval(Clamp(Sine(VarX),VarX,VarY),0.,2.);;\n  ^^^^\nError: Unbound value eval\n", "min": "\nlet _ = eval ((Clamp ((Sine VarX), VarX, VarY)), 0., 2.);;\n", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}, {"type": "scope", "out": "Characters 32-36:\n  let rv = eval (e,x,y) in\n           ^^^^\nError: Unbound value eval\n", "min": "\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))"}, {"type": "scope", "out": "Characters 17-28:\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n  ^^^^^^^^^^^\nError: Unbound value buildCosine\n", "min": "\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))"}, {"type": "scope", "out": "Characters 8-12:\n  let _ = eval (sampleExpr,0.5,0.2);;\n          ^^^^\nError: Unbound value eval\n", "min": "\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n", "in": "let rec build (rand, depth) = \nif depth=0\nthen let x=rand(0,2) in\nmatch x with\n|0 -> buildX()\n|1 -> buildY()\nelse\nlet x=rand(0,7) in\nmatch x with\n|0 -> buildSine(build(rand,depth-1))\n|1 -> buildCosine(build(rand,depth-1))\n|2 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n|3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n|4 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n|5 -> buildFoo(build(rand,depth-1),build(rand,depth-1))\n|6 -> buildClamp(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"}, {"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> let (a,b) = h in\nif a = k\nthen b\nelse\nassoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then 0.9*.eval(a,x,y) else eval 0.1*.(a,x,y)\n| Clamp (a,b,c) -> if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then 0.9*.eval(a,x,y) else 0.1*.eval(a,x,y)\n| Clamp (a,b,c) -> if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth=0\nthen let a=rand(0,2) in\nmatch a with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet a=rand(0,6) in\nmatch a with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildCosine(build(rand,depth-1))\n| 2 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildFoo(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildClamp(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth=0\nthen let a=rand(0,2) in\nmatch a with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet a=rand(0,7) in\nmatch a with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildCosine(build(rand,depth-1))\n| 2 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildFoo(build(rand,depth-1),build(rand,depth-1))\n| 6 -> buildClamp(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> let (a,b) = h in\nif a = k\nthen b\nelse\nassoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth=0\nthen let a=rand(0,2) in\nmatch a with\n| 0 -> buildX()\n| _ -> buildY()\nelse\nlet a=rand(0,7) in\nmatch a with\n| 0 -> buildSine(build(rand,depth-1))\n| 1 -> buildCosine(build(rand,depth-1))\n| 2 -> buildAverage(build(rand,depth-1),build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| 4 -> buildThresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))\n| 5 -> buildFoo(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildClamp(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> let (a,b) = h in\nif a = k\nthen b\nelse\nassoc (d,k,t)"}]}
