{"event": "eval", "ocaml": [{"in": "let rec sumList xs = failwith \"TBD:sumList\"", "out": "", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = failwith \"TBD:sumfist\"", "out": "", "min": "\nlet rec sumList xs = failwith \"TBD:sumfist\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = failwith \"TBD:sumList\"", "out": "", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (h::t) -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nmatch n < 0 with\n| true -> 0\n| false -> 1", "out": "", "min": "\nlet rec digitsOfInt n = match n < 0 with | true  -> 0 | false  -> 1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nmatch n < 0 with\n| true -> 0\n| false -> 1", "out": "", "min": "\nlet rec digitsOfInt n = match n < 0 with | true  -> 0 | false  -> 1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> 1", "out": "Characters 66-67:\n  | false -> 1;;\n             ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n = match n <= 0 with | true  -> [] | false  -> 1;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> []", "out": "", "min": "\nlet rec digitsOfInt n = match n <= 0 with | true  -> [] | false  -> [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> digitsOfInt n/10 @ [n%10]", "out": "Characters 66-79:\n  | false -> digitsOfInt n/10 @ [n%10];;\n             ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> ((digitsOfInt n) / 10) @ [n % 10];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> (digitsOfInt n/10) @ [n%10]", "out": "Characters 67-80:\n  | false -> (digitsOfInt n/10) @ [n%10];;\n              ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> ((digitsOfInt n) / 10) @ [n % 10];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| false -> (digitsOfInt n/10) @ [n%10]\n| true -> []", "out": "Characters 53-71:\n  | false -> (digitsOfInt n/10) @ [n%10]\n             ^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | false  -> ((digitsOfInt n) / 10) @ [n % 10]\n  | true  -> [];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> (digitsOfInt n/10) :: [n%10]", "out": "Characters 67-80:\n  | false -> (digitsOfInt n/10) :: [n%10];;\n              ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  match n <= 0 with | true  -> [] | false  -> [(digitsOfInt n) / 10; n % 10];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> (digitsOfInt n/10) @ [n%10]", "out": "Characters 67-80:\n  | false -> (digitsOfInt n/10) @ [n%10];;\n              ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> ((digitsOfInt n) / 10) @ [n % 10];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> [digitsOfInt n/10] @ [n%10]", "out": "Characters 67-80:\n  | false -> [digitsOfInt n/10] @ [n%10];;\n              ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> [(digitsOfInt n) / 10] @ [n % 10];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> digitsOfInt n/10 @ [n%10]", "out": "Characters 66-79:\n  | false -> digitsOfInt n/10 @ [n%10];;\n             ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> ((digitsOfInt n) / 10) @ [n % 10];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> [n%10] @ digitsOfInt n/10", "out": "Characters 68-69:\n  | false -> [n%10] @ digitsOfInt n/10;;\n               ^\nError: Unbound value %\n", "min": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> [n % 10] @ ((digitsOfInt n) / 10);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> digitsOfInt n div 10 :: [n mod 10]", "out": "Characters 66-77:\n  | false -> digitsOfInt n div 10 :: [n mod 10];;\n             ^^^^^^^^^^^\nError: This function has type int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> [digitsOfInt n div 10; n mod 10];;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> digitsOfInt n/10 :: [n mod 10]", "out": "Characters 66-79:\n  | false -> digitsOfInt n/10 :: [n mod 10];;\n             ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> [(digitsOfInt n) / 10; n mod 10];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> n mod 10 :: digitsOfInt n/10", "out": "Characters 78-91:\n  | false -> n mod 10 :: digitsOfInt n/10;;\n                         ^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> (n mod 10) :: ((digitsOfInt n) / 10);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> n mod 10 :: (digitsOfInt n/10)", "out": "Characters 79-92:\n  | false -> n mod 10 :: (digitsOfInt n/10);;\n                          ^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> (n mod 10) :: ((digitsOfInt n) / 10);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> (n mod 10) :: (digitsOfInt n/10)", "out": "Characters 81-94:\n  | false -> (n mod 10) :: (digitsOfInt n/10);;\n                            ^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> (n mod 10) :: ((digitsOfInt n) / 10);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (h::t) -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> (n mod 10) :: (digitsOfInt n - 10)", "out": "Characters 81-94:\n  | false -> (n mod 10) :: (digitsOfInt n - 10);;\n                            ^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> (n mod 10) :: ((digitsOfInt n) - 10);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> (n mod 10) :: (digitsOfInt (n/10))", "out": "", "min": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> (n mod 10) :: (digitsOfInt (n / 10));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> n mod 10 :: digitsOfInt (n/10)", "out": "", "min": "\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> (n mod 10) :: (digitsOfInt (n / 10));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| (h :: t) -> h :: listReverse t", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> h :: (listReverse t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| (h :: t) -> h :: listReverse t", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> h :: (listReverse t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| (h :: []) -> h\n| (h :: t)  -> listReverse t :: [h]", "out": "Characters 69-82:\n  | (h :: t)  -> listReverse t :: [h];;\n                 ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | h::[] -> h | h::t -> [listReverse t; h];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| []\t    -> []\n| (h :: t)  -> h :: listReverse t", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> h :: (listReverse t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| []\t    -> []\n| (t :: h :: [])  -> h :: listReverse t::[]", "out": "Characters 90-91:\n  | (t :: h :: [])  -> h :: listReverse t::[];;\n                                        ^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | t::h::[] -> [h; listReverse t];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| []\t    -> []\n| (t :: h :: [])  -> h :: listReverse t", "out": "Characters 90-91:\n  | (t :: h :: [])  -> h :: listReverse t;;\n                                        ^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | t::h::[] -> h :: (listReverse t);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| []\t    -> []\n| (_ :: h :: [])  -> h :: listReverse []", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | _::h::[] -> h :: (listReverse []);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| []\t    -> []\n| (t :: h :: [])  -> h :: listReverse []", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | t::h::[] -> h :: (listReverse []);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| []\t    -> []\n| (h :: t)  -> t :: listReverse t", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> t :: (listReverse t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| []\t    -> []\n| (h :: t)  -> listReverse t @ [h]", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> listReverse (n mod 10 :: digitsOfInt (n/10))", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> listReverse ((n mod 10) :: (digitsOfInt (n / 10)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (h::t) -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| []\t    -> []\n| (h :: t)  -> appendLists(listReverse t, [h])", "out": "", "min": "\nlet rec appendLists (l1,l2) =\n  match l1 with | [] -> l2 | h::t -> h :: (appendLists (t, l2));;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> appendLists ((listReverse t), [h]);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> appendLists(digitsOfInt (n/10), [n mod 10])", "out": "", "min": "\nlet rec appendLists (l1,l2) =\n  match l1 with | [] -> l2 | h::t -> h :: (appendLists (t, l2));;\n\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> appendLists ((digitsOfInt (n / 10)), [n mod 10]);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (h::t) -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> appendLists(digitsOfInt (n/10), [n mod 10])", "out": "", "min": "\nlet rec appendLists (l1,l2) =\n  match l1 with | [] -> l2 | h::t -> h :: (appendLists (t, l2));;\n\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> appendLists ((digitsOfInt (n / 10)), [n mod 10]);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (h::t) -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (h::t) -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nmatch arrayLen (digits n) = 1 with\n| true -> 0\n| false -> 1 + additivePersistence (digitSum (digits n))", "out": "", "min": "\nlet rec appendLists (l1,l2) =\n  match l1 with | [] -> l2 | h::t -> h :: (appendLists (t, l2));;\n\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> appendLists ((digitsOfInt (n / 10)), [n mod 10]);;\n\nlet rec arrayLen l = match l with | [] -> 0 | h::t -> 1 + (arrayLen t);;\n\nlet rec digitSum dl = match dl with | [] -> 0 | h::t -> h + (digitSum t);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec additivePersistence n =\n  match (arrayLen (digits n)) = 1 with\n  | true  -> 0\n  | false  -> 1 + (additivePersistence (digitSum (digits n)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nmatch arrayLen (digits n) = 1 with\n| true -> n\n| false -> digitalRoot (digitSum (digits n))", "out": "", "min": "\nlet rec appendLists (l1,l2) =\n  match l1 with | [] -> l2 | h::t -> h :: (appendLists (t, l2));;\n\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> appendLists ((digitsOfInt (n / 10)), [n mod 10]);;\n\nlet rec arrayLen l = match l with | [] -> 0 | h::t -> 1 + (arrayLen t);;\n\nlet rec digitSum dl = match dl with | [] -> 0 | h::t -> h + (digitSum t);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec digitalRoot n =\n  match (arrayLen (digits n)) = 1 with\n  | true  -> n\n  | false  -> digitalRoot (digitSum (digits n));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (h::t) -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (h::t) -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (h::t) -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (h::t) -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nmatch n <= 0 with\n| true -> []\n| false -> appendLists(digitsOfInt (n/10), [n mod 10])", "out": "", "min": "\nlet rec appendLists (l1,l2) =\n  match l1 with | [] -> l2 | h::t -> h :: (appendLists (t, l2));;\n\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> appendLists ((digitsOfInt (n / 10)), [n mod 10]);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = \nif (explode(w)) = (listReverse explode(w))\nthen true\nelse false", "out": "Characters 39-50:\n  if (explode(w)) = (listReverse explode(w))\n                     ^^^^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec appendLists (l1,l2) =\n  match l1 with | [] -> l2 | h::t -> h :: (appendLists (t, l2));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> appendLists ((listReverse t), [h]);;\n\nlet palindrome w =\n  if (explode w) = (listReverse explode w) then true else false;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = \nif (explode(w)) = (listReverse explode(w))\nthen true\nelse false", "out": "Characters 39-50:\n  if (explode(w)) = (listReverse explode(w))\n                     ^^^^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec appendLists (l1,l2) =\n  match l1 with | [] -> l2 | h::t -> h :: (appendLists (t, l2));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> appendLists ((listReverse t), [h]);;\n\nlet palindrome w =\n  if (explode w) = (listReverse explode w) then true else false;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = \nif (explode(w)) = (listReverse (explode(w)))\nthen true\nelse false", "out": "", "min": "\nlet rec appendLists (l1,l2) =\n  match l1 with | [] -> l2 | h::t -> h :: (appendLists (t, l2));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> appendLists ((listReverse t), [h]);;\n\nlet palindrome w =\n  if (explode w) = (listReverse (explode w)) then true else false;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = \nif explode(w) = listReverse (explode(w))\nthen true\nelse false", "out": "", "min": "\nlet rec appendLists (l1,l2) =\n  match l1 with | [] -> l2 | h::t -> h :: (appendLists (t, l2));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> appendLists ((listReverse t), [h]);;\n\nlet palindrome w =\n  if (explode w) = (listReverse (explode w)) then true else false;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = \nif explode(w) = listReverse (explode w)\nthen true\nelse false", "out": "", "min": "\nlet rec appendLists (l1,l2) =\n  match l1 with | [] -> l2 | h::t -> h :: (appendLists (t, l2));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> appendLists ((listReverse t), [h]);;\n\nlet palindrome w =\n  if (explode w) = (listReverse (explode w)) then true else false;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (h::t) -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (h::t) -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
