{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun b -> x(a y) in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "Characters 40-41:\n  let f a x = fun b -> x(a y) in\n                           ^\nError: Unbound value y\n", "min": "\nlet pipe fs =\n  let f a x b = x (a y) in let base x = x in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun b -> x(a b) in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x b = x (a b) in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun b -> c(a b) in\nlet base = fun c -> c in\nList.fold_left f base fs", "out": "Characters 36-37:\n  let f a x = fun b -> c(a b) in\n                       ^\nError: Unbound value c\n", "min": "\nlet pipe fs =\n  let f a x b = c (a b) in let base c = c in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fun b -> x(a b) in\nlet base = fun x -> x in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x b = x (a b) in let base x = x in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \"[\" ^ (sep \"; \" (List.map f l)) & \"]\"", "out": "Characters 30-33:\n  let stringOfList f l = \"[\" ^ (sep \"; \" (List.map f l)) & \"]\";;\n                                ^^^\nError: Unbound value sep\n", "min": "\nlet stringOfList f l = (\"[\" ^ (sep \"; \" (List.map f l))) & \"]\";;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) & \"]\"", "out": "Characters 23-60:\n  let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) & \"]\";;\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         bool\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = (\"[\" ^ (sepConcat \"; \" (List.map f l))) & \"]\";;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n = \nif n <= 0\nthen []\nelse x :: clone x (n - 1)", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (a, b)\nelse if a < b\nthen (clone 0 (a - b) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)", "out": "Characters 114-134:\n  then (clone 0 (a - b) @ l1, l2)\n        ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (a, b)\n  else\n    if a < b\n    then (((clone 0 (a - b)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (a, b)\nelse if a < b\nthen ((clone 0 (a - b) @ l1), l2)\nelse (l1, clone 0 (a - b) @ l2)", "out": "Characters 114-136:\n  then ((clone 0 (a - b) @ l1), l2)\n        ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (a, b)\n  else\n    if a < b\n    then (((clone 0 (a - b)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (a, b)\nelse if a < b\nthen (clone 0 (b - a) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)", "out": "Characters 114-134:\n  then (clone 0 (b - a) @ l1, l2)\n        ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (a, b)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (a, b)\nelse if a < b\nthen (clone 0 (b - a) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)", "out": "Characters 114-134:\n  then (clone 0 (b - a) @ l1, l2)\n        ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (a, b)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (l1, l2)\nelse if a < b\nthen (clone 0 (b - a) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (l1, l2)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h == 0\nthen removeZero t\nelse h::t", "out": "", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h = 0\nthen removeZero t\nelse h::t", "out": "", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h = 0\nthen removeZero t\nelse 1", "out": "Characters 89-90:\n  else 1;;\n       ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else 1;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h = 0\nthen removeZero t\nelse l", "out": "", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec removeZero l = match l with\n| [] -> []\n| h::t -> if h = 0\nthen removeZero t\nelse h::t", "out": "", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if List.length l1 < List.length l2\nthen padZero (0::l1) l2\nelse padZero l1 (0::l2)", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (l1, l2)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h::t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet c = fst x + snd x in\nmatch a with\n| h::t -> (h+c)/10::(h+c mod 10) :: t\n| _ -> (c/10)::[c mod 10] in\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 234-260:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a * 'b\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (l1, l2)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let c = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + c) / 10) :: (h + (c mod 10)) :: t\n      | _ -> [c / 10; c mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (x1, x2) = x in\nlet res = x1 + x2 + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 :: [])\n|h::t -> (newCarry, newCarry :: res mod 10 :: t) in\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 369-373:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int * int list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (l1, l2)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,result) = a in\n      let (x1,x2) = x in\n      let res = (x1 + x2) + carry in\n      let newCarry = res / 10 in\n      match result with\n      | [] -> (newCarry, [newCarry; res mod 10])\n      | h::t -> (newCarry, (newCarry :: (res mod 10) :: t)) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (x1, x2) = x in\nlet res = x1 + x2 + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 :: [])\n| h::t -> (newCarry, newCarry :: res mod 10 :: t) \nin\nlet base = [] in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 371-375:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int * int list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (l1, l2)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,result) = a in\n      let (x1,x2) = x in\n      let res = (x1 + x2) + carry in\n      let newCarry = res / 10 in\n      match result with\n      | [] -> (newCarry, [newCarry; res mod 10])\n      | h::t -> (newCarry, (newCarry :: (res mod 10) :: t)) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (x1, x2) = x in\nlet res = x1 + x2 + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 :: [])\n| h::t -> (newCarry, newCarry :: res mod 10 :: t) \nin\nlet base = [] in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 382-386:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int * int list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (l1, l2)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,result) = a in\n      let (x1,x2) = x in\n      let res = (x1 + x2) + carry in\n      let newCarry = res / 10 in\n      match result with\n      | [] -> (newCarry, [newCarry; res mod 10])\n      | h::t -> (newCarry, (newCarry :: (res mod 10) :: t)) in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (x1, x2) = x in\nlet res = x1 + x2 + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 :: [])\n| h::t -> (newCarry, newCarry :: res mod 10 :: t) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (l1, l2)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,result) = a in\n      let (x1,x2) = x in\n      let res = (x1 + x2) + carry in\n      let newCarry = res / 10 in\n      match result with\n      | [] -> (newCarry, [newCarry; res mod 10])\n      | h::t -> (newCarry, (newCarry :: (res mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = x*x + a in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if List.length l1 < List.length l2\nthen padZero (0::l1) l2\nelse padZero l1 (0::l2)", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (l1, l2)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if List.length l1 < List.length l2\nthen padZero (0::l1) l2\nelse padZero l1 (0::l2)", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (l1, l2)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if List.length l1 < List.length l2\nthen clone 0 (List.length l2 - List.length l1) @ l1, l2\nelse l1, clone 0 (List.length l1 - List.length l2 @ l2)", "out": "Characters 184-215:\n  else l1, clone 0 (List.length l1 - List.length l2 @ l2);;\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, (clone 0 (((List.length l1) - (List.length l2)) @ l2)));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if List.length l1 < List.length l2\nthen (clone 0 (List.length l2 - List.length l1) @ l1, l2)\nelse l1, clone 0 (List.length l1 - List.length l2 @ l2)", "out": "Characters 186-217:\n  else l1, clone 0 (List.length l1 - List.length l2 @ l2);;\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, (clone 0 (((List.length l1) - (List.length l2)) @ l2)));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if List.length l1 < List.length l2\nthen (clone 0 (List.length l2 - List.length l1)) @ l1, l2\nelse l1, clone 0 (List.length l1 - List.length l2 @ l2)", "out": "Characters 186-217:\n  else l1, clone 0 (List.length l1 - List.length l2 @ l2);;\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, (clone 0 (((List.length l1) - (List.length l2)) @ l2)));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 = List.length l2\nthen (l1, l2)\nelse if List.length l1 < List.length l2\nthen (clone 0 (List.length l2 - List.length l1)) @ l1, l2\nelse l1, (clone 0 (List.length l1 - List.length l2)) @ l2", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = let (i, acc) = a in\nlet (_, n) = x in\nlet res = bigAdd (mulByDigit n l1 @ clone 0 i) acc in\n(i + 1, res)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,result) = a in\n      let (x1,x2) = x in\n      let res = (x1 + x2) + carry in\n      let newCarry = res / 10 in\n      match result with\n      | [] -> (newCarry, [newCarry; res mod 10])\n      | h::t -> (newCarry, (newCarry :: (res mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let c = x * i in\n    match a with\n    | h::t -> ((h + c) / 10) :: ((h + c) mod 10) :: t\n    | _ -> [c / 10; c mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,acc) = a in\n    let (_,n) = x in\n    let res = bigAdd ((mulByDigit n l1) @ (clone 0 i)) acc in ((i + 1), res) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = let a = (b, c)  in\nlet  (_, d) = x in\nlet y = bigAdd (mulByDigit d l1 @ clone c b) c in\n(b + 1, c)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Error: Unbound value b\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 41-42:\n  let f a x = let a = (b, c)  in\n                       ^\nError: Unbound value b\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,result) = a in\n      let (x1,x2) = x in\n      let res = (x1 + x2) + carry in\n      let newCarry = res / 10 in\n      match result with\n      | [] -> (newCarry, [newCarry; res mod 10])\n      | h::t -> (newCarry, (newCarry :: (res mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let c = x * i in\n    match a with\n    | h::t -> ((h + c) / 10) :: ((h + c) mod 10) :: t\n    | _ -> [c / 10; c mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let a = (b, c) in\n    let (_,d) = x in\n    let y = bigAdd ((mulByDigit d l1) @ (clone c b)) c in ((b + 1), c) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = let (b, c) = a in\nlet  (_, d) = x in\nlet y = bigAdd (mulByDigit d l1 @ clone c b) c in\n(b + 1, c)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Error: This expression has type int but an expression was expected of type\n         int list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 114-115:\n  let y = bigAdd (mulByDigit d l1 @ clone c b) c in\n                                               ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,result) = a in\n      let (x1,x2) = x in\n      let res = (x1 + x2) + carry in\n      let newCarry = res / 10 in\n      match result with\n      | [] -> (newCarry, [newCarry; res mod 10])\n      | h::t -> (newCarry, (newCarry :: (res mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let c = x * i in\n    match a with\n    | h::t -> ((h + c) / 10) :: ((h + c) mod 10) :: t\n    | _ -> [c / 10; c mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (b,c) = a in\n    let (_,d) = x in\n    let y = bigAdd ((mulByDigit d l1) @ (clone c b)) c in ((b + 1), c) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = let (b, c) = a in\nlet (_, d) = x in\nlet res = bigAdd (mulByDigit d l1 @ clone 0 b) c in\n(b + 1, res)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,result) = a in\n      let (x1,x2) = x in\n      let res = (x1 + x2) + carry in\n      let newCarry = res / 10 in\n      match result with\n      | [] -> (newCarry, [newCarry; res mod 10])\n      | h::t -> (newCarry, (newCarry :: (res mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let c = x * i in\n    match a with\n    | h::t -> ((h + c) / 10) :: ((h + c) mod 10) :: t\n    | _ -> [c / 10; c mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (b,c) = a in\n    let (_,d) = x in\n    let res = bigAdd ((mulByDigit d l1) @ (clone 0 b)) c in ((b + 1), res) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = let (b, c) = a in\nlet (_, d) = x in\nlet e = bigAdd (mulByDigit d l1 @ clone 0 b) c in\n(b + 1, e)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,result) = a in\n      let (x1,x2) = x in\n      let res = (x1 + x2) + carry in\n      let newCarry = res / 10 in\n      match result with\n      | [] -> (newCarry, [newCarry; res mod 10])\n      | h::t -> (newCarry, (newCarry :: (res mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let c = x * i in\n    match a with\n    | h::t -> ((h + c) / 10) :: ((h + c) mod 10) :: t\n    | _ -> [c / 10; c mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (b,c) = a in\n    let (_,d) = x in\n    let e = bigAdd ((mulByDigit d l1) @ (clone 0 b)) c in ((b + 1), e) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet f a x = let b = x*i in\nmatch a with \n| h::t -> (h+b)/10 :: (h+b) mod 10 :: t\n| _ -> b / 10 :: [b mod 10]\nin let base = [] in\nremoveZero (List.fold_left f base (List.rev l))", "out": "", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let b = x * i in\n    match a with\n    | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n    | _ -> [b / 10; b mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = let (b, c) = a in\nlet (_, d) = x in\nlet e = bigAdd (mulByDigit d l1 @ clone 0 b) c in\n(b + 1, e)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,result) = a in\n      let (x1,x2) = x in\n      let res = (x1 + x2) + carry in\n      let newCarry = res / 10 in\n      match result with\n      | [] -> (newCarry, [newCarry; res mod 10])\n      | h::t -> (newCarry, (newCarry :: (res mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let b = x * i in\n    match a with\n    | h::t -> ((h + b) / 10) :: ((h + b) mod 10) :: t\n    | _ -> [b / 10; b mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (b,c) = a in\n    let (_,d) = x in\n    let e = bigAdd ((mulByDigit d l1) @ (clone 0 b)) c in ((b + 1), e) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (x1, x2) = x in\nlet res = x1 + x2 + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 :: [])\n| h::t -> (newCarry, newCarry :: res mod 10 :: t) \nin\nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,result) = a in\n      let (x1,x2) = x in\n      let res = (x1 + x2) + carry in\n      let newCarry = res / 10 in\n      match result with\n      | [] -> (newCarry, [newCarry; res mod 10])\n      | h::t -> (newCarry, (newCarry :: (res mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (x1, x2) = x in\nlet res = x1 + x2 + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 :: [])\n| h::t -> (newCarry, newCarry :: res mod 10 :: t) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,result) = a in\n      let (x1,x2) = x in\n      let res = (x1 + x2) + carry in\n      let newCarry = res / 10 in\n      match result with\n      | [] -> (newCarry, [newCarry; res mod 10])\n      | h::t -> (newCarry, (newCarry :: (res mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (b, c) = x in\nlet res = b + c + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 :: [])\n| h::t -> (newCarry, newCarry :: res mod 10 :: t) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,result) = a in\n      let (b,c) = x in\n      let res = (b + c) + carry in\n      let newCarry = res / 10 in\n      match result with\n      | [] -> (newCarry, [newCarry; res mod 10])\n      | h::t -> (newCarry, (newCarry :: (res mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (b, c) = x in\nlet res = x + x + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 :: [])\n| h::t -> (newCarry, newCarry :: res mod 10 :: t) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 108-109:\n  let res = x + x + carry in\n            ^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,result) = a in\n      let (b,c) = x in\n      let res = (x + x) + carry in\n      let newCarry = res / 10 in\n      match result with\n      | [] -> (newCarry, [newCarry; res mod 10])\n      | h::t -> (newCarry, (newCarry :: (res mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (carry, result) = a in\nlet (b, c) = x in\nlet res = b + c + carry in\nlet newCarry = res / 10 in\nmatch result with \n| [] -> (newCarry, newCarry :: res mod 10 :: [])\n| h::t -> (newCarry, newCarry :: res mod 10 :: t) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,result) = a in\n      let (b,c) = x in\n      let res = (b + c) + carry in\n      let newCarry = res / 10 in\n      match result with\n      | [] -> (newCarry, [newCarry; res mod 10])\n      | h::t -> (newCarry, (newCarry :: (res mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (addC, resOfAdd) = a in\nlet (i1, i2) = x in\nlet result = i1 + i2 + addC in\nlet nextCarry = result / 10 in\nmatch resOfAdd with \n| [] -> (nextCarry, nextCarry @ [result mod 10] @ [])\n| h::t -> (nextCarry, nextCarry @ [result mod 10] @ t) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 204-213:\n  | [] -> (nextCarry, nextCarry @ [result mod 10] @ [])\n                      ^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (addC,resOfAdd) = a in\n      let (i1,i2) = x in\n      let result = (i1 + i2) + addC in\n      let nextCarry = result / 10 in\n      match resOfAdd with\n      | [] -> (nextCarry, (nextCarry @ ([result mod 10] @ [])))\n      | h::t -> (nextCarry, (nextCarry @ ([result mod 10] @ t))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (addC, resOfAdd) = a in\nlet (i1, i2) = x in\nlet result = i1 + i2 + addC in\nlet nextCarry = result / 10 in\nmatch resOfAdd with \n| [] -> (nextCarry, [nextCarry] @ [result mod 10] @ [])\n| h::t -> (nextCarry, [nextCarry] @ [result mod 10] @ t) \nin\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (addC,resOfAdd) = a in\n      let (i1,i2) = x in\n      let result = (i1 + i2) + addC in\n      let nextCarry = result / 10 in\n      match resOfAdd with\n      | [] -> (nextCarry, ([nextCarry] @ ([result mod 10] @ [])))\n      | h::t -> (nextCarry, ([nextCarry] @ ([result mod 10] @ t))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet f a x = let b = x*i in\nmatch a with \n| h::t -> [(h+b)/10] @ [(h+b) mod 10] @ t\n| _ -> [b / 10] @ [b mod 10]\nin let base = [] in\nremoveZero (List.fold_left f base (List.rev l))", "out": "", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let b = x * i in\n    match a with\n    | h::t -> [(h + b) / 10] @ ([(h + b) mod 10] @ t)\n    | _ -> [b / 10] @ [b mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = let (b, c) = a in\nlet (_, d) = x in\nlet e = bigAdd (mulByDigit d l1 @ clone 0 b) c in\n(b + 1, e)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2))  l2  in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (addC,resOfAdd) = a in\n      let (i1,i2) = x in\n      let result = (i1 + i2) + addC in\n      let nextCarry = result / 10 in\n      match resOfAdd with\n      | [] -> (nextCarry, ([nextCarry] @ ([result mod 10] @ [])))\n      | h::t -> (nextCarry, ([nextCarry] @ ([result mod 10] @ t))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let b = x * i in\n    match a with\n    | h::t -> [(h + b) / 10] @ ([(h + b) mod 10] @ t)\n    | _ -> [b / 10] @ [b mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (b,c) = a in\n    let (_,d) = x in\n    let e = bigAdd ((mulByDigit d l1) @ (clone 0 b)) c in ((b + 1), e) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = let (b, c) = a in\nlet (_, d) = x in\nlet e = bigAdd (mulByDigit d l1 @ clone 0 b) c in\n(b + 1, e)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) List.rev l2  in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Error: This function has type 'a list -> 'b list -> ('a * 'b) list\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 165-177:\n  let args = List.combine (clone l1 (List.length l2)) List.rev l2  in\n             ^^^^^^^^^^^^\nError: This function has type 'a list -> 'b list -> ('a * 'b) list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (addC,resOfAdd) = a in\n      let (i1,i2) = x in\n      let result = (i1 + i2) + addC in\n      let nextCarry = result / 10 in\n      match resOfAdd with\n      | [] -> (nextCarry, ([nextCarry] @ ([result mod 10] @ [])))\n      | h::t -> (nextCarry, ([nextCarry] @ ([result mod 10] @ t))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let b = x * i in\n    match a with\n    | h::t -> [(h + b) / 10] @ ([(h + b) mod 10] @ t)\n    | _ -> [b / 10] @ [b mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (b,c) = a in\n    let (_,d) = x in\n    let e = bigAdd ((mulByDigit d l1) @ (clone 0 b)) c in ((b + 1), e) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) List.rev l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = let (b, c) = a in\nlet (_, d) = x in\nlet e = bigAdd (mulByDigit d l1 @ clone 0 b) c in\n(b + 1, e)\nin\nlet base = (0, []) in\nlet args = List.combine (clone l1 (List.length l2)) (List.rev l2)  in\nlet (_, res) = List.fold_left f base args in\nres", "out": "", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (addC,resOfAdd) = a in\n      let (i1,i2) = x in\n      let result = (i1 + i2) + addC in\n      let nextCarry = result / 10 in\n      match resOfAdd with\n      | [] -> (nextCarry, ([nextCarry] @ ([result mod 10] @ [])))\n      | h::t -> (nextCarry, ([nextCarry] @ ([result mod 10] @ t))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let b = x * i in\n    match a with\n    | h::t -> [(h + b) / 10] @ ([(h + b) mod 10] @ t)\n    | _ -> [b / 10] @ [b mod 10] in\n  let base = [] in removeZero (List.fold_left f base (List.rev l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (b,c) = a in\n    let (_,d) = x in\n    let e = bigAdd ((mulByDigit d l1) @ (clone 0 b)) c in ((b + 1), e) in\n  let base = (0, []) in\n  let args = List.combine (clone l1 (List.length l2)) (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "type": ""}]}
