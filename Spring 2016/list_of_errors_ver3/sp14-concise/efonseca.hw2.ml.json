{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 85-90:\n  | (s,i)::t -> if s = k then true else assoc d k t;;\n                                        ^^^^^\nError: This function has type bool * 'a * ('a * 'b) list -> bool\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then true else assoc d k t;;\n", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then true else assoc d k t"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 92-93:\n  | (s,i)::t -> if s = k then true else assoc (d k t);;\n                                               ^\nError: This expression has type bool\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then true else assoc (d k t);;\n", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then true else assoc (d k t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 93-94:\n  | (s,i)::t -> if s = k then i else assoc (d k t);;\n                                                ^\nError: This expression has type ('a * ('a -> 'b -> 'c)) list\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside ('a * ('a -> 'b -> 'c)) list\n", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d k t);;\n", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d k t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 98-99:\n  | (s,i) as h::t -> if s = k then i else assoc (d k t);;\n                                                     ^\nError: This expression has type ('a * ('a -> 'b -> 'c)) list\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside ('a * ('a -> 'b -> 'c)) list\n", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | ((s,i) as h)::t -> if s = k then i else assoc (d k t);;\n", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i) as h::t -> if s = k then i else assoc (d k t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 100-101:\n  | ((s,i) as h)::t -> if s = k then i else assoc (d k t);;\n                                                       ^\nError: This expression has type ('a * ('a -> 'b -> 'c)) list\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside ('a * ('a -> 'b -> 'c)) list\n", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | ((s,i) as h)::t -> if s = k then i else assoc (d k t);;\n", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| ((s,i) as h)::t -> if s = k then i else assoc (d k t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 97-98:\n  | h::t -> if fst h = k then snd h else assoc (d k t);;\n                                                    ^\nError: This expression has type ('a * ('a -> 'b -> 'c)) list\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside ('a * ('a -> 'b -> 'c)) list\n", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> if (fst h) = k then snd h else assoc (d k t);;\n", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> if fst h = k then snd h else assoc (d k t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> if fst h = k then snd h else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i) as h::t -> if s = k then i else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 46-47:\n  let rec wwhile (f,b) = if snd f b then wwhile f fst f b else fst f b;;\n                                                ^\nError: This expression has type 'a * ('b -> bool)\n       but an expression was expected of type ('a * ('b -> bool)) * 'b\n", "min": "\nlet rec wwhile (f,b) = if snd f b then wwhile f fst f b else fst f b;;\n", "in": "let rec wwhile (f,b) = if snd f b then wwhile f fst f b else fst f b"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = if snd (f b) then wwhile (f, fst (f b)) else fst (f b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = let res = f b in \nif snd res then wwhile (f, fst res) else fst res"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 64-65:\n  if c' then wwhile f b' else b';;\n                    ^\nError: This expression has type 'a -> 'b * bool\n       but an expression was expected of type ('a -> 'b * bool) * 'a\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile f b' else b';;\n", "in": "let rec wwhile (f,b) = \nlet (b',c') = f b in \nif c' then wwhile f b' else b'"}, {"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet (b',c') = f b in \nif c' then wwhile (f,b') else b'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet (b',c') = f b in \nif c' then wwhile (f, b') else b'"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 46-54:\n  let fixpoint (f,b) = wwhile ((if f b = b then (true,b) else (false,b)),b);;\n                                                ^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((if (f b) = b then (true, b) else (false, b)), b);;\n", "in": "let fixpoint (f,b) = wwhile ((if f b = b then (true,b) else (false,b)),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-47:\n  let fixpoint (f,b) = wwhile (((f b) = b, (f b)),b);;\n                               ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((((f b) = b), (f b)), b);;\n", "in": "let fixpoint (f,b) = wwhile (((f b) = b, (f b)),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 28-44:\n  let fixpoint (f,b) = wwhile (f b, f b = b,b);;\n                              ^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type ('d -> 'd * bool) * 'd\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f b), ((f b) = b), b);;\n", "in": "let fixpoint (f,b) = wwhile (f b, f b = b,b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 62-74:\n  wwhile(if f b = b then (f b, true) else (f b, false),b);;\n                                          ^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type bool -> bool * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (if (f b) = b then ((f b), true) else (((f b), false), b));;\n", "in": "let fixpoint (f,b) = \nwwhile(if f b = b then (f b, true) else (f b, false),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 46-57:\n  wwhile((if f b = b then (f b, true) else (f b, false)),b);;\n                          ^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((if (f b) = b then ((f b), true) else ((f b), false)), b);;\n", "in": "let fixpoint (f,b) = \nwwhile((if f b = b then (f b, true) else (f b, false)),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = let fx b' = (f b', f b' = b') in\nwwhile(fx,b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = let fx = (f b, f b = b) in\nwwhile(fx,b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 48-54:\n  wwhile(fx,b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = let fx = ((f b), ((f b) = b)) in wwhile (fx, b);;\n", "in": "let fixpoint (f,b) = let fx b= (f b, f b = b) in\nwwhile(fx,b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nlet fx b = (f b, not f b = b) in\nwwhile(fx,b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 39-42:\n  let fx b = (f b, not f b = b) in\n                   ^^^\nError: This function has type bool -> bool\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet fixpoint (f,b) = let fx b = ((f b), ((not f b) = b)) in wwhile (fx, b);;\n", "in": "let fixpoint (f,b) = \nlet fx b = (f b, not (f b = b)) in\nwwhile(fx,b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-16:\n  let _ = fixpoint (collatz, 9001);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr"}, {"type": "", "out": "", "min": "", "in": "let rec exprToString e = failwith \"to be written\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = \nlet fx x = (f x, not (f x = x)) in\nwwhile(fx,b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-16:\n  let _ = fixpoint (collatz, 9001);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "let fixpoint (f,b) = \nwwhile(fun x = f x , not (f x = x),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 22-28:\n  wwhile(fun x -> f x , not (f x = x),b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile (fun x  -> ((f x), (not ((f x) = x)), b));;\n", "in": "let fixpoint (f,b) = \nwwhile(fun x -> (f x , not (f x = x)),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 22-28:\n  wwhile(fun x -> (f x , not (f x = x)),b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile (fun x  -> (((f x), (not ((f x) = x))), b));;\n", "in": "let fixpoint (f,b) = \nwwhile((fun x -> f x , not (f x = x)),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-16:\n  let _ = fixpoint (collatz, 9001);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "let fixpoint (f,b) = \nwwhile(fun x -> f x  not (f x = x),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 22-28:\n  wwhile(fun x -> f x  not (f x = x),b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile (fun x  -> ((f x not ((f x) = x)), b));;\n", "in": "let fixpoint (f,b) = \nwwhile((fun x -> f x  not (f x = x)),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 22-28:\n  wwhile((fun x -> f x  not (f x = x)),b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((fun x  -> f x not ((f x) = x)), b);;\n", "in": "let fixpoint (f,b) = \nwwhile((fun x -> f x , not (f x = x)),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-16:\n  let _ = fixpoint (collatz, 9001);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr"}, {"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with \n| VarX -> \"VarX\"\n| VarY -> \"VarY\"\n| Sine e1 -> \"Sine(\"^ exprToString e1 ^ \")\"\n| Cosine e1 -> \"Cosine(\" ^ exprToString e1 ^ \")\"\n| Average e1 e2 -> \"Average(\" ^ exprToString e1 ^ \",\" ^ exprToString e2 ^ \")\"\n| Times e1 e2 -> \"Times(\" ^ exprToString e1 ^ \",\" ^ exprToString e2 ^ \")\"\n| Thresh e1 e2 e3 e4 -> \"Thresh(\" ^  exprToString e1 ^ \",\" ^ exprToString e2 ^\",\" ^ exprToString e3 ^ \",\" ^ exprToString e4 ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin (pi*\"^ exprToString e1 ^ \")\"\n| Cosine e1 -> \"cos (pi*\" ^ exprToString e1 ^ \")\"\n| Average (e1,e2) -> \"((\" ^ exprToString e1 ^ \" + \" ^ exprToString e2 ^ \")/2)\"\n| Times (e1,e2) -> exprToString e1 ^ \" * \" ^ exprToString e2 \n| Thresh (e1,e2,e3,e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \" ? \" ^ exprToString e3 ^ \" : \" ^ exprToString e4 ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\"^ exprToString e1 ^ \")\"\n| Cosine e1 -> \"cos(pi*\" ^ exprToString e1 ^ \")\"\n| Average (e1,e2) -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1,e2) -> exprToString e1 ^ \" * \" ^ exprToString e2 \n| Thresh (e1,e2,e3,e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"? \"^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\"^ exprToString e1 ^ \")\"\n| Cosine e1 -> \"cos(pi*\" ^ exprToString e1 ^ \")\"\n| Average (e1,e2) -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1,e2) -> exprToString e1 ^ \"*\" ^ exprToString e2 \n| Thresh (e1,e2,e3,e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\"^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 77-79:\n  | Sine e1 -> sin(pi* exprToString e1)\n                   ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi * (exprToString e1))\n  | Cosine e1 -> cos (pi * (exprToString e1))\n  | Average (e1,e2) -> ((exprToString e1) + (exprToString e2)) / 2\n  | Times (e1,e2) -> (exprToString e1) * (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      ((exprToString e1) < (exprToString e2 ?exprToString e3) : exprToString\n                                                                  e4);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi .* exprToString e1)\n| Cosine e1 -> cos(pi .* exprToString e1)\n| Average (e1,e2) -> ((exprToString e1 .+ exprToString e2 )./2)\n| Times (e1,e2) -> exprToString e1 .* exprToString e2 \n| Thresh (e1,e2,e3,e4) -> (exprToString e1 < exprToString e2 ? exprToString e3 : exprToString e4)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 83-98:\n  | Sine e1 -> sin(pi *. exprToString e1)\n                         ^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (exprToString e1))\n  | Cosine e1 -> cos (pi *. (exprToString e1))\n  | Average (e1,e2) -> ((exprToString e1) +. (exprToString e2)) /. 2\n  | Times (e1,e2) -> (exprToString e1) *. (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      ((exprToString e1) < (exprToString e2 ?exprToString e3) : exprToString\n                                                                  e4);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y) < eval (e2,x,y) ? eval (e3,x,y) : eval (e4,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> (eval (e1,x,y)) < (eval (e2,x,y)) ? (eval (e3,x,y)) : (eval(e4,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 195-196:\n  | Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n                                                           ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 160-193:\n  | Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/2)\n                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Error: This expression has type expr/1050\n       but an expression was expected of type expr/1298\nError: This expression has type expr/1576\n       but an expression was expected of type expr/1596\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 14-24:\n  let _ = eval (sampleExpr,0.5,0.2);;\n                ^^^^^^^^^^\nError: This expression has type expr/1050\n       but an expression was expected of type expr/1298\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Error: This expression has type expr/1050\n       but an expression was expected of type expr/1650\nError: This expression has type expr/1703\n       but an expression was expected of type expr/1723\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 14-24:\n  let _ = eval (sampleExpr,0.5,0.2);;\n                ^^^^^^^^^^\nError: This expression has type expr/1050\n       but an expression was expected of type expr/1650\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 397-407:\n  in  if (depth < 1) then expChooser rand (0,2) else expChooser rand (2,7);;\n                          ^^^^^^^^^^\nError: This function has type int * int -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let expChooser (r,d) =\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (d - 1)))\n    | 3 -> buildCosine (build (rand, (d - 1)))\n    | 4 -> buildAverage ((build (rand, (d - 1))), (build (rand, (d - 1))))\n    | 5 -> buildTimes ((build (rand, (d - 1))), (build (rand, (d - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (d - 1))), (build (rand, (d - 1))),\n            (build (rand, (d - 1))), (build (rand, (d - 1)))) in\n  if depth < 1 then expChooser rand (0, 2) else expChooser rand (2, 7);;\n", "in": "let rec build (rand, depth) =\nlet expChooser (r,d) =  match r with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,d-1))\n| 3\n-> buildCosine(build (rand,d-1))\n| 4\n-> buildAverage(build (rand,d-1), build (rand,d-1))\n| 5\n-> buildTimes(build (rand,d-1), build (rand,d-1))\n| 6\n-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))\nin  if (depth < 1) then expChooser rand (0,2) depth else expChooser rand (2,7) depth"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 397-407:\n  in  if (depth < 1) then expChooser rand (0,2) depth else expChooser rand (2,7) depth;;\n                          ^^^^^^^^^^\nError: This function has type int * int -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let expChooser (r,d) =\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (d - 1)))\n    | 3 -> buildCosine (build (rand, (d - 1)))\n    | 4 -> buildAverage ((build (rand, (d - 1))), (build (rand, (d - 1))))\n    | 5 -> buildTimes ((build (rand, (d - 1))), (build (rand, (d - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (d - 1))), (build (rand, (d - 1))),\n            (build (rand, (d - 1))), (build (rand, (d - 1)))) in\n  if depth < 1\n  then expChooser rand (0, 2) depth\n  else expChooser rand (2, 7) depth;;\n", "in": "let rec build (rand, depth) =\nlet expChooser (r,d) =  match r with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,d-1))\n| 3\n-> buildCosine(build (rand,d-1))\n| 4\n-> buildAverage(build (rand,d-1), build (rand,d-1))\n| 5\n-> buildTimes(build (rand,d-1), build (rand,d-1))\n| 6\n-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))\nin  if (depth < 1) then (expChooser (rand (0,2), depth) else (expChooser (rand (2,7)), depth)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 115-133:\n  -> buildSine(build (rand,d-1))\n              ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let expChooser (r,d) =\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (d - 1)))\n    | 3 -> buildCosine (build (rand, (d - 1)))\n    | 4 -> buildAverage ((build (rand, (d - 1))), (build (rand, (d - 1))))\n    | 5 -> buildTimes ((build (rand, (d - 1))), (build (rand, (d - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (d - 1))), (build (rand, (d - 1))),\n            (build (rand, (d - 1))), (build (rand, (d - 1)))) in\n  if depth < 1\n  then ((expChooser (rand (0, 2))), depth)\n  else ((expChooser (rand (2, 7))), depth);;\n", "in": "let rec build (rand, depth) =\nlet expChooser (r,d) =  match r with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,d-1))\n| 3\n-> buildCosine(build (rand,d-1))\n| 4\n-> buildAverage(build (rand,d-1), build (rand,d-1))\n| 5\n-> buildTimes(build (rand,d-1), build (rand,d-1))\n| 6\n-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))\nin  if (depth < 1) then (expChooser (rand (0,2)), depth) else (expChooser (rand (2,7)), depth)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 115-133:\n  -> buildSine(build (rand,d-1))\n              ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let expChooser (r,d) =\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (d - 1)))\n    | 3 -> buildCosine (build (rand, (d - 1)))\n    | 4 -> buildAverage ((build (rand, (d - 1))), (build (rand, (d - 1))))\n    | 5 -> buildTimes ((build (rand, (d - 1))), (build (rand, (d - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (d - 1))), (build (rand, (d - 1))),\n            (build (rand, (d - 1))), (build (rand, (d - 1)))) in\n  if depth < 1\n  then ((expChooser (rand (0, 2))), depth)\n  else ((expChooser (rand (2, 7))), depth);;\n", "in": "let rec build (rand, depth) = let n = \nif (depth < 1) then rand (0,2) else rand(2,7)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 6-7:\n  match n with\n        ^\nError: Unbound value n\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  match n with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2 -> buildSine (build (rand, (depth - 1)))\n  | 3 -> buildCosine (build (rand, (depth - 1)))\n  | 4 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) = let n = \nif (depth < 1) then rand (0,2) else rand(2,7)\nmatch n with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 45-46:\n  match n with\n        ^\nError: Unbound value n\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let n =\n    match n with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1)))) in\n  if depth < 1 then rand (0, 2) else rand (2, 7);;\n", "in": "let rec build (rand, depth) = \nlet n = \nmatch n with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))\nin n = if (depth < 1) then rand (0,2) else rand(2,7)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 46-47:\n  match n with\n        ^\nError: Unbound value n\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let n =\n    match n with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1)))) in\n  n = (if depth < 1 then rand (0, 2) else rand (2, 7));;\n", "in": "let rec build (rand, depth) = \nlet n = if (depth < 1) then rand (0,2) else rand(2,7)\nmatch n with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\"^ exprToString e1 ^ \")\"\n| Cosine e1 -> \"cos(pi*\" ^ exprToString e1 ^ \")\"\n| Average (e1,e2) -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1,e2) -> exprToString e1 ^ \"*\" ^ exprToString e2 \n| Thresh (e1,e2,e3,e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\"^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| Power(e1,e2) -> exprToString e1 ^ \"^\" ^ exprToString e2"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Power    of expr * expr\n| Comp     of expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\"^ exprToString e1 ^ \")\"\n| Cosine e1 -> \"cos(pi*\" ^ exprToString e1 ^ \")\"\n| Average (e1,e2) -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1,e2) -> exprToString e1 ^ \"*\" ^ exprToString e2 \n| Thresh (e1,e2,e3,e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\"^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| Power (e1,e2) -> exprToString e1 ^ \"^\" ^ exprToString e2\n| Comp (e1,e2,e3) -> \"(-1*\" ^ exprToString e1 ^ \"*\" ^ exprToString e2 ^ \"*\" ^ exprToString e3 ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))\n| Power (e1,e2) -> eval (e1,x,y) ** eval (e2,x,y)\n| Comp (e1,e2,e3) -> float_of_int -1 *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))\n| Power (e1,e2) -> eval (e1,x,y) ** eval (e2,x,y)\n| Comp (e1,e2,e3) -> (float_of_int (-1)) *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,9) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))\n| 7 \n-> buildPower(build (rand,depth-1), build (rand,depth-1))\n| _\n-> buildComp(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 405-420:\n  | Power (e1,e2) -> eval (e1,x,y) ** abs (eval (e2,x,y))\n                                          ^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Comp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) ** (abs (eval (e2, x, y)))\n  | Comp (e1,e2,e3) ->\n      (((float_of_int (-1)) *. (eval (e1, x, y))) *. (eval (e2, x, y))) *.\n        (eval (e3, x, y));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))\n| Power (e1,e2) -> eval (e1,x,y) ** abs_float eval (e2,x,y)\n| Comp (e1,e2,e3) -> (float_of_int (-1)) *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 401-410:\n  | Power (e1,e2) -> eval (e1,x,y) ** abs_float eval (e2,x,y)\n                                      ^^^^^^^^^\nError: This function has type float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Comp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) ** (abs_float eval (e2, x, y))\n  | Comp (e1,e2,e3) ->\n      (((float_of_int (-1)) *. (eval (e1, x, y))) *. (eval (e2, x, y))) *.\n        (eval (e3, x, y));;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))\n| Power (e1,e2) -> eval (e1,x,y) ** abs_float (eval (e2,x,y))\n| Comp (e1,e2,e3) -> (float_of_int (-1)) *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))\n| Power (e1,e2) -> eval (e1,x,y) ** abs_float (eval (e2,x,y))\n| Comp (e1,e2,e3) -> (float_of_int (-1)) *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))\n| Power (e1,e2) -> eval (e1,x,y) ** abs_float (eval (e2,x,y))\n| Comp (e1,e2,e3) -> (float_of_int (-1)) *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))\n| Power (e1,e2) -> eval (e1,x,y) ** abs_float (eval (e2,x,y))\n| Comp (e1,e2,e3) -> (float_of_int (-1)) *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)"}]}
