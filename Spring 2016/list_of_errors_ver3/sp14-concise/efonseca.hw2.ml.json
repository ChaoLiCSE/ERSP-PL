{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then true else assoc d k t", "out": "Characters 85-90:\n  | (s,i)::t -> if s = k then true else assoc d k t;;\n                                        ^^^^^\nError: This function has type bool * 'a * ('a * 'b) list -> bool\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then true else assoc d k t;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then true else assoc (d k t)", "out": "Characters 92-93:\n  | (s,i)::t -> if s = k then true else assoc (d k t);;\n                                               ^\nError: This expression has type bool\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then true else assoc (d k t);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d k t)", "out": "Characters 93-94:\n  | (s,i)::t -> if s = k then i else assoc (d k t);;\n                                                ^\nError: This expression has type ('a * ('a -> 'b -> 'c)) list\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside ('a * ('a -> 'b -> 'c)) list\n", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d k t);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i) as h::t -> if s = k then i else assoc (d k t)", "out": "Characters 98-99:\n  | (s,i) as h::t -> if s = k then i else assoc (d k t);;\n                                                     ^\nError: This expression has type ('a * ('a -> 'b -> 'c)) list\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside ('a * ('a -> 'b -> 'c)) list\n", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | ((s,i) as h)::t -> if s = k then i else assoc (d k t);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| ((s,i) as h)::t -> if s = k then i else assoc (d k t)", "out": "Characters 100-101:\n  | ((s,i) as h)::t -> if s = k then i else assoc (d k t);;\n                                                       ^\nError: This expression has type ('a * ('a -> 'b -> 'c)) list\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside ('a * ('a -> 'b -> 'c)) list\n", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | ((s,i) as h)::t -> if s = k then i else assoc (d k t);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> if fst h = k then snd h else assoc (d k t)", "out": "Characters 97-98:\n  | h::t -> if fst h = k then snd h else assoc (d k t);;\n                                                    ^\nError: This expression has type ('a * ('a -> 'b -> 'c)) list\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside ('a * ('a -> 'b -> 'c)) list\n", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> if (fst h) = k then snd h else assoc (d k t);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> if fst h = k then snd h else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> if (fst h) = k then snd h else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i) as h::t -> if s = k then i else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | ((s,i) as h)::t -> if s = k then i else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then i else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = if snd f b then wwhile f fst f b else fst f b", "out": "Characters 46-47:\n  let rec wwhile (f,b) = if snd f b then wwhile f fst f b else fst f b;;\n                                                ^\nError: This expression has type 'a * ('b -> bool)\n       but an expression was expected of type ('a * ('b -> bool)) * 'b\n", "min": "\nlet rec wwhile (f,b) = if snd f b then wwhile f fst f b else fst f b;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = if snd (f b) then wwhile (f, fst (f b)) else fst (f b)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  if snd (f b) then wwhile (f, (fst (f b))) else fst (f b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  if snd (f b) then wwhile (f, (fst (f b))) else fst (f b);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = let res = f b in \nif snd res then wwhile (f, fst res) else fst res", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let res = f b in if snd res then wwhile (f, (fst res)) else fst res;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = \nlet (b',c') = f b in \nif c' then wwhile f b' else b'", "out": "Characters 64-65:\n  if c' then wwhile f b' else b';;\n                    ^\nError: This expression has type 'a -> 'b * bool\n       but an expression was expected of type ('a -> 'b * bool) * 'a\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile f b' else b';;\n", "type": "type"}, {"in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "out": "", "min": "\nlet rec wwhile (f,b) =\n  let res = f b in if snd res then wwhile (f, (fst res)) else fst res;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = \nlet (b',c') = f b in \nif c' then wwhile (f,b') else b'", "out": "", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec wwhile (f,b) = \nlet (b',c') = f b in \nif c' then wwhile (f, b') else b'", "out": "", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile ((if f b = b then (true,b) else (false,b)),b)", "out": "Characters 46-54:\n  let fixpoint (f,b) = wwhile ((if f b = b then (true,b) else (false,b)),b);;\n                                                ^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((if (f b) = b then (true, b) else (false, b)), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (((f b) = b, (f b)),b)", "out": "Characters 29-47:\n  let fixpoint (f,b) = wwhile (((f b) = b, (f b)),b);;\n                               ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((((f b) = b), (f b)), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = wwhile (f b, f b = b,b)", "out": "Characters 28-44:\n  let fixpoint (f,b) = wwhile (f b, f b = b,b);;\n                              ^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type ('d -> 'd * bool) * 'd\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((f b), ((f b) = b), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nwwhile(if f b = b then (f b, true) else (f b, false),b)", "out": "Characters 62-74:\n  wwhile(if f b = b then (f b, true) else (f b, false),b);;\n                                          ^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type bool -> bool * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile (if (f b) = b then ((f b), true) else (((f b), false), b));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nwwhile((if f b = b then (f b, true) else (f b, false)),b)", "out": "Characters 46-57:\n  wwhile((if f b = b then (f b, true) else (f b, false)),b);;\n                          ^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) =\n  wwhile ((if (f b) = b then ((f b), true) else ((f b), false)), b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = let fx b' = (f b', f b' = b') in\nwwhile(fx,b)", "out": "", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = let fx b' = ((f b'), ((f b') = b')) in wwhile (fx, b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = let fx = (f b, f b = b) in\nwwhile(fx,b)", "out": "Characters 48-54:\n  wwhile(fx,b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = let fx = ((f b), ((f b) = b)) in wwhile (fx, b);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = let fx b= (f b, f b = b) in\nwwhile(fx,b)", "out": "Characters 49-55:\n  wwhile(fx,b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = let fx b = ((f b), ((f b) = b)) in wwhile (fx, b);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nlet fx b = (f b, not f b = b) in\nwwhile(fx,b)", "out": "Characters 39-42:\n  let fx b = (f b, not f b = b) in\n                   ^^^\nError: This function has type bool -> bool\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet fixpoint (f,b) = let fx b = ((f b), ((not f b) = b)) in wwhile (fx, b);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nlet fx b = (f b, not (f b = b)) in\nwwhile(fx,b)", "out": "Characters 57-63:\n  wwhile(fx,b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = let fx b = ((f b), (not ((f b) = b))) in wwhile (fx, b);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nlet fx x = (f x, not (f x = x)) in\nwwhile(fx,b)", "out": "Characters 57-63:\n  wwhile(fx,b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = let fx x = ((f x), (not ((f x) = x))) in wwhile (fx, b);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nwwhile(fun x -> f x , not (f x = x),b)", "out": "Characters 22-28:\n  wwhile(fun x -> f x , not (f x = x),b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile (fun x  -> ((f x), (not ((f x) = x)), b));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nwwhile(fun x -> (f x , not (f x = x)),b)", "out": "Characters 22-28:\n  wwhile(fun x -> (f x , not (f x = x)),b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile (fun x  -> (((f x), (not ((f x) = x))), b));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nwwhile((fun x -> f x , not (f x = x)),b)", "out": "Characters 22-28:\n  wwhile((fun x -> f x , not (f x = x)),b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f x), (not ((f x) = x)))), b);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nwwhile(fun x -> f x  not (f x = x),b)", "out": "Characters 22-28:\n  wwhile(fun x -> f x  not (f x = x),b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile (fun x  -> ((f x not ((f x) = x)), b));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nwwhile((fun x -> f x  not (f x = x)),b)", "out": "Characters 22-28:\n  wwhile((fun x -> f x  not (f x = x)),b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((fun x  -> f x not ((f x) = x)), b);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let fixpoint (f,b) = \nwwhile((fun x -> f x , not (f x = x)),b)", "out": "Characters 22-28:\n  wwhile((fun x -> f x , not (f x = x)),b);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((fun x  -> ((f x), (not ((f x) = x)))), b);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with \n| VarX -> \"VarX\"\n| VarY -> \"VarY\"\n| Sine e1 -> \"Sine(\"^ exprToString e1 ^ \")\"\n| Cosine e1 -> \"Cosine(\" ^ exprToString e1 ^ \")\"\n| Average (e1,e2) -> \"Average(\" ^ exprToString e1 ^ \",\" ^ exprToString e2 ^ \")\"\n| Times (e1,e2) -> \"Times(\" ^ exprToString e1 ^ \",\" ^ exprToString e2 ^ \")\"\n| Thresh (e1,e2,e3,e4) -> \"Thresh(\" ^  exprToString e1 ^ \",\" ^ exprToString e2 ^\",\" ^ exprToString e3 ^ \",\" ^ exprToString e4 ^ \")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"VarX\"\n  | VarY  -> \"VarY\"\n  | Sine e1 -> \"Sine(\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"Cosine(\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"Average(\" ^ ((exprToString e1) ^ (\",\" ^ ((exprToString e2) ^ \")\")))\n  | Times (e1,e2) ->\n      \"Times(\" ^ ((exprToString e1) ^ (\",\" ^ ((exprToString e2) ^ \")\")))\n  | Thresh (e1,e2,e3,e4) ->\n      \"Thresh(\" ^\n        ((exprToString e1) ^\n           (\",\" ^\n              ((exprToString e2) ^\n                 (\",\" ^\n                    ((exprToString e3) ^ (\",\" ^ ((exprToString e4) ^ \")\")))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin (pi*\"^ exprToString e1 ^ \")\"\n| Cosine e1 -> \"cos (pi*\" ^ exprToString e1 ^ \")\"\n| Average (e1,e2) -> \"((\" ^ exprToString e1 ^ \" + \" ^ exprToString e2 ^ \")/2)\"\n| Times (e1,e2) -> exprToString e1 ^ \" * \" ^ exprToString e2 \n| Thresh (e1,e2,e3,e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \" ? \" ^ exprToString e3 ^ \" : \" ^ exprToString e4 ^ \")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin (pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos (pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\" + \" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\" ? \" ^\n                    ((exprToString e3) ^ (\" : \" ^ ((exprToString e4) ^ \")\")))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\"^ exprToString e1 ^ \")\"\n| Cosine e1 -> \"cos(pi*\" ^ exprToString e1 ^ \")\"\n| Average (e1,e2) -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1,e2) -> exprToString e1 ^ \" * \" ^ exprToString e2 \n| Thresh (e1,e2,e3,e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"? \"^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\" * \" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"? \" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\"^ exprToString e1 ^ \")\"\n| Cosine e1 -> \"cos(pi*\" ^ exprToString e1 ^ \")\"\n| Average (e1,e2) -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1,e2) -> exprToString e1 ^ \"*\" ^ exprToString e2 \n| Thresh (e1,e2,e3,e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\"^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let buildX()                       = VarX", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. exprToString e1)\n| Cosine e1 -> cos(pi *. exprToString e1)\n| Average (e1,e2) -> ((exprToString e1 +. exprToString e2 )/.2)\n| Times (e1,e2) -> exprToString e1 *. exprToString e2 \n| Thresh (e1,e2,e3,e4) -> (exprToString e1 < exprToString e2 ? exprToString e3 : exprToString e4)", "out": "Characters 83-98:\n  | Sine e1 -> sin(pi *. exprToString e1)\n                         ^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (exprToString e1))\n  | Cosine e1 -> cos (pi *. (exprToString e1))\n  | Average (e1,e2) -> ((exprToString e1) +. (exprToString e2)) /. 2\n  | Times (e1,e2) -> (exprToString e1) *. (exprToString e2)\n  | Thresh (e1,e2,e3,e4) ->\n      ((exprToString e1) < (exprToString e2 ?exprToString e3) : exprToString\n                                                                  e4);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "eval", "out": "", "min": "\nlet rec eval (e,x,y) = failwith \"to be written\";;\n\nlet _ = eval;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))", "out": "Characters 195-196:\n  | Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.2)\n                                                           ^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))", "out": "Characters 160-193:\n  | Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/2)\n                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) / 2\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/.float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nlet expChooser (r,d) =  match r with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,d-1))\n| 3\n-> buildCosine(build (rand,d-1))\n| 4\n-> buildAverage(build (rand,d-1), build (rand,d-1))\n| 5\n-> buildTimes(build (rand,d-1), build (rand,d-1))\n| 6\n-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))\nin  if (depth < 1) then expChooser rand (0,2) else expChooser rand (2,7)", "out": "Characters 397-407:\n  in  if (depth < 1) then expChooser rand (0,2) else expChooser rand (2,7);;\n                          ^^^^^^^^^^\nError: This function has type int * int -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let expChooser (r,d) =\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (d - 1)))\n    | 3 -> buildCosine (build (rand, (d - 1)))\n    | 4 -> buildAverage ((build (rand, (d - 1))), (build (rand, (d - 1))))\n    | 5 -> buildTimes ((build (rand, (d - 1))), (build (rand, (d - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (d - 1))), (build (rand, (d - 1))),\n            (build (rand, (d - 1))), (build (rand, (d - 1)))) in\n  if depth < 1 then expChooser rand (0, 2) else expChooser rand (2, 7);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nlet expChooser (r,d) =  match r with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,d-1))\n| 3\n-> buildCosine(build (rand,d-1))\n| 4\n-> buildAverage(build (rand,d-1), build (rand,d-1))\n| 5\n-> buildTimes(build (rand,d-1), build (rand,d-1))\n| 6\n-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))\nin  if (depth < 1) then expChooser rand (0,2) depth else expChooser rand (2,7) depth", "out": "Characters 397-407:\n  in  if (depth < 1) then expChooser rand (0,2) depth else expChooser rand (2,7) depth;;\n                          ^^^^^^^^^^\nError: This function has type int * int -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let expChooser (r,d) =\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (d - 1)))\n    | 3 -> buildCosine (build (rand, (d - 1)))\n    | 4 -> buildAverage ((build (rand, (d - 1))), (build (rand, (d - 1))))\n    | 5 -> buildTimes ((build (rand, (d - 1))), (build (rand, (d - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (d - 1))), (build (rand, (d - 1))),\n            (build (rand, (d - 1))), (build (rand, (d - 1)))) in\n  if depth < 1\n  then expChooser rand (0, 2) depth\n  else expChooser rand (2, 7) depth;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nlet expChooser (r,d) =  match r with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,d-1))\n| 3\n-> buildCosine(build (rand,d-1))\n| 4\n-> buildAverage(build (rand,d-1), build (rand,d-1))\n| 5\n-> buildTimes(build (rand,d-1), build (rand,d-1))\n| 6\n-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))\nin  if (depth < 1) then (expChooser (rand (0,2)), depth) else (expChooser (rand (2,7)), depth)", "out": "Characters 115-133:\n  -> buildSine(build (rand,d-1))\n              ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let expChooser (r,d) =\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (d - 1)))\n    | 3 -> buildCosine (build (rand, (d - 1)))\n    | 4 -> buildAverage ((build (rand, (d - 1))), (build (rand, (d - 1))))\n    | 5 -> buildTimes ((build (rand, (d - 1))), (build (rand, (d - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (d - 1))), (build (rand, (d - 1))),\n            (build (rand, (d - 1))), (build (rand, (d - 1)))) in\n  if depth < 1\n  then ((expChooser (rand (0, 2))), depth)\n  else ((expChooser (rand (2, 7))), depth);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) =\nlet expChooser (r,d) =  match r with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,d-1))\n| 3\n-> buildCosine(build (rand,d-1))\n| 4\n-> buildAverage(build (rand,d-1), build (rand,d-1))\n| 5\n-> buildTimes(build (rand,d-1), build (rand,d-1))\n| 6\n-> buildThresh(build (rand,d-1), build (rand,d-1), build (rand,d-1), build (rand, d-1))\nin  if (depth < 1) then (expChooser (rand (0,2)), depth) else (expChooser (rand (2,7)), depth)", "out": "Characters 115-133:\n  -> buildSine(build (rand,d-1))\n              ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let expChooser (r,d) =\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (d - 1)))\n    | 3 -> buildCosine (build (rand, (d - 1)))\n    | 4 -> buildAverage ((build (rand, (d - 1))), (build (rand, (d - 1))))\n    | 5 -> buildTimes ((build (rand, (d - 1))), (build (rand, (d - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (d - 1))), (build (rand, (d - 1))),\n            (build (rand, (d - 1))), (build (rand, (d - 1)))) in\n  if depth < 1\n  then ((expChooser (rand (0, 2))), depth)\n  else ((expChooser (rand (2, 7))), depth);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "match n with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "out": "Characters 6-7:\n  match n with\n        ^\nError: Unbound value n\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  match n with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2 -> buildSine (build (rand, (depth - 1)))\n  | 3 -> buildCosine (build (rand, (depth - 1)))\n  | 4 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = let n = \nmatch n with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))\nin if (depth < 1) then rand (0,2) else rand(2,7)", "out": "Characters 45-46:\n  match n with\n        ^\nError: Unbound value n\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let n =\n    match n with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1)))) in\n  if depth < 1 then rand (0, 2) else rand (2, 7);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nlet n = \nmatch n with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))\nin n = if (depth < 1) then rand (0,2) else rand(2,7)", "out": "Characters 46-47:\n  match n with\n        ^\nError: Unbound value n\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let n =\n    match n with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build (rand, (depth - 1)))\n    | 3 -> buildCosine (build (rand, (depth - 1)))\n    | 4 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 6 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1)))) in\n  n = (if depth < 1 then rand (0, 2) else rand (2, 7));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let num = if depth < 1 then rand (0, 2) else rand (2, 7) in\n  match num with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2 -> buildSine (build (rand, (depth - 1)))\n  | 3 -> buildCosine (build (rand, (depth - 1)))\n  | 4 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let num = if depth < 1 then rand (0, 2) else rand (2, 7) in\n  match num with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2 -> buildSine (build (rand, (depth - 1)))\n  | 3 -> buildCosine (build (rand, (depth - 1)))\n  | 4 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | _s ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let num = if depth < 1 then rand (0, 2) else rand (2, 7) in\n  match num with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2 -> buildSine (build (rand, (depth - 1)))\n  | 3 -> buildCosine (build (rand, (depth - 1)))\n  | 4 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | _s ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\"^ exprToString e1 ^ \")\"\n| Cosine e1 -> \"cos(pi*\" ^ exprToString e1 ^ \")\"\n| Average (e1,e2) -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1,e2) -> exprToString e1 ^ \"*\" ^ exprToString e2 \n| Thresh (e1,e2,e3,e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\"^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| Power(e1,e2) -> exprToString e1 ^ \"^\" ^ exprToString e2", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Power (e1,e2) -> (exprToString e1) ^ (\"^\" ^ (exprToString e2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Power    of expr * expr\n| Comp     of expr * expr * expr", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Comp of expr* expr* expr;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec exprToString e = match e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\"^ exprToString e1 ^ \")\"\n| Cosine e1 -> \"cos(pi*\" ^ exprToString e1 ^ \")\"\n| Average (e1,e2) -> \"((\" ^ exprToString e1 ^ \"+\" ^ exprToString e2 ^ \")/2)\"\n| Times (e1,e2) -> exprToString e1 ^ \"*\" ^ exprToString e2 \n| Thresh (e1,e2,e3,e4) -> \"(\" ^ exprToString e1 ^ \"<\" ^ exprToString e2 ^ \"?\"^ exprToString e3 ^ \":\" ^ exprToString e4 ^ \")\"\n| Power (e1,e2) -> exprToString e1 ^ \"^\" ^ exprToString e2\n| Comp (e1,e2,e3) -> \"(-1*\" ^ exprToString e1 ^ \"*\" ^ exprToString e2 ^ \"*\" ^ exprToString e3 ^ \")\"", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Comp of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Power (e1,e2) -> (exprToString e1) ^ (\"^\" ^ (exprToString e2))\n  | Comp (e1,e2,e3) ->\n      \"(-1*\" ^\n        ((exprToString e1) ^\n           (\"*\" ^ ((exprToString e2) ^ (\"*\" ^ ((exprToString e3) ^ \")\")))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))\n| Power (e1,e2) -> eval (e1,x,y) ** eval (e2,x,y)\n| Comp (e1,e2,e3) -> float_of_int -1 *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y)", "out": "Characters 436-448:\n  | Comp (e1,e2,e3) -> float_of_int -1 *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y);;\n                       ^^^^^^^^^^^^\nError: This expression has type int -> float\n       but an expression was expected of type int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Comp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) ** (eval (e2, x, y))\n  | Comp (e1,e2,e3) ->\n      float_of_int -\n        (((1 *. (eval (e1, x, y))) *. (eval (e2, x, y))) *. (eval (e3, x, y)));;\n", "type": "type"}, {"in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Comp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))\n| Power (e1,e2) -> eval (e1,x,y) ** eval (e2,x,y)\n| Comp (e1,e2,e3) -> (float_of_int (-1)) *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Comp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) ** (eval (e2, x, y))\n  | Comp (e1,e2,e3) ->\n      (((float_of_int (-1)) *. (eval (e1, x, y))) *. (eval (e2, x, y))) *.\n        (eval (e3, x, y));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) ** (eval (e2, x, y))\n  | Comp (e1,e2,e3) ->\n      (((float_of_int (-1)) *. (eval (e1, x, y))) *. (eval (e2, x, y))) *.\n        (eval (e3, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Comp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildComp (e1,e2,e3) = Comp (e1, e2, e3);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildPower (e1,e2) = Power (e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let num = if depth < 1 then rand (0, 2) else rand (2, 9) in\n  match num with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2 -> buildSine (build (rand, (depth - 1)))\n  | 3 -> buildCosine (build (rand, (depth - 1)))\n  | 4 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildPower ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | _ ->\n      buildComp\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Power (e1,e2) -> (exprToString e1) ^ (\"^\" ^ (exprToString e2))\n  | Comp (e1,e2,e3) ->\n      \"(-1*\" ^\n        ((exprToString e1) ^\n           (\"*\" ^ ((exprToString e2) ^ (\"*\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,9) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))\n| 7 \n-> buildPower(build (rand,depth-1), build (rand,depth-1))\n| _\n-> buildComp(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Comp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildComp (e1,e2,e3) = Comp (e1, e2, e3);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildPower (e1,e2) = Power (e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let num = if depth < 1 then rand (0, 2) else rand (2, 9) in\n  match num with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2 -> buildSine (build (rand, (depth - 1)))\n  | 3 -> buildCosine (build (rand, (depth - 1)))\n  | 4 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildPower ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | _ ->\n      buildComp\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) ** (eval (e2, x, y))\n  | Comp (e1,e2,e3) ->\n      (((float_of_int (-1)) *. (eval (e1, x, y))) *. (eval (e2, x, y))) *.\n        (eval (e3, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Comp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildComp (e1,e2,e3) = Comp (e1, e2, e3);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildPower (e1,e2) = Power (e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let num = if depth < 1 then rand (0, 2) else rand (2, 9) in\n  match num with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2 -> buildSine (build (rand, (depth - 1)))\n  | 3 -> buildCosine (build (rand, (depth - 1)))\n  | 4 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildPower ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | _ ->\n      buildComp\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Power (e1,e2) -> (exprToString e1) ^ (\"^\" ^ (exprToString e2))\n  | Comp (e1,e2,e3) ->\n      \"(-1*\" ^\n        ((exprToString e1) ^\n           (\"*\" ^ ((exprToString e2) ^ (\"*\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) ** (eval (e2, x, y))\n  | Comp (e1,e2,e3) ->\n      (((float_of_int (-1)) *. (eval (e1, x, y))) *. (eval (e2, x, y))) *.\n        (eval (e3, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Comp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildComp (e1,e2,e3) = Comp (e1, e2, e3);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildPower (e1,e2) = Power (e1, e2);;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let num = if depth < 1 then rand (0, 2) else rand (2, 9) in\n  match num with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2 -> buildSine (build (rand, (depth - 1)))\n  | 3 -> buildCosine (build (rand, (depth - 1)))\n  | 4 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 7 ->\n      buildPower ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | _ ->\n      buildComp\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Power (e1,e2) -> (exprToString e1) ^ (\"^\" ^ (exprToString e2))\n  | Comp (e1,e2,e3) ->\n      \"(-1*\" ^\n        ((exprToString e1) ^\n           (\"*\" ^ ((exprToString e2) ^ (\"*\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Comp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let num = if depth < 1 then rand (0, 2) else rand (2, 7) in\n  match num with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2 -> buildSine (build (rand, (depth - 1)))\n  | 3 -> buildCosine (build (rand, (depth - 1)))\n  | 4 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | _ ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))\n| Power (e1,e2) -> eval (e1,x,y) ** abs_float eval (e2,x,y)\n| Comp (e1,e2,e3) -> (float_of_int (-1)) *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y)", "out": "Characters 401-410:\n  | Power (e1,e2) -> eval (e1,x,y) ** abs_float eval (e2,x,y)\n                                      ^^^^^^^^^\nError: This function has type float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Comp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) ** (abs_float eval (e2, x, y))\n  | Comp (e1,e2,e3) ->\n      (((float_of_int (-1)) *. (eval (e1, x, y))) *. (eval (e2, x, y))) *.\n        (eval (e3, x, y));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))\n| Power (e1,e2) -> eval (e1,x,y) ** abs_float (eval (e2,x,y))\n| Comp (e1,e2,e3) -> (float_of_int (-1)) *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Comp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) ** (abs_float (eval (e2, x, y)))\n  | Comp (e1,e2,e3) ->\n      (((float_of_int (-1)) *. (eval (e1, x, y))) *. (eval (e2, x, y))) *.\n        (eval (e3, x, y));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))\n| Power (e1,e2) -> eval (e1,x,y) ** abs_float (eval (e2,x,y))\n| Comp (e1,e2,e3) -> (float_of_int (-1)) *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Comp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) ** (abs_float (eval (e2, x, y)))\n  | Comp (e1,e2,e3) ->\n      (((float_of_int (-1)) *. (eval (e1, x, y))) *. (eval (e2, x, y))) *.\n        (eval (e3, x, y));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))\n| Power (e1,e2) -> eval (e1,x,y) ** abs_float (eval (e2,x,y))\n| Comp (e1,e2,e3) -> (float_of_int (-1)) *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Comp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) ** (abs_float (eval (e2, x, y)))\n  | Comp (e1,e2,e3) ->\n      (((float_of_int (-1)) *. (eval (e1, x, y))) *. (eval (e2, x, y))) *.\n        (eval (e3, x, y));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) ** (abs_float (eval (e2, x, y)))\n  | Comp (e1,e2,e3) ->\n      (((float_of_int (-1)) *. (eval (e1, x, y))) *. (eval (e2, x, y))) *.\n        (eval (e3, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Comp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let num = if depth < 1 then rand (0, 2) else rand (2, 7) in\n  match num with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2 -> buildSine (build (rand, (depth - 1)))\n  | 3 -> buildCosine (build (rand, (depth - 1)))\n  | 4 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | _ ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Power (e1,e2) -> (exprToString e1) ^ (\"^\" ^ (exprToString e2))\n  | Comp (e1,e2,e3) ->\n      \"(-1*\" ^\n        ((exprToString e1) ^\n           (\"*\" ^ ((exprToString e2) ^ (\"*\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) ** (abs_float (eval (e2, x, y)))\n  | Comp (e1,e2,e3) ->\n      (((float_of_int (-1)) *. (eval (e1, x, y))) *. (eval (e2, x, y))) *.\n        (eval (e3, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Comp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let num = if depth < 1 then rand (0, 2) else rand (2, 7) in\n  match num with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2 -> buildSine (build (rand, (depth - 1)))\n  | 3 -> buildCosine (build (rand, (depth - 1)))\n  | 4 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | _ ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Power (e1,e2) -> (exprToString e1) ^ (\"^\" ^ (exprToString e2))\n  | Comp (e1,e2,e3) ->\n      \"(-1*\" ^\n        ((exprToString e1) ^\n           (\"*\" ^ ((exprToString e2) ^ (\"*\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) ** (abs_float (eval (e2, x, y)))\n  | Comp (e1,e2,e3) ->\n      (((float_of_int (-1)) *. (eval (e1, x, y))) *. (eval (e2, x, y))) *.\n        (eval (e3, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Comp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let num = if depth < 1 then rand (0, 2) else rand (2, 7) in\n  match num with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2 -> buildSine (build (rand, (depth - 1)))\n  | 3 -> buildCosine (build (rand, (depth - 1)))\n  | 4 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | _ ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Power (e1,e2) -> (exprToString e1) ^ (\"^\" ^ (exprToString e2))\n  | Comp (e1,e2,e3) ->\n      \"(-1*\" ^\n        ((exprToString e1) ^\n           (\"*\" ^ ((exprToString e2) ^ (\"*\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "out": "", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) ** (abs_float (eval (e2, x, y)))\n  | Comp (e1,e2,e3) ->\n      (((float_of_int (-1)) *. (eval (e1, x, y))) *. (eval (e2, x, y))) *.\n        (eval (e3, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Comp of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let num = if depth < 1 then rand (0, 2) else rand (2, 7) in\n  match num with\n  | 0 -> buildX ()\n  | 1 -> buildY ()\n  | 2 -> buildSine (build (rand, (depth - 1)))\n  | 3 -> buildCosine (build (rand, (depth - 1)))\n  | 4 ->\n      buildAverage ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 ->\n      buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | _ ->\n      buildThresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))))\n  | Power (e1,e2) -> (exprToString e1) ^ (\"^\" ^ (exprToString e2))\n  | Comp (e1,e2,e3) ->\n      \"(-1*\" ^\n        ((exprToString e1) ^\n           (\"*\" ^ ((exprToString e2) ^ (\"*\" ^ ((exprToString e3) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1,x,y))\n| Cosine e1 -> cos(pi *. eval (e1,x,y))\n| Average (e1,e2) -> ((eval (e1,x,y) +. eval (e2,x,y) )/. float_of_int 2)\n| Times (e1,e2) -> eval (e1,x,y) *. eval (e2,x,y) \n| Thresh (e1,e2,e3,e4) -> if (eval (e1,x,y) < eval (e2,x,y)) then (eval (e3,x,y)) else (eval(e4,x,y))\n| Power (e1,e2) -> eval (e1,x,y) ** abs_float (eval (e2,x,y))\n| Comp (e1,e2,e3) -> (float_of_int (-1)) *. eval (e1,x,y) *. eval (e2,x,y) *. eval (e3,x,y)", "out": "", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | Comp of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) /. (float_of_int 2)\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) ** (abs_float (eval (e2, x, y)))\n  | Comp (e1,e2,e3) ->\n      (((float_of_int (-1)) *. (eval (e1, x, y))) *. (eval (e2, x, y))) *.\n        (eval (e3, x, y));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (f,s)::t -> if f = k then s else assoc (d, k, t)", "out": "", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (f,s)::t -> if f = k then s else assoc (d, k, t);;\n", "type": ""}]}
